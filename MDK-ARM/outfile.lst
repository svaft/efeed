
========================================================================

** ELF Header Information

    File Name: C:\STM32\project\efeed\MDK-ARM\efeed\efeed.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x080000ed
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_SOFT (0x05000202)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Soft float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 1
    Section header entries: 16

    Program header offset: 838144 (0x000cca00)
    Section header offset: 838176 (0x000cca20)

    Section header string table index: 15

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 15672 bytes (13068 bytes in file)
    Virtual address: 0x08000000 (Alignment 8)


========================================================================

** Section #1 'ER_IROM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 12656 bytes (alignment 8)
    Address: 0x08000000

    $d.realdata
    RESET
    __Vectors
        0x08000000:    20000bc8    ...     DCD    536873928
        0x08000004:    08000101    ....    DCD    134217985
        0x08000008:    08000109    ....    DCD    134217993
        0x0800000c:    0800010b    ....    DCD    134217995
        0x08000010:    0800010d    ....    DCD    134217997
        0x08000014:    0800010f    ....    DCD    134217999
        0x08000018:    08000111    ....    DCD    134218001
        0x0800001c:    00000000    ....    DCD    0
        0x08000020:    00000000    ....    DCD    0
        0x08000024:    00000000    ....    DCD    0
        0x08000028:    00000000    ....    DCD    0
        0x0800002c:    08001c85    ....    DCD    134225029
        0x08000030:    08000115    ....    DCD    134218005
        0x08000034:    00000000    ....    DCD    0
        0x08000038:    08001b85    ....    DCD    134224773
        0x0800003c:    08001c89    ....    DCD    134225033
        0x08000040:    0800011b    ....    DCD    134218011
        0x08000044:    0800011b    ....    DCD    134218011
        0x08000048:    0800011b    ....    DCD    134218011
        0x0800004c:    0800011b    ....    DCD    134218011
        0x08000050:    0800011b    ....    DCD    134218011
        0x08000054:    0800011b    ....    DCD    134218011
        0x08000058:    0800011b    ....    DCD    134218011
        0x0800005c:    0800011b    ....    DCD    134218011
        0x08000060:    0800011b    ....    DCD    134218011
        0x08000064:    0800011b    ....    DCD    134218011
        0x08000068:    0800011b    ....    DCD    134218011
        0x0800006c:    0800011b    ....    DCD    134218011
        0x08000070:    0800011b    ....    DCD    134218011
        0x08000074:    0800011b    ....    DCD    134218011
        0x08000078:    080006e5    ....    DCD    134219493
        0x0800007c:    0800011b    ....    DCD    134218011
        0x08000080:    0800071d    ....    DCD    134219549
        0x08000084:    0800011b    ....    DCD    134218011
        0x08000088:    0800011b    ....    DCD    134218011
        0x0800008c:    0800011b    ....    DCD    134218011
        0x08000090:    0800011b    ....    DCD    134218011
        0x08000094:    0800011b    ....    DCD    134218011
        0x08000098:    0800011b    ....    DCD    134218011
        0x0800009c:    0800011b    ....    DCD    134218011
        0x080000a0:    0800011b    ....    DCD    134218011
        0x080000a4:    08001e29    )...    DCD    134225449
        0x080000a8:    0800011b    ....    DCD    134218011
        0x080000ac:    0800011b    ....    DCD    134218011
        0x080000b0:    08001e49    I...    DCD    134225481
        0x080000b4:    08001e91    ....    DCD    134225553
        0x080000b8:    08001e95    ....    DCD    134225557
        0x080000bc:    0800011b    ....    DCD    134218011
        0x080000c0:    0800011b    ....    DCD    134218011
        0x080000c4:    080007d1    ....    DCD    134219729
        0x080000c8:    080007cd    ....    DCD    134219725
        0x080000cc:    0800011b    ....    DCD    134218011
        0x080000d0:    0800011b    ....    DCD    134218011
        0x080000d4:    0800011b    ....    DCD    134218011
        0x080000d8:    08001f49    I...    DCD    134225737
        0x080000dc:    0800011b    ....    DCD    134218011
        0x080000e0:    0800011b    ....    DCD    134218011
        0x080000e4:    0800011b    ....    DCD    134218011
        0x080000e8:    0800011b    ....    DCD    134218011
    $t
    .ARM.Collect$$$$00000000
    .ARM.Collect$$$$00000001
    __Vectors_End
    __main
    _main_stk
        0x080000ec:    f8dfd00c    ....    LDR      sp,__lit__00000000 ; [0x80000fc] = 0x20000bc8
    .ARM.Collect$$$$00000004
    _main_scatterload
        0x080000f0:    f000faba    ....    BL       __scatterload ; 0x8000668
    .ARM.Collect$$$$00000008
    .ARM.Collect$$$$0000000A
    .ARM.Collect$$$$0000000B
    __main_after_scatterload
    _main_clock
    _main_cpp_init
    _main_init
        0x080000f4:    4800        .H      LDR      r0,[pc,#0] ; [0x80000f8] = 0x800290d
        0x080000f6:    4700        .G      BX       r0
    $d
        0x080000f8:    0800290d    .)..    DCD    134228237
    .ARM.Collect$$$$00002712
    __lit__00000000
    .ARM.Collect$$$$0000000D
    .ARM.Collect$$$$0000000F
    __rt_final_cpp
    __rt_final_exit
        0x080000fc:    20000bc8    ...     DCD    536873928
    $t
    .text
    Reset_Handler
;;;150                     LDR     R0, =SystemInit
        0x08000100:    4806        .H      LDR      r0,[pc,#24] ; [0x800011c] = 0x8001dd1
;;;151                     BLX     R0
        0x08000102:    4780        .G      BLX      r0
;;;152                     LDR     R0, =__main
        0x08000104:    4806        .H      LDR      r0,[pc,#24] ; [0x8000120] = 0x80000ed
;;;153                     BX      R0
        0x08000106:    4700        .G      BX       r0
    NMI_Handler
;;;154                     ENDP
;;;155    
;;;156    ; Dummy Exception Handlers (infinite loops which can be modified)
;;;157    
;;;158    NMI_Handler     PROC
;;;159                    EXPORT  NMI_Handler                [WEAK]
;;;160                    B       .
        0x08000108:    e7fe        ..      B        NMI_Handler ; 0x8000108
    HardFault_Handler
;;;161                    ENDP
;;;162    HardFault_Handler\
;;;163                    PROC
;;;164                    EXPORT  HardFault_Handler          [WEAK]
;;;165                    B       .
        0x0800010a:    e7fe        ..      B        HardFault_Handler ; 0x800010a
    MemManage_Handler
;;;166                    ENDP
;;;167    MemManage_Handler\
;;;168                    PROC
;;;169                    EXPORT  MemManage_Handler          [WEAK]
;;;170                    B       .
        0x0800010c:    e7fe        ..      B        MemManage_Handler ; 0x800010c
    BusFault_Handler
;;;171                    ENDP
;;;172    BusFault_Handler\
;;;173                    PROC
;;;174                    EXPORT  BusFault_Handler           [WEAK]
;;;175                    B       .
        0x0800010e:    e7fe        ..      B        BusFault_Handler ; 0x800010e
    UsageFault_Handler
;;;176                    ENDP
;;;177    UsageFault_Handler\
;;;178                    PROC
;;;179                    EXPORT  UsageFault_Handler         [WEAK]
;;;180                    B       .
        0x08000110:    e7fe        ..      B        UsageFault_Handler ; 0x8000110
;;;181                    ENDP
;;;182    SVC_Handler     PROC
;;;183                    EXPORT  SVC_Handler                [WEAK]
;;;184                    B       .
        0x08000112:    e7fe        ..      B        0x8000112 ; UsageFault_Handler + 2
    DebugMon_Handler
;;;185                    ENDP
;;;186    DebugMon_Handler\
;;;187                    PROC
;;;188                    EXPORT  DebugMon_Handler           [WEAK]
;;;189                    B       .
        0x08000114:    e7fe        ..      B        DebugMon_Handler ; 0x8000114
;;;190                    ENDP
;;;191    PendSV_Handler  PROC
;;;192                    EXPORT  PendSV_Handler             [WEAK]
;;;193                    B       .
        0x08000116:    e7fe        ..      B        0x8000116 ; DebugMon_Handler + 2
;;;194                    ENDP
;;;195    SysTick_Handler PROC
;;;196                    EXPORT  SysTick_Handler            [WEAK]
;;;197                    B       .
        0x08000118:    e7fe        ..      B        0x8000118 ; DebugMon_Handler + 4
    ADC1_2_IRQHandler
    CAN1_RX1_IRQHandler
    CAN1_SCE_IRQHandler
    DMA1_Channel1_IRQHandler
    DMA1_Channel2_IRQHandler
    DMA1_Channel3_IRQHandler
    DMA1_Channel5_IRQHandler
    DMA1_Channel7_IRQHandler
    EXTI0_IRQHandler
    EXTI15_10_IRQHandler
    EXTI1_IRQHandler
    EXTI2_IRQHandler
    EXTI3_IRQHandler
    EXTI4_IRQHandler
    EXTI9_5_IRQHandler
    FLASH_IRQHandler
    I2C1_ER_IRQHandler
    I2C1_EV_IRQHandler
    PVD_IRQHandler
    RCC_IRQHandler
    RTC_Alarm_IRQHandler
    RTC_IRQHandler
    SPI1_IRQHandler
    SPI2_IRQHandler
    TAMPER_IRQHandler
    TIM1_BRK_IRQHandler
    TIM1_CC_IRQHandler
    TIM1_TRG_COM_IRQHandler
    USART1_IRQHandler
    USART3_IRQHandler
    USBWakeUp_IRQHandler
    USB_HP_CAN1_TX_IRQHandler
    USB_LP_CAN1_RX0_IRQHandler
    WWDG_IRQHandler
;;;198                    ENDP
;;;199    
;;;200    Default_Handler PROC
;;;201    
;;;202                    EXPORT  WWDG_IRQHandler            [WEAK]
;;;203                    EXPORT  PVD_IRQHandler             [WEAK]
;;;204                    EXPORT  TAMPER_IRQHandler          [WEAK]
;;;205                    EXPORT  RTC_IRQHandler             [WEAK]
;;;206                    EXPORT  FLASH_IRQHandler           [WEAK]
;;;207                    EXPORT  RCC_IRQHandler             [WEAK]
;;;208                    EXPORT  EXTI0_IRQHandler           [WEAK]
;;;209                    EXPORT  EXTI1_IRQHandler           [WEAK]
;;;210                    EXPORT  EXTI2_IRQHandler           [WEAK]
;;;211                    EXPORT  EXTI3_IRQHandler           [WEAK]
;;;212                    EXPORT  EXTI4_IRQHandler           [WEAK]
;;;213                    EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
;;;214                    EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
;;;215                    EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
;;;216                    EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
;;;217                    EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
;;;218                    EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
;;;219                    EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
;;;220                    EXPORT  ADC1_2_IRQHandler          [WEAK]
;;;221                    EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
;;;222                    EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
;;;223                    EXPORT  CAN1_RX1_IRQHandler        [WEAK]
;;;224                    EXPORT  CAN1_SCE_IRQHandler        [WEAK]
;;;225                    EXPORT  EXTI9_5_IRQHandler         [WEAK]
;;;226                    EXPORT  TIM1_BRK_IRQHandler        [WEAK]
;;;227                    EXPORT  TIM1_UP_IRQHandler         [WEAK]
;;;228                    EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
;;;229                    EXPORT  TIM1_CC_IRQHandler         [WEAK]
;;;230                    EXPORT  TIM2_IRQHandler            [WEAK]
;;;231                    EXPORT  TIM3_IRQHandler            [WEAK]
;;;232                    EXPORT  TIM4_IRQHandler            [WEAK]
;;;233                    EXPORT  I2C1_EV_IRQHandler         [WEAK]
;;;234                    EXPORT  I2C1_ER_IRQHandler         [WEAK]
;;;235                    EXPORT  I2C2_EV_IRQHandler         [WEAK]
;;;236                    EXPORT  I2C2_ER_IRQHandler         [WEAK]
;;;237                    EXPORT  SPI1_IRQHandler            [WEAK]
;;;238                    EXPORT  SPI2_IRQHandler            [WEAK]
;;;239                    EXPORT  USART1_IRQHandler          [WEAK]
;;;240                    EXPORT  USART2_IRQHandler          [WEAK]
;;;241                    EXPORT  USART3_IRQHandler          [WEAK]
;;;242                    EXPORT  EXTI15_10_IRQHandler       [WEAK]
;;;243                    EXPORT  RTC_Alarm_IRQHandler        [WEAK]
;;;244                    EXPORT  USBWakeUp_IRQHandler       [WEAK]
;;;245    
;;;246    WWDG_IRQHandler
;;;247    PVD_IRQHandler
;;;248    TAMPER_IRQHandler
;;;249    RTC_IRQHandler
;;;250    FLASH_IRQHandler
;;;251    RCC_IRQHandler
;;;252    EXTI0_IRQHandler
;;;253    EXTI1_IRQHandler
;;;254    EXTI2_IRQHandler
;;;255    EXTI3_IRQHandler
;;;256    EXTI4_IRQHandler
;;;257    DMA1_Channel1_IRQHandler
;;;258    DMA1_Channel2_IRQHandler
;;;259    DMA1_Channel3_IRQHandler
;;;260    DMA1_Channel4_IRQHandler
;;;261    DMA1_Channel5_IRQHandler
;;;262    DMA1_Channel6_IRQHandler
;;;263    DMA1_Channel7_IRQHandler
;;;264    ADC1_2_IRQHandler
;;;265    USB_HP_CAN1_TX_IRQHandler
;;;266    USB_LP_CAN1_RX0_IRQHandler
;;;267    CAN1_RX1_IRQHandler
;;;268    CAN1_SCE_IRQHandler
;;;269    EXTI9_5_IRQHandler
;;;270    TIM1_BRK_IRQHandler
;;;271    TIM1_UP_IRQHandler
;;;272    TIM1_TRG_COM_IRQHandler
;;;273    TIM1_CC_IRQHandler
;;;274    TIM2_IRQHandler
;;;275    TIM3_IRQHandler
;;;276    TIM4_IRQHandler
;;;277    I2C1_EV_IRQHandler
;;;278    I2C1_ER_IRQHandler
;;;279    I2C2_EV_IRQHandler
;;;280    I2C2_ER_IRQHandler
;;;281    SPI1_IRQHandler
;;;282    SPI2_IRQHandler
;;;283    USART1_IRQHandler
;;;284    USART2_IRQHandler
;;;285    USART3_IRQHandler
;;;286    EXTI15_10_IRQHandler
;;;287    RTC_Alarm_IRQHandler
;;;288    USBWakeUp_IRQHandler
;;;289    
;;;290                    B       .
        0x0800011a:    e7fe        ..      B        ADC1_2_IRQHandler ; 0x800011a
    $d
        0x0800011c:    08001dd1    ....    DCD    134225361
        0x08000120:    080000ed    ....    DCD    134217965
    $t
    .text
    __aeabi_uldivmod
        0x08000124:    e92d5ff0    -.._    PUSH     {r4-r12,lr}
        0x08000128:    4605        .F      MOV      r5,r0
        0x0800012a:    2000        .       MOVS     r0,#0
        0x0800012c:    4692        .F      MOV      r10,r2
        0x0800012e:    469b        .F      MOV      r11,r3
        0x08000130:    4688        .F      MOV      r8,r1
        0x08000132:    4606        .F      MOV      r6,r0
        0x08000134:    4681        .F      MOV      r9,r0
        0x08000136:    2440        @$      MOVS     r4,#0x40
        0x08000138:    e01b        ..      B        0x8000172 ; __aeabi_uldivmod + 78
        0x0800013a:    4628        (F      MOV      r0,r5
        0x0800013c:    4641        AF      MOV      r1,r8
        0x0800013e:    4647        GF      MOV      r7,r8
        0x08000140:    4622        "F      MOV      r2,r4
        0x08000142:    f000fa12    ....    BL       __aeabi_llsr ; 0x800056a
        0x08000146:    4653        SF      MOV      r3,r10
        0x08000148:    465a        ZF      MOV      r2,r11
        0x0800014a:    1ac0        ..      SUBS     r0,r0,r3
        0x0800014c:    4191        .A      SBCS     r1,r1,r2
        0x0800014e:    d310        ..      BCC      0x8000172 ; __aeabi_uldivmod + 78
        0x08000150:    4611        .F      MOV      r1,r2
        0x08000152:    4618        .F      MOV      r0,r3
        0x08000154:    4622        "F      MOV      r2,r4
        0x08000156:    f000f9f9    ....    BL       __aeabi_llsl ; 0x800054c
        0x0800015a:    1a2d        -.      SUBS     r5,r5,r0
        0x0800015c:    eb670801    g...    SBC      r8,r7,r1
        0x08000160:    464f        OF      MOV      r7,r9
        0x08000162:    4622        "F      MOV      r2,r4
        0x08000164:    2001        .       MOVS     r0,#1
        0x08000166:    2100        .!      MOVS     r1,#0
        0x08000168:    f000f9f0    ....    BL       __aeabi_llsl ; 0x800054c
        0x0800016c:    eb170900    ....    ADDS     r9,r7,r0
        0x08000170:    414e        NA      ADCS     r6,r6,r1
        0x08000172:    1e20         .      SUBS     r0,r4,#0
        0x08000174:    f1a40401    ....    SUB      r4,r4,#1
        0x08000178:    dcdf        ..      BGT      0x800013a ; __aeabi_uldivmod + 22
        0x0800017a:    4648        HF      MOV      r0,r9
        0x0800017c:    4631        1F      MOV      r1,r6
        0x0800017e:    462a        *F      MOV      r2,r5
        0x08000180:    4643        CF      MOV      r3,r8
        0x08000182:    e8bd9ff0    ....    POP      {r4-r12,pc}
    .text
    __aeabi_memset
    __aeabi_memset4
    __aeabi_memset8
        0x08000186:    b2d2        ..      UXTB     r2,r2
        0x08000188:    e001        ..      B        0x800018e ; __aeabi_memset + 8
        0x0800018a:    f8002b01    ...+    STRB     r2,[r0],#1
        0x0800018e:    1e49        I.      SUBS     r1,r1,#1
        0x08000190:    d2fb        ..      BCS      0x800018a ; __aeabi_memset + 4
        0x08000192:    4770        pG      BX       lr
    __aeabi_memclr
    __aeabi_memclr4
    __aeabi_memclr8
        0x08000194:    2200        ."      MOVS     r2,#0
        0x08000196:    e7f6        ..      B        __aeabi_memset ; 0x8000186
    _memset$wrapper
        0x08000198:    b510        ..      PUSH     {r4,lr}
        0x0800019a:    4613        .F      MOV      r3,r2
        0x0800019c:    460a        .F      MOV      r2,r1
        0x0800019e:    4604        .F      MOV      r4,r0
        0x080001a0:    4619        .F      MOV      r1,r3
        0x080001a2:    f7fffff0    ....    BL       __aeabi_memset ; 0x8000186
        0x080001a6:    4620         F      MOV      r0,r4
        0x080001a8:    bd10        ..      POP      {r4,pc}
    .text
    __aeabi_dadd
        0x080001aa:    e92d4ffe    -..O    PUSH     {r1-r11,lr}
        0x080001ae:    4680        .F      MOV      r8,r0
        0x080001b0:    ea810003    ....    EOR      r0,r1,r3
        0x080001b4:    0fc0        ..      LSRS     r0,r0,#31
        0x080001b6:    460c        .F      MOV      r4,r1
        0x080001b8:    9000        ..      STR      r0,[sp,#0]
        0x080001ba:    f0214100    !..A    BIC      r1,r1,#0x80000000
        0x080001be:    f0234500    #..E    BIC      r5,r3,#0x80000000
        0x080001c2:    ebb80002    ....    SUBS     r0,r8,r2
        0x080001c6:    41a9        .A      SBCS     r1,r1,r5
        0x080001c8:    d205        ..      BCS      0x80001d6 ; __aeabi_dadd + 44
        0x080001ca:    4640        @F      MOV      r0,r8
        0x080001cc:    4621        !F      MOV      r1,r4
        0x080001ce:    4690        .F      MOV      r8,r2
        0x080001d0:    461c        .F      MOV      r4,r3
        0x080001d2:    460b        .F      MOV      r3,r1
        0x080001d4:    4602        .F      MOV      r2,r0
        0x080001d6:    f0234000    #..@    BIC      r0,r3,#0x80000000
        0x080001da:    4310        .C      ORRS     r0,r0,r2
        0x080001dc:    d047        G.      BEQ      0x800026e ; __aeabi_dadd + 196
        0x080001de:    0d27        '.      LSRS     r7,r4,#20
        0x080001e0:    f3c7000a    ....    UBFX     r0,r7,#0,#11
        0x080001e4:    f3c3510a    ...Q    UBFX     r1,r3,#20,#11
        0x080001e8:    9002        ..      STR      r0,[sp,#8]
        0x080001ea:    1a40        @.      SUBS     r0,r0,r1
        0x080001ec:    9001        ..      STR      r0,[sp,#4]
        0x080001ee:    2840        @(      CMP      r0,#0x40
        0x080001f0:    da6b        k.      BGE      0x80002ca ; __aeabi_dadd + 288
        0x080001f2:    f3c30013    ....    UBFX     r0,r3,#0,#20
        0x080001f6:    f4401b80    @...    ORR      r11,r0,#0x100000
        0x080001fa:    9800        ..      LDR      r0,[sp,#0]
        0x080001fc:    4692        .F      MOV      r10,r2
        0x080001fe:    b120         .      CBZ      r0,0x800020a ; __aeabi_dadd + 96
        0x08000200:    2300        .#      MOVS     r3,#0
        0x08000202:    ebd20a03    ....    RSBS     r10,r2,r3
        0x08000206:    eb630b0b    c...    SBC      r11,r3,r11
        0x0800020a:    9801        ..      LDR      r0,[sp,#4]
        0x0800020c:    4659        YF      MOV      r1,r11
        0x0800020e:    f1c00240    ..@.    RSB      r2,r0,#0x40
        0x08000212:    4650        PF      MOV      r0,r10
        0x08000214:    f000f99a    ....    BL       __aeabi_llsl ; 0x800054c
        0x08000218:    4606        .F      MOV      r6,r0
        0x0800021a:    460d        .F      MOV      r5,r1
        0x0800021c:    4650        PF      MOV      r0,r10
        0x0800021e:    4659        YF      MOV      r1,r11
        0x08000220:    9a01        ..      LDR      r2,[sp,#4]
        0x08000222:    f000f9b2    ....    BL       __aeabi_lasr ; 0x800058a
        0x08000226:    eb100008    ....    ADDS     r0,r0,r8
        0x0800022a:    4161        aA      ADCS     r1,r1,r4
        0x0800022c:    2400        .$      MOVS     r4,#0
        0x0800022e:    ea875211    ...R    EOR      r2,r7,r1,LSR #20
        0x08000232:    ea8473e7    ...s    EOR      r3,r4,r7,ASR #31
        0x08000236:    431a        .C      ORRS     r2,r2,r3
        0x08000238:    d040        @.      BEQ      0x80002bc ; __aeabi_dadd + 274
        0x0800023a:    9a00        ..      LDR      r2,[sp,#0]
        0x0800023c:    b362        b.      CBZ      r2,0x8000298 ; __aeabi_dadd + 238
        0x0800023e:    9a01        ..      LDR      r2,[sp,#4]
        0x08000240:    2a01        .*      CMP      r2,#1
        0x08000242:    ea4f5207    O..R    LSL      r2,r7,#20
        0x08000246:    dc15        ..      BGT      0x8000274 ; __aeabi_dadd + 202
        0x08000248:    1b00        ..      SUBS     r0,r0,r4
        0x0800024a:    eb610102    a...    SBC      r1,r1,r2
        0x0800024e:    f04f4200    O..B    MOV      r2,#0x80000000
        0x08000252:    ea025207    ...R    AND      r2,r2,r7,LSL #20
        0x08000256:    e9cd4200    ...B    STRD     r4,r2,[sp,#0]
        0x0800025a:    1c00        ..      ADDS     r0,r0,#0
        0x0800025c:    f5411180    A...    ADC      r1,r1,#0x100000
        0x08000260:    4632        2F      MOV      r2,r6
        0x08000262:    462b        +F      MOV      r3,r5
        0x08000264:    f000f9b2    ....    BL       _double_epilogue ; 0x80005cc
        0x08000268:    b003        ..      ADD      sp,sp,#0xc
        0x0800026a:    e8bd8ff0    ....    POP      {r4-r11,pc}
        0x0800026e:    4640        @F      MOV      r0,r8
        0x08000270:    4621        !F      MOV      r1,r4
        0x08000272:    e7f9        ..      B        0x8000268 ; __aeabi_dadd + 190
        0x08000274:    1b00        ..      SUBS     r0,r0,r4
        0x08000276:    eb610102    a...    SBC      r1,r1,r2
        0x0800027a:    1c00        ..      ADDS     r0,r0,#0
        0x0800027c:    f5411380    A...    ADC      r3,r1,#0x100000
        0x08000280:    1800        ..      ADDS     r0,r0,r0
        0x08000282:    415b        [A      ADCS     r3,r3,r3
        0x08000284:    1820         .      ADDS     r0,r4,r0
        0x08000286:    f5a21700    ....    SUB      r7,r2,#0x200000
        0x0800028a:    eb470103    G...    ADC      r1,r7,r3
        0x0800028e:    ea4070d5    @..p    ORR      r0,r0,r5,LSR #31
        0x08000292:    19b6        ..      ADDS     r6,r6,r6
        0x08000294:    416d        mA      ADCS     r5,r5,r5
        0x08000296:    e011        ..      B        0x80002bc ; __aeabi_dadd + 274
        0x08000298:    086d        m.      LSRS     r5,r5,#1
        0x0800029a:    ea4f0636    O.6.    RRX      r6,r6
        0x0800029e:    ea4575c0    E..u    ORR      r5,r5,r0,LSL #31
        0x080002a2:    ea4f5207    O..R    LSL      r2,r7,#20
        0x080002a6:    1b00        ..      SUBS     r0,r0,r4
        0x080002a8:    eb610102    a...    SBC      r1,r1,r2
        0x080002ac:    1c00        ..      ADDS     r0,r0,#0
        0x080002ae:    f5411180    A...    ADC      r1,r1,#0x100000
        0x080002b2:    0849        I.      LSRS     r1,r1,#1
        0x080002b4:    ea4f0030    O.0.    RRX      r0,r0
        0x080002b8:    1900        ..      ADDS     r0,r0,r4
        0x080002ba:    4151        QA      ADCS     r1,r1,r2
        0x080002bc:    4632        2F      MOV      r2,r6
        0x080002be:    462b        +F      MOV      r3,r5
        0x080002c0:    b003        ..      ADD      sp,sp,#0xc
        0x080002c2:    e8bd4ff0    ...O    POP      {r4-r11,lr}
        0x080002c6:    f000b972    ..r.    B.W      __I$use$fp ; 0x80005ae
        0x080002ca:    9800        ..      LDR      r0,[sp,#0]
        0x080002cc:    2201        ."      MOVS     r2,#1
        0x080002ce:    0040        @.      LSLS     r0,r0,#1
        0x080002d0:    2300        .#      MOVS     r3,#0
        0x080002d2:    ebd00202    ....    RSBS     r2,r0,r2
        0x080002d6:    eb6373e0    c..s    SBC      r3,r3,r0,ASR #31
        0x080002da:    9800        ..      LDR      r0,[sp,#0]
        0x080002dc:    4621        !F      MOV      r1,r4
        0x080002de:    ea4f74e0    O..t    ASR      r4,r0,#31
        0x080002e2:    ebb80000    ....    SUBS     r0,r8,r0
        0x080002e6:    eb610104    a...    SBC      r1,r1,r4
        0x080002ea:    e7e9        ..      B        0x80002c0 ; __aeabi_dadd + 278
    __aeabi_dsub
        0x080002ec:    f0834300    ...C    EOR      r3,r3,#0x80000000
        0x080002f0:    e75b        [.      B        __aeabi_dadd ; 0x80001aa
    __aeabi_drsub
        0x080002f2:    f0814100    ...A    EOR      r1,r1,#0x80000000
        0x080002f6:    e758        X.      B        __aeabi_dadd ; 0x80001aa
    .text
    __aeabi_dmul
        0x080002f8:    e92d4ffe    -..O    PUSH     {r1-r11,lr}
        0x080002fc:    ea810403    ....    EOR      r4,r1,r3
        0x08000300:    f0044400    ...D    AND      r4,r4,#0x80000000
        0x08000304:    f0214100    !..A    BIC      r1,r1,#0x80000000
        0x08000308:    9400        ..      STR      r4,[sp,#0]
        0x0800030a:    f04f0b00    O...    MOV      r11,#0
        0x0800030e:    f0234300    #..C    BIC      r3,r3,#0x80000000
        0x08000312:    ea500401    P...    ORRS     r4,r0,r1
        0x08000316:    d05e        ^.      BEQ      0x80003d6 ; __aeabi_dmul + 222
        0x08000318:    ea520403    R...    ORRS     r4,r2,r3
        0x0800031c:    d05b        [.      BEQ      0x80003d6 ; __aeabi_dmul + 222
        0x0800031e:    f3c3540a    ...T    UBFX     r4,r3,#20,#11
        0x08000322:    f3c1550a    ...U    UBFX     r5,r1,#20,#11
        0x08000326:    442c        ,D      ADD      r4,r4,r5
        0x08000328:    f2a434f3    ...4    SUB      r4,r4,#0x3f3
        0x0800032c:    9401        ..      STR      r4,[sp,#4]
        0x0800032e:    fba05402    ...T    UMULL    r5,r4,r0,r2
        0x08000332:    f3c10113    ....    UBFX     r1,r1,#0,#20
        0x08000336:    f4411180    A...    ORR      r1,r1,#0x100000
        0x0800033a:    f3c30313    ....    UBFX     r3,r3,#0,#20
        0x0800033e:    f4431380    C...    ORR      r3,r3,#0x100000
        0x08000342:    fb014402    ...D    MLA      r4,r1,r2,r4
        0x08000346:    fb004e03    ...N    MLA      lr,r0,r3,r4
        0x0800034a:    0a84        ..      LSRS     r4,r0,#10
        0x0800034c:    0a97        ..      LSRS     r7,r2,#10
        0x0800034e:    ea445481    D..T    ORR      r4,r4,r1,LSL #22
        0x08000352:    ea475783    G..W    ORR      r7,r7,r3,LSL #22
        0x08000356:    fba46807    ...h    UMULL    r6,r8,r4,r7
        0x0800035a:    9502        ..      STR      r5,[sp,#8]
        0x0800035c:    0a8d        ..      LSRS     r5,r1,#10
        0x0800035e:    fb058507    ....    MLA      r5,r5,r7,r8
        0x08000362:    ea4f2c93    O..,    LSR      r12,r3,#10
        0x08000366:    fb04540c    ...T    MLA      r4,r4,r12,r5
        0x0800036a:    0527        '.      LSLS     r7,r4,#20
        0x0800036c:    9d02        ..      LDR      r5,[sp,#8]
        0x0800036e:    ea4f5806    O..X    LSL      r8,r6,#20
        0x08000372:    ea473716    G..7    ORR      r7,r7,r6,LSR #12
        0x08000376:    ebb50508    ....    SUBS     r5,r5,r8
        0x0800037a:    eb6e0c07    n...    SBC      r12,lr,r7
        0x0800037e:    0e87        ..      LSRS     r7,r0,#26
        0x08000380:    0e92        ..      LSRS     r2,r2,#26
        0x08000382:    ea471781    G...    ORR      r7,r7,r1,LSL #6
        0x08000386:    ea421283    B...    ORR      r2,r2,r3,LSL #6
        0x0800038a:    fba70102    ....    UMULL    r0,r1,r7,r2
        0x0800038e:    ebb6010b    ....    SUBS     r1,r6,r11
        0x08000392:    eb640400    d...    SBC      r4,r4,r0
        0x08000396:    0d2b        +.      LSRS     r3,r5,#20
        0x08000398:    ea43330c    C..3    ORR      r3,r3,r12,LSL #12
        0x0800039c:    185e        ^.      ADDS     r6,r3,r1
        0x0800039e:    eb44501c    D..P    ADC      r0,r4,r12,LSR #20
        0x080003a2:    46da        .F      MOV      r10,r11
        0x080003a4:    4651        QF      MOV      r1,r10
        0x080003a6:    fbe70102    ....    UMLAL    r0,r1,r7,r2
        0x080003aa:    f3c50413    ....    UBFX     r4,r5,#0,#20
        0x080003ae:    ea4f330b    O..3    LSL      r3,r11,#12
        0x080003b2:    ea435314    C..S    ORR      r3,r3,r4,LSR #20
        0x080003b6:    ea4f3204    O..2    LSL      r2,r4,#12
        0x080003ba:    9c01        ..      LDR      r4,[sp,#4]
        0x080003bc:    ea430306    C...    ORR      r3,r3,r6
        0x080003c0:    f1a4040c    ....    SUB      r4,r4,#0xc
        0x080003c4:    9402        ..      STR      r4,[sp,#8]
        0x080003c6:    9c00        ..      LDR      r4,[sp,#0]
        0x080003c8:    e9cdb400    ....    STRD     r11,r4,[sp,#0]
        0x080003cc:    f000f8fe    ....    BL       _double_epilogue ; 0x80005cc
        0x080003d0:    b003        ..      ADD      sp,sp,#0xc
        0x080003d2:    e8bd8ff0    ....    POP      {r4-r11,pc}
        0x080003d6:    2000        .       MOVS     r0,#0
        0x080003d8:    4601        .F      MOV      r1,r0
        0x080003da:    e7f9        ..      B        0x80003d0 ; __aeabi_dmul + 216
    .text
    __aeabi_ddiv
        0x080003dc:    e92d4df0    -..M    PUSH     {r4-r8,r10,r11,lr}
        0x080003e0:    ea810403    ....    EOR      r4,r1,r3
        0x080003e4:    f0044b00    ...K    AND      r11,r4,#0x80000000
        0x080003e8:    f0214500    !..E    BIC      r5,r1,#0x80000000
        0x080003ec:    4614        .F      MOV      r4,r2
        0x080003ee:    f04f0a00    O...    MOV      r10,#0
        0x080003f2:    f0234100    #..A    BIC      r1,r3,#0x80000000
        0x080003f6:    ea500205    P...    ORRS     r2,r0,r5
        0x080003fa:    d020         .      BEQ      0x800043e ; __aeabi_ddiv + 98
        0x080003fc:    ea540201    T...    ORRS     r2,r4,r1
        0x08000400:    d01d        ..      BEQ      0x800043e ; __aeabi_ddiv + 98
        0x08000402:    f3c5570a    ...W    UBFX     r7,r5,#20,#11
        0x08000406:    4602        .F      MOV      r2,r0
        0x08000408:    f3c50313    ....    UBFX     r3,r5,#0,#20
        0x0800040c:    f3c10013    ....    UBFX     r0,r1,#0,#20
        0x08000410:    f3c1560a    ...V    UBFX     r6,r1,#20,#11
        0x08000414:    f4401580    @...    ORR      r5,r0,#0x100000
        0x08000418:    f4431380    C...    ORR      r3,r3,#0x100000
        0x0800041c:    eba70806    ....    SUB      r8,r7,r6
        0x08000420:    1b10        ..      SUBS     r0,r2,r4
        0x08000422:    46d6        .F      MOV      lr,r10
        0x08000424:    f20838fd    ...8    ADD      r8,r8,#0x3fd
        0x08000428:    eb730005    s...    SBCS     r0,r3,r5
        0x0800042c:    d302        ..      BCC      0x8000434 ; __aeabi_ddiv + 88
        0x0800042e:    f1080801    ....    ADD      r8,r8,#1
        0x08000432:    e001        ..      B        0x8000438 ; __aeabi_ddiv + 92
        0x08000434:    1892        ..      ADDS     r2,r2,r2
        0x08000436:    415b        [A      ADCS     r3,r3,r3
        0x08000438:    f1b80f00    ....    CMP      r8,#0
        0x0800043c:    da03        ..      BGE      0x8000446 ; __aeabi_ddiv + 106
        0x0800043e:    2000        .       MOVS     r0,#0
        0x08000440:    4601        .F      MOV      r1,r0
        0x08000442:    e8bd8df0    ....    POP      {r4-r8,r10,r11,pc}
        0x08000446:    2000        .       MOVS     r0,#0
        0x08000448:    f44f1180    O...    MOV      r1,#0x100000
        0x0800044c:    4606        .F      MOV      r6,r0
        0x0800044e:    4684        .F      MOV      r12,r0
        0x08000450:    e00e        ..      B        0x8000470 ; __aeabi_ddiv + 148
        0x08000452:    1b17        ..      SUBS     r7,r2,r4
        0x08000454:    eb730705    s...    SBCS     r7,r3,r5
        0x08000458:    d305        ..      BCC      0x8000466 ; __aeabi_ddiv + 138
        0x0800045a:    1b12        ..      SUBS     r2,r2,r4
        0x0800045c:    eb630305    c...    SBC      r3,r3,r5
        0x08000460:    4306        .C      ORRS     r6,r6,r0
        0x08000462:    ea4c0c01    L...    ORR      r12,r12,r1
        0x08000466:    0849        I.      LSRS     r1,r1,#1
        0x08000468:    ea4f0030    O.0.    RRX      r0,r0
        0x0800046c:    1892        ..      ADDS     r2,r2,r2
        0x0800046e:    415b        [A      ADCS     r3,r3,r3
        0x08000470:    ea500701    P...    ORRS     r7,r0,r1
        0x08000474:    d1ed        ..      BNE      0x8000452 ; __aeabi_ddiv + 118
        0x08000476:    ea520003    R...    ORRS     r0,r2,r3
        0x0800047a:    d012        ..      BEQ      0x80004a2 ; __aeabi_ddiv + 198
        0x0800047c:    ea820004    ....    EOR      r0,r2,r4
        0x08000480:    ea830105    ....    EOR      r1,r3,r5
        0x08000484:    4308        .C      ORRS     r0,r0,r1
        0x08000486:    d005        ..      BEQ      0x8000494 ; __aeabi_ddiv + 184
        0x08000488:    1b10        ..      SUBS     r0,r2,r4
        0x0800048a:    41ab        .A      SBCS     r3,r3,r5
        0x0800048c:    d206        ..      BCS      0x800049c ; __aeabi_ddiv + 192
        0x0800048e:    2201        ."      MOVS     r2,#1
        0x08000490:    2300        .#      MOVS     r3,#0
        0x08000492:    e006        ..      B        0x80004a2 ; __aeabi_ddiv + 198
        0x08000494:    2200        ."      MOVS     r2,#0
        0x08000496:    f04f4300    O..C    MOV      r3,#0x80000000
        0x0800049a:    e002        ..      B        0x80004a2 ; __aeabi_ddiv + 198
        0x0800049c:    f06f0201    o...    MVN      r2,#1
        0x080004a0:    1053        S.      ASRS     r3,r2,#1
        0x080004a2:    eb1a0006    ....    ADDS     r0,r10,r6
        0x080004a6:    eb4c5108    L..Q    ADC      r1,r12,r8,LSL #20
        0x080004aa:    eb10000a    ....    ADDS     r0,r0,r10
        0x080004ae:    eb41010b    A...    ADC      r1,r1,r11
        0x080004b2:    e8bd4df0    ...M    POP      {r4-r8,r10,r11,lr}
        0x080004b6:    f000b87a    ..z.    B.W      __I$use$fp ; 0x80005ae
    .text
    __aeabi_i2d
        0x080004ba:    b50e        ..      PUSH     {r1-r3,lr}
        0x080004bc:    0fc1        ..      LSRS     r1,r0,#31
        0x080004be:    ea8070e0    ...p    EOR      r0,r0,r0,ASR #31
        0x080004c2:    4408        .D      ADD      r0,r0,r1
        0x080004c4:    07ca        ..      LSLS     r2,r1,#31
        0x080004c6:    2100        .!      MOVS     r1,#0
        0x080004c8:    f2404333    @.3C    MOV      r3,#0x433
        0x080004cc:    e88d000e    ....    STM      sp,{r1-r3}
        0x080004d0:    460a        .F      MOV      r2,r1
        0x080004d2:    460b        .F      MOV      r3,r1
        0x080004d4:    f000f87a    ..z.    BL       _double_epilogue ; 0x80005cc
        0x080004d8:    b003        ..      ADD      sp,sp,#0xc
        0x080004da:    bd00        ..      POP      {pc}
    .text
    __aeabi_d2iz
        0x080004dc:    b570        p.      PUSH     {r4-r6,lr}
        0x080004de:    f3c1520a    ...R    UBFX     r2,r1,#20,#11
        0x080004e2:    f0014500    ...E    AND      r5,r1,#0x80000000
        0x080004e6:    2400        .$      MOVS     r4,#0
        0x080004e8:    f3c10113    ....    UBFX     r1,r1,#0,#20
        0x080004ec:    f24033ff    @..3    MOV      r3,#0x3ff
        0x080004f0:    f4411180    A...    ORR      r1,r1,#0x100000
        0x080004f4:    429a        .B      CMP      r2,r3
        0x080004f6:    da01        ..      BGE      0x80004fc ; __aeabi_d2iz + 32
        0x080004f8:    2000        .       MOVS     r0,#0
        0x080004fa:    bd70        p.      POP      {r4-r6,pc}
        0x080004fc:    f2404333    @.3C    MOV      r3,#0x433
        0x08000500:    429a        .B      CMP      r2,r3
        0x08000502:    f2a24233    ..3B    SUB      r2,r2,#0x433
        0x08000506:    dc03        ..      BGT      0x8000510 ; __aeabi_d2iz + 52
        0x08000508:    4252        RB      RSBS     r2,r2,#0
        0x0800050a:    f000f82e    ....    BL       __aeabi_llsr ; 0x800056a
        0x0800050e:    e000        ..      B        0x8000512 ; __aeabi_d2iz + 54
        0x08000510:    4090        .@      LSLS     r0,r0,r2
        0x08000512:    432c        ,C      ORRS     r4,r4,r5
        0x08000514:    d0f1        ..      BEQ      0x80004fa ; __aeabi_d2iz + 30
        0x08000516:    4240        @B      RSBS     r0,r0,#0
        0x08000518:    bd70        p.      POP      {r4-r6,pc}
        0x0800051a:    0000        ..      MOVS     r0,r0
    .text
    __aeabi_cdcmpeq
    __aeabi_cdcmple
        0x0800051c:    b530        0.      PUSH     {r4,r5,lr}
        0x0800051e:    1e04        ..      SUBS     r4,r0,#0
        0x08000520:    f1710400    q...    SBCS     r4,r1,#0
        0x08000524:    db04        ..      BLT      0x8000530 ; __aeabi_cdcmpeq + 20
        0x08000526:    f04f4400    O..D    MOV      r4,#0x80000000
        0x0800052a:    4240        @B      RSBS     r0,r0,#0
        0x0800052c:    eb640101    d...    SBC      r1,r4,r1
        0x08000530:    1e14        ..      SUBS     r4,r2,#0
        0x08000532:    f1730400    s...    SBCS     r4,r3,#0
        0x08000536:    db05        ..      BLT      0x8000544 ; __aeabi_cdcmpeq + 40
        0x08000538:    461c        .F      MOV      r4,r3
        0x0800053a:    f04f4300    O..C    MOV      r3,#0x80000000
        0x0800053e:    4252        RB      RSBS     r2,r2,#0
        0x08000540:    eb630304    c...    SBC      r3,r3,r4
        0x08000544:    428b        .B      CMP      r3,r1
        0x08000546:    bf08        ..      IT       EQ
        0x08000548:    4282        .B      CMPEQ    r2,r0
        0x0800054a:    bd30        0.      POP      {r4,r5,pc}
    .text
    __aeabi_llsl
    _ll_shift_l
        0x0800054c:    2a20         *      CMP      r2,#0x20
        0x0800054e:    db04        ..      BLT      0x800055a ; __aeabi_llsl + 14
        0x08000550:    3a20         :      SUBS     r2,r2,#0x20
        0x08000552:    fa00f102    ....    LSL      r1,r0,r2
        0x08000556:    2000        .       MOVS     r0,#0
        0x08000558:    4770        pG      BX       lr
        0x0800055a:    4091        .@      LSLS     r1,r1,r2
        0x0800055c:    f1c20320    .. .    RSB      r3,r2,#0x20
        0x08000560:    fa20f303     ...    LSR      r3,r0,r3
        0x08000564:    4319        .C      ORRS     r1,r1,r3
        0x08000566:    4090        .@      LSLS     r0,r0,r2
        0x08000568:    4770        pG      BX       lr
    .text
    __aeabi_llsr
    _ll_ushift_r
        0x0800056a:    2a20         *      CMP      r2,#0x20
        0x0800056c:    db04        ..      BLT      0x8000578 ; __aeabi_llsr + 14
        0x0800056e:    3a20         :      SUBS     r2,r2,#0x20
        0x08000570:    fa21f002    !...    LSR      r0,r1,r2
        0x08000574:    2100        .!      MOVS     r1,#0
        0x08000576:    4770        pG      BX       lr
        0x08000578:    fa21f302    !...    LSR      r3,r1,r2
        0x0800057c:    40d0        .@      LSRS     r0,r0,r2
        0x0800057e:    f1c20220    .. .    RSB      r2,r2,#0x20
        0x08000582:    4091        .@      LSLS     r1,r1,r2
        0x08000584:    4308        .C      ORRS     r0,r0,r1
        0x08000586:    4619        .F      MOV      r1,r3
        0x08000588:    4770        pG      BX       lr
    .text
    __aeabi_lasr
    _ll_sshift_r
        0x0800058a:    2a20         *      CMP      r2,#0x20
        0x0800058c:    db06        ..      BLT      0x800059c ; __aeabi_lasr + 18
        0x0800058e:    17cb        ..      ASRS     r3,r1,#31
        0x08000590:    3a20         :      SUBS     r2,r2,#0x20
        0x08000592:    fa41f002    A...    ASR      r0,r1,r2
        0x08000596:    ea4373e0    C..s    ORR      r3,r3,r0,ASR #31
        0x0800059a:    e006        ..      B        0x80005aa ; __aeabi_lasr + 32
        0x0800059c:    fa41f302    A...    ASR      r3,r1,r2
        0x080005a0:    40d0        .@      LSRS     r0,r0,r2
        0x080005a2:    f1c20220    .. .    RSB      r2,r2,#0x20
        0x080005a6:    4091        .@      LSLS     r1,r1,r2
        0x080005a8:    4308        .C      ORRS     r0,r0,r1
        0x080005aa:    4619        .F      MOV      r1,r3
        0x080005ac:    4770        pG      BX       lr
    .text
    .text
    __I$use$fp
    _double_round
        0x080005ae:    b510        ..      PUSH     {r4,lr}
        0x080005b0:    1e14        ..      SUBS     r4,r2,#0
        0x080005b2:    f1730400    s...    SBCS     r4,r3,#0
        0x080005b6:    da08        ..      BGE      0x80005ca ; __I$use$fp + 28
        0x080005b8:    1c40        @.      ADDS     r0,r0,#1
        0x080005ba:    f1410100    A...    ADC      r1,r1,#0
        0x080005be:    1892        ..      ADDS     r2,r2,r2
        0x080005c0:    415b        [A      ADCS     r3,r3,r3
        0x080005c2:    431a        .C      ORRS     r2,r2,r3
        0x080005c4:    d101        ..      BNE      0x80005ca ; __I$use$fp + 28
        0x080005c6:    f0200001     ...    BIC      r0,r0,#1
        0x080005ca:    bd10        ..      POP      {r4,pc}
    _double_epilogue
        0x080005cc:    e92d4df0    -..M    PUSH     {r4-r8,r10,r11,lr}
        0x080005d0:    4692        .F      MOV      r10,r2
        0x080005d2:    469b        .F      MOV      r11,r3
        0x080005d4:    b111        ..      CBZ      r1,0x80005dc ; _double_epilogue + 16
        0x080005d6:    fab1f281    ....    CLZ      r2,r1
        0x080005da:    e002        ..      B        0x80005e2 ; _double_epilogue + 22
        0x080005dc:    fab0f280    ....    CLZ      r2,r0
        0x080005e0:    3220         2      ADDS     r2,r2,#0x20
        0x080005e2:    4690        .F      MOV      r8,r2
        0x080005e4:    f7ffffb2    ....    BL       __aeabi_llsl ; 0x800054c
        0x080005e8:    4604        .F      MOV      r4,r0
        0x080005ea:    460f        .F      MOV      r7,r1
        0x080005ec:    ea40000a    @...    ORR      r0,r0,r10
        0x080005f0:    ea41010b    A...    ORR      r1,r1,r11
        0x080005f4:    4653        SF      MOV      r3,r10
        0x080005f6:    465a        ZF      MOV      r2,r11
        0x080005f8:    4308        .C      ORRS     r0,r0,r1
        0x080005fa:    d013        ..      BEQ      0x8000624 ; _double_epilogue + 88
        0x080005fc:    4611        .F      MOV      r1,r2
        0x080005fe:    ea530001    S...    ORRS     r0,r3,r1
        0x08000602:    d019        ..      BEQ      0x8000638 ; _double_epilogue + 108
        0x08000604:    f1c80240    ..@.    RSB      r2,r8,#0x40
        0x08000608:    4650        PF      MOV      r0,r10
        0x0800060a:    f7ffffae    ....    BL       __aeabi_llsr ; 0x800056a
        0x0800060e:    4605        .F      MOV      r5,r0
        0x08000610:    460e        .F      MOV      r6,r1
        0x08000612:    4650        PF      MOV      r0,r10
        0x08000614:    4659        YF      MOV      r1,r11
        0x08000616:    4642        BF      MOV      r2,r8
        0x08000618:    f7ffff98    ....    BL       __aeabi_llsl ; 0x800054c
        0x0800061c:    4308        .C      ORRS     r0,r0,r1
        0x0800061e:    d005        ..      BEQ      0x800062c ; _double_epilogue + 96
        0x08000620:    2001        .       MOVS     r0,#1
        0x08000622:    e004        ..      B        0x800062e ; _double_epilogue + 98
        0x08000624:    4620         F      MOV      r0,r4
        0x08000626:    4639        9F      MOV      r1,r7
        0x08000628:    e8bd8df0    ....    POP      {r4-r8,r10,r11,pc}
        0x0800062c:    2000        .       MOVS     r0,#0
        0x0800062e:    4305        .C      ORRS     r5,r5,r0
        0x08000630:    ea4676e0    F..v    ORR      r6,r6,r0,ASR #31
        0x08000634:    432c        ,C      ORRS     r4,r4,r5
        0x08000636:    4337        7C      ORRS     r7,r7,r6
        0x08000638:    980a        ..      LDR      r0,[sp,#0x28]
        0x0800063a:    0563        c.      LSLS     r3,r4,#21
        0x0800063c:    0ae4        ..      LSRS     r4,r4,#11
        0x0800063e:    eba00008    ....    SUB      r0,r0,r8
        0x08000642:    2200        ."      MOVS     r2,#0
        0x08000644:    0afd        ..      LSRS     r5,r7,#11
        0x08000646:    ea445447    D.GT    ORR      r4,r4,r7,LSL #21
        0x0800064a:    300a        .0      ADDS     r0,r0,#0xa
        0x0800064c:    d502        ..      BPL      0x8000654 ; _double_epilogue + 136
        0x0800064e:    2000        .       MOVS     r0,#0
        0x08000650:    4601        .F      MOV      r1,r0
        0x08000652:    e7e9        ..      B        0x8000628 ; _double_epilogue + 92
        0x08000654:    0501        ..      LSLS     r1,r0,#20
        0x08000656:    1910        ..      ADDS     r0,r2,r4
        0x08000658:    4169        iA      ADCS     r1,r1,r5
        0x0800065a:    e9dd4508    ...E    LDRD     r4,r5,[sp,#0x20]
        0x0800065e:    1900        ..      ADDS     r0,r0,r4
        0x08000660:    4169        iA      ADCS     r1,r1,r5
        0x08000662:    e8bd4df0    ...M    POP      {r4-r8,r10,r11,lr}
        0x08000666:    e7a2        ..      B        __I$use$fp ; 0x80005ae
    .text
    __scatterload
    __scatterload_rt2
        0x08000668:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000684] = 0x8003150
        0x0800066a:    4d07        .M      LDR      r5,[pc,#28] ; [0x8000688] = 0x8003170
        0x0800066c:    e006        ..      B        0x800067c ; __scatterload + 20
        0x0800066e:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000670:    f0400301    @...    ORR      r3,r0,#1
        0x08000674:    e8940007    ....    LDM      r4,{r0-r2}
        0x08000678:    4798        .G      BLX      r3
        0x0800067a:    3410        .4      ADDS     r4,r4,#0x10
        0x0800067c:    42ac        .B      CMP      r4,r5
        0x0800067e:    d3f6        ..      BCC      0x800066e ; __scatterload + 6
        0x08000680:    f7fffd38    ..8.    BL       __main_after_scatterload ; 0x80000f4
    $d
        0x08000684:    08003150    P1..    DCD    134230352
        0x08000688:    08003170    p1..    DCD    134230384
    $t
    .text
    __decompress
    __decompress1
        0x0800068c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800068e:    188c        ..      ADDS     r4,r1,r2
        0x08000690:    f8105b01    ...[    LDRB     r5,[r0],#1
        0x08000694:    f0150307    ....    ANDS     r3,r5,#7
        0x08000698:    d101        ..      BNE      0x800069e ; __decompress + 18
        0x0800069a:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x0800069e:    112a        *.      ASRS     r2,r5,#4
        0x080006a0:    d106        ..      BNE      0x80006b0 ; __decompress + 36
        0x080006a2:    f8102b01    ...+    LDRB     r2,[r0],#1
        0x080006a6:    e003        ..      B        0x80006b0 ; __decompress + 36
        0x080006a8:    f8106b01    ...k    LDRB     r6,[r0],#1
        0x080006ac:    f8016b01    ...k    STRB     r6,[r1],#1
        0x080006b0:    1e5b        [.      SUBS     r3,r3,#1
        0x080006b2:    d1f9        ..      BNE      0x80006a8 ; __decompress + 28
        0x080006b4:    072b        +.      LSLS     r3,r5,#28
        0x080006b6:    d405        ..      BMI      0x80006c4 ; __decompress + 56
        0x080006b8:    2300        .#      MOVS     r3,#0
        0x080006ba:    1e52        R.      SUBS     r2,r2,#1
        0x080006bc:    d40d        ..      BMI      0x80006da ; __decompress + 78
        0x080006be:    f8013b01    ...;    STRB     r3,[r1],#1
        0x080006c2:    e7fa        ..      B        0x80006ba ; __decompress + 46
        0x080006c4:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x080006c8:    1acb        ..      SUBS     r3,r1,r3
        0x080006ca:    1c92        ..      ADDS     r2,r2,#2
        0x080006cc:    e003        ..      B        0x80006d6 ; __decompress + 74
        0x080006ce:    f8135b01    ...[    LDRB     r5,[r3],#1
        0x080006d2:    f8015b01    ...[    STRB     r5,[r1],#1
        0x080006d6:    1e52        R.      SUBS     r2,r2,#1
        0x080006d8:    d5f9        ..      BPL      0x80006ce ; __decompress + 66
        0x080006da:    42a1        .B      CMP      r1,r4
        0x080006dc:    d3d8        ..      BCC      0x8000690 ; __decompress + 4
        0x080006de:    2000        .       MOVS     r0,#0
        0x080006e0:    bd70        p.      POP      {r4-r6,pc}
        0x080006e2:    0000        ..      MOVS     r0,r0
    i.DMA1_Channel4_IRQHandler
    DMA1_Channel4_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;192    {
        0x080006e4:    b510        ..      PUSH     {r4,lr}
;;;193      /* USER CODE BEGIN DMA1_Channel4_IRQn 0 */
;;;194      if(LL_DMA_IsActiveFlag_TC4(DMA1))
        0x080006e6:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1258     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
        0x080006e8:    480b        .H      LDR      r0,[pc,#44] ; [0x8000718] = 0x40020000
        0x080006ea:    6800        .h      LDR      r0,[r0,#0]
        0x080006ec:    f3c03040    ..@0    UBFX     r0,r0,#13,#1
        0x080006f0:    b140        @.      CBZ      r0,0x8000704 ; DMA1_Channel4_IRQHandler + 32
;;; .\../Src/stm32f1xx_it.c
;;;196        LL_DMA_ClearFlag_GI4(DMA1);
        0x080006f2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1489     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
        0x080006f4:    f44f5080    O..P    MOV      r0,#0x1000
        0x080006f8:    4907        .I      LDR      r1,[pc,#28] ; [0x8000718] = 0x40020000
        0x080006fa:    6048        H`      STR      r0,[r1,#4]
;;;1490   }
        0x080006fc:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;197        Transfer_Complete_Callback();
        0x080006fe:    f001fbed    ....    BL       Transfer_Complete_Callback ; 0x8001edc
        0x08000702:    e007        ..      B        0x8000714 ; DMA1_Channel4_IRQHandler + 48
;;;198    //    DMA1_Transfer_Complete_Callback();
;;;199      }
;;;200      else if(LL_DMA_IsActiveFlag_TE4(DMA1))
        0x08000704:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1412     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
        0x08000706:    4804        .H      LDR      r0,[pc,#16] ; [0x8000718] = 0x40020000
        0x08000708:    6800        .h      LDR      r0,[r0,#0]
        0x0800070a:    f3c030c0    ...0    UBFX     r0,r0,#15,#1
        0x0800070e:    b108        ..      CBZ      r0,0x8000714 ; DMA1_Channel4_IRQHandler + 48
;;; .\../Src/stm32f1xx_it.c
;;;202        Transfer_Error_Callback();
        0x08000710:    f001fc0e    ....    BL       Transfer_Error_Callback ; 0x8001f30
;;;203      }
;;;204    
;;;205      /* USER CODE END DMA1_Channel4_IRQn 0 */
;;;206      
;;;207      /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */
;;;208    
;;;209      /* USER CODE END DMA1_Channel4_IRQn 1 */
;;;210    }
        0x08000714:    bd10        ..      POP      {r4,pc}
    $d
        0x08000716:    0000        ..      DCW    0
        0x08000718:    40020000    ...@    DCD    1073872896
    $t
    i.DMA1_Channel6_IRQHandler
    DMA1_Channel6_IRQHandler
;;;211    
;;;212    /**
;;;213      * @brief This function handles DMA1 channel6 global interrupt.
;;;214      */
;;;215    void DMA1_Channel6_IRQHandler(void)
;;;216    {
;;;217      /* USER CODE BEGIN DMA1_Channel6_IRQn 0 */
;;;218    
;;;219      /* USER CODE END DMA1_Channel6_IRQn 0 */
;;;220      
;;;221      /* USER CODE BEGIN DMA1_Channel6_IRQn 1 */
;;;222    
;;;223      /* USER CODE END DMA1_Channel6_IRQn 1 */
;;;224    }
        0x0800071c:    4770        pG      BX       lr
    i.Error_Handler
    Error_Handler
;;; .\../Src/main.c
;;;1007   	while (1) {
        0x0800071e:    bf00        ..      NOP      
        0x08000720:    e7fe        ..      B        0x8000720 ; Error_Handler + 2
        0x08000722:    0000        ..      MOVS     r0,r0
    i.G01
    G01
;;; .\..\Src\fsm.c
;;;490    void G01(int dx, int dz, int feed){
        0x08000724:    b570        p.      PUSH     {r4-r6,lr}
        0x08000726:    4605        .F      MOV      r5,r0
        0x08000728:    460c        .F      MOV      r4,r1
        0x0800072a:    4616        .F      MOV      r6,r2
;;;491    	dzdx_init(dx, dz, &state);
        0x0800072c:    4a21        !J      LDR      r2,[pc,#132] ; [0x80007b4] = 0x20000044
        0x0800072e:    4621        !F      MOV      r1,r4
        0x08000730:    4628        (F      MOV      r0,r5
        0x08000732:    f001ff21    ..!.    BL       dzdx_init ; 0x8002578
;;;492    
;;;493    	if(dz<0) {
        0x08000736:    2c00        .,      CMP      r4,#0
        0x08000738:    da07        ..      BGE      0x800074a ; G01 + 38
;;;494    		feed_direction = feed_direction_left;
        0x0800073a:    2000        .       MOVS     r0,#0
        0x0800073c:    491e        .I      LDR      r1,[pc,#120] ; [0x80007b8] = 0x200000a1
        0x0800073e:    7008        .p      STRB     r0,[r1,#0]
;;;495    		MOTOR_Z_Reverse();
        0x08000740:    f2480080    H...    MOV      r0,#0x8080
        0x08000744:    491d        .I      LDR      r1,[pc,#116] ; [0x80007bc] = 0x40010814
        0x08000746:    6008        .`      STR      r0,[r1,#0]
        0x08000748:    e007        ..      B        0x800075a ; G01 + 54
;;;496    	} else {
;;;497    		feed_direction = feed_direction_right;
        0x0800074a:    2001        .       MOVS     r0,#1
        0x0800074c:    491a        .I      LDR      r1,[pc,#104] ; [0x80007b8] = 0x200000a1
        0x0800074e:    7008        .p      STRB     r0,[r1,#0]
;;;498    		MOTOR_Z_Forward();
        0x08000750:    f2480080    H...    MOV      r0,#0x8080
        0x08000754:    4919        .I      LDR      r1,[pc,#100] ; [0x80007bc] = 0x40010814
        0x08000756:    1f09        ..      SUBS     r1,r1,#4
        0x08000758:    6008        .`      STR      r0,[r1,#0]
;;;499    	}
;;;500    
;;;501    	if(dx<0) {
        0x0800075a:    2d00        .-      CMP      r5,#0
        0x0800075c:    da03        ..      BGE      0x8000766 ; G01 + 66
;;;502    		MOTOR_X_Reverse();
        0x0800075e:    4818        .H      LDR      r0,[pc,#96] ; [0x80007c0] = 0x4800080
        0x08000760:    4918        .I      LDR      r1,[pc,#96] ; [0x80007c4] = 0x40011000
        0x08000762:    6148        Ha      STR      r0,[r1,#0x14]
        0x08000764:    e002        ..      B        0x800076c ; G01 + 72
;;;503    	} else {
;;;504    		MOTOR_X_Forward();
        0x08000766:    4816        .H      LDR      r0,[pc,#88] ; [0x80007c0] = 0x4800080
        0x08000768:    4916        .I      LDR      r1,[pc,#88] ; [0x80007c4] = 0x40011000
        0x0800076a:    6108        .a      STR      r0,[r1,#0x10]
;;;505    	}
;;;506    
;;;507    	state.sync = false;
        0x0800076c:    2000        .       MOVS     r0,#0
        0x0800076e:    4911        .I      LDR      r1,[pc,#68] ; [0x80007b4] = 0x20000044
        0x08000770:    7408        .t      STRB     r0,[r1,#0x10]
;;;508    	if(state.sync){
        0x08000772:    4608        .F      MOV      r0,r1
        0x08000774:    7c00        .|      LDRB     r0,[r0,#0x10]
        0x08000776:    b110        ..      CBZ      r0,0x800077e ; G01 + 90
;;;509    		state.main_feed_direction = feed_direction;
        0x08000778:    480f        .H      LDR      r0,[pc,#60] ; [0x80007b8] = 0x200000a1
        0x0800077a:    7800        .x      LDRB     r0,[r0,#0]
        0x0800077c:    7448        Ht      STRB     r0,[r1,#0x11]
;;;510    	}
;;;511    
;;;512    	z_axis.current_pos = 0;
        0x0800077e:    2000        .       MOVS     r0,#0
        0x08000780:    4911        .I      LDR      r1,[pc,#68] ; [0x80007c8] = 0x200005e0
        0x08000782:    6008        .`      STR      r0,[r1,#0]
;;;513    	z_axis.end_pos = abs(dz);
        0x08000784:    1e20         .      SUBS     r0,r4,#0
        0x08000786:    db01        ..      BLT      0x800078c ; G01 + 104
        0x08000788:    4601        .F      MOV      r1,r0
        0x0800078a:    e000        ..      B        0x800078e ; G01 + 106
        0x0800078c:    4241        AB      RSBS     r1,r0,#0
        0x0800078e:    4a0e        .J      LDR      r2,[pc,#56] ; [0x80007c8] = 0x200005e0
        0x08000790:    6051        Q`      STR      r1,[r2,#4]
;;;514    	if(z_axis.end_pos > 0){
        0x08000792:    4610        .F      MOV      r0,r2
        0x08000794:    6840        @h      LDR      r0,[r0,#4]
        0x08000796:    b130        0.      CBZ      r0,0x80007a6 ; G01 + 130
;;;515    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
        0x08000798:    4610        .F      MOV      r0,r2
        0x0800079a:    6840        @h      LDR      r0,[r0,#4]
        0x0800079c:    f0200001     ...    BIC      r0,r0,#1
        0x080007a0:    4611        .F      MOV      r1,r2
        0x080007a2:    6048        H`      STR      r0,[r1,#4]
        0x080007a4:    e002        ..      B        0x80007ac ; G01 + 136
;;;516    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;517    
;;;518    	} else {
;;;519    		state.sync = true;
        0x080007a6:    2001        .       MOVS     r0,#1
        0x080007a8:    4902        .I      LDR      r1,[pc,#8] ; [0x80007b4] = 0x20000044
        0x080007aa:    7408        .t      STRB     r0,[r1,#0x10]
;;;520    	}
;;;521    	do_fsm_move_start(&state);
        0x080007ac:    4801        .H      LDR      r0,[pc,#4] ; [0x80007b4] = 0x20000044
        0x080007ae:    f001fdb9    ....    BL       do_fsm_move_start ; 0x8002324
;;;522    }
        0x080007b2:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080007b4:    20000044    D..     DCD    536870980
        0x080007b8:    200000a1    ...     DCD    536871073
        0x080007bc:    40010814    ...@    DCD    1073809428
        0x080007c0:    04800080    ....    DCD    75497600
        0x080007c4:    40011000    ...@    DCD    1073811456
        0x080007c8:    200005e0    ...     DCD    536872416
    $t
    i.I2C2_ER_IRQHandler
    I2C2_ER_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;367      while(1){
        0x080007cc:    bf00        ..      NOP      
        0x080007ce:    e7fe        ..      B        0x80007ce ; I2C2_ER_IRQHandler + 2
    i.I2C2_EV_IRQHandler
    I2C2_EV_IRQHandler
;;; .\../Src/stm32f1xx_it.c (336)
        0x080007d0:    b508        ..      PUSH     {r3,lr}
;;;337      /* USER CODE BEGIN I2C2_EV_IRQn 0 */
;;;338      /* Check SB flag value in ISR register */
;;;339      if(LL_I2C_IsActiveFlag_SB(I2C2))
        0x080007d2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1186     return (READ_BIT(I2Cx->SR1, I2C_SR1_SB) == (I2C_SR1_SB));
        0x080007d4:    4814        .H      LDR      r0,[pc,#80] ; [0x8000828] = 0x40005800
        0x080007d6:    6940        @i      LDR      r0,[r0,#0x14]
        0x080007d8:    f0000001    ....    AND      r0,r0,#1
        0x080007dc:    b148        H.      CBZ      r0,0x80007f2 ; I2C2_EV_IRQHandler + 34
;;; .\../Src/stm32f1xx_it.c
;;;342        LL_I2C_TransmitData8(I2C2, SSD1306_I2C_ADDR);
        0x080007de:    2078        x       MOVS     r0,#0x78
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1758     MODIFY_REG(I2Cx->DR, I2C_DR_DR, Data);
        0x080007e0:    4911        .I      LDR      r1,[pc,#68] ; [0x8000828] = 0x40005800
        0x080007e2:    6909        .i      LDR      r1,[r1,#0x10]
        0x080007e4:    f02101ff    !...    BIC      r1,r1,#0xff
        0x080007e8:    4301        .C      ORRS     r1,r1,r0
        0x080007ea:    4a0f        .J      LDR      r2,[pc,#60] ; [0x8000828] = 0x40005800
        0x080007ec:    6111        .a      STR      r1,[r2,#0x10]
;;;1759   }
        0x080007ee:    bf00        ..      NOP      
        0x080007f0:    e018        ..      B        0x8000824 ; I2C2_EV_IRQHandler + 84
;;; .\../Src/stm32f1xx_it.c
;;;345      else if(LL_I2C_IsActiveFlag_ADDR(I2C2))
        0x080007f2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1199     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADDR) == (I2C_SR1_ADDR));
        0x080007f4:    480c        .H      LDR      r0,[pc,#48] ; [0x8000828] = 0x40005800
        0x080007f6:    6940        @i      LDR      r0,[r0,#0x14]
        0x080007f8:    f3c00040    ..@.    UBFX     r0,r0,#1,#1
        0x080007fc:    b190        ..      CBZ      r0,0x8000824 ; I2C2_EV_IRQHandler + 84
;;; .\../Src/stm32f1xx_it.c
;;;348        LL_I2C_EnableDMAReq_TX(I2C2);
        0x080007fe:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;401      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
        0x08000800:    4809        .H      LDR      r0,[pc,#36] ; [0x8000828] = 0x40005800
        0x08000802:    6840        @h      LDR      r0,[r0,#4]
        0x08000804:    f4406000    @..`    ORR      r0,r0,#0x800
        0x08000808:    4907        .I      LDR      r1,[pc,#28] ; [0x8000828] = 0x40005800
        0x0800080a:    6048        H`      STR      r0,[r1,#4]
;;;402    }
        0x0800080c:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;351        LL_I2C_ClearFlag_ADDR(I2C2);
        0x0800080e:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1415     tmpreg = I2Cx->SR1;
        0x08000810:    4608        .F      MOV      r0,r1
        0x08000812:    6940        @i      LDR      r0,[r0,#0x14]
        0x08000814:    9000        ..      STR      r0,[sp,#0]
;;;1416     (void) tmpreg;
        0x08000816:    bf00        ..      NOP      
;;;1417     tmpreg = I2Cx->SR2;
        0x08000818:    4608        .F      MOV      r0,r1
        0x0800081a:    6980        .i      LDR      r0,[r0,#0x18]
        0x0800081c:    9000        ..      STR      r0,[sp,#0]
;;;1418     (void) tmpreg;
        0x0800081e:    bf00        ..      NOP      
;;;1419   }
        0x08000820:    bf00        ..      NOP      
        0x08000822:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;359    }
        0x08000824:    bd08        ..      POP      {r3,pc}
    $d
        0x08000826:    0000        ..      DCW    0
        0x08000828:    40005800    .X.@    DCD    1073764352
    $t
    i.LL_APB1_GRP1_EnableClock
    LL_APB1_GRP1_EnableClock
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;464    {
        0x0800082c:    b508        ..      PUSH     {r3,lr}
;;;465      __IO uint32_t tmpreg;
;;;466      SET_BIT(RCC->APB1ENR, Periphs);
        0x0800082e:    4905        .I      LDR      r1,[pc,#20] ; [0x8000844] = 0x40021000
        0x08000830:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x08000832:    4301        .C      ORRS     r1,r1,r0
        0x08000834:    4a03        .J      LDR      r2,[pc,#12] ; [0x8000844] = 0x40021000
        0x08000836:    61d1        .a      STR      r1,[r2,#0x1c]
;;;467      /* Delay after an RCC peripheral clock enabling */
;;;468      tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
        0x08000838:    4611        .F      MOV      r1,r2
        0x0800083a:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x0800083c:    4001        .@      ANDS     r1,r1,r0
        0x0800083e:    9100        ..      STR      r1,[sp,#0]
;;;469      (void)tmpreg;
        0x08000840:    bf00        ..      NOP      
;;;470    }
        0x08000842:    bd08        ..      POP      {r3,pc}
    $d
        0x08000844:    40021000    ...@    DCD    1073876992
    $t
    i.LL_APB2_GRP1_EnableClock
    LL_APB2_GRP1_EnableClock
;;;471    
;;;472    /**
;;;473      * @brief  Check if APB1 peripheral clock is enabled or not
;;;474      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_IsEnabledClock\n
;;;475      *         APB1ENR      CAN1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;476      *         APB1ENR      CAN2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;477      *         APB1ENR      CECEN         LL_APB1_GRP1_IsEnabledClock\n
;;;478      *         APB1ENR      DACEN         LL_APB1_GRP1_IsEnabledClock\n
;;;479      *         APB1ENR      I2C1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;480      *         APB1ENR      I2C2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;481      *         APB1ENR      PWREN         LL_APB1_GRP1_IsEnabledClock\n
;;;482      *         APB1ENR      SPI2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;483      *         APB1ENR      SPI3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;484      *         APB1ENR      TIM12EN       LL_APB1_GRP1_IsEnabledClock\n
;;;485      *         APB1ENR      TIM13EN       LL_APB1_GRP1_IsEnabledClock\n
;;;486      *         APB1ENR      TIM14EN       LL_APB1_GRP1_IsEnabledClock\n
;;;487      *         APB1ENR      TIM2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;488      *         APB1ENR      TIM3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;489      *         APB1ENR      TIM4EN        LL_APB1_GRP1_IsEnabledClock\n
;;;490      *         APB1ENR      TIM5EN        LL_APB1_GRP1_IsEnabledClock\n
;;;491      *         APB1ENR      TIM6EN        LL_APB1_GRP1_IsEnabledClock\n
;;;492      *         APB1ENR      TIM7EN        LL_APB1_GRP1_IsEnabledClock\n
;;;493      *         APB1ENR      UART4EN       LL_APB1_GRP1_IsEnabledClock\n
;;;494      *         APB1ENR      UART5EN       LL_APB1_GRP1_IsEnabledClock\n
;;;495      *         APB1ENR      USART2EN      LL_APB1_GRP1_IsEnabledClock\n
;;;496      *         APB1ENR      USART3EN      LL_APB1_GRP1_IsEnabledClock\n
;;;497      *         APB1ENR      USBEN         LL_APB1_GRP1_IsEnabledClock\n
;;;498      *         APB1ENR      WWDGEN        LL_APB1_GRP1_IsEnabledClock
;;;499      * @param  Periphs This parameter can be a combination of the following values:
;;;500      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;501      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;502      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;503      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;504      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;505      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;506      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;507      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;508      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;509      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;510      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;511      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;512      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;513      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;514      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;515      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;516      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;517      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;518      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;519      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;520      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;521      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;522      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;523      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;524      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;525      *
;;;526      *         (*) value not defined in all devices.
;;;527      * @retval State of Periphs (1 or 0).
;;;528    */
;;;529    __STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
;;;530    {
;;;531      return (READ_BIT(RCC->APB1ENR, Periphs) == Periphs);
;;;532    }
;;;533    
;;;534    /**
;;;535      * @brief  Disable APB1 peripherals clock.
;;;536      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_DisableClock\n
;;;537      *         APB1ENR      CAN1EN        LL_APB1_GRP1_DisableClock\n
;;;538      *         APB1ENR      CAN2EN        LL_APB1_GRP1_DisableClock\n
;;;539      *         APB1ENR      CECEN         LL_APB1_GRP1_DisableClock\n
;;;540      *         APB1ENR      DACEN         LL_APB1_GRP1_DisableClock\n
;;;541      *         APB1ENR      I2C1EN        LL_APB1_GRP1_DisableClock\n
;;;542      *         APB1ENR      I2C2EN        LL_APB1_GRP1_DisableClock\n
;;;543      *         APB1ENR      PWREN         LL_APB1_GRP1_DisableClock\n
;;;544      *         APB1ENR      SPI2EN        LL_APB1_GRP1_DisableClock\n
;;;545      *         APB1ENR      SPI3EN        LL_APB1_GRP1_DisableClock\n
;;;546      *         APB1ENR      TIM12EN       LL_APB1_GRP1_DisableClock\n
;;;547      *         APB1ENR      TIM13EN       LL_APB1_GRP1_DisableClock\n
;;;548      *         APB1ENR      TIM14EN       LL_APB1_GRP1_DisableClock\n
;;;549      *         APB1ENR      TIM2EN        LL_APB1_GRP1_DisableClock\n
;;;550      *         APB1ENR      TIM3EN        LL_APB1_GRP1_DisableClock\n
;;;551      *         APB1ENR      TIM4EN        LL_APB1_GRP1_DisableClock\n
;;;552      *         APB1ENR      TIM5EN        LL_APB1_GRP1_DisableClock\n
;;;553      *         APB1ENR      TIM6EN        LL_APB1_GRP1_DisableClock\n
;;;554      *         APB1ENR      TIM7EN        LL_APB1_GRP1_DisableClock\n
;;;555      *         APB1ENR      UART4EN       LL_APB1_GRP1_DisableClock\n
;;;556      *         APB1ENR      UART5EN       LL_APB1_GRP1_DisableClock\n
;;;557      *         APB1ENR      USART2EN      LL_APB1_GRP1_DisableClock\n
;;;558      *         APB1ENR      USART3EN      LL_APB1_GRP1_DisableClock\n
;;;559      *         APB1ENR      USBEN         LL_APB1_GRP1_DisableClock\n
;;;560      *         APB1ENR      WWDGEN        LL_APB1_GRP1_DisableClock
;;;561      * @param  Periphs This parameter can be a combination of the following values:
;;;562      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;563      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;564      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;565      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;566      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;567      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;568      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;569      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;570      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;571      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;572      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;573      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;574      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;575      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;576      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;577      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;578      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;579      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;580      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;581      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;582      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;583      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;584      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;585      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;586      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;587      *
;;;588      *         (*) value not defined in all devices.
;;;589      * @retval None
;;;590    */
;;;591    __STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
;;;592    {
;;;593      CLEAR_BIT(RCC->APB1ENR, Periphs);
;;;594    }
;;;595    
;;;596    /**
;;;597      * @brief  Force APB1 peripherals reset.
;;;598      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ForceReset\n
;;;599      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ForceReset\n
;;;600      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ForceReset\n
;;;601      *         APB1RSTR     CECRST        LL_APB1_GRP1_ForceReset\n
;;;602      *         APB1RSTR     DACRST        LL_APB1_GRP1_ForceReset\n
;;;603      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ForceReset\n
;;;604      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ForceReset\n
;;;605      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ForceReset\n
;;;606      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ForceReset\n
;;;607      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ForceReset\n
;;;608      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ForceReset\n
;;;609      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ForceReset\n
;;;610      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ForceReset\n
;;;611      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ForceReset\n
;;;612      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ForceReset\n
;;;613      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ForceReset\n
;;;614      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ForceReset\n
;;;615      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ForceReset\n
;;;616      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ForceReset\n
;;;617      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ForceReset\n
;;;618      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ForceReset\n
;;;619      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ForceReset\n
;;;620      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ForceReset\n
;;;621      *         APB1RSTR     USBRST        LL_APB1_GRP1_ForceReset\n
;;;622      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ForceReset
;;;623      * @param  Periphs This parameter can be a combination of the following values:
;;;624      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;625      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;626      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;627      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;628      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;629      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;630      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;631      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;632      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;633      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;634      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;635      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;636      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;637      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;638      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;639      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;640      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;641      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;642      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;643      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;644      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;645      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;646      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;647      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;648      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;649      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;650      *
;;;651      *         (*) value not defined in all devices.
;;;652      * @retval None
;;;653    */
;;;654    __STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
;;;655    {
;;;656      SET_BIT(RCC->APB1RSTR, Periphs);
;;;657    }
;;;658    
;;;659    /**
;;;660      * @brief  Release APB1 peripherals reset.
;;;661      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ReleaseReset\n
;;;662      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ReleaseReset\n
;;;663      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ReleaseReset\n
;;;664      *         APB1RSTR     CECRST        LL_APB1_GRP1_ReleaseReset\n
;;;665      *         APB1RSTR     DACRST        LL_APB1_GRP1_ReleaseReset\n
;;;666      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ReleaseReset\n
;;;667      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ReleaseReset\n
;;;668      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ReleaseReset\n
;;;669      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ReleaseReset\n
;;;670      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ReleaseReset\n
;;;671      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ReleaseReset\n
;;;672      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ReleaseReset\n
;;;673      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ReleaseReset\n
;;;674      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ReleaseReset\n
;;;675      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ReleaseReset\n
;;;676      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ReleaseReset\n
;;;677      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ReleaseReset\n
;;;678      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ReleaseReset\n
;;;679      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ReleaseReset\n
;;;680      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ReleaseReset\n
;;;681      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ReleaseReset\n
;;;682      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ReleaseReset\n
;;;683      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ReleaseReset\n
;;;684      *         APB1RSTR     USBRST        LL_APB1_GRP1_ReleaseReset\n
;;;685      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ReleaseReset
;;;686      * @param  Periphs This parameter can be a combination of the following values:
;;;687      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;688      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;689      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;690      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;691      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;692      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;693      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;694      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;695      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;696      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;697      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;698      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;699      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;700      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;701      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;702      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;703      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;704      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;705      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;706      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;707      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;708      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;709      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;710      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;711      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;712      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;713      *
;;;714      *         (*) value not defined in all devices.
;;;715      * @retval None
;;;716    */
;;;717    __STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
;;;718    {
;;;719      CLEAR_BIT(RCC->APB1RSTR, Periphs);
;;;720    }
;;;721    
;;;722    /**
;;;723      * @}
;;;724      */
;;;725    
;;;726    /** @defgroup BUS_LL_EF_APB2 APB2
;;;727      * @{
;;;728      */
;;;729    
;;;730    /**
;;;731      * @brief  Enable APB2 peripherals clock.
;;;732      * @rmtoll APB2ENR      ADC1EN        LL_APB2_GRP1_EnableClock\n
;;;733      *         APB2ENR      ADC2EN        LL_APB2_GRP1_EnableClock\n
;;;734      *         APB2ENR      ADC3EN        LL_APB2_GRP1_EnableClock\n
;;;735      *         APB2ENR      AFIOEN        LL_APB2_GRP1_EnableClock\n
;;;736      *         APB2ENR      IOPAEN        LL_APB2_GRP1_EnableClock\n
;;;737      *         APB2ENR      IOPBEN        LL_APB2_GRP1_EnableClock\n
;;;738      *         APB2ENR      IOPCEN        LL_APB2_GRP1_EnableClock\n
;;;739      *         APB2ENR      IOPDEN        LL_APB2_GRP1_EnableClock\n
;;;740      *         APB2ENR      IOPEEN        LL_APB2_GRP1_EnableClock\n
;;;741      *         APB2ENR      IOPFEN        LL_APB2_GRP1_EnableClock\n
;;;742      *         APB2ENR      IOPGEN        LL_APB2_GRP1_EnableClock\n
;;;743      *         APB2ENR      SPI1EN        LL_APB2_GRP1_EnableClock\n
;;;744      *         APB2ENR      TIM10EN       LL_APB2_GRP1_EnableClock\n
;;;745      *         APB2ENR      TIM11EN       LL_APB2_GRP1_EnableClock\n
;;;746      *         APB2ENR      TIM15EN       LL_APB2_GRP1_EnableClock\n
;;;747      *         APB2ENR      TIM16EN       LL_APB2_GRP1_EnableClock\n
;;;748      *         APB2ENR      TIM17EN       LL_APB2_GRP1_EnableClock\n
;;;749      *         APB2ENR      TIM1EN        LL_APB2_GRP1_EnableClock\n
;;;750      *         APB2ENR      TIM8EN        LL_APB2_GRP1_EnableClock\n
;;;751      *         APB2ENR      TIM9EN        LL_APB2_GRP1_EnableClock\n
;;;752      *         APB2ENR      USART1EN      LL_APB2_GRP1_EnableClock
;;;753      * @param  Periphs This parameter can be a combination of the following values:
;;;754      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC1
;;;755      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC2 (*)
;;;756      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC3 (*)
;;;757      *         @arg @ref LL_APB2_GRP1_PERIPH_AFIO
;;;758      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOA
;;;759      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOB
;;;760      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOC
;;;761      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOD
;;;762      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOE (*)
;;;763      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOF (*)
;;;764      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOG (*)
;;;765      *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
;;;766      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM10 (*)
;;;767      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM11 (*)
;;;768      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15 (*)
;;;769      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16 (*)
;;;770      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
;;;771      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
;;;772      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
;;;773      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM9 (*)
;;;774      *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
;;;775      *
;;;776      *         (*) value not defined in all devices.
;;;777      * @retval None
;;;778    */
;;;779    __STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
;;;780    {
        0x08000848:    b508        ..      PUSH     {r3,lr}
;;;781      __IO uint32_t tmpreg;
;;;782      SET_BIT(RCC->APB2ENR, Periphs);
        0x0800084a:    4905        .I      LDR      r1,[pc,#20] ; [0x8000860] = 0x40021000
        0x0800084c:    6989        .i      LDR      r1,[r1,#0x18]
        0x0800084e:    4301        .C      ORRS     r1,r1,r0
        0x08000850:    4a03        .J      LDR      r2,[pc,#12] ; [0x8000860] = 0x40021000
        0x08000852:    6191        .a      STR      r1,[r2,#0x18]
;;;783      /* Delay after an RCC peripheral clock enabling */
;;;784      tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
        0x08000854:    4611        .F      MOV      r1,r2
        0x08000856:    6989        .i      LDR      r1,[r1,#0x18]
        0x08000858:    4001        .@      ANDS     r1,r1,r0
        0x0800085a:    9100        ..      STR      r1,[sp,#0]
;;;785      (void)tmpreg;
        0x0800085c:    bf00        ..      NOP      
;;;786    }
        0x0800085e:    bd08        ..      POP      {r3,pc}
    $d
        0x08000860:    40021000    ...@    DCD    1073876992
    $t
    i.LL_DMA_SetChannelPriorityLevel
    LL_DMA_SetChannelPriorityLevel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;850    {
        0x08000864:    b530        0.      PUSH     {r4,r5,lr}
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
        0x08000866:    1e4b        K.      SUBS     r3,r1,#1
        0x08000868:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000880] = 0x8003118
        0x0800086a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800086c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800086e:    f4235340    #.@S    BIC      r3,r3,#0x3000
        0x08000872:    4313        .C      ORRS     r3,r3,r2
        0x08000874:    1e4c        L.      SUBS     r4,r1,#1
        0x08000876:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000880] = 0x8003118
        0x08000878:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800087a:    5103        .Q      STR      r3,[r0,r4]
;;;852                 Priority);
;;;853    }
        0x0800087c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800087e:    0000        ..      DCW    0
        0x08000880:    08003118    .1..    DCD    134230296
    $t
    i.LL_DMA_SetDataTransferDirection
    LL_DMA_SetDataTransferDirection
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (570)
        0x08000884:    b530        0.      PUSH     {r4,r5,lr}
;;;571      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
        0x08000886:    1e4b        K.      SUBS     r3,r1,#1
        0x08000888:    4c05        .L      LDR      r4,[pc,#20] ; [0x80008a0] = 0x8003118
        0x0800088a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800088c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800088e:    f2440410    D...    MOV      r4,#0x4010
        0x08000892:    43a3        .C      BICS     r3,r3,r4
        0x08000894:    4313        .C      ORRS     r3,r3,r2
        0x08000896:    1e4c        L.      SUBS     r4,r1,#1
        0x08000898:    4d01        .M      LDR      r5,[pc,#4] ; [0x80008a0] = 0x8003118
        0x0800089a:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800089c:    5103        .Q      STR      r3,[r0,r4]
;;;572                 DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
;;;573    }
        0x0800089e:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008a0:    08003118    .1..    DCD    134230296
    $t
    i.LL_DMA_SetMemoryIncMode
    LL_DMA_SetMemoryIncMode
;;;574    
;;;575    /**
;;;576      * @brief  Get Data transfer direction (read from peripheral or from memory).
;;;577      * @rmtoll CCR          DIR           LL_DMA_GetDataTransferDirection\n
;;;578      *         CCR          MEM2MEM       LL_DMA_GetDataTransferDirection
;;;579      * @param  DMAx DMAx Instance
;;;580      * @param  Channel This parameter can be one of the following values:
;;;581      *         @arg @ref LL_DMA_CHANNEL_1
;;;582      *         @arg @ref LL_DMA_CHANNEL_2
;;;583      *         @arg @ref LL_DMA_CHANNEL_3
;;;584      *         @arg @ref LL_DMA_CHANNEL_4
;;;585      *         @arg @ref LL_DMA_CHANNEL_5
;;;586      *         @arg @ref LL_DMA_CHANNEL_6
;;;587      *         @arg @ref LL_DMA_CHANNEL_7
;;;588      * @retval Returned value can be one of the following values:
;;;589      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;590      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;591      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;592      */
;;;593    __STATIC_INLINE uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
;;;594    {
;;;595      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;596                       DMA_CCR_DIR | DMA_CCR_MEM2MEM));
;;;597    }
;;;598    
;;;599    /**
;;;600      * @brief  Set DMA mode circular or normal.
;;;601      * @note The circular buffer mode cannot be used if the memory-to-memory
;;;602      * data transfer is configured on the selected Channel.
;;;603      * @rmtoll CCR          CIRC          LL_DMA_SetMode
;;;604      * @param  DMAx DMAx Instance
;;;605      * @param  Channel This parameter can be one of the following values:
;;;606      *         @arg @ref LL_DMA_CHANNEL_1
;;;607      *         @arg @ref LL_DMA_CHANNEL_2
;;;608      *         @arg @ref LL_DMA_CHANNEL_3
;;;609      *         @arg @ref LL_DMA_CHANNEL_4
;;;610      *         @arg @ref LL_DMA_CHANNEL_5
;;;611      *         @arg @ref LL_DMA_CHANNEL_6
;;;612      *         @arg @ref LL_DMA_CHANNEL_7
;;;613      * @param  Mode This parameter can be one of the following values:
;;;614      *         @arg @ref LL_DMA_MODE_NORMAL
;;;615      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;616      * @retval None
;;;617      */
;;;618    __STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
;;;619    {
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
;;;621                 Mode);
;;;622    }
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
        0x080008a4:    b530        0.      PUSH     {r4,r5,lr}
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
        0x080008a6:    1e4b        K.      SUBS     r3,r1,#1
        0x080008a8:    4c05        .L      LDR      r4,[pc,#20] ; [0x80008c0] = 0x8003118
        0x080008aa:    5ce3        .\      LDRB     r3,[r4,r3]
        0x080008ac:    58c3        .X      LDR      r3,[r0,r3]
        0x080008ae:    f0230380    #...    BIC      r3,r3,#0x80
        0x080008b2:    4313        .C      ORRS     r3,r3,r2
        0x080008b4:    1e4c        L.      SUBS     r4,r1,#1
        0x080008b6:    4d02        .M      LDR      r5,[pc,#8] ; [0x80008c0] = 0x8003118
        0x080008b8:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x080008ba:    5103        .Q      STR      r3,[r0,r4]
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
        0x080008bc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008be:    0000        ..      DCW    0
        0x080008c0:    08003118    .1..    DCD    134230296
    $t
    i.LL_DMA_SetMemorySize
    LL_DMA_SetMemorySize
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
;;;759    
;;;760    /**
;;;761      * @brief  Get Peripheral size.
;;;762      * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
;;;763      * @param  DMAx DMAx Instance
;;;764      * @param  Channel This parameter can be one of the following values:
;;;765      *         @arg @ref LL_DMA_CHANNEL_1
;;;766      *         @arg @ref LL_DMA_CHANNEL_2
;;;767      *         @arg @ref LL_DMA_CHANNEL_3
;;;768      *         @arg @ref LL_DMA_CHANNEL_4
;;;769      *         @arg @ref LL_DMA_CHANNEL_5
;;;770      *         @arg @ref LL_DMA_CHANNEL_6
;;;771      *         @arg @ref LL_DMA_CHANNEL_7
;;;772      * @retval Returned value can be one of the following values:
;;;773      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;774      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;775      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;776      */
;;;777    __STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;778    {
;;;779      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;780                       DMA_CCR_PSIZE));
;;;781    }
;;;782    
;;;783    /**
;;;784      * @brief  Set Memory size.
;;;785      * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
;;;786      * @param  DMAx DMAx Instance
;;;787      * @param  Channel This parameter can be one of the following values:
;;;788      *         @arg @ref LL_DMA_CHANNEL_1
;;;789      *         @arg @ref LL_DMA_CHANNEL_2
;;;790      *         @arg @ref LL_DMA_CHANNEL_3
;;;791      *         @arg @ref LL_DMA_CHANNEL_4
;;;792      *         @arg @ref LL_DMA_CHANNEL_5
;;;793      *         @arg @ref LL_DMA_CHANNEL_6
;;;794      *         @arg @ref LL_DMA_CHANNEL_7
;;;795      * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
;;;796      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;797      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;798      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;799      * @retval None
;;;800      */
;;;801    __STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
;;;802    {
        0x080008c4:    b530        0.      PUSH     {r4,r5,lr}
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
        0x080008c6:    1e4b        K.      SUBS     r3,r1,#1
        0x080008c8:    4c05        .L      LDR      r4,[pc,#20] ; [0x80008e0] = 0x8003118
        0x080008ca:    5ce3        .\      LDRB     r3,[r4,r3]
        0x080008cc:    58c3        .X      LDR      r3,[r0,r3]
        0x080008ce:    f4236340    #.@c    BIC      r3,r3,#0xc00
        0x080008d2:    4313        .C      ORRS     r3,r3,r2
        0x080008d4:    1e4c        L.      SUBS     r4,r1,#1
        0x080008d6:    4d02        .M      LDR      r5,[pc,#8] ; [0x80008e0] = 0x8003118
        0x080008d8:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x080008da:    5103        .Q      STR      r3,[r0,r4]
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
        0x080008dc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008de:    0000        ..      DCW    0
        0x080008e0:    08003118    .1..    DCD    134230296
    $t
    i.LL_DMA_SetMode
    LL_DMA_SetMode
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (619)
        0x080008e4:    b530        0.      PUSH     {r4,r5,lr}
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
        0x080008e6:    1e4b        K.      SUBS     r3,r1,#1
        0x080008e8:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000900] = 0x8003118
        0x080008ea:    5ce3        .\      LDRB     r3,[r4,r3]
        0x080008ec:    58c3        .X      LDR      r3,[r0,r3]
        0x080008ee:    f0230320    #. .    BIC      r3,r3,#0x20
        0x080008f2:    4313        .C      ORRS     r3,r3,r2
        0x080008f4:    1e4c        L.      SUBS     r4,r1,#1
        0x080008f6:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000900] = 0x8003118
        0x080008f8:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x080008fa:    5103        .Q      STR      r3,[r0,r4]
;;;621                 Mode);
;;;622    }
        0x080008fc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008fe:    0000        ..      DCW    0
        0x08000900:    08003118    .1..    DCD    134230296
    $t
    i.LL_DMA_SetPeriphIncMode
    LL_DMA_SetPeriphIncMode
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
        0x08000904:    b530        0.      PUSH     {r4,r5,lr}
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
        0x08000906:    1e4b        K.      SUBS     r3,r1,#1
        0x08000908:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000920] = 0x8003118
        0x0800090a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800090c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800090e:    f0230340    #.@.    BIC      r3,r3,#0x40
        0x08000912:    4313        .C      ORRS     r3,r3,r2
        0x08000914:    1e4c        L.      SUBS     r4,r1,#1
        0x08000916:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000920] = 0x8003118
        0x08000918:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800091a:    5103        .Q      STR      r3,[r0,r4]
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
        0x0800091c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800091e:    0000        ..      DCW    0
        0x08000920:    08003118    .1..    DCD    134230296
    $t
    i.LL_DMA_SetPeriphSize
    LL_DMA_SetPeriphSize
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
        0x08000924:    b530        0.      PUSH     {r4,r5,lr}
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
        0x08000926:    1e4b        K.      SUBS     r3,r1,#1
        0x08000928:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000940] = 0x8003118
        0x0800092a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800092c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800092e:    f4237340    #.@s    BIC      r3,r3,#0x300
        0x08000932:    4313        .C      ORRS     r3,r3,r2
        0x08000934:    1e4c        L.      SUBS     r4,r1,#1
        0x08000936:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000940] = 0x8003118
        0x08000938:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800093a:    5103        .Q      STR      r3,[r0,r4]
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
        0x0800093c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800093e:    0000        ..      DCW    0
        0x08000940:    08003118    .1..    DCD    134230296
    $t
    i.LL_GPIO_Init
    LL_GPIO_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;172    {
        0x08000944:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08000948:    4602        .F      MOV      r2,r0
        0x0800094a:    460b        .F      MOV      r3,r1
;;;173      uint32_t pinmask;
;;;174      uint32_t pinpos;
;;;175      uint32_t currentpin;
;;;176    
;;;177      /* Check the parameters */
;;;178      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;179      assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));
;;;180    
;;;181      /* ------------------------- Configure the port pins ---------------- */
;;;182      /* Initialize  pinpos on first pin set */
;;;183    
;;;184      pinmask = ((GPIO_InitStruct->Pin) << GPIO_PIN_MASK_POS) >> GPIO_PIN_NB;
        0x0800094c:    6818        .h      LDR      r0,[r3,#0]
        0x0800094e:    f3c0250f    ...%    UBFX     r5,r0,#8,#16
;;;185      pinpos = POSITION_VAL(pinmask);
        0x08000952:    fa95f0a5    ....    RBIT     r0,r5
        0x08000956:    fab0f480    ....    CLZ      r4,r0
;;;186    
;;;187      /* Configure the port pins */
;;;188      while ((pinmask  >> pinpos) != 0U)
        0x0800095a:    e07c        |.      B        0x8000a56 ; LL_GPIO_Init + 274
;;;189      {
;;;190        /* skip if bit is not set */
;;;191        if ((pinmask & (1U << pinpos)) != 0U)
        0x0800095c:    2001        .       MOVS     r0,#1
        0x0800095e:    40a0        .@      LSLS     r0,r0,r4
        0x08000960:    4028        (@      ANDS     r0,r0,r5
        0x08000962:    2800        .(      CMP      r0,#0
        0x08000964:    d076        v.      BEQ      0x8000a54 ; LL_GPIO_Init + 272
;;;192        {
;;;193          /* Get current io position */
;;;194          if (pinpos < GPIO_PIN_MASK_POS)
        0x08000966:    2c08        .,      CMP      r4,#8
        0x08000968:    d204        ..      BCS      0x8000974 ; LL_GPIO_Init + 48
;;;195          {
;;;196            currentpin = (0x00000101U << pinpos);
        0x0800096a:    f2401001    @...    MOV      r0,#0x101
        0x0800096e:    fa00f104    ....    LSL      r1,r0,r4
        0x08000972:    e006        ..      B        0x8000982 ; LL_GPIO_Init + 62
;;;197          }
;;;198          else
;;;199          {
;;;200            currentpin = ((0x00010001U << (pinpos - GPIO_PIN_MASK_POS)) | 0x04000000U);
        0x08000974:    f1a40008    ....    SUB      r0,r4,#8
        0x08000978:    f04f1601    O...    MOV      r6,#0x10001
        0x0800097c:    4086        .@      LSLS     r6,r6,r0
        0x0800097e:    f0466180    F..a    ORR      r1,r6,#0x4000000
;;;201          }
;;;202    
;;;203          /* Check Pin Mode and Pin Pull parameters */
;;;204          assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
;;;205          assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));
;;;206    
;;;207          /* Pin Mode configuration */
;;;208          LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
        0x08000982:    6858        Xh      LDR      r0,[r3,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;360      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000984:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;361      MODIFY_REG(*pReg, ((GPIO_CRL_CNF0 | GPIO_CRL_MODE0) << (POSITION_VAL(Pin) * 4U)), (Mode << (POSITION_VAL(Pin) * 4U)));
        0x08000988:    fa91fca1    ....    RBIT     r12,r1
        0x0800098c:    fabcfc8c    ....    CLZ      r12,r12
        0x08000990:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000994:    f04f0c0f    O...    MOV      r12,#0xf
        0x08000998:    fa0cfc08    ....    LSL      r12,r12,r8
        0x0800099c:    6837        7h      LDR      r7,[r6,#0]
        0x0800099e:    ea27070c    '...    BIC      r7,r7,r12
        0x080009a2:    fa91fca1    ....    RBIT     r12,r1
        0x080009a6:    fabcfc8c    ....    CLZ      r12,r12
        0x080009aa:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x080009ae:    fa00fc0c    ....    LSL      r12,r0,r12
        0x080009b2:    ea47070c    G...    ORR      r7,r7,r12
        0x080009b6:    6037        7`      STR      r7,[r6,#0]
;;;362    }
        0x080009b8:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;211          LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
        0x080009ba:    6918        .i      LDR      r0,[r3,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;583      MODIFY_REG(GPIOx->ODR, (Pin >> GPIO_PIN_MASK_POS), Pull << (POSITION_VAL(Pin >> GPIO_PIN_MASK_POS)));
        0x080009bc:    68d6        .h      LDR      r6,[r2,#0xc]
        0x080009be:    ea262611    &..&    BIC      r6,r6,r1,LSR #8
        0x080009c2:    0a0f        ..      LSRS     r7,r1,#8
        0x080009c4:    fa97f7a7    ....    RBIT     r7,r7
        0x080009c8:    fab7f787    ....    CLZ      r7,r7
        0x080009cc:    fa00f707    ....    LSL      r7,r0,r7
        0x080009d0:    433e        >C      ORRS     r6,r6,r7
        0x080009d2:    60d6        .`      STR      r6,[r2,#0xc]
;;;584    }
        0x080009d4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;213          if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
        0x080009d6:    6858        Xh      LDR      r0,[r3,#4]
        0x080009d8:    2801        .(      CMP      r0,#1
        0x080009da:    d002        ..      BEQ      0x80009e2 ; LL_GPIO_Init + 158
        0x080009dc:    6858        Xh      LDR      r0,[r3,#4]
        0x080009de:    2809        .(      CMP      r0,#9
        0x080009e0:    d138        8.      BNE      0x8000a54 ; LL_GPIO_Init + 272
;;;214          {
;;;215            /* Check speed and Output mode parameters */
;;;216            assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
;;;217            assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
;;;218    
;;;219            /* Speed mode configuration */
;;;220            LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
        0x080009e2:    6898        .h      LDR      r0,[r3,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;438      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x080009e4:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;439      MODIFY_REG(*pReg, (GPIO_CRL_MODE0 << (POSITION_VAL(Pin) * 4U)),
        0x080009e8:    fa91fca1    ....    RBIT     r12,r1
        0x080009ec:    fabcfc8c    ....    CLZ      r12,r12
        0x080009f0:    ea4f088c    O...    LSL      r8,r12,#2
        0x080009f4:    f04f0c03    O...    MOV      r12,#3
        0x080009f8:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080009fc:    6837        7h      LDR      r7,[r6,#0]
        0x080009fe:    ea27070c    '...    BIC      r7,r7,r12
        0x08000a02:    fa91fca1    ....    RBIT     r12,r1
        0x08000a06:    fabcfc8c    ....    CLZ      r12,r12
        0x08000a0a:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x08000a0e:    fa00fc0c    ....    LSL      r12,r0,r12
        0x08000a12:    ea47070c    G...    ORR      r7,r7,r12
        0x08000a16:    6037        7`      STR      r7,[r6,#0]
;;;440                 (Speed << (POSITION_VAL(Pin) * 4U)));
;;;441    }
        0x08000a18:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;223            LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
        0x08000a1a:    68d8        .h      LDR      r0,[r3,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;512      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000a1c:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;513      MODIFY_REG(*pReg, (GPIO_CRL_CNF0_0 << (POSITION_VAL(Pin) * 4U)),
        0x08000a20:    fa91fca1    ....    RBIT     r12,r1
        0x08000a24:    fabcfc8c    ....    CLZ      r12,r12
        0x08000a28:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000a2c:    f04f0c04    O...    MOV      r12,#4
        0x08000a30:    fa0cfc08    ....    LSL      r12,r12,r8
        0x08000a34:    6837        7h      LDR      r7,[r6,#0]
        0x08000a36:    ea27070c    '...    BIC      r7,r7,r12
        0x08000a3a:    fa91fca1    ....    RBIT     r12,r1
        0x08000a3e:    fabcfc8c    ....    CLZ      r12,r12
        0x08000a42:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x08000a46:    fa00fc0c    ....    LSL      r12,r0,r12
        0x08000a4a:    ea47070c    G...    ORR      r7,r7,r12
        0x08000a4e:    6037        7`      STR      r7,[r6,#0]
;;;514                 (OutputType << (POSITION_VAL(Pin) * 4U)));
;;;515    }
        0x08000a50:    bf00        ..      NOP      
        0x08000a52:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;226        pinpos++;
        0x08000a54:    1c64        d.      ADDS     r4,r4,#1
        0x08000a56:    fa25f004    %...    LSR      r0,r5,r4
        0x08000a5a:    2800        .(      CMP      r0,#0
        0x08000a5c:    f47faf7e    ..~.    BNE      0x800095c ; LL_GPIO_Init + 24
;;;227      }
;;;228      return (SUCCESS);
        0x08000a60:    2001        .       MOVS     r0,#1
;;;229    }
        0x08000a62:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_GPIO_IsInputPinSet
    LL_GPIO_IsInputPinSet
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;740    {
        0x08000a66:    4602        .F      MOV      r2,r0
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08000a68:    6890        .h      LDR      r0,[r2,#8]
        0x08000a6a:    f3c1230f    ...#    UBFX     r3,r1,#8,#16
        0x08000a6e:    4018        .@      ANDS     r0,r0,r3
        0x08000a70:    f3c1230f    ...#    UBFX     r3,r1,#8,#16
        0x08000a74:    4298        .B      CMP      r0,r3
        0x08000a76:    d101        ..      BNE      0x8000a7c ; LL_GPIO_IsInputPinSet + 22
        0x08000a78:    2001        .       MOVS     r0,#1
        0x08000a7a:    4770        pG      BX       lr
        0x08000a7c:    2000        .       MOVS     r0,#0
        0x08000a7e:    e7fc        ..      B        0x8000a7a ; LL_GPIO_IsInputPinSet + 20
    i.LL_GPIO_ResetOutputPin
    LL_GPIO_ResetOutputPin
;;;742    }
;;;743    
;;;744    /**
;;;745      * @brief  Write output data register for the port.
;;;746      * @rmtoll ODR          ODy           LL_GPIO_WriteOutputPort
;;;747      * @param  GPIOx GPIO Port
;;;748      * @param  PortValue Level value for each pin of the port
;;;749      * @retval None
;;;750      */
;;;751    __STATIC_INLINE void LL_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue)
;;;752    {
;;;753      WRITE_REG(GPIOx->ODR, PortValue);
;;;754    }
;;;755    
;;;756    /**
;;;757      * @brief  Return full output data register value for a dedicated port.
;;;758      * @rmtoll ODR          ODy           LL_GPIO_ReadOutputPort
;;;759      * @param  GPIOx GPIO Port
;;;760      * @retval Output data register value of port
;;;761      */
;;;762    __STATIC_INLINE uint32_t LL_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx)
;;;763    {
;;;764      return (uint32_t)(READ_REG(GPIOx->ODR));
;;;765    }
;;;766    
;;;767    /**
;;;768      * @brief  Return if input data level for several pins of dedicated port is high or low.
;;;769      * @rmtoll ODR          ODy           LL_GPIO_IsOutputPinSet
;;;770      * @param  GPIOx GPIO Port
;;;771      * @param  PinMask This parameter can be a combination of the following values:
;;;772      *         @arg @ref LL_GPIO_PIN_0
;;;773      *         @arg @ref LL_GPIO_PIN_1
;;;774      *         @arg @ref LL_GPIO_PIN_2
;;;775      *         @arg @ref LL_GPIO_PIN_3
;;;776      *         @arg @ref LL_GPIO_PIN_4
;;;777      *         @arg @ref LL_GPIO_PIN_5
;;;778      *         @arg @ref LL_GPIO_PIN_6
;;;779      *         @arg @ref LL_GPIO_PIN_7
;;;780      *         @arg @ref LL_GPIO_PIN_8
;;;781      *         @arg @ref LL_GPIO_PIN_9
;;;782      *         @arg @ref LL_GPIO_PIN_10
;;;783      *         @arg @ref LL_GPIO_PIN_11
;;;784      *         @arg @ref LL_GPIO_PIN_12
;;;785      *         @arg @ref LL_GPIO_PIN_13
;;;786      *         @arg @ref LL_GPIO_PIN_14
;;;787      *         @arg @ref LL_GPIO_PIN_15
;;;788      *         @arg @ref LL_GPIO_PIN_ALL
;;;789      * @retval State of bit (1 or 0).
;;;790      */
;;;791    __STATIC_INLINE uint32_t LL_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;792    {
;;;793      return (READ_BIT(GPIOx->ODR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
;;;794    }
;;;795    
;;;796    /**
;;;797      * @brief  Set several pins to high level on dedicated gpio port.
;;;798      * @rmtoll BSRR         BSy           LL_GPIO_SetOutputPin
;;;799      * @param  GPIOx GPIO Port
;;;800      * @param  PinMask This parameter can be a combination of the following values:
;;;801      *         @arg @ref LL_GPIO_PIN_0
;;;802      *         @arg @ref LL_GPIO_PIN_1
;;;803      *         @arg @ref LL_GPIO_PIN_2
;;;804      *         @arg @ref LL_GPIO_PIN_3
;;;805      *         @arg @ref LL_GPIO_PIN_4
;;;806      *         @arg @ref LL_GPIO_PIN_5
;;;807      *         @arg @ref LL_GPIO_PIN_6
;;;808      *         @arg @ref LL_GPIO_PIN_7
;;;809      *         @arg @ref LL_GPIO_PIN_8
;;;810      *         @arg @ref LL_GPIO_PIN_9
;;;811      *         @arg @ref LL_GPIO_PIN_10
;;;812      *         @arg @ref LL_GPIO_PIN_11
;;;813      *         @arg @ref LL_GPIO_PIN_12
;;;814      *         @arg @ref LL_GPIO_PIN_13
;;;815      *         @arg @ref LL_GPIO_PIN_14
;;;816      *         @arg @ref LL_GPIO_PIN_15
;;;817      *         @arg @ref LL_GPIO_PIN_ALL
;;;818      * @retval None
;;;819      */
;;;820    __STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;821    {
;;;822      WRITE_REG(GPIOx->BSRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
;;;823    }
;;;824    
;;;825    /**
;;;826      * @brief  Set several pins to low level on dedicated gpio port.
;;;827      * @rmtoll BRR          BRy           LL_GPIO_ResetOutputPin
;;;828      * @param  GPIOx GPIO Port
;;;829      * @param  PinMask This parameter can be a combination of the following values:
;;;830      *         @arg @ref LL_GPIO_PIN_0
;;;831      *         @arg @ref LL_GPIO_PIN_1
;;;832      *         @arg @ref LL_GPIO_PIN_2
;;;833      *         @arg @ref LL_GPIO_PIN_3
;;;834      *         @arg @ref LL_GPIO_PIN_4
;;;835      *         @arg @ref LL_GPIO_PIN_5
;;;836      *         @arg @ref LL_GPIO_PIN_6
;;;837      *         @arg @ref LL_GPIO_PIN_7
;;;838      *         @arg @ref LL_GPIO_PIN_8
;;;839      *         @arg @ref LL_GPIO_PIN_9
;;;840      *         @arg @ref LL_GPIO_PIN_10
;;;841      *         @arg @ref LL_GPIO_PIN_11
;;;842      *         @arg @ref LL_GPIO_PIN_12
;;;843      *         @arg @ref LL_GPIO_PIN_13
;;;844      *         @arg @ref LL_GPIO_PIN_14
;;;845      *         @arg @ref LL_GPIO_PIN_15
;;;846      *         @arg @ref LL_GPIO_PIN_ALL
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;850    {
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x08000a80:    f3c1220f    ..."    UBFX     r2,r1,#8,#16
        0x08000a84:    6142        Ba      STR      r2,[r0,#0x14]
;;;852    }
        0x08000a86:    4770        pG      BX       lr
    i.LL_I2C_ConfigSpeed
    LL_I2C_ConfigSpeed
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;747    {
        0x08000a88:    b5f0        ..      PUSH     {r4-r7,lr}
;;;748      register uint32_t freqrange = 0x0U;
        0x08000a8a:    2400        .$      MOVS     r4,#0
;;;749      register uint32_t clockconfig = 0x0U;
        0x08000a8c:    2500        .%      MOVS     r5,#0
;;;750    
;;;751      /* Compute frequency range */
;;;752      freqrange = __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock);
        0x08000a8e:    4e2b        +N      LDR      r6,[pc,#172] ; [0x8000b3c] = 0xf4240
        0x08000a90:    fbb1f4f6    ....    UDIV     r4,r1,r6
;;;753    
;;;754      /* Configure I2Cx: Frequency range register */
;;;755      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, freqrange);
        0x08000a94:    6846        Fh      LDR      r6,[r0,#4]
        0x08000a96:    f026063f    &.?.    BIC      r6,r6,#0x3f
        0x08000a9a:    4326        &C      ORRS     r6,r6,r4
        0x08000a9c:    6046        F`      STR      r6,[r0,#4]
;;;756    
;;;757      /* Configure I2Cx: Rise Time register */
;;;758      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, __LL_I2C_RISE_TIME(freqrange, ClockSpeed));
        0x08000a9e:    4e28        (N      LDR      r6,[pc,#160] ; [0x8000b40] = 0x186a0
        0x08000aa0:    42b2        .B      CMP      r2,r6
        0x08000aa2:    d801        ..      BHI      0x8000aa8 ; LL_I2C_ConfigSpeed + 32
        0x08000aa4:    1c66        f.      ADDS     r6,r4,#1
        0x08000aa6:    e007        ..      B        0x8000ab8 ; LL_I2C_ConfigSpeed + 48
        0x08000aa8:    f44f7696    O..v    MOV      r6,#0x12c
        0x08000aac:    4366        fC      MULS     r6,r4,r6
        0x08000aae:    f44f777a    O.zw    MOV      r7,#0x3e8
        0x08000ab2:    fbb6f6f7    ....    UDIV     r6,r6,r7
        0x08000ab6:    1c76        v.      ADDS     r6,r6,#1
        0x08000ab8:    6a07        .j      LDR      r7,[r0,#0x20]
        0x08000aba:    f027073f    '.?.    BIC      r7,r7,#0x3f
        0x08000abe:    433e        >C      ORRS     r6,r6,r7
        0x08000ac0:    6206        .b      STR      r6,[r0,#0x20]
;;;759    
;;;760      /* Configure Speed mode, Duty Cycle and Clock control register value */
;;;761      if (ClockSpeed > LL_I2C_MAX_SPEED_STANDARD)
        0x08000ac2:    4e1f        .N      LDR      r6,[pc,#124] ; [0x8000b40] = 0x186a0
        0x08000ac4:    42b2        .B      CMP      r2,r6
        0x08000ac6:    d924        $.      BLS      0x8000b12 ; LL_I2C_ConfigSpeed + 138
;;;762      {
;;;763        /* Set Speed mode at fast and duty cycle for Clock Speed request in fast clock range */
;;;764        clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
        0x08000ac8:    b96b        k.      CBNZ     r3,0x8000ae6 ; LL_I2C_ConfigSpeed + 94
;;;765                      __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
        0x08000aca:    eb020642    ..B.    ADD      r6,r2,r2,LSL #1
        0x08000ace:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000ad2:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000ad6:    b90e        ..      CBNZ     r6,0x8000adc ; LL_I2C_ConfigSpeed + 84
        0x08000ad8:    2601        .&      MOVS     r6,#1
        0x08000ada:    e015        ..      B        0x8000b08 ; LL_I2C_ConfigSpeed + 128
        0x08000adc:    eb020642    ..B.    ADD      r6,r2,r2,LSL #1
        0x08000ae0:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000ae4:    e010        ..      B        0x8000b08 ; LL_I2C_ConfigSpeed + 128
        0x08000ae6:    eb0206c2    ....    ADD      r6,r2,r2,LSL #3
        0x08000aea:    eb061602    ....    ADD      r6,r6,r2,LSL #4
        0x08000aee:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000af2:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000af6:    b90e        ..      CBNZ     r6,0x8000afc ; LL_I2C_ConfigSpeed + 116
        0x08000af8:    2601        .&      MOVS     r6,#1
        0x08000afa:    e005        ..      B        0x8000b08 ; LL_I2C_ConfigSpeed + 128
        0x08000afc:    eb0206c2    ....    ADD      r6,r2,r2,LSL #3
        0x08000b00:    eb061602    ....    ADD      r6,r6,r2,LSL #4
        0x08000b04:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000b08:    f4464600    F..F    ORR      r6,r6,#0x8000
        0x08000b0c:    ea460503    F...    ORR      r5,r6,r3
        0x08000b10:    e00c        ..      B        0x8000b2c ; LL_I2C_ConfigSpeed + 164
;;;766                      DutyCycle;
;;;767      }
;;;768      else
;;;769      {
;;;770        /* Set Speed mode at standard for Clock Speed request in standard clock range */
;;;771        clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
        0x08000b12:    0056        V.      LSLS     r6,r2,#1
        0x08000b14:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000b18:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000b1c:    2e04        ..      CMP      r6,#4
        0x08000b1e:    d201        ..      BCS      0x8000b24 ; LL_I2C_ConfigSpeed + 156
;;;772                      __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
        0x08000b20:    2604        .&      MOVS     r6,#4
        0x08000b22:    e002        ..      B        0x8000b2a ; LL_I2C_ConfigSpeed + 162
        0x08000b24:    0056        V.      LSLS     r6,r2,#1
        0x08000b26:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000b2a:    4635        5F      MOV      r5,r6
;;;773      }
;;;774    
;;;775      /* Configure I2Cx: Clock control register */
;;;776      MODIFY_REG(I2Cx->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), clockconfig);
        0x08000b2c:    69c6        .i      LDR      r6,[r0,#0x1c]
        0x08000b2e:    f64c77ff    L..w    MOV      r7,#0xcfff
        0x08000b32:    43be        .C      BICS     r6,r6,r7
        0x08000b34:    432e        .C      ORRS     r6,r6,r5
        0x08000b36:    61c6        .a      STR      r6,[r0,#0x1c]
;;;777    }
        0x08000b38:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000b3a:    0000        ..      DCW    0
        0x08000b3c:    000f4240    @B..    DCD    1000000
        0x08000b40:    000186a0    ....    DCD    100000
    $t
    i.LL_I2C_Init
    LL_I2C_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;147    {
        0x08000b44:    b57f        ..      PUSH     {r0-r6,lr}
        0x08000b46:    4604        .F      MOV      r4,r0
        0x08000b48:    460d        .F      MOV      r5,r1
;;;148      LL_RCC_ClocksTypeDef rcc_clocks;
;;;149    
;;;150      /* Check the I2C Instance I2Cx */
;;;151      assert_param(IS_I2C_ALL_INSTANCE(I2Cx));
;;;152    
;;;153      /* Check the I2C parameters from I2C_InitStruct */
;;;154      assert_param(IS_LL_I2C_PERIPHERAL_MODE(I2C_InitStruct->PeripheralMode));
;;;155      assert_param(IS_LL_I2C_CLOCK_SPEED(I2C_InitStruct->ClockSpeed));
;;;156      assert_param(IS_LL_I2C_DUTY_CYCLE(I2C_InitStruct->DutyCycle));
;;;157      assert_param(IS_LL_I2C_OWN_ADDRESS1(I2C_InitStruct->OwnAddress1));
;;;158      assert_param(IS_LL_I2C_TYPE_ACKNOWLEDGE(I2C_InitStruct->TypeAcknowledge));
;;;159      assert_param(IS_LL_I2C_OWN_ADDRSIZE(I2C_InitStruct->OwnAddrSize));
;;;160    
;;;161      /* Disable the selected I2Cx Peripheral */
;;;162      LL_I2C_Disable(I2Cx);
        0x08000b4a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;378      CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000b4c:    6820         h      LDR      r0,[r4,#0]
        0x08000b4e:    f0200001     ...    BIC      r0,r0,#1
        0x08000b52:    6020         `      STR      r0,[r4,#0]
;;;379    }
        0x08000b54:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;165      LL_RCC_GetSystemClocksFreq(&rcc_clocks);
        0x08000b56:    4668        hF      MOV      r0,sp
        0x08000b58:    f000f836    ..6.    BL       LL_RCC_GetSystemClocksFreq ; 0x8000bc8
;;;166    
;;;167      /*---------------------------- I2Cx SCL Clock Speed Configuration ------------
;;;168       * Configure the SCL speed :
;;;169       * - ClockSpeed: I2C_CR2_FREQ[5:0], I2C_TRISE_TRISE[5:0], I2C_CCR_FS,
;;;170       *           and I2C_CCR_CCR[11:0] bits
;;;171       * - DutyCycle: I2C_CCR_DUTY[7:0] bits
;;;172       */
;;;173      LL_I2C_ConfigSpeed(I2Cx, rcc_clocks.PCLK1_Frequency, I2C_InitStruct->ClockSpeed, I2C_InitStruct->DutyCycle);
        0x08000b5c:    e9d52301    ...#    LDRD     r2,r3,[r5,#4]
        0x08000b60:    4620         F      MOV      r0,r4
        0x08000b62:    9902        ..      LDR      r1,[sp,#8]
        0x08000b64:    f7ffff90    ....    BL       LL_I2C_ConfigSpeed ; 0x8000a88
;;;174    
;;;175      /*---------------------------- I2Cx OAR1 Configuration -----------------------
;;;176       * Disable, Configure and Enable I2Cx device own address 1 with parameters :
;;;177       * - OwnAddress1:  I2C_OAR1_ADD[9:8], I2C_OAR1_ADD[7:1] and I2C_OAR1_ADD0 bits
;;;178       * - OwnAddrSize:  I2C_OAR1_ADDMODE bit
;;;179       */
;;;180      LL_I2C_SetOwnAddress1(I2Cx, I2C_InitStruct->OwnAddress1, I2C_InitStruct->OwnAddrSize);
        0x08000b68:    6969        ii      LDR      r1,[r5,#0x14]
        0x08000b6a:    68e8        .h      LDR      r0,[r5,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;555      MODIFY_REG(I2Cx->OAR1, I2C_OAR1_ADD0 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD8_9 | I2C_OAR1_ADDMODE, OwnAddress1 | OwnAddrSize);
        0x08000b6c:    68a2        .h      LDR      r2,[r4,#8]
        0x08000b6e:    f24833ff    H..3    MOV      r3,#0x83ff
        0x08000b72:    439a        .C      BICS     r2,r2,r3
        0x08000b74:    ea400301    @...    ORR      r3,r0,r1
        0x08000b78:    431a        .C      ORRS     r2,r2,r3
        0x08000b7a:    60a2        .`      STR      r2,[r4,#8]
;;;556    }
        0x08000b7c:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;186      LL_I2C_SetMode(I2Cx, I2C_InitStruct->PeripheralMode);
        0x08000b7e:    6828        (h      LDR      r0,[r5,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;796      MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
        0x08000b80:    6821        !h      LDR      r1,[r4,#0]
        0x08000b82:    f021011a    !...    BIC      r1,r1,#0x1a
        0x08000b86:    4301        .C      ORRS     r1,r1,r0
        0x08000b88:    6021        !`      STR      r1,[r4,#0]
;;;797    }
        0x08000b8a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;189      LL_I2C_Enable(I2Cx);
        0x08000b8c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;367      SET_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000b8e:    6820         h      LDR      r0,[r4,#0]
        0x08000b90:    f0400001    @...    ORR      r0,r0,#1
        0x08000b94:    6020         `      STR      r0,[r4,#0]
;;;368    }
        0x08000b96:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;196      LL_I2C_AcknowledgeNextData(I2Cx, I2C_InitStruct->TypeAcknowledge);
        0x08000b98:    6928        (i      LDR      r0,[r5,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1572     MODIFY_REG(I2Cx->CR1, I2C_CR1_ACK, TypeAcknowledge);
        0x08000b9a:    6821        !h      LDR      r1,[r4,#0]
        0x08000b9c:    f4216180    !..a    BIC      r1,r1,#0x400
        0x08000ba0:    4301        .C      ORRS     r1,r1,r0
        0x08000ba2:    6021        !`      STR      r1,[r4,#0]
;;;1573   }
        0x08000ba4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;198      return SUCCESS;
        0x08000ba6:    2001        .       MOVS     r0,#1
;;;199    }
        0x08000ba8:    b004        ..      ADD      sp,sp,#0x10
        0x08000baa:    bd70        p.      POP      {r4-r6,pc}
    i.LL_Init1msTick
    LL_Init1msTick
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;187      LL_InitTick(HCLKFrequency, 1000U);
        0x08000bac:    f44f717a    O.zq    MOV      r1,#0x3e8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_utils.h
;;;237      SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
        0x08000bb0:    fbb0f2f1    ....    UDIV     r2,r0,r1
        0x08000bb4:    1e52        R.      SUBS     r2,r2,#1
        0x08000bb6:    f04f23e0    O..#    MOV      r3,#0xe000e000
        0x08000bba:    615a        Za      STR      r2,[r3,#0x14]
;;;238      SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
        0x08000bbc:    2200        ."      MOVS     r2,#0
        0x08000bbe:    619a        .a      STR      r2,[r3,#0x18]
;;;239      SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
        0x08000bc0:    2205        ."      MOVS     r2,#5
        0x08000bc2:    611a        .a      STR      r2,[r3,#0x10]
;;;240                       SysTick_CTRL_ENABLE_Msk;                   /* Enable the Systick Timer */
;;;241    }
        0x08000bc4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;188    }
        0x08000bc6:    4770        pG      BX       lr
    i.LL_RCC_GetSystemClocksFreq
    LL_RCC_GetSystemClocksFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;206    {
        0x08000bc8:    b510        ..      PUSH     {r4,lr}
        0x08000bca:    4604        .F      MOV      r4,r0
;;;207      /* Get SYSCLK frequency */
;;;208      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
        0x08000bcc:    f001f810    ....    BL       RCC_GetSystemClockFreq ; 0x8001bf0
        0x08000bd0:    6020         `      STR      r0,[r4,#0]
;;;209    
;;;210      /* HCLK clock frequency */
;;;211      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
        0x08000bd2:    6820         h      LDR      r0,[r4,#0]
        0x08000bd4:    f000ffd8    ....    BL       RCC_GetHCLKClockFreq ; 0x8001b88
        0x08000bd8:    6060        ``      STR      r0,[r4,#4]
;;;212    
;;;213      /* PCLK1 clock frequency */
;;;214      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x08000bda:    6860        `h      LDR      r0,[r4,#4]
        0x08000bdc:    f000ffe4    ....    BL       RCC_GetPCLK1ClockFreq ; 0x8001ba8
        0x08000be0:    60a0        .`      STR      r0,[r4,#8]
;;;215    
;;;216      /* PCLK2 clock frequency */
;;;217      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x08000be2:    6860        `h      LDR      r0,[r4,#4]
        0x08000be4:    f000fff2    ....    BL       RCC_GetPCLK2ClockFreq ; 0x8001bcc
        0x08000be8:    60e0        .`      STR      r0,[r4,#0xc]
;;;218    }
        0x08000bea:    bd10        ..      POP      {r4,pc}
    i.LL_SetSystemCoreClock
    LL_SetSystemCoreClock
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;261      SystemCoreClock = HCLKFrequency;
        0x08000bec:    4901        .I      LDR      r1,[pc,#4] ; [0x8000bf4] = 0x20000000
        0x08000bee:    6008        .`      STR      r0,[r1,#0]
;;;262    }
        0x08000bf0:    4770        pG      BX       lr
    $d
        0x08000bf2:    0000        ..      DCW    0
        0x08000bf4:    20000000    ...     DCD    536870912
    $t
    i.LL_TIM_BDTR_Init
    LL_TIM_BDTR_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;715    {
        0x08000bf8:    b510        ..      PUSH     {r4,lr}
        0x08000bfa:    4603        .F      MOV      r3,r0
        0x08000bfc:    460a        .F      MOV      r2,r1
;;;716      uint32_t tmpbdtr = 0;
        0x08000bfe:    2100        .!      MOVS     r1,#0
;;;717    
;;;718      /* Check the parameters */
;;;719      assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
;;;720      assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
;;;721      assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
;;;722      assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
;;;723      assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
;;;724      assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
;;;725      assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
;;;726    
;;;727      /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;728      the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;729    
;;;730      /* Set the BDTR bits */
;;;731      MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
        0x08000c00:    7b14        .{      LDRB     r4,[r2,#0xc]
        0x08000c02:    4621        !F      MOV      r1,r4
;;;732      MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
        0x08000c04:    6890        .h      LDR      r0,[r2,#8]
        0x08000c06:    4301        .C      ORRS     r1,r1,r0
;;;733      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
        0x08000c08:    f4216080    !..`    BIC      r0,r1,#0x400
        0x08000c0c:    6854        Th      LDR      r4,[r2,#4]
        0x08000c0e:    ea400104    @...    ORR      r1,r0,r4
;;;734      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
        0x08000c12:    f4216000    !..`    BIC      r0,r1,#0x800
        0x08000c16:    6814        .h      LDR      r4,[r2,#0]
        0x08000c18:    ea400104    @...    ORR      r1,r0,r4
;;;735      MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
        0x08000c1c:    f4215080    !..P    BIC      r0,r1,#0x1000
        0x08000c20:    89d4        ..      LDRH     r4,[r2,#0xe]
        0x08000c22:    ea400104    @...    ORR      r1,r0,r4
;;;736      MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
        0x08000c26:    f4215000    !..P    BIC      r0,r1,#0x2000
        0x08000c2a:    6914        .i      LDR      r4,[r2,#0x10]
        0x08000c2c:    ea400104    @...    ORR      r1,r0,r4
;;;737      MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x08000c30:    f4214080    !..@    BIC      r0,r1,#0x4000
        0x08000c34:    6954        Ti      LDR      r4,[r2,#0x14]
        0x08000c36:    ea400104    @...    ORR      r1,r0,r4
;;;738      MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x08000c3a:    f4214000    !..@    BIC      r0,r1,#0x8000
        0x08000c3e:    6954        Ti      LDR      r4,[r2,#0x14]
        0x08000c40:    ea400104    @...    ORR      r1,r0,r4
;;;739    
;;;740      /* Set TIMx_BDTR */
;;;741      LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
        0x08000c44:    6459        Yd      STR      r1,[r3,#0x44]
;;;742    
;;;743      return SUCCESS;
        0x08000c46:    2001        .       MOVS     r0,#1
;;;744    }
        0x08000c48:    bd10        ..      POP      {r4,pc}
    i.LL_TIM_CC_DisableChannel
    LL_TIM_CC_DisableChannel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
        0x08000c4a:    6a02        .j      LDR      r2,[r0,#0x20]
        0x08000c4c:    438a        .C      BICS     r2,r2,r1
        0x08000c4e:    6202        .b      STR      r2,[r0,#0x20]
;;;1519   }
        0x08000c50:    4770        pG      BX       lr
    i.LL_TIM_CC_EnableChannel
    LL_TIM_CC_EnableChannel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1493)
        0x08000c52:    6a02        .j      LDR      r2,[r0,#0x20]
        0x08000c54:    430a        .C      ORRS     r2,r2,r1
        0x08000c56:    6202        .b      STR      r2,[r0,#0x20]
;;;1494   }
        0x08000c58:    4770        pG      BX       lr
    i.LL_TIM_DisableARRPreload
    LL_TIM_DisableARRPreload
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1209)
        0x08000c5a:    6801        .h      LDR      r1,[r0,#0]
        0x08000c5c:    f0210180    !...    BIC      r1,r1,#0x80
        0x08000c60:    6001        .`      STR      r1,[r0,#0]
;;;1210   }
        0x08000c62:    4770        pG      BX       lr
    i.LL_TIM_DisableMasterSlaveMode
    LL_TIM_DisableMasterSlaveMode
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000c64:    6881        .h      LDR      r1,[r0,#8]
        0x08000c66:    f0210180    !...    BIC      r1,r1,#0x80
        0x08000c6a:    6081        .`      STR      r1,[r0,#8]
        0x08000c6c:    4770        pG      BX       lr
    i.LL_TIM_EnableARRPreload
    LL_TIM_EnableARRPreload
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1198)
        0x08000c6e:    6801        .h      LDR      r1,[r0,#0]
        0x08000c70:    f0410180    A...    ORR      r1,r1,#0x80
        0x08000c74:    6001        .`      STR      r1,[r0,#0]
;;;1199   }
        0x08000c76:    4770        pG      BX       lr
    i.LL_TIM_EnableIT_UPDATE
    LL_TIM_EnableIT_UPDATE
;;;1200   
;;;1201   /**
;;;1202     * @brief  Disable auto-reload (ARR) preload.
;;;1203     * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
;;;1204     * @param  TIMx Timer instance
;;;1205     * @retval None
;;;1206     */
;;;1207   __STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
;;;1208   {
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2645   }
;;;2646   
;;;2647   /**
;;;2648     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2649     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2650     * a timer instance can operate as a slave timer.
;;;2651     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2652     * @param  TIMx Timer instance
;;;2653     * @retval State of bit (1 or 0).
;;;2654     */
;;;2655   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2656   {
;;;2657     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2658   }
;;;2659   
;;;2660   /**
;;;2661     * @brief  Configure the external trigger (ETR) input.
;;;2662     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2663     *       a timer instance provides an external trigger input.
;;;2664     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2665     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2666     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2667     * @param  TIMx Timer instance
;;;2668     * @param  ETRPolarity This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2670     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2671     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2673     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2674     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2675     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2676     * @param  ETRFilter This parameter can be one of the following values:
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2690     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2691     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2692     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2693     * @retval None
;;;2694     */
;;;2695   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2696                                         uint32_t ETRFilter)
;;;2697   {
;;;2698     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2699   }
;;;2700   
;;;2701   /**
;;;2702     * @}
;;;2703     */
;;;2704   
;;;2705   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2706     * @{
;;;2707     */
;;;2708   /**
;;;2709     * @brief  Enable the break function.
;;;2710     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2711     *       a timer instance provides a break input.
;;;2712     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2713     * @param  TIMx Timer instance
;;;2714     * @retval None
;;;2715     */
;;;2716   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2717   {
;;;2718     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2719   }
;;;2720   
;;;2721   /**
;;;2722     * @brief  Disable the break function.
;;;2723     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2724     * @param  TIMx Timer instance
;;;2725     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2726     *       a timer instance provides a break input.
;;;2727     * @retval None
;;;2728     */
;;;2729   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2730   {
;;;2731     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2732   }
;;;2733   
;;;2734   /**
;;;2735     * @brief  Configure the break input.
;;;2736     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2737     *       a timer instance provides a break input.
;;;2738     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2739     * @param  TIMx Timer instance
;;;2740     * @param  BreakPolarity This parameter can be one of the following values:
;;;2741     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2742     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2743     * @retval None
;;;2744     */
;;;2745   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2746   {
;;;2747     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2748   }
;;;2749   
;;;2750   /**
;;;2751     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2752     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2753     *       a timer instance provides a break input.
;;;2754     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2755     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2756     * @param  TIMx Timer instance
;;;2757     * @param  OffStateIdle This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2760     * @param  OffStateRun This parameter can be one of the following values:
;;;2761     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2762     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2763     * @retval None
;;;2764     */
;;;2765   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2766   {
;;;2767     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2768   }
;;;2769   
;;;2770   /**
;;;2771     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2772     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2773     *       a timer instance provides a break input.
;;;2774     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2775     * @param  TIMx Timer instance
;;;2776     * @retval None
;;;2777     */
;;;2778   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2779   {
;;;2780     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2781   }
;;;2782   
;;;2783   /**
;;;2784     * @brief  Disable automatic output (MOE can be set only by software).
;;;2785     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2786     *       a timer instance provides a break input.
;;;2787     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2788     * @param  TIMx Timer instance
;;;2789     * @retval None
;;;2790     */
;;;2791   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2792   {
;;;2793     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2794   }
;;;2795   
;;;2796   /**
;;;2797     * @brief  Indicate whether automatic output is enabled.
;;;2798     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2799     *       a timer instance provides a break input.
;;;2800     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2801     * @param  TIMx Timer instance
;;;2802     * @retval State of bit (1 or 0).
;;;2803     */
;;;2804   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2805   {
;;;2806     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2807   }
;;;2808   
;;;2809   /**
;;;2810     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2811     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2812     *       software and is reset in case of break or break2 event
;;;2813     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2814     *       a timer instance provides a break input.
;;;2815     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2816     * @param  TIMx Timer instance
;;;2817     * @retval None
;;;2818     */
;;;2819   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2820   {
;;;2821     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2822   }
;;;2823   
;;;2824   /**
;;;2825     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2826     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2827     *       software and is reset in case of break or break2 event.
;;;2828     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2829     *       a timer instance provides a break input.
;;;2830     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2831     * @param  TIMx Timer instance
;;;2832     * @retval None
;;;2833     */
;;;2834   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2835   {
;;;2836     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2837   }
;;;2838   
;;;2839   /**
;;;2840     * @brief  Indicates whether outputs are enabled.
;;;2841     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2842     *       a timer instance provides a break input.
;;;2843     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2844     * @param  TIMx Timer instance
;;;2845     * @retval State of bit (1 or 0).
;;;2846     */
;;;2847   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2848   {
;;;2849     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2850   }
;;;2851   
;;;2852   /**
;;;2853     * @}
;;;2854     */
;;;2855   
;;;2856   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2857     * @{
;;;2858     */
;;;2859   /**
;;;2860     * @brief  Configures the timer DMA burst feature.
;;;2861     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2862     *       not a timer instance supports the DMA burst mode.
;;;2863     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2864     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2865     * @param  TIMx Timer instance
;;;2866     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2882     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2883     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2884     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2885     * @param  DMABurstLength This parameter can be one of the following values:
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2901     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2902     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2903     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2904     * @retval None
;;;2905     */
;;;2906   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2907   {
;;;2908     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2909   }
;;;2910   
;;;2911   /**
;;;2912     * @}
;;;2913     */
;;;2914   
;;;2915   
;;;2916   /**
;;;2917     * @}
;;;2918     */
;;;2919   
;;;2920   
;;;2921   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2922     * @{
;;;2923     */
;;;2924   /**
;;;2925     * @brief  Clear the update interrupt flag (UIF).
;;;2926     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2927     * @param  TIMx Timer instance
;;;2928     * @retval None
;;;2929     */
;;;2930   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2931   {
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
        0x08000c78:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08000c7a:    f0410101    A...    ORR      r1,r1,#1
        0x08000c7e:    60c1        .`      STR      r1,[r0,#0xc]
        0x08000c80:    4770        pG      BX       lr
    i.LL_TIM_EnableMasterSlaveMode
    LL_TIM_EnableMasterSlaveMode
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2631)
        0x08000c82:    6881        .h      LDR      r1,[r0,#8]
        0x08000c84:    f0410180    A...    ORR      r1,r1,#0x80
        0x08000c88:    6081        .`      STR      r1,[r0,#8]
;;;2632   }
        0x08000c8a:    4770        pG      BX       lr
    i.LL_TIM_GenerateEvent_UPDATE
    LL_TIM_GenerateEvent_UPDATE
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2645   }
;;;2646   
;;;2647   /**
;;;2648     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2649     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2650     * a timer instance can operate as a slave timer.
;;;2651     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2652     * @param  TIMx Timer instance
;;;2653     * @retval State of bit (1 or 0).
;;;2654     */
;;;2655   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2656   {
;;;2657     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2658   }
;;;2659   
;;;2660   /**
;;;2661     * @brief  Configure the external trigger (ETR) input.
;;;2662     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2663     *       a timer instance provides an external trigger input.
;;;2664     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2665     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2666     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2667     * @param  TIMx Timer instance
;;;2668     * @param  ETRPolarity This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2670     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2671     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2673     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2674     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2675     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2676     * @param  ETRFilter This parameter can be one of the following values:
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2690     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2691     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2692     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2693     * @retval None
;;;2694     */
;;;2695   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2696                                         uint32_t ETRFilter)
;;;2697   {
;;;2698     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2699   }
;;;2700   
;;;2701   /**
;;;2702     * @}
;;;2703     */
;;;2704   
;;;2705   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2706     * @{
;;;2707     */
;;;2708   /**
;;;2709     * @brief  Enable the break function.
;;;2710     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2711     *       a timer instance provides a break input.
;;;2712     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2713     * @param  TIMx Timer instance
;;;2714     * @retval None
;;;2715     */
;;;2716   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2717   {
;;;2718     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2719   }
;;;2720   
;;;2721   /**
;;;2722     * @brief  Disable the break function.
;;;2723     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2724     * @param  TIMx Timer instance
;;;2725     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2726     *       a timer instance provides a break input.
;;;2727     * @retval None
;;;2728     */
;;;2729   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2730   {
;;;2731     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2732   }
;;;2733   
;;;2734   /**
;;;2735     * @brief  Configure the break input.
;;;2736     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2737     *       a timer instance provides a break input.
;;;2738     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2739     * @param  TIMx Timer instance
;;;2740     * @param  BreakPolarity This parameter can be one of the following values:
;;;2741     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2742     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2743     * @retval None
;;;2744     */
;;;2745   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2746   {
;;;2747     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2748   }
;;;2749   
;;;2750   /**
;;;2751     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2752     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2753     *       a timer instance provides a break input.
;;;2754     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2755     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2756     * @param  TIMx Timer instance
;;;2757     * @param  OffStateIdle This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2760     * @param  OffStateRun This parameter can be one of the following values:
;;;2761     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2762     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2763     * @retval None
;;;2764     */
;;;2765   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2766   {
;;;2767     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2768   }
;;;2769   
;;;2770   /**
;;;2771     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2772     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2773     *       a timer instance provides a break input.
;;;2774     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2775     * @param  TIMx Timer instance
;;;2776     * @retval None
;;;2777     */
;;;2778   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2779   {
;;;2780     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2781   }
;;;2782   
;;;2783   /**
;;;2784     * @brief  Disable automatic output (MOE can be set only by software).
;;;2785     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2786     *       a timer instance provides a break input.
;;;2787     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2788     * @param  TIMx Timer instance
;;;2789     * @retval None
;;;2790     */
;;;2791   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2792   {
;;;2793     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2794   }
;;;2795   
;;;2796   /**
;;;2797     * @brief  Indicate whether automatic output is enabled.
;;;2798     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2799     *       a timer instance provides a break input.
;;;2800     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2801     * @param  TIMx Timer instance
;;;2802     * @retval State of bit (1 or 0).
;;;2803     */
;;;2804   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2805   {
;;;2806     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2807   }
;;;2808   
;;;2809   /**
;;;2810     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2811     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2812     *       software and is reset in case of break or break2 event
;;;2813     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2814     *       a timer instance provides a break input.
;;;2815     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2816     * @param  TIMx Timer instance
;;;2817     * @retval None
;;;2818     */
;;;2819   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2820   {
;;;2821     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2822   }
;;;2823   
;;;2824   /**
;;;2825     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2826     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2827     *       software and is reset in case of break or break2 event.
;;;2828     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2829     *       a timer instance provides a break input.
;;;2830     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2831     * @param  TIMx Timer instance
;;;2832     * @retval None
;;;2833     */
;;;2834   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2835   {
;;;2836     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2837   }
;;;2838   
;;;2839   /**
;;;2840     * @brief  Indicates whether outputs are enabled.
;;;2841     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2842     *       a timer instance provides a break input.
;;;2843     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2844     * @param  TIMx Timer instance
;;;2845     * @retval State of bit (1 or 0).
;;;2846     */
;;;2847   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2848   {
;;;2849     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2850   }
;;;2851   
;;;2852   /**
;;;2853     * @}
;;;2854     */
;;;2855   
;;;2856   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2857     * @{
;;;2858     */
;;;2859   /**
;;;2860     * @brief  Configures the timer DMA burst feature.
;;;2861     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2862     *       not a timer instance supports the DMA burst mode.
;;;2863     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2864     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2865     * @param  TIMx Timer instance
;;;2866     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2882     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2883     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2884     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2885     * @param  DMABurstLength This parameter can be one of the following values:
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2901     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2902     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2903     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2904     * @retval None
;;;2905     */
;;;2906   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2907   {
;;;2908     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2909   }
;;;2910   
;;;2911   /**
;;;2912     * @}
;;;2913     */
;;;2914   
;;;2915   
;;;2916   /**
;;;2917     * @}
;;;2918     */
;;;2919   
;;;2920   
;;;2921   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2922     * @{
;;;2923     */
;;;2924   /**
;;;2925     * @brief  Clear the update interrupt flag (UIF).
;;;2926     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2927     * @param  TIMx Timer instance
;;;2928     * @retval None
;;;2929     */
;;;2930   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2931   {
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3204   }
;;;3205   
;;;3206   /**
;;;3207     * @brief  Disable update interrupt (UIE).
;;;3208     * @rmtoll DIER         UIE           LL_TIM_DisableIT_UPDATE
;;;3209     * @param  TIMx Timer instance
;;;3210     * @retval None
;;;3211     */
;;;3212   __STATIC_INLINE void LL_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3213   {
;;;3214     CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3215   }
;;;3216   
;;;3217   /**
;;;3218     * @brief  Indicates whether the update interrupt (UIE) is enabled.
;;;3219     * @rmtoll DIER         UIE           LL_TIM_IsEnabledIT_UPDATE
;;;3220     * @param  TIMx Timer instance
;;;3221     * @retval State of bit (1 or 0).
;;;3222     */
;;;3223   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
;;;3224   {
;;;3225     return (READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE));
;;;3226   }
;;;3227   
;;;3228   /**
;;;3229     * @brief  Enable capture/compare 1 interrupt (CC1IE).
;;;3230     * @rmtoll DIER         CC1IE         LL_TIM_EnableIT_CC1
;;;3231     * @param  TIMx Timer instance
;;;3232     * @retval None
;;;3233     */
;;;3234   __STATIC_INLINE void LL_TIM_EnableIT_CC1(TIM_TypeDef *TIMx)
;;;3235   {
;;;3236     SET_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3237   }
;;;3238   
;;;3239   /**
;;;3240     * @brief  Disable capture/compare 1  interrupt (CC1IE).
;;;3241     * @rmtoll DIER         CC1IE         LL_TIM_DisableIT_CC1
;;;3242     * @param  TIMx Timer instance
;;;3243     * @retval None
;;;3244     */
;;;3245   __STATIC_INLINE void LL_TIM_DisableIT_CC1(TIM_TypeDef *TIMx)
;;;3246   {
;;;3247     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3248   }
;;;3249   
;;;3250   /**
;;;3251     * @brief  Indicates whether the capture/compare 1 interrupt (CC1IE) is enabled.
;;;3252     * @rmtoll DIER         CC1IE         LL_TIM_IsEnabledIT_CC1
;;;3253     * @param  TIMx Timer instance
;;;3254     * @retval State of bit (1 or 0).
;;;3255     */
;;;3256   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx)
;;;3257   {
;;;3258     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1IE) == (TIM_DIER_CC1IE));
;;;3259   }
;;;3260   
;;;3261   /**
;;;3262     * @brief  Enable capture/compare 2 interrupt (CC2IE).
;;;3263     * @rmtoll DIER         CC2IE         LL_TIM_EnableIT_CC2
;;;3264     * @param  TIMx Timer instance
;;;3265     * @retval None
;;;3266     */
;;;3267   __STATIC_INLINE void LL_TIM_EnableIT_CC2(TIM_TypeDef *TIMx)
;;;3268   {
;;;3269     SET_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3270   }
;;;3271   
;;;3272   /**
;;;3273     * @brief  Disable capture/compare 2  interrupt (CC2IE).
;;;3274     * @rmtoll DIER         CC2IE         LL_TIM_DisableIT_CC2
;;;3275     * @param  TIMx Timer instance
;;;3276     * @retval None
;;;3277     */
;;;3278   __STATIC_INLINE void LL_TIM_DisableIT_CC2(TIM_TypeDef *TIMx)
;;;3279   {
;;;3280     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3281   }
;;;3282   
;;;3283   /**
;;;3284     * @brief  Indicates whether the capture/compare 2 interrupt (CC2IE) is enabled.
;;;3285     * @rmtoll DIER         CC2IE         LL_TIM_IsEnabledIT_CC2
;;;3286     * @param  TIMx Timer instance
;;;3287     * @retval State of bit (1 or 0).
;;;3288     */
;;;3289   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx)
;;;3290   {
;;;3291     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2IE) == (TIM_DIER_CC2IE));
;;;3292   }
;;;3293   
;;;3294   /**
;;;3295     * @brief  Enable capture/compare 3 interrupt (CC3IE).
;;;3296     * @rmtoll DIER         CC3IE         LL_TIM_EnableIT_CC3
;;;3297     * @param  TIMx Timer instance
;;;3298     * @retval None
;;;3299     */
;;;3300   __STATIC_INLINE void LL_TIM_EnableIT_CC3(TIM_TypeDef *TIMx)
;;;3301   {
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3303   }
;;;3304   
;;;3305   /**
;;;3306     * @brief  Disable capture/compare 3  interrupt (CC3IE).
;;;3307     * @rmtoll DIER         CC3IE         LL_TIM_DisableIT_CC3
;;;3308     * @param  TIMx Timer instance
;;;3309     * @retval None
;;;3310     */
;;;3311   __STATIC_INLINE void LL_TIM_DisableIT_CC3(TIM_TypeDef *TIMx)
;;;3312   {
;;;3313     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3314   }
;;;3315   
;;;3316   /**
;;;3317     * @brief  Indicates whether the capture/compare 3 interrupt (CC3IE) is enabled.
;;;3318     * @rmtoll DIER         CC3IE         LL_TIM_IsEnabledIT_CC3
;;;3319     * @param  TIMx Timer instance
;;;3320     * @retval State of bit (1 or 0).
;;;3321     */
;;;3322   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx)
;;;3323   {
;;;3324     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3IE) == (TIM_DIER_CC3IE));
;;;3325   }
;;;3326   
;;;3327   /**
;;;3328     * @brief  Enable capture/compare 4 interrupt (CC4IE).
;;;3329     * @rmtoll DIER         CC4IE         LL_TIM_EnableIT_CC4
;;;3330     * @param  TIMx Timer instance
;;;3331     * @retval None
;;;3332     */
;;;3333   __STATIC_INLINE void LL_TIM_EnableIT_CC4(TIM_TypeDef *TIMx)
;;;3334   {
;;;3335     SET_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3336   }
;;;3337   
;;;3338   /**
;;;3339     * @brief  Disable capture/compare 4  interrupt (CC4IE).
;;;3340     * @rmtoll DIER         CC4IE         LL_TIM_DisableIT_CC4
;;;3341     * @param  TIMx Timer instance
;;;3342     * @retval None
;;;3343     */
;;;3344   __STATIC_INLINE void LL_TIM_DisableIT_CC4(TIM_TypeDef *TIMx)
;;;3345   {
;;;3346     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3347   }
;;;3348   
;;;3349   /**
;;;3350     * @brief  Indicates whether the capture/compare 4 interrupt (CC4IE) is enabled.
;;;3351     * @rmtoll DIER         CC4IE         LL_TIM_IsEnabledIT_CC4
;;;3352     * @param  TIMx Timer instance
;;;3353     * @retval State of bit (1 or 0).
;;;3354     */
;;;3355   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx)
;;;3356   {
;;;3357     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4IE) == (TIM_DIER_CC4IE));
;;;3358   }
;;;3359   
;;;3360   /**
;;;3361     * @brief  Enable commutation interrupt (COMIE).
;;;3362     * @rmtoll DIER         COMIE         LL_TIM_EnableIT_COM
;;;3363     * @param  TIMx Timer instance
;;;3364     * @retval None
;;;3365     */
;;;3366   __STATIC_INLINE void LL_TIM_EnableIT_COM(TIM_TypeDef *TIMx)
;;;3367   {
;;;3368     SET_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3369   }
;;;3370   
;;;3371   /**
;;;3372     * @brief  Disable commutation interrupt (COMIE).
;;;3373     * @rmtoll DIER         COMIE         LL_TIM_DisableIT_COM
;;;3374     * @param  TIMx Timer instance
;;;3375     * @retval None
;;;3376     */
;;;3377   __STATIC_INLINE void LL_TIM_DisableIT_COM(TIM_TypeDef *TIMx)
;;;3378   {
;;;3379     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3380   }
;;;3381   
;;;3382   /**
;;;3383     * @brief  Indicates whether the commutation interrupt (COMIE) is enabled.
;;;3384     * @rmtoll DIER         COMIE         LL_TIM_IsEnabledIT_COM
;;;3385     * @param  TIMx Timer instance
;;;3386     * @retval State of bit (1 or 0).
;;;3387     */
;;;3388   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx)
;;;3389   {
;;;3390     return (READ_BIT(TIMx->DIER, TIM_DIER_COMIE) == (TIM_DIER_COMIE));
;;;3391   }
;;;3392   
;;;3393   /**
;;;3394     * @brief  Enable trigger interrupt (TIE).
;;;3395     * @rmtoll DIER         TIE           LL_TIM_EnableIT_TRIG
;;;3396     * @param  TIMx Timer instance
;;;3397     * @retval None
;;;3398     */
;;;3399   __STATIC_INLINE void LL_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx)
;;;3400   {
;;;3401     SET_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3402   }
;;;3403   
;;;3404   /**
;;;3405     * @brief  Disable trigger interrupt (TIE).
;;;3406     * @rmtoll DIER         TIE           LL_TIM_DisableIT_TRIG
;;;3407     * @param  TIMx Timer instance
;;;3408     * @retval None
;;;3409     */
;;;3410   __STATIC_INLINE void LL_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx)
;;;3411   {
;;;3412     CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3413   }
;;;3414   
;;;3415   /**
;;;3416     * @brief  Indicates whether the trigger interrupt (TIE) is enabled.
;;;3417     * @rmtoll DIER         TIE           LL_TIM_IsEnabledIT_TRIG
;;;3418     * @param  TIMx Timer instance
;;;3419     * @retval State of bit (1 or 0).
;;;3420     */
;;;3421   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx)
;;;3422   {
;;;3423     return (READ_BIT(TIMx->DIER, TIM_DIER_TIE) == (TIM_DIER_TIE));
;;;3424   }
;;;3425   
;;;3426   /**
;;;3427     * @brief  Enable break interrupt (BIE).
;;;3428     * @rmtoll DIER         BIE           LL_TIM_EnableIT_BRK
;;;3429     * @param  TIMx Timer instance
;;;3430     * @retval None
;;;3431     */
;;;3432   __STATIC_INLINE void LL_TIM_EnableIT_BRK(TIM_TypeDef *TIMx)
;;;3433   {
;;;3434     SET_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3435   }
;;;3436   
;;;3437   /**
;;;3438     * @brief  Disable break interrupt (BIE).
;;;3439     * @rmtoll DIER         BIE           LL_TIM_DisableIT_BRK
;;;3440     * @param  TIMx Timer instance
;;;3441     * @retval None
;;;3442     */
;;;3443   __STATIC_INLINE void LL_TIM_DisableIT_BRK(TIM_TypeDef *TIMx)
;;;3444   {
;;;3445     CLEAR_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3446   }
;;;3447   
;;;3448   /**
;;;3449     * @brief  Indicates whether the break interrupt (BIE) is enabled.
;;;3450     * @rmtoll DIER         BIE           LL_TIM_IsEnabledIT_BRK
;;;3451     * @param  TIMx Timer instance
;;;3452     * @retval State of bit (1 or 0).
;;;3453     */
;;;3454   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx)
;;;3455   {
;;;3456     return (READ_BIT(TIMx->DIER, TIM_DIER_BIE) == (TIM_DIER_BIE));
;;;3457   }
;;;3458   
;;;3459   /**
;;;3460     * @}
;;;3461     */
;;;3462   
;;;3463   /** @defgroup TIM_LL_EF_DMA_Management DMA-Management
;;;3464     * @{
;;;3465     */
;;;3466   /**
;;;3467     * @brief  Enable update DMA request (UDE).
;;;3468     * @rmtoll DIER         UDE           LL_TIM_EnableDMAReq_UPDATE
;;;3469     * @param  TIMx Timer instance
;;;3470     * @retval None
;;;3471     */
;;;3472   __STATIC_INLINE void LL_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3473   {
;;;3474     SET_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3475   }
;;;3476   
;;;3477   /**
;;;3478     * @brief  Disable update DMA request (UDE).
;;;3479     * @rmtoll DIER         UDE           LL_TIM_DisableDMAReq_UPDATE
;;;3480     * @param  TIMx Timer instance
;;;3481     * @retval None
;;;3482     */
;;;3483   __STATIC_INLINE void LL_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3484   {
;;;3485     CLEAR_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3486   }
;;;3487   
;;;3488   /**
;;;3489     * @brief  Indicates whether the update DMA request  (UDE) is enabled.
;;;3490     * @rmtoll DIER         UDE           LL_TIM_IsEnabledDMAReq_UPDATE
;;;3491     * @param  TIMx Timer instance
;;;3492     * @retval State of bit (1 or 0).
;;;3493     */
;;;3494   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3495   {
;;;3496     return (READ_BIT(TIMx->DIER, TIM_DIER_UDE) == (TIM_DIER_UDE));
;;;3497   }
;;;3498   
;;;3499   /**
;;;3500     * @brief  Enable capture/compare 1 DMA request (CC1DE).
;;;3501     * @rmtoll DIER         CC1DE         LL_TIM_EnableDMAReq_CC1
;;;3502     * @param  TIMx Timer instance
;;;3503     * @retval None
;;;3504     */
;;;3505   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3506   {
;;;3507     SET_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3508   }
;;;3509   
;;;3510   /**
;;;3511     * @brief  Disable capture/compare 1  DMA request (CC1DE).
;;;3512     * @rmtoll DIER         CC1DE         LL_TIM_DisableDMAReq_CC1
;;;3513     * @param  TIMx Timer instance
;;;3514     * @retval None
;;;3515     */
;;;3516   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3517   {
;;;3518     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3519   }
;;;3520   
;;;3521   /**
;;;3522     * @brief  Indicates whether the capture/compare 1 DMA request (CC1DE) is enabled.
;;;3523     * @rmtoll DIER         CC1DE         LL_TIM_IsEnabledDMAReq_CC1
;;;3524     * @param  TIMx Timer instance
;;;3525     * @retval State of bit (1 or 0).
;;;3526     */
;;;3527   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3528   {
;;;3529     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1DE) == (TIM_DIER_CC1DE));
;;;3530   }
;;;3531   
;;;3532   /**
;;;3533     * @brief  Enable capture/compare 2 DMA request (CC2DE).
;;;3534     * @rmtoll DIER         CC2DE         LL_TIM_EnableDMAReq_CC2
;;;3535     * @param  TIMx Timer instance
;;;3536     * @retval None
;;;3537     */
;;;3538   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3539   {
;;;3540     SET_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3541   }
;;;3542   
;;;3543   /**
;;;3544     * @brief  Disable capture/compare 2  DMA request (CC2DE).
;;;3545     * @rmtoll DIER         CC2DE         LL_TIM_DisableDMAReq_CC2
;;;3546     * @param  TIMx Timer instance
;;;3547     * @retval None
;;;3548     */
;;;3549   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3550   {
;;;3551     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3552   }
;;;3553   
;;;3554   /**
;;;3555     * @brief  Indicates whether the capture/compare 2 DMA request (CC2DE) is enabled.
;;;3556     * @rmtoll DIER         CC2DE         LL_TIM_IsEnabledDMAReq_CC2
;;;3557     * @param  TIMx Timer instance
;;;3558     * @retval State of bit (1 or 0).
;;;3559     */
;;;3560   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3561   {
;;;3562     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2DE) == (TIM_DIER_CC2DE));
;;;3563   }
;;;3564   
;;;3565   /**
;;;3566     * @brief  Enable capture/compare 3 DMA request (CC3DE).
;;;3567     * @rmtoll DIER         CC3DE         LL_TIM_EnableDMAReq_CC3
;;;3568     * @param  TIMx Timer instance
;;;3569     * @retval None
;;;3570     */
;;;3571   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3572   {
;;;3573     SET_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3574   }
;;;3575   
;;;3576   /**
;;;3577     * @brief  Disable capture/compare 3  DMA request (CC3DE).
;;;3578     * @rmtoll DIER         CC3DE         LL_TIM_DisableDMAReq_CC3
;;;3579     * @param  TIMx Timer instance
;;;3580     * @retval None
;;;3581     */
;;;3582   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3583   {
;;;3584     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3585   }
;;;3586   
;;;3587   /**
;;;3588     * @brief  Indicates whether the capture/compare 3 DMA request (CC3DE) is enabled.
;;;3589     * @rmtoll DIER         CC3DE         LL_TIM_IsEnabledDMAReq_CC3
;;;3590     * @param  TIMx Timer instance
;;;3591     * @retval State of bit (1 or 0).
;;;3592     */
;;;3593   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3594   {
;;;3595     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3DE) == (TIM_DIER_CC3DE));
;;;3596   }
;;;3597   
;;;3598   /**
;;;3599     * @brief  Enable capture/compare 4 DMA request (CC4DE).
;;;3600     * @rmtoll DIER         CC4DE         LL_TIM_EnableDMAReq_CC4
;;;3601     * @param  TIMx Timer instance
;;;3602     * @retval None
;;;3603     */
;;;3604   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3605   {
;;;3606     SET_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3607   }
;;;3608   
;;;3609   /**
;;;3610     * @brief  Disable capture/compare 4  DMA request (CC4DE).
;;;3611     * @rmtoll DIER         CC4DE         LL_TIM_DisableDMAReq_CC4
;;;3612     * @param  TIMx Timer instance
;;;3613     * @retval None
;;;3614     */
;;;3615   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3616   {
;;;3617     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3618   }
;;;3619   
;;;3620   /**
;;;3621     * @brief  Indicates whether the capture/compare 4 DMA request (CC4DE) is enabled.
;;;3622     * @rmtoll DIER         CC4DE         LL_TIM_IsEnabledDMAReq_CC4
;;;3623     * @param  TIMx Timer instance
;;;3624     * @retval State of bit (1 or 0).
;;;3625     */
;;;3626   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3627   {
;;;3628     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4DE) == (TIM_DIER_CC4DE));
;;;3629   }
;;;3630   
;;;3631   /**
;;;3632     * @brief  Enable commutation DMA request (COMDE).
;;;3633     * @rmtoll DIER         COMDE         LL_TIM_EnableDMAReq_COM
;;;3634     * @param  TIMx Timer instance
;;;3635     * @retval None
;;;3636     */
;;;3637   __STATIC_INLINE void LL_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3638   {
;;;3639     SET_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3640   }
;;;3641   
;;;3642   /**
;;;3643     * @brief  Disable commutation DMA request (COMDE).
;;;3644     * @rmtoll DIER         COMDE         LL_TIM_DisableDMAReq_COM
;;;3645     * @param  TIMx Timer instance
;;;3646     * @retval None
;;;3647     */
;;;3648   __STATIC_INLINE void LL_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3649   {
;;;3650     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3651   }
;;;3652   
;;;3653   /**
;;;3654     * @brief  Indicates whether the commutation DMA request (COMDE) is enabled.
;;;3655     * @rmtoll DIER         COMDE         LL_TIM_IsEnabledDMAReq_COM
;;;3656     * @param  TIMx Timer instance
;;;3657     * @retval State of bit (1 or 0).
;;;3658     */
;;;3659   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx)
;;;3660   {
;;;3661     return (READ_BIT(TIMx->DIER, TIM_DIER_COMDE) == (TIM_DIER_COMDE));
;;;3662   }
;;;3663   
;;;3664   /**
;;;3665     * @brief  Enable trigger interrupt (TDE).
;;;3666     * @rmtoll DIER         TDE           LL_TIM_EnableDMAReq_TRIG
;;;3667     * @param  TIMx Timer instance
;;;3668     * @retval None
;;;3669     */
;;;3670   __STATIC_INLINE void LL_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3671   {
;;;3672     SET_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3673   }
;;;3674   
;;;3675   /**
;;;3676     * @brief  Disable trigger interrupt (TDE).
;;;3677     * @rmtoll DIER         TDE           LL_TIM_DisableDMAReq_TRIG
;;;3678     * @param  TIMx Timer instance
;;;3679     * @retval None
;;;3680     */
;;;3681   __STATIC_INLINE void LL_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3682   {
;;;3683     CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3684   }
;;;3685   
;;;3686   /**
;;;3687     * @brief  Indicates whether the trigger interrupt (TDE) is enabled.
;;;3688     * @rmtoll DIER         TDE           LL_TIM_IsEnabledDMAReq_TRIG
;;;3689     * @param  TIMx Timer instance
;;;3690     * @retval State of bit (1 or 0).
;;;3691     */
;;;3692   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3693   {
;;;3694     return (READ_BIT(TIMx->DIER, TIM_DIER_TDE) == (TIM_DIER_TDE));
;;;3695   }
;;;3696   
;;;3697   /**
;;;3698     * @}
;;;3699     */
;;;3700   
;;;3701   /** @defgroup TIM_LL_EF_EVENT_Management EVENT-Management
;;;3702     * @{
;;;3703     */
;;;3704   /**
;;;3705     * @brief  Generate an update event.
;;;3706     * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
;;;3707     * @param  TIMx Timer instance
;;;3708     * @retval None
;;;3709     */
;;;3710   __STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
;;;3711   {
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08000c8c:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08000c8e:    f0410101    A...    ORR      r1,r1,#1
        0x08000c92:    6141        Aa      STR      r1,[r0,#0x14]
;;;3713   }
        0x08000c94:    4770        pG      BX       lr
        0x08000c96:    0000        ..      MOVS     r0,r0
    i.LL_TIM_IC_SetActiveInput
    LL_TIM_IC_SetActiveInput
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2164)
        0x08000c98:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000c9a:    4603        .F      MOV      r3,r0
        0x08000c9c:    4614        .F      MOV      r4,r2
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000c9e:    2901        .)      CMP      r1,#1
        0x08000ca0:    d101        ..      BNE      0x8000ca6 ; LL_TIM_IC_SetActiveInput + 14
        0x08000ca2:    2500        .%      MOVS     r5,#0
        0x08000ca4:    e016        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000ca6:    2904        .)      CMP      r1,#4
        0x08000ca8:    d101        ..      BNE      0x8000cae ; LL_TIM_IC_SetActiveInput + 22
        0x08000caa:    2501        .%      MOVS     r5,#1
        0x08000cac:    e012        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cae:    2910        .)      CMP      r1,#0x10
        0x08000cb0:    d101        ..      BNE      0x8000cb6 ; LL_TIM_IC_SetActiveInput + 30
        0x08000cb2:    2502        .%      MOVS     r5,#2
        0x08000cb4:    e00e        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cb6:    2940        @)      CMP      r1,#0x40
        0x08000cb8:    d101        ..      BNE      0x8000cbe ; LL_TIM_IC_SetActiveInput + 38
        0x08000cba:    2503        .%      MOVS     r5,#3
        0x08000cbc:    e00a        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cbe:    f5b17f80    ....    CMP      r1,#0x100
        0x08000cc2:    d101        ..      BNE      0x8000cc8 ; LL_TIM_IC_SetActiveInput + 48
        0x08000cc4:    2504        .%      MOVS     r5,#4
        0x08000cc6:    e005        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cc8:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000ccc:    d101        ..      BNE      0x8000cd2 ; LL_TIM_IC_SetActiveInput + 58
        0x08000cce:    2505        .%      MOVS     r5,#5
        0x08000cd0:    e000        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cd2:    2506        .%      MOVS     r5,#6
        0x08000cd4:    4628        (F      MOV      r0,r5
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000cd6:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000cfc] = 0x800311f
        0x08000cd8:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000cda:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000cde:    1972        r.      ADDS     r2,r6,r5
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000ce0:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000d00] = 0x800312d
        0x08000ce2:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000ce4:    2603        .&      MOVS     r6,#3
        0x08000ce6:    40be        .@      LSLS     r6,r6,r7
        0x08000ce8:    6815        .h      LDR      r5,[r2,#0]
        0x08000cea:    43b5        .C      BICS     r5,r5,r6
        0x08000cec:    0c26        &.      LSRS     r6,r4,#16
        0x08000cee:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000d00] = 0x800312d
        0x08000cf0:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000cf2:    40be        .@      LSLS     r6,r6,r7
        0x08000cf4:    4335        5C      ORRS     r5,r5,r6
        0x08000cf6:    6015        .`      STR      r5,[r2,#0]
;;;2168   }
        0x08000cf8:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000cfa:    0000        ..      DCW    0
        0x08000cfc:    0800311f    .1..    DCD    134230303
        0x08000d00:    0800312d    -1..    DCD    134230317
    $t
    i.LL_TIM_IC_SetFilter
    LL_TIM_IC_SetFilter
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
        0x08000d04:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000d06:    4603        .F      MOV      r3,r0
        0x08000d08:    4614        .F      MOV      r4,r2
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000d0a:    2901        .)      CMP      r1,#1
        0x08000d0c:    d101        ..      BNE      0x8000d12 ; LL_TIM_IC_SetFilter + 14
        0x08000d0e:    2500        .%      MOVS     r5,#0
        0x08000d10:    e016        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d12:    2904        .)      CMP      r1,#4
        0x08000d14:    d101        ..      BNE      0x8000d1a ; LL_TIM_IC_SetFilter + 22
        0x08000d16:    2501        .%      MOVS     r5,#1
        0x08000d18:    e012        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d1a:    2910        .)      CMP      r1,#0x10
        0x08000d1c:    d101        ..      BNE      0x8000d22 ; LL_TIM_IC_SetFilter + 30
        0x08000d1e:    2502        .%      MOVS     r5,#2
        0x08000d20:    e00e        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d22:    2940        @)      CMP      r1,#0x40
        0x08000d24:    d101        ..      BNE      0x8000d2a ; LL_TIM_IC_SetFilter + 38
        0x08000d26:    2503        .%      MOVS     r5,#3
        0x08000d28:    e00a        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d2a:    f5b17f80    ....    CMP      r1,#0x100
        0x08000d2e:    d101        ..      BNE      0x8000d34 ; LL_TIM_IC_SetFilter + 48
        0x08000d30:    2504        .%      MOVS     r5,#4
        0x08000d32:    e005        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d34:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000d38:    d101        ..      BNE      0x8000d3e ; LL_TIM_IC_SetFilter + 58
        0x08000d3a:    2505        .%      MOVS     r5,#5
        0x08000d3c:    e000        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d3e:    2506        .%      MOVS     r5,#6
        0x08000d40:    4628        (F      MOV      r0,r5
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000d42:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000d68] = 0x800311f
        0x08000d44:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000d46:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000d4a:    1972        r.      ADDS     r2,r6,r5
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000d4c:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000d6c] = 0x800312d
        0x08000d4e:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000d50:    26f0        .&      MOVS     r6,#0xf0
        0x08000d52:    40be        .@      LSLS     r6,r6,r7
        0x08000d54:    6815        .h      LDR      r5,[r2,#0]
        0x08000d56:    43b5        .C      BICS     r5,r5,r6
        0x08000d58:    0c26        &.      LSRS     r6,r4,#16
        0x08000d5a:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000d6c] = 0x800312d
        0x08000d5c:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000d5e:    40be        .@      LSLS     r6,r6,r7
        0x08000d60:    4335        5C      ORRS     r5,r5,r6
        0x08000d62:    6015        .`      STR      r5,[r2,#0]
;;;2281   }
        0x08000d64:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000d66:    0000        ..      DCW    0
        0x08000d68:    0800311f    .1..    DCD    134230303
        0x08000d6c:    0800312d    -1..    DCD    134230317
    $t
    i.LL_TIM_IC_SetPolarity
    LL_TIM_IC_SetPolarity
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
        0x08000d70:    b570        p.      PUSH     {r4-r6,lr}
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000d72:    2901        .)      CMP      r1,#1
        0x08000d74:    d101        ..      BNE      0x8000d7a ; LL_TIM_IC_SetPolarity + 10
        0x08000d76:    2400        .$      MOVS     r4,#0
        0x08000d78:    e016        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d7a:    2904        .)      CMP      r1,#4
        0x08000d7c:    d101        ..      BNE      0x8000d82 ; LL_TIM_IC_SetPolarity + 18
        0x08000d7e:    2401        .$      MOVS     r4,#1
        0x08000d80:    e012        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d82:    2910        .)      CMP      r1,#0x10
        0x08000d84:    d101        ..      BNE      0x8000d8a ; LL_TIM_IC_SetPolarity + 26
        0x08000d86:    2402        .$      MOVS     r4,#2
        0x08000d88:    e00e        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d8a:    2940        @)      CMP      r1,#0x40
        0x08000d8c:    d101        ..      BNE      0x8000d92 ; LL_TIM_IC_SetPolarity + 34
        0x08000d8e:    2403        .$      MOVS     r4,#3
        0x08000d90:    e00a        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d92:    f5b17f80    ....    CMP      r1,#0x100
        0x08000d96:    d101        ..      BNE      0x8000d9c ; LL_TIM_IC_SetPolarity + 44
        0x08000d98:    2404        .$      MOVS     r4,#4
        0x08000d9a:    e005        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d9c:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000da0:    d101        ..      BNE      0x8000da6 ; LL_TIM_IC_SetPolarity + 54
        0x08000da2:    2405        .$      MOVS     r4,#5
        0x08000da4:    e000        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000da6:    2406        .$      MOVS     r4,#6
        0x08000da8:    4623        #F      MOV      r3,r4
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
        0x08000daa:    6a04        .j      LDR      r4,[r0,#0x20]
        0x08000dac:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000dc4] = 0x8003134
        0x08000dae:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000db0:    250a        .%      MOVS     r5,#0xa
        0x08000db2:    40b5        .@      LSLS     r5,r5,r6
        0x08000db4:    43ac        .C      BICS     r4,r4,r5
        0x08000db6:    4d03        .M      LDR      r5,[pc,#12] ; [0x8000dc4] = 0x8003134
        0x08000db8:    5ced        .\      LDRB     r5,[r5,r3]
        0x08000dba:    fa02f505    ....    LSL      r5,r2,r5
        0x08000dbe:    432c        ,C      ORRS     r4,r4,r5
        0x08000dc0:    6204        .b      STR      r4,[r0,#0x20]
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
        0x08000dc2:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000dc4:    08003134    41..    DCD    134230324
    $t
    i.LL_TIM_IC_SetPrescaler
    LL_TIM_IC_SetPrescaler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2214)
        0x08000dc8:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000dca:    4603        .F      MOV      r3,r0
        0x08000dcc:    4614        .F      MOV      r4,r2
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000dce:    2901        .)      CMP      r1,#1
        0x08000dd0:    d101        ..      BNE      0x8000dd6 ; LL_TIM_IC_SetPrescaler + 14
        0x08000dd2:    2500        .%      MOVS     r5,#0
        0x08000dd4:    e016        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000dd6:    2904        .)      CMP      r1,#4
        0x08000dd8:    d101        ..      BNE      0x8000dde ; LL_TIM_IC_SetPrescaler + 22
        0x08000dda:    2501        .%      MOVS     r5,#1
        0x08000ddc:    e012        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000dde:    2910        .)      CMP      r1,#0x10
        0x08000de0:    d101        ..      BNE      0x8000de6 ; LL_TIM_IC_SetPrescaler + 30
        0x08000de2:    2502        .%      MOVS     r5,#2
        0x08000de4:    e00e        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000de6:    2940        @)      CMP      r1,#0x40
        0x08000de8:    d101        ..      BNE      0x8000dee ; LL_TIM_IC_SetPrescaler + 38
        0x08000dea:    2503        .%      MOVS     r5,#3
        0x08000dec:    e00a        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000dee:    f5b17f80    ....    CMP      r1,#0x100
        0x08000df2:    d101        ..      BNE      0x8000df8 ; LL_TIM_IC_SetPrescaler + 48
        0x08000df4:    2504        .%      MOVS     r5,#4
        0x08000df6:    e005        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000df8:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000dfc:    d101        ..      BNE      0x8000e02 ; LL_TIM_IC_SetPrescaler + 58
        0x08000dfe:    2505        .%      MOVS     r5,#5
        0x08000e00:    e000        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000e02:    2506        .%      MOVS     r5,#6
        0x08000e04:    4628        (F      MOV      r0,r5
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000e06:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000e2c] = 0x800311f
        0x08000e08:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000e0a:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000e0e:    1972        r.      ADDS     r2,r6,r5
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000e10:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000e30] = 0x800312d
        0x08000e12:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000e14:    260c        .&      MOVS     r6,#0xc
        0x08000e16:    40be        .@      LSLS     r6,r6,r7
        0x08000e18:    6815        .h      LDR      r5,[r2,#0]
        0x08000e1a:    43b5        .C      BICS     r5,r5,r6
        0x08000e1c:    0c26        &.      LSRS     r6,r4,#16
        0x08000e1e:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000e30] = 0x800312d
        0x08000e20:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000e22:    40be        .@      LSLS     r6,r6,r7
        0x08000e24:    4335        5C      ORRS     r5,r5,r6
        0x08000e26:    6015        .`      STR      r5,[r2,#0]
;;;2218   }
        0x08000e28:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000e2a:    0000        ..      DCW    0
        0x08000e2c:    0800311f    .1..    DCD    134230303
        0x08000e30:    0800312d    -1..    DCD    134230317
    $t
    i.LL_TIM_Init
    LL_TIM_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;341    {
        0x08000e34:    b510        ..      PUSH     {r4,lr}
        0x08000e36:    4602        .F      MOV      r2,r0
;;;342      uint32_t tmpcr1 = 0U;
        0x08000e38:    2300        .#      MOVS     r3,#0
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_TIM_INSTANCE(TIMx));
;;;346      assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
;;;347      assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
;;;348    
;;;349      tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
        0x08000e3a:    6813        .h      LDR      r3,[r2,#0]
;;;350    
;;;351      if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
        0x08000e3c:    481b        .H      LDR      r0,[pc,#108] ; [0x8000eac] = 0x40012c00
        0x08000e3e:    4282        .B      CMP      r2,r0
        0x08000e40:    d008        ..      BEQ      0x8000e54 ; LL_TIM_Init + 32
        0x08000e42:    f1b24f80    ...O    CMP      r2,#0x40000000
        0x08000e46:    d005        ..      BEQ      0x8000e54 ; LL_TIM_Init + 32
        0x08000e48:    4819        .H      LDR      r0,[pc,#100] ; [0x8000eb0] = 0x40000400
        0x08000e4a:    4282        .B      CMP      r2,r0
        0x08000e4c:    d002        ..      BEQ      0x8000e54 ; LL_TIM_Init + 32
        0x08000e4e:    4819        .H      LDR      r0,[pc,#100] ; [0x8000eb4] = 0x40000800
        0x08000e50:    4282        .B      CMP      r2,r0
        0x08000e52:    d104        ..      BNE      0x8000e5e ; LL_TIM_Init + 42
;;;352      {
;;;353        /* Select the Counter Mode */
;;;354        MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
        0x08000e54:    f0230070    #.p.    BIC      r0,r3,#0x70
        0x08000e58:    684c        Lh      LDR      r4,[r1,#4]
        0x08000e5a:    ea400304    @...    ORR      r3,r0,r4
;;;355      }
;;;356    
;;;357      if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
        0x08000e5e:    4813        .H      LDR      r0,[pc,#76] ; [0x8000eac] = 0x40012c00
        0x08000e60:    4282        .B      CMP      r2,r0
        0x08000e62:    d008        ..      BEQ      0x8000e76 ; LL_TIM_Init + 66
        0x08000e64:    f1b24f80    ...O    CMP      r2,#0x40000000
        0x08000e68:    d005        ..      BEQ      0x8000e76 ; LL_TIM_Init + 66
        0x08000e6a:    4811        .H      LDR      r0,[pc,#68] ; [0x8000eb0] = 0x40000400
        0x08000e6c:    4282        .B      CMP      r2,r0
        0x08000e6e:    d002        ..      BEQ      0x8000e76 ; LL_TIM_Init + 66
        0x08000e70:    4810        .H      LDR      r0,[pc,#64] ; [0x8000eb4] = 0x40000800
        0x08000e72:    4282        .B      CMP      r2,r0
        0x08000e74:    d104        ..      BNE      0x8000e80 ; LL_TIM_Init + 76
;;;358      {
;;;359        /* Set the clock division */
;;;360        MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
        0x08000e76:    f4237040    #.@p    BIC      r0,r3,#0x300
        0x08000e7a:    68cc        .h      LDR      r4,[r1,#0xc]
        0x08000e7c:    ea400304    @...    ORR      r3,r0,r4
;;;361      }
;;;362    
;;;363      /* Write to TIMx CR1 */
;;;364      LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
        0x08000e80:    6013        .`      STR      r3,[r2,#0]
;;;365    
;;;366      /* Set the Autoreload value */
;;;367      LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
        0x08000e82:    6888        .h      LDR      r0,[r1,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
        0x08000e84:    62d0        .b      STR      r0,[r2,#0x2c]
;;;1333   }
        0x08000e86:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;370      LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
        0x08000e88:    8808        ..      LDRH     r0,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
        0x08000e8a:    6290        .b      STR      r0,[r2,#0x28]
;;;1308   }
        0x08000e8c:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;372      if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
        0x08000e8e:    4807        .H      LDR      r0,[pc,#28] ; [0x8000eac] = 0x40012c00
        0x08000e90:    4282        .B      CMP      r2,r0
        0x08000e92:    d103        ..      BNE      0x8000e9c ; LL_TIM_Init + 104
;;;373      {
;;;374        /* Set the Repetition Counter value */
;;;375        LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
        0x08000e94:    7c08        .|      LDRB     r0,[r1,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
        0x08000e96:    6310        .c      STR      r0,[r2,#0x30]
;;;1358   }
        0x08000e98:    bf00        ..      NOP      
        0x08000e9a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;380      LL_TIM_GenerateEvent_UPDATE(TIMx);
        0x08000e9c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08000e9e:    6950        Pi      LDR      r0,[r2,#0x14]
        0x08000ea0:    f0400001    @...    ORR      r0,r0,#1
        0x08000ea4:    6150        Pa      STR      r0,[r2,#0x14]
;;;3713   }
        0x08000ea6:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;382      return SUCCESS;
        0x08000ea8:    2001        .       MOVS     r0,#1
;;;383    }
        0x08000eaa:    bd10        ..      POP      {r4,pc}
    $d
        0x08000eac:    40012c00    .,.@    DCD    1073818624
        0x08000eb0:    40000400    ...@    DCD    1073742848
        0x08000eb4:    40000800    ...@    DCD    1073743872
    $t
    i.LL_TIM_IsActiveFlag_UPDATE
    LL_TIM_IsActiveFlag_UPDATE
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2942   {
        0x08000eb8:    4601        .F      MOV      r1,r0
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
        0x08000eba:    6908        .i      LDR      r0,[r1,#0x10]
        0x08000ebc:    f0000001    ....    AND      r0,r0,#1
;;;2944   }
        0x08000ec0:    4770        pG      BX       lr
        0x08000ec2:    0000        ..      MOVS     r0,r0
    i.LL_TIM_OC_DisableFast
    LL_TIM_OC_DisableFast
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1805)
        0x08000ec4:    b570        p.      PUSH     {r4-r6,lr}
        0x08000ec6:    4602        .F      MOV      r2,r0
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000ec8:    2901        .)      CMP      r1,#1
        0x08000eca:    d101        ..      BNE      0x8000ed0 ; LL_TIM_OC_DisableFast + 12
        0x08000ecc:    2400        .$      MOVS     r4,#0
        0x08000ece:    e016        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ed0:    2904        .)      CMP      r1,#4
        0x08000ed2:    d101        ..      BNE      0x8000ed8 ; LL_TIM_OC_DisableFast + 20
        0x08000ed4:    2401        .$      MOVS     r4,#1
        0x08000ed6:    e012        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ed8:    2910        .)      CMP      r1,#0x10
        0x08000eda:    d101        ..      BNE      0x8000ee0 ; LL_TIM_OC_DisableFast + 28
        0x08000edc:    2402        .$      MOVS     r4,#2
        0x08000ede:    e00e        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ee0:    2940        @)      CMP      r1,#0x40
        0x08000ee2:    d101        ..      BNE      0x8000ee8 ; LL_TIM_OC_DisableFast + 36
        0x08000ee4:    2403        .$      MOVS     r4,#3
        0x08000ee6:    e00a        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ee8:    f5b17f80    ....    CMP      r1,#0x100
        0x08000eec:    d101        ..      BNE      0x8000ef2 ; LL_TIM_OC_DisableFast + 46
        0x08000eee:    2404        .$      MOVS     r4,#4
        0x08000ef0:    e005        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ef2:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000ef6:    d101        ..      BNE      0x8000efc ; LL_TIM_OC_DisableFast + 56
        0x08000ef8:    2405        .$      MOVS     r4,#5
        0x08000efa:    e000        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000efc:    2406        .$      MOVS     r4,#6
        0x08000efe:    4623        #F      MOV      r3,r4
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000f00:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000f1c] = 0x800311f
        0x08000f02:    5ce5        .\      LDRB     r5,[r4,r3]
        0x08000f04:    f1020418    ....    ADD      r4,r2,#0x18
        0x08000f08:    1928        (.      ADDS     r0,r5,r4
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
        0x08000f0a:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000f20] = 0x8003126
        0x08000f0c:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000f0e:    2504        .%      MOVS     r5,#4
        0x08000f10:    40b5        .@      LSLS     r5,r5,r6
        0x08000f12:    6804        .h      LDR      r4,[r0,#0]
        0x08000f14:    43ac        .C      BICS     r4,r4,r5
        0x08000f16:    6004        .`      STR      r4,[r0,#0]
;;;1809   
;;;1810   }
        0x08000f18:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000f1a:    0000        ..      DCW    0
        0x08000f1c:    0800311f    .1..    DCD    134230303
        0x08000f20:    08003126    &1..    DCD    134230310
    $t
    i.LL_TIM_OC_EnablePreload
    LL_TIM_OC_EnablePreload
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
        0x08000f24:    b570        p.      PUSH     {r4-r6,lr}
        0x08000f26:    4602        .F      MOV      r2,r0
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000f28:    2901        .)      CMP      r1,#1
        0x08000f2a:    d101        ..      BNE      0x8000f30 ; LL_TIM_OC_EnablePreload + 12
        0x08000f2c:    2400        .$      MOVS     r4,#0
        0x08000f2e:    e016        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f30:    2904        .)      CMP      r1,#4
        0x08000f32:    d101        ..      BNE      0x8000f38 ; LL_TIM_OC_EnablePreload + 20
        0x08000f34:    2401        .$      MOVS     r4,#1
        0x08000f36:    e012        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f38:    2910        .)      CMP      r1,#0x10
        0x08000f3a:    d101        ..      BNE      0x8000f40 ; LL_TIM_OC_EnablePreload + 28
        0x08000f3c:    2402        .$      MOVS     r4,#2
        0x08000f3e:    e00e        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f40:    2940        @)      CMP      r1,#0x40
        0x08000f42:    d101        ..      BNE      0x8000f48 ; LL_TIM_OC_EnablePreload + 36
        0x08000f44:    2403        .$      MOVS     r4,#3
        0x08000f46:    e00a        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f48:    f5b17f80    ....    CMP      r1,#0x100
        0x08000f4c:    d101        ..      BNE      0x8000f52 ; LL_TIM_OC_EnablePreload + 46
        0x08000f4e:    2404        .$      MOVS     r4,#4
        0x08000f50:    e005        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f52:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000f56:    d101        ..      BNE      0x8000f5c ; LL_TIM_OC_EnablePreload + 56
        0x08000f58:    2405        .$      MOVS     r4,#5
        0x08000f5a:    e000        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f5c:    2406        .$      MOVS     r4,#6
        0x08000f5e:    4623        #F      MOV      r3,r4
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000f60:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000f7c] = 0x800311f
        0x08000f62:    5ce5        .\      LDRB     r5,[r4,r3]
        0x08000f64:    f1020418    ....    ADD      r4,r2,#0x18
        0x08000f68:    1928        (.      ADDS     r0,r5,r4
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
        0x08000f6a:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000f80] = 0x8003126
        0x08000f6c:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000f6e:    2508        .%      MOVS     r5,#8
        0x08000f70:    40b5        .@      LSLS     r5,r5,r6
        0x08000f72:    6804        .h      LDR      r4,[r0,#0]
        0x08000f74:    432c        ,C      ORRS     r4,r4,r5
        0x08000f76:    6004        .`      STR      r4,[r0,#0]
;;;1853   }
        0x08000f78:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000f7a:    0000        ..      DCW    0
        0x08000f7c:    0800311f    .1..    DCD    134230303
        0x08000f80:    08003126    &1..    DCD    134230310
    $t
    i.LL_TIM_OC_Init
    LL_TIM_OC_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;418    {
        0x08000f84:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08000f88:    4606        .F      MOV      r6,r0
        0x08000f8a:    460c        .F      MOV      r4,r1
        0x08000f8c:    4615        .F      MOV      r5,r2
;;;419      ErrorStatus result = ERROR;
        0x08000f8e:    2700        .'      MOVS     r7,#0
;;;420    
;;;421      switch (Channel)
        0x08000f90:    2c01        .,      CMP      r4,#1
        0x08000f92:    d008        ..      BEQ      0x8000fa6 ; LL_TIM_OC_Init + 34
        0x08000f94:    2c10        .,      CMP      r4,#0x10
        0x08000f96:    d00c        ..      BEQ      0x8000fb2 ; LL_TIM_OC_Init + 46
        0x08000f98:    f5b47f80    ....    CMP      r4,#0x100
        0x08000f9c:    d00f        ..      BEQ      0x8000fbe ; LL_TIM_OC_Init + 58
        0x08000f9e:    f5b45f80    ..._    CMP      r4,#0x1000
        0x08000fa2:    d118        ..      BNE      0x8000fd6 ; LL_TIM_OC_Init + 82
        0x08000fa4:    e011        ..      B        0x8000fca ; LL_TIM_OC_Init + 70
;;;422      {
;;;423        case LL_TIM_CHANNEL_CH1:
;;;424          result = OC1Config(TIMx, TIM_OC_InitStruct);
        0x08000fa6:    4629        )F      MOV      r1,r5
        0x08000fa8:    4630        0F      MOV      r0,r6
        0x08000faa:    f000fcfb    ....    BL       OC1Config ; 0x80019a4
        0x08000fae:    4607        .F      MOV      r7,r0
;;;425          break;
        0x08000fb0:    e012        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;426        case LL_TIM_CHANNEL_CH2:
;;;427          result = OC2Config(TIMx, TIM_OC_InitStruct);
        0x08000fb2:    4629        )F      MOV      r1,r5
        0x08000fb4:    4630        0F      MOV      r0,r6
        0x08000fb6:    f000fd33    ..3.    BL       OC2Config ; 0x8001a20
        0x08000fba:    4607        .F      MOV      r7,r0
;;;428          break;
        0x08000fbc:    e00c        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;429        case LL_TIM_CHANNEL_CH3:
;;;430          result = OC3Config(TIMx, TIM_OC_InitStruct);
        0x08000fbe:    4629        )F      MOV      r1,r5
        0x08000fc0:    4630        0F      MOV      r0,r6
        0x08000fc2:    f000fd71    ..q.    BL       OC3Config ; 0x8001aa8
        0x08000fc6:    4607        .F      MOV      r7,r0
;;;431          break;
        0x08000fc8:    e006        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;432        case LL_TIM_CHANNEL_CH4:
;;;433          result = OC4Config(TIMx, TIM_OC_InitStruct);
        0x08000fca:    4629        )F      MOV      r1,r5
        0x08000fcc:    4630        0F      MOV      r0,r6
        0x08000fce:    f000fda9    ....    BL       OC4Config ; 0x8001b24
        0x08000fd2:    4607        .F      MOV      r7,r0
;;;434          break;
        0x08000fd4:    e000        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;435        default:
;;;436          break;
        0x08000fd6:    bf00        ..      NOP      
        0x08000fd8:    bf00        ..      NOP      
;;;437      }
;;;438    
;;;439      return result;
        0x08000fda:    4638        8F      MOV      r0,r7
;;;440    }
        0x08000fdc:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_TIM_OC_SetCompareCH2
    LL_TIM_OC_SetCompareCH2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
        0x08000fe0:    6381        .c      STR      r1,[r0,#0x38]
;;;2012   }
        0x08000fe2:    4770        pG      BX       lr
    i.LL_TIM_SetClockSource
    LL_TIM_SetClockSource
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
        0x08000fe4:    6882        .h      LDR      r2,[r0,#8]
        0x08000fe6:    f2440307    D...    MOV      r3,#0x4007
        0x08000fea:    439a        .C      BICS     r2,r2,r3
        0x08000fec:    430a        .C      ORRS     r2,r2,r1
        0x08000fee:    6082        .`      STR      r2,[r0,#8]
;;;2533   }
        0x08000ff0:    4770        pG      BX       lr
    i.LL_TIM_SetTriggerOutput
    LL_TIM_SetTriggerOutput
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
        0x08000ff2:    6842        Bh      LDR      r2,[r0,#4]
        0x08000ff4:    f0220270    ".p.    BIC      r2,r2,#0x70
        0x08000ff8:    430a        .C      ORRS     r2,r2,r1
        0x08000ffa:    6042        B`      STR      r2,[r0,#4]
;;;2579   }
        0x08000ffc:    4770        pG      BX       lr
        0x08000ffe:    0000        ..      MOVS     r0,r0
    i.LL_USART_Init
    LL_USART_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;212    {
        0x08001000:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x08001004:    4604        .F      MOV      r4,r0
        0x08001006:    460d        .F      MOV      r5,r1
;;;213      ErrorStatus status = ERROR;
        0x08001008:    2700        .'      MOVS     r7,#0
;;;214      uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;
        0x0800100a:    2600        .&      MOVS     r6,#0
;;;215      LL_RCC_ClocksTypeDef rcc_clocks;
;;;216    
;;;217      /* Check the parameters */
;;;218      assert_param(IS_UART_INSTANCE(USARTx));
;;;219      assert_param(IS_LL_USART_BAUDRATE(USART_InitStruct->BaudRate));
;;;220      assert_param(IS_LL_USART_DATAWIDTH(USART_InitStruct->DataWidth));
;;;221      assert_param(IS_LL_USART_STOPBITS(USART_InitStruct->StopBits));
;;;222      assert_param(IS_LL_USART_PARITY(USART_InitStruct->Parity));
;;;223      assert_param(IS_LL_USART_DIRECTION(USART_InitStruct->TransferDirection));
;;;224      assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
;;;225    #if defined(USART_CR1_OVER8)
;;;226      assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));
;;;227    #endif /* USART_OverSampling_Feature */
;;;228    
;;;229      /* USART needs to be in disabled state, in order to be able to configure some bits in
;;;230         CRx registers */
;;;231      if (LL_USART_IsEnabled(USARTx) == 0U)
        0x0800100c:    4620         F      MOV      r0,r4
        0x0800100e:    f000f83f    ..?.    BL       LL_USART_IsEnabled ; 0x8001090
        0x08001012:    2800        .(      CMP      r0,#0
        0x08001014:    d132        2.      BNE      0x800107c ; LL_USART_Init + 124
;;;232      {
;;;233        /*---------------------------- USART CR1 Configuration -----------------------
;;;234         * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:
;;;235         * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
;;;236         * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
;;;237         * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
;;;238         * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
;;;239         */
;;;240    #if defined(USART_CR1_OVER8)
;;;241        MODIFY_REG(USARTx->CR1,
;;;242                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;243                    USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;244                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;245                    USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));
;;;246    #else
;;;247        MODIFY_REG(USARTx->CR1,
        0x08001016:    68e9        .h      LDR      r1,[r5,#0xc]
        0x08001018:    6868        hh      LDR      r0,[r5,#4]
        0x0800101a:    4308        .C      ORRS     r0,r0,r1
        0x0800101c:    6929        )i      LDR      r1,[r5,#0x10]
        0x0800101e:    4308        .C      ORRS     r0,r0,r1
        0x08001020:    68e1        .h      LDR      r1,[r4,#0xc]
        0x08001022:    f241620c    A..b    MOV      r2,#0x160c
        0x08001026:    4391        .C      BICS     r1,r1,r2
        0x08001028:    4308        .C      ORRS     r0,r0,r1
        0x0800102a:    60e0        .`      STR      r0,[r4,#0xc]
;;;248                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;249                    USART_CR1_TE | USART_CR1_RE),
;;;250                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;251                    USART_InitStruct->TransferDirection));
;;;252    #endif /* USART_OverSampling_Feature */
;;;253    
;;;254        /*---------------------------- USART CR2 Configuration -----------------------
;;;255         * Configure USARTx CR2 (Stop bits) with parameters:
;;;256         * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.
;;;257         * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().
;;;258         */
;;;259        LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
        0x0800102c:    68a8        .h      LDR      r0,[r5,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;828      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
        0x0800102e:    6921        !i      LDR      r1,[r4,#0x10]
        0x08001030:    f4215140    !.@Q    BIC      r1,r1,#0x3000
        0x08001034:    4301        .C      ORRS     r1,r1,r0
        0x08001036:    6121        !a      STR      r1,[r4,#0x10]
;;;829    }
        0x08001038:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;265        LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
        0x0800103a:    6968        hi      LDR      r0,[r5,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;972      MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
        0x0800103c:    6961        ai      LDR      r1,[r4,#0x14]
        0x0800103e:    f4217140    !.@q    BIC      r1,r1,#0x300
        0x08001042:    4301        .C      ORRS     r1,r1,r0
        0x08001044:    6161        aa      STR      r1,[r4,#0x14]
;;;973    }
        0x08001046:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;270        LL_RCC_GetSystemClocksFreq(&rcc_clocks);
        0x08001048:    4668        hF      MOV      r0,sp
        0x0800104a:    f7fffdbd    ....    BL       LL_RCC_GetSystemClocksFreq ; 0x8000bc8
;;;271        if (USARTx == USART1)
        0x0800104e:    480d        .H      LDR      r0,[pc,#52] ; [0x8001084] = 0x40013800
        0x08001050:    4284        .B      CMP      r4,r0
        0x08001052:    d101        ..      BNE      0x8001058 ; LL_USART_Init + 88
;;;272        {
;;;273          periphclk = rcc_clocks.PCLK2_Frequency;
        0x08001054:    9e03        ..      LDR      r6,[sp,#0xc]
        0x08001056:    e008        ..      B        0x800106a ; LL_USART_Init + 106
;;;274        }
;;;275        else if (USARTx == USART2)
        0x08001058:    480b        .H      LDR      r0,[pc,#44] ; [0x8001088] = 0x40004400
        0x0800105a:    4284        .B      CMP      r4,r0
        0x0800105c:    d101        ..      BNE      0x8001062 ; LL_USART_Init + 98
;;;276        {
;;;277          periphclk = rcc_clocks.PCLK1_Frequency;
        0x0800105e:    9e02        ..      LDR      r6,[sp,#8]
        0x08001060:    e003        ..      B        0x800106a ; LL_USART_Init + 106
;;;278        }
;;;279    #if defined(USART3)
;;;280        else if (USARTx == USART3)
        0x08001062:    480a        .H      LDR      r0,[pc,#40] ; [0x800108c] = 0x40004800
        0x08001064:    4284        .B      CMP      r4,r0
        0x08001066:    d100        ..      BNE      0x800106a ; LL_USART_Init + 106
;;;281        {
;;;282          periphclk = rcc_clocks.PCLK1_Frequency;
        0x08001068:    9e02        ..      LDR      r6,[sp,#8]
;;;283        }
;;;284    #endif /* USART3 */
;;;285    #if defined(UART4)
;;;286        else if (USARTx == UART4)
;;;287        {
;;;288          periphclk = rcc_clocks.PCLK1_Frequency;
;;;289        }
;;;290    #endif /* UART4 */
;;;291    #if defined(UART5)
;;;292        else if (USARTx == UART5)
;;;293        {
;;;294          periphclk = rcc_clocks.PCLK1_Frequency;
;;;295        }
;;;296    #endif /* UART5 */
;;;297        else
;;;298        {
;;;299          /* Nothing to do, as error code is already assigned to ERROR value */
;;;300        }
;;;301    
;;;302        /* Configure the USART Baud Rate :
;;;303           - valid baud rate value (different from 0) is required
;;;304           - Peripheral clock as returned by RCC service, should be valid (different from 0).
;;;305        */
;;;306        if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
        0x0800106a:    b13e        >.      CBZ      r6,0x800107c ; LL_USART_Init + 124
;;;307            && (USART_InitStruct->BaudRate != 0U))
        0x0800106c:    6828        (h      LDR      r0,[r5,#0]
        0x0800106e:    b128        (.      CBZ      r0,0x800107c ; LL_USART_Init + 124
;;;308        {
;;;309          status = SUCCESS;
        0x08001070:    2701        .'      MOVS     r7,#1
;;;310    #if defined(USART_CR1_OVER8)
;;;311          LL_USART_SetBaudRate(USARTx,
;;;312                               periphclk,
;;;313                               USART_InitStruct->OverSampling,
;;;314                               USART_InitStruct->BaudRate);
;;;315    #else
;;;316          LL_USART_SetBaudRate(USARTx,
        0x08001072:    4631        1F      MOV      r1,r6
        0x08001074:    4620         F      MOV      r0,r4
        0x08001076:    682a        *h      LDR      r2,[r5,#0]
        0x08001078:    f000f80f    ....    BL       LL_USART_SetBaudRate ; 0x800109a
;;;317                               periphclk,
;;;318                               USART_InitStruct->BaudRate);
;;;319    #endif /* USART_OverSampling_Feature */
;;;320        }
;;;321      }
;;;322      /* Endif (=> USART not in Disabled state => return ERROR) */
;;;323    
;;;324      return (status);
        0x0800107c:    4638        8F      MOV      r0,r7
;;;325    }
        0x0800107e:    b004        ..      ADD      sp,sp,#0x10
        0x08001080:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x08001084:    40013800    .8.@    DCD    1073821696
        0x08001088:    40004400    .D.@    DCD    1073759232
        0x0800108c:    40004800    .H.@    DCD    1073760256
    $t
    i.LL_USART_IsEnabled
    LL_USART_IsEnabled
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;455    {
        0x08001090:    4601        .F      MOV      r1,r0
;;;456      return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
        0x08001092:    68c8        .h      LDR      r0,[r1,#0xc]
        0x08001094:    f3c03040    ..@0    UBFX     r0,r0,#13,#1
;;;457    }
        0x08001098:    4770        pG      BX       lr
    i.LL_USART_SetBaudRate
    LL_USART_SetBaudRate
;;;458    
;;;459    /**
;;;460      * @brief  Receiver Enable (Receiver is enabled and begins searching for a start bit)
;;;461      * @rmtoll CR1          RE            LL_USART_EnableDirectionRx
;;;462      * @param  USARTx USART Instance
;;;463      * @retval None
;;;464      */
;;;465    __STATIC_INLINE void LL_USART_EnableDirectionRx(USART_TypeDef *USARTx)
;;;466    {
;;;467      SET_BIT(USARTx->CR1, USART_CR1_RE);
;;;468    }
;;;469    
;;;470    /**
;;;471      * @brief  Receiver Disable
;;;472      * @rmtoll CR1          RE            LL_USART_DisableDirectionRx
;;;473      * @param  USARTx USART Instance
;;;474      * @retval None
;;;475      */
;;;476    __STATIC_INLINE void LL_USART_DisableDirectionRx(USART_TypeDef *USARTx)
;;;477    {
;;;478      CLEAR_BIT(USARTx->CR1, USART_CR1_RE);
;;;479    }
;;;480    
;;;481    /**
;;;482      * @brief  Transmitter Enable
;;;483      * @rmtoll CR1          TE            LL_USART_EnableDirectionTx
;;;484      * @param  USARTx USART Instance
;;;485      * @retval None
;;;486      */
;;;487    __STATIC_INLINE void LL_USART_EnableDirectionTx(USART_TypeDef *USARTx)
;;;488    {
;;;489      SET_BIT(USARTx->CR1, USART_CR1_TE);
;;;490    }
;;;491    
;;;492    /**
;;;493      * @brief  Transmitter Disable
;;;494      * @rmtoll CR1          TE            LL_USART_DisableDirectionTx
;;;495      * @param  USARTx USART Instance
;;;496      * @retval None
;;;497      */
;;;498    __STATIC_INLINE void LL_USART_DisableDirectionTx(USART_TypeDef *USARTx)
;;;499    {
;;;500      CLEAR_BIT(USARTx->CR1, USART_CR1_TE);
;;;501    }
;;;502    
;;;503    /**
;;;504      * @brief  Configure simultaneously enabled/disabled states
;;;505      *         of Transmitter and Receiver
;;;506      * @rmtoll CR1          RE            LL_USART_SetTransferDirection\n
;;;507      *         CR1          TE            LL_USART_SetTransferDirection
;;;508      * @param  USARTx USART Instance
;;;509      * @param  TransferDirection This parameter can be one of the following values:
;;;510      *         @arg @ref LL_USART_DIRECTION_NONE
;;;511      *         @arg @ref LL_USART_DIRECTION_RX
;;;512      *         @arg @ref LL_USART_DIRECTION_TX
;;;513      *         @arg @ref LL_USART_DIRECTION_TX_RX
;;;514      * @retval None
;;;515      */
;;;516    __STATIC_INLINE void LL_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection)
;;;517    {
;;;518      MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
;;;519    }
;;;520    
;;;521    /**
;;;522      * @brief  Return enabled/disabled states of Transmitter and Receiver
;;;523      * @rmtoll CR1          RE            LL_USART_GetTransferDirection\n
;;;524      *         CR1          TE            LL_USART_GetTransferDirection
;;;525      * @param  USARTx USART Instance
;;;526      * @retval Returned value can be one of the following values:
;;;527      *         @arg @ref LL_USART_DIRECTION_NONE
;;;528      *         @arg @ref LL_USART_DIRECTION_RX
;;;529      *         @arg @ref LL_USART_DIRECTION_TX
;;;530      *         @arg @ref LL_USART_DIRECTION_TX_RX
;;;531      */
;;;532    __STATIC_INLINE uint32_t LL_USART_GetTransferDirection(USART_TypeDef *USARTx)
;;;533    {
;;;534      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_RE | USART_CR1_TE));
;;;535    }
;;;536    
;;;537    /**
;;;538      * @brief  Configure Parity (enabled/disabled and parity mode if enabled).
;;;539      * @note   This function selects if hardware parity control (generation and detection) is enabled or disabled.
;;;540      *         When the parity control is enabled (Odd or Even), computed parity bit is inserted at the MSB position
;;;541      *         (9th or 8th bit depending on data width) and parity is checked on the received data.
;;;542      * @rmtoll CR1          PS            LL_USART_SetParity\n
;;;543      *         CR1          PCE           LL_USART_SetParity
;;;544      * @param  USARTx USART Instance
;;;545      * @param  Parity This parameter can be one of the following values:
;;;546      *         @arg @ref LL_USART_PARITY_NONE
;;;547      *         @arg @ref LL_USART_PARITY_EVEN
;;;548      *         @arg @ref LL_USART_PARITY_ODD
;;;549      * @retval None
;;;550      */
;;;551    __STATIC_INLINE void LL_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity)
;;;552    {
;;;553      MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
;;;554    }
;;;555    
;;;556    /**
;;;557      * @brief  Return Parity configuration (enabled/disabled and parity mode if enabled)
;;;558      * @rmtoll CR1          PS            LL_USART_GetParity\n
;;;559      *         CR1          PCE           LL_USART_GetParity
;;;560      * @param  USARTx USART Instance
;;;561      * @retval Returned value can be one of the following values:
;;;562      *         @arg @ref LL_USART_PARITY_NONE
;;;563      *         @arg @ref LL_USART_PARITY_EVEN
;;;564      *         @arg @ref LL_USART_PARITY_ODD
;;;565      */
;;;566    __STATIC_INLINE uint32_t LL_USART_GetParity(USART_TypeDef *USARTx)
;;;567    {
;;;568      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
;;;569    }
;;;570    
;;;571    /**
;;;572      * @brief  Set Receiver Wake Up method from Mute mode.
;;;573      * @rmtoll CR1          WAKE          LL_USART_SetWakeUpMethod
;;;574      * @param  USARTx USART Instance
;;;575      * @param  Method This parameter can be one of the following values:
;;;576      *         @arg @ref LL_USART_WAKEUP_IDLELINE
;;;577      *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
;;;578      * @retval None
;;;579      */
;;;580    __STATIC_INLINE void LL_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method)
;;;581    {
;;;582      MODIFY_REG(USARTx->CR1, USART_CR1_WAKE, Method);
;;;583    }
;;;584    
;;;585    /**
;;;586      * @brief  Return Receiver Wake Up method from Mute mode
;;;587      * @rmtoll CR1          WAKE          LL_USART_GetWakeUpMethod
;;;588      * @param  USARTx USART Instance
;;;589      * @retval Returned value can be one of the following values:
;;;590      *         @arg @ref LL_USART_WAKEUP_IDLELINE
;;;591      *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
;;;592      */
;;;593    __STATIC_INLINE uint32_t LL_USART_GetWakeUpMethod(USART_TypeDef *USARTx)
;;;594    {
;;;595      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_WAKE));
;;;596    }
;;;597    
;;;598    /**
;;;599      * @brief  Set Word length (i.e. nb of data bits, excluding start and stop bits)
;;;600      * @rmtoll CR1          M             LL_USART_SetDataWidth
;;;601      * @param  USARTx USART Instance
;;;602      * @param  DataWidth This parameter can be one of the following values:
;;;603      *         @arg @ref LL_USART_DATAWIDTH_8B
;;;604      *         @arg @ref LL_USART_DATAWIDTH_9B
;;;605      * @retval None
;;;606      */
;;;607    __STATIC_INLINE void LL_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth)
;;;608    {
;;;609      MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
;;;610    }
;;;611    
;;;612    /**
;;;613      * @brief  Return Word length (i.e. nb of data bits, excluding start and stop bits)
;;;614      * @rmtoll CR1          M             LL_USART_GetDataWidth
;;;615      * @param  USARTx USART Instance
;;;616      * @retval Returned value can be one of the following values:
;;;617      *         @arg @ref LL_USART_DATAWIDTH_8B
;;;618      *         @arg @ref LL_USART_DATAWIDTH_9B
;;;619      */
;;;620    __STATIC_INLINE uint32_t LL_USART_GetDataWidth(USART_TypeDef *USARTx)
;;;621    {
;;;622      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
;;;623    }
;;;624    
;;;625    #if defined(USART_CR1_OVER8)
;;;626    /**
;;;627      * @brief  Set Oversampling to 8-bit or 16-bit mode
;;;628      * @rmtoll CR1          OVER8         LL_USART_SetOverSampling
;;;629      * @param  USARTx USART Instance
;;;630      * @param  OverSampling This parameter can be one of the following values:
;;;631      *         @arg @ref LL_USART_OVERSAMPLING_16
;;;632      *         @arg @ref LL_USART_OVERSAMPLING_8
;;;633      * @retval None
;;;634      */
;;;635    __STATIC_INLINE void LL_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling)
;;;636    {
;;;637      MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
;;;638    }
;;;639    
;;;640    /**
;;;641      * @brief  Return Oversampling mode
;;;642      * @rmtoll CR1          OVER8         LL_USART_GetOverSampling
;;;643      * @param  USARTx USART Instance
;;;644      * @retval Returned value can be one of the following values:
;;;645      *         @arg @ref LL_USART_OVERSAMPLING_16
;;;646      *         @arg @ref LL_USART_OVERSAMPLING_8
;;;647      */
;;;648    __STATIC_INLINE uint32_t LL_USART_GetOverSampling(USART_TypeDef *USARTx)
;;;649    {
;;;650      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_OVER8));
;;;651    }
;;;652    
;;;653    #endif /* USART_OverSampling_Feature */
;;;654    /**
;;;655      * @brief  Configure if Clock pulse of the last data bit is output to the SCLK pin or not
;;;656      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;657      *         Synchronous mode is supported by the USARTx instance.
;;;658      * @rmtoll CR2          LBCL          LL_USART_SetLastClkPulseOutput
;;;659      * @param  USARTx USART Instance
;;;660      * @param  LastBitClockPulse This parameter can be one of the following values:
;;;661      *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
;;;662      *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
;;;663      * @retval None
;;;664      */
;;;665    __STATIC_INLINE void LL_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPulse)
;;;666    {
;;;667      MODIFY_REG(USARTx->CR2, USART_CR2_LBCL, LastBitClockPulse);
;;;668    }
;;;669    
;;;670    /**
;;;671      * @brief  Retrieve Clock pulse of the last data bit output configuration
;;;672      *         (Last bit Clock pulse output to the SCLK pin or not)
;;;673      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;674      *         Synchronous mode is supported by the USARTx instance.
;;;675      * @rmtoll CR2          LBCL          LL_USART_GetLastClkPulseOutput
;;;676      * @param  USARTx USART Instance
;;;677      * @retval Returned value can be one of the following values:
;;;678      *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
;;;679      *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
;;;680      */
;;;681    __STATIC_INLINE uint32_t LL_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx)
;;;682    {
;;;683      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBCL));
;;;684    }
;;;685    
;;;686    /**
;;;687      * @brief  Select the phase of the clock output on the SCLK pin in synchronous mode
;;;688      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;689      *         Synchronous mode is supported by the USARTx instance.
;;;690      * @rmtoll CR2          CPHA          LL_USART_SetClockPhase
;;;691      * @param  USARTx USART Instance
;;;692      * @param  ClockPhase This parameter can be one of the following values:
;;;693      *         @arg @ref LL_USART_PHASE_1EDGE
;;;694      *         @arg @ref LL_USART_PHASE_2EDGE
;;;695      * @retval None
;;;696      */
;;;697    __STATIC_INLINE void LL_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase)
;;;698    {
;;;699      MODIFY_REG(USARTx->CR2, USART_CR2_CPHA, ClockPhase);
;;;700    }
;;;701    
;;;702    /**
;;;703      * @brief  Return phase of the clock output on the SCLK pin in synchronous mode
;;;704      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;705      *         Synchronous mode is supported by the USARTx instance.
;;;706      * @rmtoll CR2          CPHA          LL_USART_GetClockPhase
;;;707      * @param  USARTx USART Instance
;;;708      * @retval Returned value can be one of the following values:
;;;709      *         @arg @ref LL_USART_PHASE_1EDGE
;;;710      *         @arg @ref LL_USART_PHASE_2EDGE
;;;711      */
;;;712    __STATIC_INLINE uint32_t LL_USART_GetClockPhase(USART_TypeDef *USARTx)
;;;713    {
;;;714      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPHA));
;;;715    }
;;;716    
;;;717    /**
;;;718      * @brief  Select the polarity of the clock output on the SCLK pin in synchronous mode
;;;719      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;720      *         Synchronous mode is supported by the USARTx instance.
;;;721      * @rmtoll CR2          CPOL          LL_USART_SetClockPolarity
;;;722      * @param  USARTx USART Instance
;;;723      * @param  ClockPolarity This parameter can be one of the following values:
;;;724      *         @arg @ref LL_USART_POLARITY_LOW
;;;725      *         @arg @ref LL_USART_POLARITY_HIGH
;;;726      * @retval None
;;;727      */
;;;728    __STATIC_INLINE void LL_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity)
;;;729    {
;;;730      MODIFY_REG(USARTx->CR2, USART_CR2_CPOL, ClockPolarity);
;;;731    }
;;;732    
;;;733    /**
;;;734      * @brief  Return polarity of the clock output on the SCLK pin in synchronous mode
;;;735      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;736      *         Synchronous mode is supported by the USARTx instance.
;;;737      * @rmtoll CR2          CPOL          LL_USART_GetClockPolarity
;;;738      * @param  USARTx USART Instance
;;;739      * @retval Returned value can be one of the following values:
;;;740      *         @arg @ref LL_USART_POLARITY_LOW
;;;741      *         @arg @ref LL_USART_POLARITY_HIGH
;;;742      */
;;;743    __STATIC_INLINE uint32_t LL_USART_GetClockPolarity(USART_TypeDef *USARTx)
;;;744    {
;;;745      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPOL));
;;;746    }
;;;747    
;;;748    /**
;;;749      * @brief  Configure Clock signal format (Phase Polarity and choice about output of last bit clock pulse)
;;;750      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;751      *         Synchronous mode is supported by the USARTx instance.
;;;752      * @note   Call of this function is equivalent to following function call sequence :
;;;753      *         - Clock Phase configuration using @ref LL_USART_SetClockPhase() function
;;;754      *         - Clock Polarity configuration using @ref LL_USART_SetClockPolarity() function
;;;755      *         - Output of Last bit Clock pulse configuration using @ref LL_USART_SetLastClkPulseOutput() function
;;;756      * @rmtoll CR2          CPHA          LL_USART_ConfigClock\n
;;;757      *         CR2          CPOL          LL_USART_ConfigClock\n
;;;758      *         CR2          LBCL          LL_USART_ConfigClock
;;;759      * @param  USARTx USART Instance
;;;760      * @param  Phase This parameter can be one of the following values:
;;;761      *         @arg @ref LL_USART_PHASE_1EDGE
;;;762      *         @arg @ref LL_USART_PHASE_2EDGE
;;;763      * @param  Polarity This parameter can be one of the following values:
;;;764      *         @arg @ref LL_USART_POLARITY_LOW
;;;765      *         @arg @ref LL_USART_POLARITY_HIGH
;;;766      * @param  LBCPOutput This parameter can be one of the following values:
;;;767      *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
;;;768      *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
;;;769      * @retval None
;;;770      */
;;;771    __STATIC_INLINE void LL_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity, uint32_t LBCPOutput)
;;;772    {
;;;773      MODIFY_REG(USARTx->CR2, USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL, Phase | Polarity | LBCPOutput);
;;;774    }
;;;775    
;;;776    /**
;;;777      * @brief  Enable Clock output on SCLK pin
;;;778      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;779      *         Synchronous mode is supported by the USARTx instance.
;;;780      * @rmtoll CR2          CLKEN         LL_USART_EnableSCLKOutput
;;;781      * @param  USARTx USART Instance
;;;782      * @retval None
;;;783      */
;;;784    __STATIC_INLINE void LL_USART_EnableSCLKOutput(USART_TypeDef *USARTx)
;;;785    {
;;;786      SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
;;;787    }
;;;788    
;;;789    /**
;;;790      * @brief  Disable Clock output on SCLK pin
;;;791      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;792      *         Synchronous mode is supported by the USARTx instance.
;;;793      * @rmtoll CR2          CLKEN         LL_USART_DisableSCLKOutput
;;;794      * @param  USARTx USART Instance
;;;795      * @retval None
;;;796      */
;;;797    __STATIC_INLINE void LL_USART_DisableSCLKOutput(USART_TypeDef *USARTx)
;;;798    {
;;;799      CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
;;;800    }
;;;801    
;;;802    /**
;;;803      * @brief  Indicate if Clock output on SCLK pin is enabled
;;;804      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;805      *         Synchronous mode is supported by the USARTx instance.
;;;806      * @rmtoll CR2          CLKEN         LL_USART_IsEnabledSCLKOutput
;;;807      * @param  USARTx USART Instance
;;;808      * @retval State of bit (1 or 0).
;;;809      */
;;;810    __STATIC_INLINE uint32_t LL_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx)
;;;811    {
;;;812      return (READ_BIT(USARTx->CR2, USART_CR2_CLKEN) == (USART_CR2_CLKEN));
;;;813    }
;;;814    
;;;815    /**
;;;816      * @brief  Set the length of the stop bits
;;;817      * @rmtoll CR2          STOP          LL_USART_SetStopBitsLength
;;;818      * @param  USARTx USART Instance
;;;819      * @param  StopBits This parameter can be one of the following values:
;;;820      *         @arg @ref LL_USART_STOPBITS_0_5
;;;821      *         @arg @ref LL_USART_STOPBITS_1
;;;822      *         @arg @ref LL_USART_STOPBITS_1_5
;;;823      *         @arg @ref LL_USART_STOPBITS_2
;;;824      * @retval None
;;;825      */
;;;826    __STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
;;;827    {
;;;828      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
;;;829    }
;;;830    
;;;831    /**
;;;832      * @brief  Retrieve the length of the stop bits
;;;833      * @rmtoll CR2          STOP          LL_USART_GetStopBitsLength
;;;834      * @param  USARTx USART Instance
;;;835      * @retval Returned value can be one of the following values:
;;;836      *         @arg @ref LL_USART_STOPBITS_0_5
;;;837      *         @arg @ref LL_USART_STOPBITS_1
;;;838      *         @arg @ref LL_USART_STOPBITS_1_5
;;;839      *         @arg @ref LL_USART_STOPBITS_2
;;;840      */
;;;841    __STATIC_INLINE uint32_t LL_USART_GetStopBitsLength(USART_TypeDef *USARTx)
;;;842    {
;;;843      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
;;;844    }
;;;845    
;;;846    /**
;;;847      * @brief  Configure Character frame format (Datawidth, Parity control, Stop Bits)
;;;848      * @note   Call of this function is equivalent to following function call sequence :
;;;849      *         - Data Width configuration using @ref LL_USART_SetDataWidth() function
;;;850      *         - Parity Control and mode configuration using @ref LL_USART_SetParity() function
;;;851      *         - Stop bits configuration using @ref LL_USART_SetStopBitsLength() function
;;;852      * @rmtoll CR1          PS            LL_USART_ConfigCharacter\n
;;;853      *         CR1          PCE           LL_USART_ConfigCharacter\n
;;;854      *         CR1          M             LL_USART_ConfigCharacter\n
;;;855      *         CR2          STOP          LL_USART_ConfigCharacter
;;;856      * @param  USARTx USART Instance
;;;857      * @param  DataWidth This parameter can be one of the following values:
;;;858      *         @arg @ref LL_USART_DATAWIDTH_8B
;;;859      *         @arg @ref LL_USART_DATAWIDTH_9B
;;;860      * @param  Parity This parameter can be one of the following values:
;;;861      *         @arg @ref LL_USART_PARITY_NONE
;;;862      *         @arg @ref LL_USART_PARITY_EVEN
;;;863      *         @arg @ref LL_USART_PARITY_ODD
;;;864      * @param  StopBits This parameter can be one of the following values:
;;;865      *         @arg @ref LL_USART_STOPBITS_0_5
;;;866      *         @arg @ref LL_USART_STOPBITS_1
;;;867      *         @arg @ref LL_USART_STOPBITS_1_5
;;;868      *         @arg @ref LL_USART_STOPBITS_2
;;;869      * @retval None
;;;870      */
;;;871    __STATIC_INLINE void LL_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
;;;872                                                  uint32_t StopBits)
;;;873    {
;;;874      MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
;;;875      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
;;;876    }
;;;877    
;;;878    /**
;;;879      * @brief  Set Address of the USART node.
;;;880      * @note   This is used in multiprocessor communication during Mute mode or Stop mode,
;;;881      *         for wake up with address mark detection.
;;;882      * @rmtoll CR2          ADD           LL_USART_SetNodeAddress
;;;883      * @param  USARTx USART Instance
;;;884      * @param  NodeAddress 4 bit Address of the USART node.
;;;885      * @retval None
;;;886      */
;;;887    __STATIC_INLINE void LL_USART_SetNodeAddress(USART_TypeDef *USARTx, uint32_t NodeAddress)
;;;888    {
;;;889      MODIFY_REG(USARTx->CR2, USART_CR2_ADD, (NodeAddress & USART_CR2_ADD));
;;;890    }
;;;891    
;;;892    /**
;;;893      * @brief  Return 4 bit Address of the USART node as set in ADD field of CR2.
;;;894      * @note   only 4bits (b3-b0) of returned value are relevant (b31-b4 are not relevant)
;;;895      * @rmtoll CR2          ADD           LL_USART_GetNodeAddress
;;;896      * @param  USARTx USART Instance
;;;897      * @retval Address of the USART node (Value between Min_Data=0 and Max_Data=255)
;;;898      */
;;;899    __STATIC_INLINE uint32_t LL_USART_GetNodeAddress(USART_TypeDef *USARTx)
;;;900    {
;;;901      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADD));
;;;902    }
;;;903    
;;;904    /**
;;;905      * @brief  Enable RTS HW Flow Control
;;;906      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;907      *         Hardware Flow control feature is supported by the USARTx instance.
;;;908      * @rmtoll CR3          RTSE          LL_USART_EnableRTSHWFlowCtrl
;;;909      * @param  USARTx USART Instance
;;;910      * @retval None
;;;911      */
;;;912    __STATIC_INLINE void LL_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;913    {
;;;914      SET_BIT(USARTx->CR3, USART_CR3_RTSE);
;;;915    }
;;;916    
;;;917    /**
;;;918      * @brief  Disable RTS HW Flow Control
;;;919      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;920      *         Hardware Flow control feature is supported by the USARTx instance.
;;;921      * @rmtoll CR3          RTSE          LL_USART_DisableRTSHWFlowCtrl
;;;922      * @param  USARTx USART Instance
;;;923      * @retval None
;;;924      */
;;;925    __STATIC_INLINE void LL_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;926    {
;;;927      CLEAR_BIT(USARTx->CR3, USART_CR3_RTSE);
;;;928    }
;;;929    
;;;930    /**
;;;931      * @brief  Enable CTS HW Flow Control
;;;932      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;933      *         Hardware Flow control feature is supported by the USARTx instance.
;;;934      * @rmtoll CR3          CTSE          LL_USART_EnableCTSHWFlowCtrl
;;;935      * @param  USARTx USART Instance
;;;936      * @retval None
;;;937      */
;;;938    __STATIC_INLINE void LL_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;939    {
;;;940      SET_BIT(USARTx->CR3, USART_CR3_CTSE);
;;;941    }
;;;942    
;;;943    /**
;;;944      * @brief  Disable CTS HW Flow Control
;;;945      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;946      *         Hardware Flow control feature is supported by the USARTx instance.
;;;947      * @rmtoll CR3          CTSE          LL_USART_DisableCTSHWFlowCtrl
;;;948      * @param  USARTx USART Instance
;;;949      * @retval None
;;;950      */
;;;951    __STATIC_INLINE void LL_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;952    {
;;;953      CLEAR_BIT(USARTx->CR3, USART_CR3_CTSE);
;;;954    }
;;;955    
;;;956    /**
;;;957      * @brief  Configure HW Flow Control mode (both CTS and RTS)
;;;958      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;959      *         Hardware Flow control feature is supported by the USARTx instance.
;;;960      * @rmtoll CR3          RTSE          LL_USART_SetHWFlowCtrl\n
;;;961      *         CR3          CTSE          LL_USART_SetHWFlowCtrl
;;;962      * @param  USARTx USART Instance
;;;963      * @param  HardwareFlowControl This parameter can be one of the following values:
;;;964      *         @arg @ref LL_USART_HWCONTROL_NONE
;;;965      *         @arg @ref LL_USART_HWCONTROL_RTS
;;;966      *         @arg @ref LL_USART_HWCONTROL_CTS
;;;967      *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
;;;968      * @retval None
;;;969      */
;;;970    __STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
;;;971    {
;;;972      MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
;;;973    }
;;;974    
;;;975    /**
;;;976      * @brief  Return HW Flow Control configuration (both CTS and RTS)
;;;977      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;978      *         Hardware Flow control feature is supported by the USARTx instance.
;;;979      * @rmtoll CR3          RTSE          LL_USART_GetHWFlowCtrl\n
;;;980      *         CR3          CTSE          LL_USART_GetHWFlowCtrl
;;;981      * @param  USARTx USART Instance
;;;982      * @retval Returned value can be one of the following values:
;;;983      *         @arg @ref LL_USART_HWCONTROL_NONE
;;;984      *         @arg @ref LL_USART_HWCONTROL_RTS
;;;985      *         @arg @ref LL_USART_HWCONTROL_CTS
;;;986      *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
;;;987      */
;;;988    __STATIC_INLINE uint32_t LL_USART_GetHWFlowCtrl(USART_TypeDef *USARTx)
;;;989    {
;;;990      return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
;;;991    }
;;;992    
;;;993    #if defined(USART_CR3_ONEBIT)
;;;994    /**
;;;995      * @brief  Enable One bit sampling method
;;;996      * @rmtoll CR3          ONEBIT        LL_USART_EnableOneBitSamp
;;;997      * @param  USARTx USART Instance
;;;998      * @retval None
;;;999      */
;;;1000   __STATIC_INLINE void LL_USART_EnableOneBitSamp(USART_TypeDef *USARTx)
;;;1001   {
;;;1002     SET_BIT(USARTx->CR3, USART_CR3_ONEBIT);
;;;1003   }
;;;1004   
;;;1005   /**
;;;1006     * @brief  Disable One bit sampling method
;;;1007     * @rmtoll CR3          ONEBIT        LL_USART_DisableOneBitSamp
;;;1008     * @param  USARTx USART Instance
;;;1009     * @retval None
;;;1010     */
;;;1011   __STATIC_INLINE void LL_USART_DisableOneBitSamp(USART_TypeDef *USARTx)
;;;1012   {
;;;1013     CLEAR_BIT(USARTx->CR3, USART_CR3_ONEBIT);
;;;1014   }
;;;1015   
;;;1016   /**
;;;1017     * @brief  Indicate if One bit sampling method is enabled
;;;1018     * @rmtoll CR3          ONEBIT        LL_USART_IsEnabledOneBitSamp
;;;1019     * @param  USARTx USART Instance
;;;1020     * @retval State of bit (1 or 0).
;;;1021     */
;;;1022   __STATIC_INLINE uint32_t LL_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx)
;;;1023   {
;;;1024     return (READ_BIT(USARTx->CR3, USART_CR3_ONEBIT) == (USART_CR3_ONEBIT));
;;;1025   }
;;;1026   #endif /* USART_OneBitSampling_Feature */
;;;1027   
;;;1028   #if defined(USART_CR1_OVER8)
;;;1029   /**
;;;1030     * @brief  Configure USART BRR register for achieving expected Baud Rate value.
;;;1031     * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
;;;1032     *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
;;;1033     * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
;;;1034     *         (Baud rate value != 0)
;;;1035     * @rmtoll BRR          BRR           LL_USART_SetBaudRate
;;;1036     * @param  USARTx USART Instance
;;;1037     * @param  PeriphClk Peripheral Clock
;;;1038     * @param  OverSampling This parameter can be one of the following values:
;;;1039     *         @arg @ref LL_USART_OVERSAMPLING_16
;;;1040     *         @arg @ref LL_USART_OVERSAMPLING_8
;;;1041     * @param  BaudRate Baud Rate
;;;1042     * @retval None
;;;1043     */
;;;1044   __STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
;;;1045                                             uint32_t BaudRate)
;;;1046   {
;;;1047     if (OverSampling == LL_USART_OVERSAMPLING_8)
;;;1048     {
;;;1049       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
;;;1050     }
;;;1051     else
;;;1052     {
;;;1053       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
;;;1054     }
;;;1055   }
;;;1056   
;;;1057   /**
;;;1058     * @brief  Return current Baud Rate value, according to USARTDIV present in BRR register
;;;1059     *         (full BRR content), and to used Peripheral Clock and Oversampling mode values
;;;1060     * @note   In case of non-initialized or invalid value stored in BRR register, value 0 will be returned.
;;;1061     * @rmtoll BRR          BRR           LL_USART_GetBaudRate
;;;1062     * @param  USARTx USART Instance
;;;1063     * @param  PeriphClk Peripheral Clock
;;;1064     * @param  OverSampling This parameter can be one of the following values:
;;;1065     *         @arg @ref LL_USART_OVERSAMPLING_16
;;;1066     *         @arg @ref LL_USART_OVERSAMPLING_8
;;;1067     * @retval Baud Rate
;;;1068     */
;;;1069   __STATIC_INLINE uint32_t LL_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling)
;;;1070   {
;;;1071     register uint32_t usartdiv = 0x0U;
;;;1072     register uint32_t brrresult = 0x0U;
;;;1073   
;;;1074     usartdiv = USARTx->BRR;
;;;1075   
;;;1076     if (OverSampling == LL_USART_OVERSAMPLING_8)
;;;1077     {
;;;1078       if ((usartdiv & 0xFFF7U) != 0U)
;;;1079       {
;;;1080         usartdiv = (uint16_t)((usartdiv & 0xFFF0U) | ((usartdiv & 0x0007U) << 1U)) ;
;;;1081         brrresult = (PeriphClk * 2U) / usartdiv;
;;;1082       }
;;;1083     }
;;;1084     else
;;;1085     {
;;;1086       if ((usartdiv & 0xFFFFU) != 0U)
;;;1087       {
;;;1088         brrresult = PeriphClk / usartdiv;
;;;1089       }
;;;1090     }
;;;1091     return (brrresult);
;;;1092   }
;;;1093   #else
;;;1094   /**
;;;1095     * @brief  Configure USART BRR register for achieving expected Baud Rate value.
;;;1096     * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
;;;1097     *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
;;;1098     * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
;;;1099     *         (Baud rate value != 0)
;;;1100     * @rmtoll BRR          BRR           LL_USART_SetBaudRate
;;;1101     * @param  USARTx USART Instance
;;;1102     * @param  PeriphClk Peripheral Clock
;;;1103     * @param  BaudRate Baud Rate
;;;1104     * @retval None
;;;1105     */
;;;1106   __STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t BaudRate)
;;;1107   {
        0x0800109a:    b570        p.      PUSH     {r4-r6,lr}
;;;1108       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
        0x0800109c:    eb0103c1    ....    ADD      r3,r1,r1,LSL #3
        0x080010a0:    eb031301    ....    ADD      r3,r3,r1,LSL #4
        0x080010a4:    0094        ..      LSLS     r4,r2,#2
        0x080010a6:    fbb3f3f4    ....    UDIV     r3,r3,r4
        0x080010aa:    eb0104c1    ....    ADD      r4,r1,r1,LSL #3
        0x080010ae:    eb041401    ....    ADD      r4,r4,r1,LSL #4
        0x080010b2:    0095        ..      LSLS     r5,r2,#2
        0x080010b4:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010b8:    2564        d%      MOVS     r5,#0x64
        0x080010ba:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010be:    eb0405c4    ....    ADD      r5,r4,r4,LSL #3
        0x080010c2:    eb051404    ....    ADD      r4,r5,r4,LSL #4
        0x080010c6:    eba30384    ....    SUB      r3,r3,r4,LSL #2
        0x080010ca:    2432        2$      MOVS     r4,#0x32
        0x080010cc:    eb041303    ....    ADD      r3,r4,r3,LSL #4
        0x080010d0:    2464        d$      MOVS     r4,#0x64
        0x080010d2:    fbb3f3f4    ....    UDIV     r3,r3,r4
        0x080010d6:    f00303f0    ....    AND      r3,r3,#0xf0
        0x080010da:    eb0104c1    ....    ADD      r4,r1,r1,LSL #3
        0x080010de:    eb041401    ....    ADD      r4,r4,r1,LSL #4
        0x080010e2:    0095        ..      LSLS     r5,r2,#2
        0x080010e4:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010e8:    2564        d%      MOVS     r5,#0x64
        0x080010ea:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010ee:    eb031404    ....    ADD      r4,r3,r4,LSL #4
        0x080010f2:    eb0103c1    ....    ADD      r3,r1,r1,LSL #3
        0x080010f6:    eb031301    ....    ADD      r3,r3,r1,LSL #4
        0x080010fa:    0095        ..      LSLS     r5,r2,#2
        0x080010fc:    fbb3f3f5    ....    UDIV     r3,r3,r5
        0x08001100:    eb0105c1    ....    ADD      r5,r1,r1,LSL #3
        0x08001104:    eb051501    ....    ADD      r5,r5,r1,LSL #4
        0x08001108:    0096        ..      LSLS     r6,r2,#2
        0x0800110a:    fbb5f5f6    ....    UDIV     r5,r5,r6
        0x0800110e:    2664        d&      MOVS     r6,#0x64
        0x08001110:    fbb5f5f6    ....    UDIV     r5,r5,r6
        0x08001114:    eb0506c5    ....    ADD      r6,r5,r5,LSL #3
        0x08001118:    eb061505    ....    ADD      r5,r6,r5,LSL #4
        0x0800111c:    eba30385    ....    SUB      r3,r3,r5,LSL #2
        0x08001120:    2532        2%      MOVS     r5,#0x32
        0x08001122:    eb051303    ....    ADD      r3,r5,r3,LSL #4
        0x08001126:    2564        d%      MOVS     r5,#0x64
        0x08001128:    fbb3f3f5    ....    UDIV     r3,r3,r5
        0x0800112c:    f003030f    ....    AND      r3,r3,#0xf
        0x08001130:    4423        #D      ADD      r3,r3,r4
        0x08001132:    b29b        ..      UXTH     r3,r3
        0x08001134:    6083        .`      STR      r3,[r0,#8]
;;;1109   }
        0x08001136:    bd70        p.      POP      {r4-r6,pc}
    i.LL_mDelay
    LL_mDelay
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;201    {
        0x08001138:    b508        ..      PUSH     {r3,lr}
;;;202      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
        0x0800113a:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x0800113e:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001140:    9100        ..      STR      r1,[sp,#0]
;;;203      /* Add this code to indicate that local variable is not used */
;;;204      ((void)tmp);
        0x08001142:    bf00        ..      NOP      
;;;205    
;;;206      /* Add a period to guaranty minimum wait */
;;;207      if (Delay < LL_MAX_DELAY)
        0x08001144:    1c41        A.      ADDS     r1,r0,#1
        0x08001146:    b101        ..      CBZ      r1,0x800114a ; LL_mDelay + 18
;;;208      {
;;;209        Delay++;
        0x08001148:    1c40        @.      ADDS     r0,r0,#1
;;;210      }
;;;211    
;;;212      while (Delay)
        0x0800114a:    e006        ..      B        0x800115a ; LL_mDelay + 34
        0x0800114c:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001150:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001152:    f4013180    ...1    AND      r1,r1,#0x10000
        0x08001156:    b101        ..      CBZ      r1,0x800115a ; LL_mDelay + 34
        0x08001158:    1e40        @.      SUBS     r0,r0,#1
        0x0800115a:    2800        .(      CMP      r0,#0
        0x0800115c:    d1f6        ..      BNE      0x800114c ; LL_mDelay + 20
;;;213      {
;;;214        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
;;;215        {
;;;216          Delay--;
;;;217        }
;;;218      }
;;;219    }
        0x0800115e:    bd08        ..      POP      {r3,pc}
    i.MX_DMA_Init
    MX_DMA_Init
;;; .\../Src/main.c
;;;899    {
        0x08001160:    b538        8.      PUSH     {r3-r5,lr}
;;;900      /* Init with LL driver */
;;;901      /* DMA controller clock enable */
;;;902      LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);
        0x08001162:    2001        .       MOVS     r0,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;288      SET_BIT(RCC->AHBENR, Periphs);
        0x08001164:    4914        .I      LDR      r1,[pc,#80] ; [0x80011b8] = 0x40021000
        0x08001166:    6949        Ii      LDR      r1,[r1,#0x14]
        0x08001168:    4301        .C      ORRS     r1,r1,r0
        0x0800116a:    4a13        .J      LDR      r2,[pc,#76] ; [0x80011b8] = 0x40021000
        0x0800116c:    6151        Qa      STR      r1,[r2,#0x14]
;;;289      /* Delay after an RCC peripheral clock enabling */
;;;290      tmpreg = READ_BIT(RCC->AHBENR, Periphs);
        0x0800116e:    4611        .F      MOV      r1,r2
        0x08001170:    6949        Ii      LDR      r1,[r1,#0x14]
        0x08001172:    4001        .@      ANDS     r1,r1,r0
        0x08001174:    9100        ..      STR      r1,[sp,#0]
;;;291      (void)tmpreg;
        0x08001176:    bf00        ..      NOP      
;;;292    }
        0x08001178:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;906      NVIC_SetPriority(DMA1_Channel4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x0800117a:    f000fbf7    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x0800117e:    4605        .F      MOV      r5,r0
        0x08001180:    2200        ."      MOVS     r2,#0
        0x08001182:    2102        .!      MOVS     r1,#2
        0x08001184:    f000fbd1    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x08001188:    4604        .F      MOV      r4,r0
        0x0800118a:    4621        !F      MOV      r1,r4
        0x0800118c:    200e        .       MOVS     r0,#0xe
        0x0800118e:    f000fbf5    ....    BL       NVIC_SetPriority ; 0x800197c
;;;907      NVIC_EnableIRQ(DMA1_Channel4_IRQn);
        0x08001192:    200e        .       MOVS     r0,#0xe
        0x08001194:    f000fbbe    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;908      /* DMA1_Channel6_IRQn interrupt configuration */
;;;909      NVIC_SetPriority(DMA1_Channel6_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08001198:    f000fbe8    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x0800119c:    4605        .F      MOV      r5,r0
        0x0800119e:    2200        ."      MOVS     r2,#0
        0x080011a0:    4611        .F      MOV      r1,r2
        0x080011a2:    f000fbc2    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x080011a6:    4604        .F      MOV      r4,r0
        0x080011a8:    4621        !F      MOV      r1,r4
        0x080011aa:    2010        .       MOVS     r0,#0x10
        0x080011ac:    f000fbe6    ....    BL       NVIC_SetPriority ; 0x800197c
;;;910      NVIC_EnableIRQ(DMA1_Channel6_IRQn);
        0x080011b0:    2010        .       MOVS     r0,#0x10
        0x080011b2:    f000fbaf    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;911    
;;;912    }
        0x080011b6:    bd38        8.      POP      {r3-r5,pc}
    $d
        0x080011b8:    40021000    ...@    DCD    1073876992
    $t
    i.MX_GPIO_Init
    MX_GPIO_Init
;;;913    
;;;914    /**
;;;915      * @brief GPIO Initialization Function
;;;916      * @param None
;;;917      * @retval None
;;;918      */
;;;919    static void MX_GPIO_Init(void)
;;;920    {
        0x080011bc:    b500        ..      PUSH     {lr}
        0x080011be:    b085        ..      SUB      sp,sp,#0x14
;;;921      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080011c0:    2114        .!      MOVS     r1,#0x14
        0x080011c2:    4668        hF      MOV      r0,sp
        0x080011c4:    f7feffe6    ....    BL       __aeabi_memclr ; 0x8000194
;;;922    
;;;923      /* GPIO Ports Clock Enable */
;;;924      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOC);
        0x080011c8:    2010        .       MOVS     r0,#0x10
        0x080011ca:    f7fffb3d    ..=.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;925      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOD);
        0x080011ce:    2020                MOVS     r0,#0x20
        0x080011d0:    f7fffb3a    ..:.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;926      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x080011d4:    2004        .       MOVS     r0,#4
        0x080011d6:    f7fffb37    ..7.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;927      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080011da:    2008        .       MOVS     r0,#8
        0x080011dc:    f7fffb34    ..4.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;928    
;;;929      /**/
;;;930      LL_GPIO_ResetOutputPin(GPIOC, LED_Pin|MOTOR_X_DIR_Pin);
        0x080011e0:    492b        +I      LDR      r1,[pc,#172] ; [0x8001290] = 0x4a000a0
        0x080011e2:    482c        ,H      LDR      r0,[pc,#176] ; [0x8001294] = 0x40011000
        0x080011e4:    f7fffc4c    ..L.    BL       LL_GPIO_ResetOutputPin ; 0x8000a80
;;;931    
;;;932      /**/
;;;933      LL_GPIO_ResetOutputPin(GPIOA, MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin);
        0x080011e8:    f2482182    H..!    MOV      r1,#0x8282
        0x080011ec:    482a        *H      LDR      r0,[pc,#168] ; [0x8001298] = 0x40010800
        0x080011ee:    f7fffc47    ..G.    BL       LL_GPIO_ResetOutputPin ; 0x8000a80
;;;934    
;;;935      /**/
;;;936      LL_GPIO_ResetOutputPin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
        0x080011f2:    f2402102    @..!    MOV      r1,#0x202
        0x080011f6:    4829        )H      LDR      r0,[pc,#164] ; [0x800129c] = 0x40010c00
        0x080011f8:    f7fffc42    ..B.    BL       LL_GPIO_ResetOutputPin ; 0x8000a80
;;;937    
;;;938      /**/
;;;939      GPIO_InitStruct.Pin = LED_Pin|MOTOR_X_DIR_Pin;
        0x080011fc:    4824        $H      LDR      r0,[pc,#144] ; [0x8001290] = 0x4a000a0
        0x080011fe:    9000        ..      STR      r0,[sp,#0]
;;;940      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08001200:    2001        .       MOVS     r0,#1
        0x08001202:    9001        ..      STR      r0,[sp,#4]
;;;941      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08001204:    2002        .       MOVS     r0,#2
        0x08001206:    9002        ..      STR      r0,[sp,#8]
;;;942      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08001208:    2000        .       MOVS     r0,#0
        0x0800120a:    9003        ..      STR      r0,[sp,#0xc]
;;;943      LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x0800120c:    4669        iF      MOV      r1,sp
        0x0800120e:    4821        !H      LDR      r0,[pc,#132] ; [0x8001294] = 0x40011000
        0x08001210:    f7fffb98    ....    BL       LL_GPIO_Init ; 0x8000944
;;;944    
;;;945      /**/
;;;946      GPIO_InitStruct.Pin = LL_GPIO_PIN_14;
        0x08001214:    4822        "H      LDR      r0,[pc,#136] ; [0x80012a0] = 0x4400040
        0x08001216:    9000        ..      STR      r0,[sp,#0]
;;;947      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08001218:    2000        .       MOVS     r0,#0
        0x0800121a:    9001        ..      STR      r0,[sp,#4]
;;;948      LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x0800121c:    4669        iF      MOV      r1,sp
        0x0800121e:    481d        .H      LDR      r0,[pc,#116] ; [0x8001294] = 0x40011000
        0x08001220:    f7fffb90    ....    BL       LL_GPIO_Init ; 0x8000944
;;;949    
;;;950      /**/
;;;951      GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_10 
        0x08001224:    481f        .H      LDR      r0,[pc,#124] ; [0x80012a4] = 0x49c31bd
        0x08001226:    9000        ..      STR      r0,[sp,#0]
;;;952                              |LL_GPIO_PIN_11|LL_GPIO_PIN_12|LL_GPIO_PIN_15;
;;;953      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08001228:    2000        .       MOVS     r0,#0
        0x0800122a:    9001        ..      STR      r0,[sp,#4]
;;;954      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x0800122c:    4669        iF      MOV      r1,sp
        0x0800122e:    481a        .H      LDR      r0,[pc,#104] ; [0x8001298] = 0x40010800
        0x08001230:    f7fffb88    ....    BL       LL_GPIO_Init ; 0x8000944
;;;955    
;;;956      /**/
;;;957      GPIO_InitStruct.Pin = MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin;
        0x08001234:    f2482082    H..     MOV      r0,#0x8282
        0x08001238:    9000        ..      STR      r0,[sp,#0]
;;;958      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x0800123a:    2001        .       MOVS     r0,#1
        0x0800123c:    9001        ..      STR      r0,[sp,#4]
;;;959      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x0800123e:    2002        .       MOVS     r0,#2
        0x08001240:    9002        ..      STR      r0,[sp,#8]
;;;960      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08001242:    2000        .       MOVS     r0,#0
        0x08001244:    9003        ..      STR      r0,[sp,#0xc]
;;;961      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001246:    4669        iF      MOV      r1,sp
        0x08001248:    4813        .H      LDR      r0,[pc,#76] ; [0x8001298] = 0x40010800
        0x0800124a:    f7fffb7b    ..{.    BL       LL_GPIO_Init ; 0x8000944
;;;962    
;;;963      /**/
;;;964      GPIO_InitStruct.Pin = MOTOR_Z_ENABLE_Pin;
        0x0800124e:    f2402002    @..     MOV      r0,#0x202
        0x08001252:    9000        ..      STR      r0,[sp,#0]
;;;965      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08001254:    2001        .       MOVS     r0,#1
        0x08001256:    9001        ..      STR      r0,[sp,#4]
;;;966      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08001258:    2002        .       MOVS     r0,#2
        0x0800125a:    9002        ..      STR      r0,[sp,#8]
;;;967      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x0800125c:    2000        .       MOVS     r0,#0
        0x0800125e:    9003        ..      STR      r0,[sp,#0xc]
;;;968      LL_GPIO_Init(MOTOR_Z_ENABLE_GPIO_Port, &GPIO_InitStruct);
        0x08001260:    4669        iF      MOV      r1,sp
        0x08001262:    480e        .H      LDR      r0,[pc,#56] ; [0x800129c] = 0x40010c00
        0x08001264:    f7fffb6e    ..n.    BL       LL_GPIO_Init ; 0x8000944
;;;969    
;;;970      /**/
;;;971      GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14 
        0x08001268:    480f        .H      LDR      r0,[pc,#60] ; [0x80012a8] = 0x4f23cfe
        0x0800126a:    9000        ..      STR      r0,[sp,#0]
;;;972                              |LL_GPIO_PIN_15|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5 
;;;973                              |LL_GPIO_PIN_9;
;;;974      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x0800126c:    2000        .       MOVS     r0,#0
        0x0800126e:    9001        ..      STR      r0,[sp,#4]
;;;975      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08001270:    4669        iF      MOV      r1,sp
        0x08001272:    480a        .H      LDR      r0,[pc,#40] ; [0x800129c] = 0x40010c00
        0x08001274:    f7fffb66    ..f.    BL       LL_GPIO_Init ; 0x8000944
;;;976    
;;;977      /**/
;;;978      GPIO_InitStruct.Pin = BUTTON_1_Pin|BUTTON_2_Pin;
        0x08001278:    480c        .H      LDR      r0,[pc,#48] ; [0x80012ac] = 0x4030003
        0x0800127a:    9000        ..      STR      r0,[sp,#0]
;;;979      GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x0800127c:    2008        .       MOVS     r0,#8
        0x0800127e:    9001        ..      STR      r0,[sp,#4]
;;;980      GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x08001280:    2001        .       MOVS     r0,#1
        0x08001282:    9004        ..      STR      r0,[sp,#0x10]
;;;981      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001284:    4669        iF      MOV      r1,sp
        0x08001286:    4804        .H      LDR      r0,[pc,#16] ; [0x8001298] = 0x40010800
        0x08001288:    f7fffb5c    ..\.    BL       LL_GPIO_Init ; 0x8000944
;;;982    
;;;983    }
        0x0800128c:    b005        ..      ADD      sp,sp,#0x14
        0x0800128e:    bd00        ..      POP      {pc}
    $d
        0x08001290:    04a000a0    ....    DCD    77594784
        0x08001294:    40011000    ...@    DCD    1073811456
        0x08001298:    40010800    ...@    DCD    1073809408
        0x0800129c:    40010c00    ...@    DCD    1073810432
        0x080012a0:    04400040    @.@.    DCD    71303232
        0x080012a4:    049c31bd    .1..    DCD    77345213
        0x080012a8:    04f23cfe    .<..    DCD    82984190
        0x080012ac:    04030003    ....    DCD    67305475
    $t
    i.MX_I2C2_Init
    MX_I2C2_Init
;;; .\../Src/main.c (501)
        0x080012b0:    b530        0.      PUSH     {r4,r5,lr}
        0x080012b2:    b08b        ..      SUB      sp,sp,#0x2c
;;;502    
;;;503      /* USER CODE BEGIN I2C2_Init 0 */
;;;504    
;;;505      /* USER CODE END I2C2_Init 0 */
;;;506    
;;;507      LL_I2C_InitTypeDef I2C_InitStruct = {0};
        0x080012b4:    2118        .!      MOVS     r1,#0x18
        0x080012b6:    a805        ..      ADD      r0,sp,#0x14
        0x080012b8:    f7feff6c    ..l.    BL       __aeabi_memclr ; 0x8000194
;;;508    
;;;509      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080012bc:    2114        .!      MOVS     r1,#0x14
        0x080012be:    4668        hF      MOV      r0,sp
        0x080012c0:    f7feff68    ..h.    BL       __aeabi_memclr ; 0x8000194
;;;510    
;;;511      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080012c4:    2008        .       MOVS     r0,#8
        0x080012c6:    f7fffabf    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;512      /**I2C2 GPIO Configuration  
;;;513      PB10   ------> I2C2_SCL
;;;514      PB11   ------> I2C2_SDA 
;;;515      */
;;;516      GPIO_InitStruct.Pin = LL_GPIO_PIN_10|LL_GPIO_PIN_11;
        0x080012ca:    4840        @H      LDR      r0,[pc,#256] ; [0x80013cc] = 0x40c000c
        0x080012cc:    9000        ..      STR      r0,[sp,#0]
;;;517      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080012ce:    2009        .       MOVS     r0,#9
        0x080012d0:    9001        ..      STR      r0,[sp,#4]
;;;518      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080012d2:    2003        .       MOVS     r0,#3
        0x080012d4:    9002        ..      STR      r0,[sp,#8]
;;;519      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
        0x080012d6:    2004        .       MOVS     r0,#4
        0x080012d8:    9003        ..      STR      r0,[sp,#0xc]
;;;520      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x080012da:    4669        iF      MOV      r1,sp
        0x080012dc:    483c        <H      LDR      r0,[pc,#240] ; [0x80013d0] = 0x40010c00
        0x080012de:    f7fffb31    ..1.    BL       LL_GPIO_Init ; 0x8000944
;;;521    
;;;522      /* Peripheral clock enable */
;;;523      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_I2C2);
        0x080012e2:    f44f0080    O...    MOV      r0,#0x400000
        0x080012e6:    f7fffaa1    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;524    
;;;525      /* I2C2 DMA Init */
;;;526      
;;;527      /* I2C2_TX Init */
;;;528      LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_4, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);
        0x080012ea:    2210        ."      MOVS     r2,#0x10
        0x080012ec:    2104        .!      MOVS     r1,#4
        0x080012ee:    4839        9H      LDR      r0,[pc,#228] ; [0x80013d4] = 0x40020000
        0x080012f0:    f7fffac8    ....    BL       LL_DMA_SetDataTransferDirection ; 0x8000884
;;;529    
;;;530      LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PRIORITY_LOW);
        0x080012f4:    2200        ."      MOVS     r2,#0
        0x080012f6:    2104        .!      MOVS     r1,#4
        0x080012f8:    4836        6H      LDR      r0,[pc,#216] ; [0x80013d4] = 0x40020000
        0x080012fa:    f7fffab3    ....    BL       LL_DMA_SetChannelPriorityLevel ; 0x8000864
;;;531    
;;;532      LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MODE_NORMAL);
        0x080012fe:    2200        ."      MOVS     r2,#0
        0x08001300:    2104        .!      MOVS     r1,#4
        0x08001302:    4834        4H      LDR      r0,[pc,#208] ; [0x80013d4] = 0x40020000
        0x08001304:    f7fffaee    ....    BL       LL_DMA_SetMode ; 0x80008e4
;;;533    
;;;534      LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PERIPH_NOINCREMENT);
        0x08001308:    2200        ."      MOVS     r2,#0
        0x0800130a:    2104        .!      MOVS     r1,#4
        0x0800130c:    4831        1H      LDR      r0,[pc,#196] ; [0x80013d4] = 0x40020000
        0x0800130e:    f7fffaf9    ....    BL       LL_DMA_SetPeriphIncMode ; 0x8000904
;;;535    
;;;536      LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MEMORY_INCREMENT);
        0x08001312:    2280        ."      MOVS     r2,#0x80
        0x08001314:    2104        .!      MOVS     r1,#4
        0x08001316:    482f        /H      LDR      r0,[pc,#188] ; [0x80013d4] = 0x40020000
        0x08001318:    f7fffac4    ....    BL       LL_DMA_SetMemoryIncMode ; 0x80008a4
;;;537    
;;;538      LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PDATAALIGN_BYTE);
        0x0800131c:    2200        ."      MOVS     r2,#0
        0x0800131e:    2104        .!      MOVS     r1,#4
        0x08001320:    482c        ,H      LDR      r0,[pc,#176] ; [0x80013d4] = 0x40020000
        0x08001322:    f7fffaff    ....    BL       LL_DMA_SetPeriphSize ; 0x8000924
;;;539    
;;;540      LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MDATAALIGN_BYTE);
        0x08001326:    2200        ."      MOVS     r2,#0
        0x08001328:    2104        .!      MOVS     r1,#4
        0x0800132a:    482a        *H      LDR      r0,[pc,#168] ; [0x80013d4] = 0x40020000
        0x0800132c:    f7fffaca    ....    BL       LL_DMA_SetMemorySize ; 0x80008c4
;;;541    
;;;542      /* I2C2 interrupt Init */
;;;543      NVIC_SetPriority(I2C2_EV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08001330:    f000fb1c    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x08001334:    4605        .F      MOV      r5,r0
        0x08001336:    2200        ."      MOVS     r2,#0
        0x08001338:    2102        .!      MOVS     r1,#2
        0x0800133a:    f000faf6    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x0800133e:    4604        .F      MOV      r4,r0
        0x08001340:    4621        !F      MOV      r1,r4
        0x08001342:    2021        !       MOVS     r0,#0x21
        0x08001344:    f000fb1a    ....    BL       NVIC_SetPriority ; 0x800197c
;;;544      NVIC_EnableIRQ(I2C2_EV_IRQn);
        0x08001348:    2021        !       MOVS     r0,#0x21
        0x0800134a:    f000fae3    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;545      NVIC_SetPriority(I2C2_ER_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x0800134e:    f000fb0d    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x08001352:    4605        .F      MOV      r5,r0
        0x08001354:    2200        ."      MOVS     r2,#0
        0x08001356:    2102        .!      MOVS     r1,#2
        0x08001358:    f000fae7    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x0800135c:    4604        .F      MOV      r4,r0
        0x0800135e:    4621        !F      MOV      r1,r4
        0x08001360:    2022        "       MOVS     r0,#0x22
        0x08001362:    f000fb0b    ....    BL       NVIC_SetPriority ; 0x800197c
;;;546      NVIC_EnableIRQ(I2C2_ER_IRQn);
        0x08001366:    2022        "       MOVS     r0,#0x22
        0x08001368:    f000fad4    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;547    
;;;548      /* USER CODE BEGIN I2C2_Init 1 */
;;;549    
;;;550      /* USER CODE END I2C2_Init 1 */
;;;551      /**I2C Initialization 
;;;552      */
;;;553      LL_I2C_DisableOwnAddress2(I2C2);
        0x0800136c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;590      CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
        0x0800136e:    481a        .H      LDR      r0,[pc,#104] ; [0x80013d8] = 0x40005800
        0x08001370:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08001372:    f0200001     ...    BIC      r0,r0,#1
        0x08001376:    4918        .I      LDR      r1,[pc,#96] ; [0x80013d8] = 0x40005800
        0x08001378:    60c8        .`      STR      r0,[r1,#0xc]
;;;591    }
        0x0800137a:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;554      LL_I2C_DisableGeneralCall(I2C2);
        0x0800137c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;526      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENGC);
        0x0800137e:    4608        .F      MOV      r0,r1
        0x08001380:    6800        .h      LDR      r0,[r0,#0]
        0x08001382:    f0200040     .@.    BIC      r0,r0,#0x40
        0x08001386:    6008        .`      STR      r0,[r1,#0]
;;;527    }
        0x08001388:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;555      LL_I2C_EnableClockStretching(I2C2);
        0x0800138a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;479      CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
        0x0800138c:    4608        .F      MOV      r0,r1
        0x0800138e:    6800        .h      LDR      r0,[r0,#0]
        0x08001390:    f0200080     ...    BIC      r0,r0,#0x80
        0x08001394:    6008        .`      STR      r0,[r1,#0]
;;;480    }
        0x08001396:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;556      I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
        0x08001398:    2000        .       MOVS     r0,#0
        0x0800139a:    9005        ..      STR      r0,[sp,#0x14]
;;;557      I2C_InitStruct.ClockSpeed = 400000;
        0x0800139c:    480f        .H      LDR      r0,[pc,#60] ; [0x80013dc] = 0x61a80
        0x0800139e:    9006        ..      STR      r0,[sp,#0x18]
;;;558      I2C_InitStruct.DutyCycle = LL_I2C_DUTYCYCLE_2;
        0x080013a0:    2000        .       MOVS     r0,#0
        0x080013a2:    9007        ..      STR      r0,[sp,#0x1c]
;;;559      I2C_InitStruct.OwnAddress1 = 0;
        0x080013a4:    9008        ..      STR      r0,[sp,#0x20]
;;;560      I2C_InitStruct.TypeAcknowledge = LL_I2C_ACK;
        0x080013a6:    1508        ..      ASRS     r0,r1,#20
        0x080013a8:    9009        ..      STR      r0,[sp,#0x24]
;;;561      I2C_InitStruct.OwnAddrSize = LL_I2C_OWNADDRESS1_7BIT;
        0x080013aa:    0100        ..      LSLS     r0,r0,#4
        0x080013ac:    900a        ..      STR      r0,[sp,#0x28]
;;;562      LL_I2C_Init(I2C2, &I2C_InitStruct);
        0x080013ae:    a905        ..      ADD      r1,sp,#0x14
        0x080013b0:    4809        .H      LDR      r0,[pc,#36] ; [0x80013d8] = 0x40005800
        0x080013b2:    f7fffbc7    ....    BL       LL_I2C_Init ; 0x8000b44
;;;563      LL_I2C_SetOwnAddress2(I2C2, 0);
        0x080013b6:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;568      MODIFY_REG(I2Cx->OAR2, I2C_OAR2_ADD2, OwnAddress2);
        0x080013b8:    4907        .I      LDR      r1,[pc,#28] ; [0x80013d8] = 0x40005800
        0x080013ba:    68c9        .h      LDR      r1,[r1,#0xc]
        0x080013bc:    f02101fe    !...    BIC      r1,r1,#0xfe
        0x080013c0:    4301        .C      ORRS     r1,r1,r0
        0x080013c2:    4a05        .J      LDR      r2,[pc,#20] ; [0x80013d8] = 0x40005800
        0x080013c4:    60d1        .`      STR      r1,[r2,#0xc]
;;;569    }
        0x080013c6:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;568    }
        0x080013c8:    b00b        ..      ADD      sp,sp,#0x2c
        0x080013ca:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080013cc:    040c000c    ....    DCD    67895308
        0x080013d0:    40010c00    ...@    DCD    1073810432
        0x080013d4:    40020000    ...@    DCD    1073872896
        0x080013d8:    40005800    .X.@    DCD    1073764352
        0x080013dc:    00061a80    ....    DCD    400000
    $t
    i.MX_TIM1_Init
    MX_TIM1_Init
;;;569    
;;;570    /**
;;;571      * @brief TIM1 Initialization Function
;;;572      * @param None
;;;573      * @retval None
;;;574      */
;;;575    static void MX_TIM1_Init(void)
;;;576    {
        0x080013e0:    b530        0.      PUSH     {r4,r5,lr}
        0x080013e2:    b093        ..      SUB      sp,sp,#0x4c
;;;577    
;;;578      /* USER CODE BEGIN TIM1_Init 0 */
;;;579    
;;;580      /* USER CODE END TIM1_Init 0 */
;;;581    
;;;582      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x080013e4:    2114        .!      MOVS     r1,#0x14
        0x080013e6:    a80e        ..      ADD      r0,sp,#0x38
        0x080013e8:    f7fefed4    ....    BL       __aeabi_memclr ; 0x8000194
;;;583      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x080013ec:    2120         !      MOVS     r1,#0x20
        0x080013ee:    a806        ..      ADD      r0,sp,#0x18
        0x080013f0:    f7fefed0    ....    BL       __aeabi_memclr ; 0x8000194
;;;584      LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};
        0x080013f4:    2118        .!      MOVS     r1,#0x18
        0x080013f6:    4668        hF      MOV      r0,sp
        0x080013f8:    f7fefecc    ....    BL       __aeabi_memclr ; 0x8000194
;;;585    
;;;586      /* Peripheral clock enable */
;;;587      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);
        0x080013fc:    f44f6000    O..`    MOV      r0,#0x800
        0x08001400:    f7fffa22    ..".    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;588    
;;;589      /* TIM1 interrupt Init */
;;;590      NVIC_SetPriority(TIM1_UP_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
        0x08001404:    f000fab2    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x08001408:    4605        .F      MOV      r5,r0
        0x0800140a:    2200        ."      MOVS     r2,#0
        0x0800140c:    210f        .!      MOVS     r1,#0xf
        0x0800140e:    f000fa8c    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x08001412:    4604        .F      MOV      r4,r0
        0x08001414:    4621        !F      MOV      r1,r4
        0x08001416:    2019        .       MOVS     r0,#0x19
        0x08001418:    f000fab0    ....    BL       NVIC_SetPriority ; 0x800197c
;;;591      NVIC_EnableIRQ(TIM1_UP_IRQn);
        0x0800141c:    2019        .       MOVS     r0,#0x19
        0x0800141e:    f000fa79    ..y.    BL       NVIC_EnableIRQ ; 0x8001914
;;;592    
;;;593      /* USER CODE BEGIN TIM1_Init 1 */
;;;594    
;;;595      /* USER CODE END TIM1_Init 1 */
;;;596      TIM_InitStruct.Prescaler = 720;
        0x08001422:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x08001426:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;597      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x0800142a:    2000        .       MOVS     r0,#0
        0x0800142c:    900f        ..      STR      r0,[sp,#0x3c]
;;;598      TIM_InitStruct.Autoreload = 0;
        0x0800142e:    9010        ..      STR      r0,[sp,#0x40]
;;;599      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08001430:    9011        ..      STR      r0,[sp,#0x44]
;;;600      TIM_InitStruct.RepetitionCounter = 0;
        0x08001432:    f88d0048    ..H.    STRB     r0,[sp,#0x48]
;;;601      LL_TIM_Init(TIM1, &TIM_InitStruct);
        0x08001436:    a90e        ..      ADD      r1,sp,#0x38
        0x08001438:    481d        .H      LDR      r0,[pc,#116] ; [0x80014b0] = 0x40012c00
        0x0800143a:    f7fffcfb    ....    BL       LL_TIM_Init ; 0x8000e34
;;;602      LL_TIM_DisableARRPreload(TIM1);
        0x0800143e:    481c        .H      LDR      r0,[pc,#112] ; [0x80014b0] = 0x40012c00
        0x08001440:    f7fffc0b    ....    BL       LL_TIM_DisableARRPreload ; 0x8000c5a
;;;603      LL_TIM_SetClockSource(TIM1, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x08001444:    2100        .!      MOVS     r1,#0
        0x08001446:    481a        .H      LDR      r0,[pc,#104] ; [0x80014b0] = 0x40012c00
        0x08001448:    f7fffdcc    ....    BL       LL_TIM_SetClockSource ; 0x8000fe4
;;;604      LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1);
        0x0800144c:    2101        .!      MOVS     r1,#1
        0x0800144e:    4818        .H      LDR      r0,[pc,#96] ; [0x80014b0] = 0x40012c00
        0x08001450:    f7fffd68    ..h.    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;605      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
        0x08001454:    2060        `       MOVS     r0,#0x60
        0x08001456:    9006        ..      STR      r0,[sp,#0x18]
;;;606      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001458:    2000        .       MOVS     r0,#0
        0x0800145a:    9007        ..      STR      r0,[sp,#0x1c]
;;;607      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800145c:    9008        ..      STR      r0,[sp,#0x20]
;;;608      TIM_OC_InitStruct.CompareValue = 0;
        0x0800145e:    9009        ..      STR      r0,[sp,#0x24]
;;;609      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001460:    900a        ..      STR      r0,[sp,#0x28]
;;;610      TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001462:    900b        ..      STR      r0,[sp,#0x2c]
;;;611      TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x08001464:    900c        ..      STR      r0,[sp,#0x30]
;;;612      TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x08001466:    900d        ..      STR      r0,[sp,#0x34]
;;;613      LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08001468:    aa06        ..      ADD      r2,sp,#0x18
        0x0800146a:    2101        .!      MOVS     r1,#1
        0x0800146c:    4810        .H      LDR      r0,[pc,#64] ; [0x80014b0] = 0x40012c00
        0x0800146e:    f7fffd89    ....    BL       LL_TIM_OC_Init ; 0x8000f84
;;;614      LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1);
        0x08001472:    2101        .!      MOVS     r1,#1
        0x08001474:    480e        .H      LDR      r0,[pc,#56] ; [0x80014b0] = 0x40012c00
        0x08001476:    f7fffd25    ..%.    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;615      LL_TIM_SetTriggerOutput(TIM1, LL_TIM_TRGO_RESET);
        0x0800147a:    2100        .!      MOVS     r1,#0
        0x0800147c:    480c        .H      LDR      r0,[pc,#48] ; [0x80014b0] = 0x40012c00
        0x0800147e:    f7fffdb8    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;616      LL_TIM_DisableMasterSlaveMode(TIM1);
        0x08001482:    480b        .H      LDR      r0,[pc,#44] ; [0x80014b0] = 0x40012c00
        0x08001484:    f7fffbee    ....    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000c64
;;;617      TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;
        0x08001488:    2000        .       MOVS     r0,#0
        0x0800148a:    9000        ..      STR      r0,[sp,#0]
;;;618      TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;
        0x0800148c:    9001        ..      STR      r0,[sp,#4]
;;;619      TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
        0x0800148e:    9002        ..      STR      r0,[sp,#8]
;;;620      TIM_BDTRInitStruct.DeadTime = 0;
        0x08001490:    f88d000c    ....    STRB     r0,[sp,#0xc]
;;;621      TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
        0x08001494:    f8ad000e    ....    STRH     r0,[sp,#0xe]
;;;622      TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
        0x08001498:    f44f5000    O..P    MOV      r0,#0x2000
        0x0800149c:    9004        ..      STR      r0,[sp,#0x10]
;;;623      TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
        0x0800149e:    2000        .       MOVS     r0,#0
        0x080014a0:    9005        ..      STR      r0,[sp,#0x14]
;;;624      LL_TIM_BDTR_Init(TIM1, &TIM_BDTRInitStruct);
        0x080014a2:    4669        iF      MOV      r1,sp
        0x080014a4:    4802        .H      LDR      r0,[pc,#8] ; [0x80014b0] = 0x40012c00
        0x080014a6:    f7fffba7    ....    BL       LL_TIM_BDTR_Init ; 0x8000bf8
;;;625      /* USER CODE BEGIN TIM1_Init 2 */
;;;626    
;;;627      /* USER CODE END TIM1_Init 2 */
;;;628    
;;;629    }
        0x080014aa:    b013        ..      ADD      sp,sp,#0x4c
        0x080014ac:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080014ae:    0000        ..      DCW    0
        0x080014b0:    40012c00    .,.@    DCD    1073818624
    $t
    i.MX_TIM2_Init
    MX_TIM2_Init
;;;630    
;;;631    /**
;;;632      * @brief TIM2 Initialization Function
;;;633      * @param None
;;;634      * @retval None
;;;635      */
;;;636    static void MX_TIM2_Init(void)
;;;637    {
        0x080014b4:    b530        0.      PUSH     {r4,r5,lr}
        0x080014b6:    b08d        ..      SUB      sp,sp,#0x34
;;;638    
;;;639      /* USER CODE BEGIN TIM2_Init 0 */
;;;640    
;;;641      /* USER CODE END TIM2_Init 0 */
;;;642    
;;;643      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x080014b8:    2114        .!      MOVS     r1,#0x14
        0x080014ba:    a808        ..      ADD      r0,sp,#0x20
        0x080014bc:    f7fefe6a    ..j.    BL       __aeabi_memclr ; 0x8000194
;;;644      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x080014c0:    2120         !      MOVS     r1,#0x20
        0x080014c2:    4668        hF      MOV      r0,sp
        0x080014c4:    f7fefe66    ..f.    BL       __aeabi_memclr ; 0x8000194
;;;645    
;;;646      /* Peripheral clock enable */
;;;647      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM2);
        0x080014c8:    2001        .       MOVS     r0,#1
        0x080014ca:    f7fff9af    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;648    
;;;649      /* TIM2 interrupt Init */
;;;650      NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),1, 0));
        0x080014ce:    f000fa4d    ..M.    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x080014d2:    4605        .F      MOV      r5,r0
        0x080014d4:    2200        ."      MOVS     r2,#0
        0x080014d6:    2101        .!      MOVS     r1,#1
        0x080014d8:    f000fa27    ..'.    BL       NVIC_EncodePriority ; 0x800192a
        0x080014dc:    4604        .F      MOV      r4,r0
        0x080014de:    4621        !F      MOV      r1,r4
        0x080014e0:    201c        .       MOVS     r0,#0x1c
        0x080014e2:    f000fa4b    ..K.    BL       NVIC_SetPriority ; 0x800197c
;;;651      NVIC_EnableIRQ(TIM2_IRQn);
        0x080014e6:    201c        .       MOVS     r0,#0x1c
        0x080014e8:    f000fa14    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;652    
;;;653      /* USER CODE BEGIN TIM2_Init 1 */
;;;654    
;;;655      /* USER CODE END TIM2_Init 1 */
;;;656      TIM_InitStruct.Prescaler = 720;
        0x080014ec:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x080014f0:    f8ad0020    .. .    STRH     r0,[sp,#0x20]
;;;657      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x080014f4:    2000        .       MOVS     r0,#0
        0x080014f6:    9009        ..      STR      r0,[sp,#0x24]
;;;658      TIM_InitStruct.Autoreload = 50;
        0x080014f8:    2032        2       MOVS     r0,#0x32
        0x080014fa:    900a        ..      STR      r0,[sp,#0x28]
;;;659      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x080014fc:    2000        .       MOVS     r0,#0
        0x080014fe:    900b        ..      STR      r0,[sp,#0x2c]
;;;660      LL_TIM_Init(TIM2, &TIM_InitStruct);
        0x08001500:    a908        ..      ADD      r1,sp,#0x20
        0x08001502:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001506:    f7fffc95    ....    BL       LL_TIM_Init ; 0x8000e34
;;;661      LL_TIM_EnableARRPreload(TIM2);
        0x0800150a:    f04f4080    O..@    MOV      r0,#0x40000000
        0x0800150e:    f7fffbae    ....    BL       LL_TIM_EnableARRPreload ; 0x8000c6e
;;;662      LL_TIM_SetClockSource(TIM2, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x08001512:    2100        .!      MOVS     r1,#0
        0x08001514:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001518:    f7fffd64    ..d.    BL       LL_TIM_SetClockSource ; 0x8000fe4
;;;663      LL_TIM_OC_EnablePreload(TIM2, LL_TIM_CHANNEL_CH1);
        0x0800151c:    2101        .!      MOVS     r1,#1
        0x0800151e:    0788        ..      LSLS     r0,r1,#30
        0x08001520:    f7fffd00    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;664      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x08001524:    2070        p       MOVS     r0,#0x70
        0x08001526:    9000        ..      STR      r0,[sp,#0]
;;;665      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001528:    2000        .       MOVS     r0,#0
        0x0800152a:    9001        ..      STR      r0,[sp,#4]
;;;666      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800152c:    9002        ..      STR      r0,[sp,#8]
;;;667      TIM_OC_InitStruct.CompareValue = 48;
        0x0800152e:    2030        0       MOVS     r0,#0x30
        0x08001530:    9003        ..      STR      r0,[sp,#0xc]
;;;668      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001532:    2000        .       MOVS     r0,#0
        0x08001534:    9004        ..      STR      r0,[sp,#0x10]
;;;669      LL_TIM_OC_Init(TIM2, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08001536:    466a        jF      MOV      r2,sp
        0x08001538:    2101        .!      MOVS     r1,#1
        0x0800153a:    0788        ..      LSLS     r0,r1,#30
        0x0800153c:    f7fffd22    ..".    BL       LL_TIM_OC_Init ; 0x8000f84
;;;670      LL_TIM_OC_DisableFast(TIM2, LL_TIM_CHANNEL_CH1);
        0x08001540:    2101        .!      MOVS     r1,#1
        0x08001542:    0788        ..      LSLS     r0,r1,#30
        0x08001544:    f7fffcbe    ....    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;671      LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
        0x08001548:    2120         !      MOVS     r1,#0x20
        0x0800154a:    0648        H.      LSLS     r0,r1,#25
        0x0800154c:    f7fffd51    ..Q.    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;672      LL_TIM_EnableMasterSlaveMode(TIM2);
        0x08001550:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001554:    f7fffb95    ....    BL       LL_TIM_EnableMasterSlaveMode ; 0x8000c82
;;;673      /* USER CODE BEGIN TIM2_Init 2 */
;;;674    
;;;675      /* USER CODE END TIM2_Init 2 */
;;;676    
;;;677    }
        0x08001558:    b00d        ..      ADD      sp,sp,#0x34
        0x0800155a:    bd30        0.      POP      {r4,r5,pc}
    i.MX_TIM3_Init
    MX_TIM3_Init
;;;678    
;;;679    /**
;;;680      * @brief TIM3 Initialization Function
;;;681      * @param None
;;;682      * @retval None
;;;683      */
;;;684    static void MX_TIM3_Init(void)
;;;685    {
        0x0800155c:    b530        0.      PUSH     {r4,r5,lr}
        0x0800155e:    b093        ..      SUB      sp,sp,#0x4c
;;;686    
;;;687      /* USER CODE BEGIN TIM3_Init 0 */
;;;688    
;;;689      /* USER CODE END TIM3_Init 0 */
;;;690    
;;;691      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x08001560:    2114        .!      MOVS     r1,#0x14
        0x08001562:    a80e        ..      ADD      r0,sp,#0x38
        0x08001564:    f7fefe16    ....    BL       __aeabi_memclr ; 0x8000194
;;;692      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x08001568:    2120         !      MOVS     r1,#0x20
        0x0800156a:    a806        ..      ADD      r0,sp,#0x18
        0x0800156c:    f7fefe12    ....    BL       __aeabi_memclr ; 0x8000194
;;;693    
;;;694      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x08001570:    2114        .!      MOVS     r1,#0x14
        0x08001572:    a801        ..      ADD      r0,sp,#4
        0x08001574:    f7fefe0e    ....    BL       __aeabi_memclr ; 0x8000194
;;;695    
;;;696      /* Peripheral clock enable */
;;;697      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM3);
        0x08001578:    2002        .       MOVS     r0,#2
        0x0800157a:    f7fff957    ..W.    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;698    
;;;699      /* TIM3 interrupt Init */
;;;700      NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x0800157e:    f000f9f5    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x08001582:    4605        .F      MOV      r5,r0
        0x08001584:    2200        ."      MOVS     r2,#0
        0x08001586:    4611        .F      MOV      r1,r2
        0x08001588:    f000f9cf    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x0800158c:    4604        .F      MOV      r4,r0
        0x0800158e:    4621        !F      MOV      r1,r4
        0x08001590:    201d        .       MOVS     r0,#0x1d
        0x08001592:    f000f9f3    ....    BL       NVIC_SetPriority ; 0x800197c
;;;701      NVIC_EnableIRQ(TIM3_IRQn);
        0x08001596:    201d        .       MOVS     r0,#0x1d
        0x08001598:    f000f9bc    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;702    
;;;703      /* USER CODE BEGIN TIM3_Init 1 */
;;;704      NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),1, 0));
        0x0800159c:    f000f9e6    ....    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x080015a0:    4605        .F      MOV      r5,r0
        0x080015a2:    2200        ."      MOVS     r2,#0
        0x080015a4:    2101        .!      MOVS     r1,#1
        0x080015a6:    f000f9c0    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x080015aa:    4604        .F      MOV      r4,r0
        0x080015ac:    4621        !F      MOV      r1,r4
        0x080015ae:    201d        .       MOVS     r0,#0x1d
        0x080015b0:    f000f9e4    ....    BL       NVIC_SetPriority ; 0x800197c
;;;705      NVIC_EnableIRQ(TIM3_IRQn);
        0x080015b4:    201d        .       MOVS     r0,#0x1d
        0x080015b6:    f000f9ad    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;706    
;;;707      /* USER CODE END TIM3_Init 1 */
;;;708      TIM_InitStruct.Prescaler = 0;
        0x080015ba:    2000        .       MOVS     r0,#0
        0x080015bc:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;709      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x080015c0:    900f        ..      STR      r0,[sp,#0x3c]
;;;710      TIM_InitStruct.Autoreload = min_pulse;
        0x080015c2:    f24020d5    @..     MOV      r0,#0x2d5
        0x080015c6:    9010        ..      STR      r0,[sp,#0x40]
;;;711      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x080015c8:    2000        .       MOVS     r0,#0
        0x080015ca:    9011        ..      STR      r0,[sp,#0x44]
;;;712      LL_TIM_Init(TIM3, &TIM_InitStruct);
        0x080015cc:    a90e        ..      ADD      r1,sp,#0x38
        0x080015ce:    4842        BH      LDR      r0,[pc,#264] ; [0x80016d8] = 0x40000400
        0x080015d0:    f7fffc30    ..0.    BL       LL_TIM_Init ; 0x8000e34
;;;713      LL_TIM_EnableARRPreload(TIM3);
        0x080015d4:    4840        @H      LDR      r0,[pc,#256] ; [0x80016d8] = 0x40000400
        0x080015d6:    f7fffb4a    ..J.    BL       LL_TIM_EnableARRPreload ; 0x8000c6e
;;;714      LL_TIM_SetClockSource(TIM3, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x080015da:    2100        .!      MOVS     r1,#0
        0x080015dc:    483e        >H      LDR      r0,[pc,#248] ; [0x80016d8] = 0x40000400
        0x080015de:    f7fffd01    ....    BL       LL_TIM_SetClockSource ; 0x8000fe4
;;;715      LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH1);
        0x080015e2:    2101        .!      MOVS     r1,#1
        0x080015e4:    483c        <H      LDR      r0,[pc,#240] ; [0x80016d8] = 0x40000400
        0x080015e6:    f7fffc9d    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;716      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x080015ea:    2070        p       MOVS     r0,#0x70
        0x080015ec:    9006        ..      STR      r0,[sp,#0x18]
;;;717      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x080015ee:    2000        .       MOVS     r0,#0
        0x080015f0:    9007        ..      STR      r0,[sp,#0x1c]
;;;718      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x080015f2:    9008        ..      STR      r0,[sp,#0x20]
;;;719      TIM_OC_InitStruct.CompareValue = 1;
        0x080015f4:    2001        .       MOVS     r0,#1
        0x080015f6:    9009        ..      STR      r0,[sp,#0x24]
;;;720      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x080015f8:    2000        .       MOVS     r0,#0
        0x080015fa:    900a        ..      STR      r0,[sp,#0x28]
;;;721      LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x080015fc:    aa06        ..      ADD      r2,sp,#0x18
        0x080015fe:    2101        .!      MOVS     r1,#1
        0x08001600:    4835        5H      LDR      r0,[pc,#212] ; [0x80016d8] = 0x40000400
        0x08001602:    f7fffcbf    ....    BL       LL_TIM_OC_Init ; 0x8000f84
;;;722      LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH1);
        0x08001606:    2101        .!      MOVS     r1,#1
        0x08001608:    4833        3H      LDR      r0,[pc,#204] ; [0x80016d8] = 0x40000400
        0x0800160a:    f7fffc5b    ..[.    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;723      LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH3);
        0x0800160e:    f44f7180    O..q    MOV      r1,#0x100
        0x08001612:    4831        1H      LDR      r0,[pc,#196] ; [0x80016d8] = 0x40000400
        0x08001614:    f7fffc86    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;724      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001618:    2000        .       MOVS     r0,#0
        0x0800161a:    9007        ..      STR      r0,[sp,#0x1c]
;;;725      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800161c:    9008        ..      STR      r0,[sp,#0x20]
;;;726      LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
        0x0800161e:    aa06        ..      ADD      r2,sp,#0x18
        0x08001620:    f44f7180    O..q    MOV      r1,#0x100
        0x08001624:    482c        ,H      LDR      r0,[pc,#176] ; [0x80016d8] = 0x40000400
        0x08001626:    f7fffcad    ....    BL       LL_TIM_OC_Init ; 0x8000f84
;;;727      LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH3);
        0x0800162a:    f44f7180    O..q    MOV      r1,#0x100
        0x0800162e:    482a        *H      LDR      r0,[pc,#168] ; [0x80016d8] = 0x40000400
        0x08001630:    f7fffc48    ..H.    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;728      LL_TIM_SetOnePulseMode(TIM3, LL_TIM_ONEPULSEMODE_SINGLE);
        0x08001634:    2008        .       MOVS     r0,#8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1130     MODIFY_REG(TIMx->CR1, TIM_CR1_OPM, OnePulseMode);
        0x08001636:    4928        (I      LDR      r1,[pc,#160] ; [0x80016d8] = 0x40000400
        0x08001638:    6809        .h      LDR      r1,[r1,#0]
        0x0800163a:    f0210108    !...    BIC      r1,r1,#8
        0x0800163e:    4301        .C      ORRS     r1,r1,r0
        0x08001640:    4a25        %J      LDR      r2,[pc,#148] ; [0x80016d8] = 0x40000400
        0x08001642:    6011        .`      STR      r1,[r2,#0]
;;;1131   }
        0x08001644:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;729      LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1);
        0x08001646:    2010        .       MOVS     r0,#0x10
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x08001648:    4611        .F      MOV      r1,r2
        0x0800164a:    6889        .h      LDR      r1,[r1,#8]
        0x0800164c:    f0210170    !.p.    BIC      r1,r1,#0x70
        0x08001650:    4301        .C      ORRS     r1,r1,r0
        0x08001652:    6091        .`      STR      r1,[r2,#8]
;;;2619   }
        0x08001654:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;730      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
        0x08001656:    2006        .       MOVS     r0,#6
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
        0x08001658:    4611        .F      MOV      r1,r2
        0x0800165a:    6889        .h      LDR      r1,[r1,#8]
        0x0800165c:    f0210107    !...    BIC      r1,r1,#7
        0x08001660:    4301        .C      ORRS     r1,r1,r0
        0x08001662:    6091        .`      STR      r1,[r2,#8]
;;;2597   }
        0x08001664:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;731      LL_TIM_DisableIT_TRIG(TIM3);
        0x08001666:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3412     CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
        0x08001668:    4610        .F      MOV      r0,r2
        0x0800166a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800166c:    f0200040     .@.    BIC      r0,r0,#0x40
        0x08001670:    4611        .F      MOV      r1,r2
        0x08001672:    60c8        .`      STR      r0,[r1,#0xc]
;;;3413   }
        0x08001674:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;732      LL_TIM_DisableDMAReq_TRIG(TIM3);
        0x08001676:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3683     CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
        0x08001678:    4608        .F      MOV      r0,r1
        0x0800167a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800167c:    f4204080     ..@    BIC      r0,r0,#0x4000
        0x08001680:    60c8        .`      STR      r0,[r1,#0xc]
;;;3684   }
        0x08001682:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;733      LL_TIM_SetTriggerOutput(TIM3, LL_TIM_TRGO_RESET);
        0x08001684:    2100        .!      MOVS     r1,#0
        0x08001686:    4610        .F      MOV      r0,r2
        0x08001688:    f7fffcb3    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;734      LL_TIM_DisableMasterSlaveMode(TIM3);
        0x0800168c:    4812        .H      LDR      r0,[pc,#72] ; [0x80016d8] = 0x40000400
        0x0800168e:    f7fffae9    ....    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000c64
;;;735      /* USER CODE BEGIN TIM3_Init 2 */
;;;736    
;;;737      /* USER CODE END TIM3_Init 2 */
;;;738      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08001692:    2004        .       MOVS     r0,#4
        0x08001694:    f7fff8d8    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;739      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x08001698:    2008        .       MOVS     r0,#8
        0x0800169a:    f7fff8d5    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;740      /**TIM3 GPIO Configuration  
;;;741      PA6   ------> TIM3_CH1
;;;742      PB0   ------> TIM3_CH3 
;;;743      */
;;;744      GPIO_InitStruct.Pin = MOTOR_X_STEP_Pin;
        0x0800169e:    f2440040    D.@.    MOV      r0,#0x4040
        0x080016a2:    9001        ..      STR      r0,[sp,#4]
;;;745      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080016a4:    2009        .       MOVS     r0,#9
        0x080016a6:    9002        ..      STR      r0,[sp,#8]
;;;746      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080016a8:    2003        .       MOVS     r0,#3
        0x080016aa:    9003        ..      STR      r0,[sp,#0xc]
;;;747      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080016ac:    2000        .       MOVS     r0,#0
        0x080016ae:    9004        ..      STR      r0,[sp,#0x10]
;;;748      LL_GPIO_Init(MOTOR_X_STEP_GPIO_Port, &GPIO_InitStruct);
        0x080016b0:    a901        ..      ADD      r1,sp,#4
        0x080016b2:    480a        .H      LDR      r0,[pc,#40] ; [0x80016dc] = 0x40010800
        0x080016b4:    f7fff946    ..F.    BL       LL_GPIO_Init ; 0x8000944
;;;749    
;;;750      GPIO_InitStruct.Pin = MOTOR_Z_STEP_Pin;
        0x080016b8:    f2401001    @...    MOV      r0,#0x101
        0x080016bc:    9001        ..      STR      r0,[sp,#4]
;;;751      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080016be:    2009        .       MOVS     r0,#9
        0x080016c0:    9002        ..      STR      r0,[sp,#8]
;;;752      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080016c2:    2003        .       MOVS     r0,#3
        0x080016c4:    9003        ..      STR      r0,[sp,#0xc]
;;;753      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080016c6:    2000        .       MOVS     r0,#0
        0x080016c8:    9004        ..      STR      r0,[sp,#0x10]
;;;754      LL_GPIO_Init(MOTOR_Z_STEP_GPIO_Port, &GPIO_InitStruct);
        0x080016ca:    a901        ..      ADD      r1,sp,#4
        0x080016cc:    4804        .H      LDR      r0,[pc,#16] ; [0x80016e0] = 0x40010c00
        0x080016ce:    f7fff939    ..9.    BL       LL_GPIO_Init ; 0x8000944
;;;755    
;;;756    }
        0x080016d2:    b013        ..      ADD      sp,sp,#0x4c
        0x080016d4:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080016d6:    0000        ..      DCW    0
        0x080016d8:    40000400    ...@    DCD    1073742848
        0x080016dc:    40010800    ...@    DCD    1073809408
        0x080016e0:    40010c00    ...@    DCD    1073810432
    $t
    i.MX_TIM4_Init
    MX_TIM4_Init
;;;757    
;;;758    /**
;;;759      * @brief TIM4 Initialization Function
;;;760      * @param None
;;;761      * @retval None
;;;762      */
;;;763    static void MX_TIM4_Init(void)
;;;764    {
        0x080016e4:    b530        0.      PUSH     {r4,r5,lr}
        0x080016e6:    b08b        ..      SUB      sp,sp,#0x2c
;;;765    
;;;766      /* USER CODE BEGIN TIM4_Init 0 */
;;;767    
;;;768      /* USER CODE END TIM4_Init 0 */
;;;769    
;;;770      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x080016e8:    2114        .!      MOVS     r1,#0x14
        0x080016ea:    a806        ..      ADD      r0,sp,#0x18
        0x080016ec:    f7fefd52    ..R.    BL       __aeabi_memclr ; 0x8000194
;;;771    
;;;772      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080016f0:    2114        .!      MOVS     r1,#0x14
        0x080016f2:    a801        ..      ADD      r0,sp,#4
        0x080016f4:    f7fefd4e    ..N.    BL       __aeabi_memclr ; 0x8000194
;;;773    
;;;774      /* Peripheral clock enable */
;;;775      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM4);
        0x080016f8:    2004        .       MOVS     r0,#4
        0x080016fa:    f7fff897    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;776      
;;;777      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080016fe:    2008        .       MOVS     r0,#8
        0x08001700:    f7fff8a2    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;778      /**TIM4 GPIO Configuration  
;;;779      PB6   ------> TIM4_CH1
;;;780      PB7   ------> TIM4_CH2
;;;781      PB8   ------> TIM4_CH3 
;;;782      */
;;;783      GPIO_InitStruct.Pin = ENC_A_Pin|ENC_B_Pin|ENC_ZERO_Pin;
        0x08001704:    483e        >H      LDR      r0,[pc,#248] ; [0x8001800] = 0x401c0c1
        0x08001706:    9001        ..      STR      r0,[sp,#4]
;;;784      GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x08001708:    2008        .       MOVS     r0,#8
        0x0800170a:    9002        ..      STR      r0,[sp,#8]
;;;785      GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x0800170c:    2001        .       MOVS     r0,#1
        0x0800170e:    9005        ..      STR      r0,[sp,#0x14]
;;;786      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08001710:    a901        ..      ADD      r1,sp,#4
        0x08001712:    483c        <H      LDR      r0,[pc,#240] ; [0x8001804] = 0x40010c00
        0x08001714:    f7fff916    ....    BL       LL_GPIO_Init ; 0x8000944
;;;787    
;;;788      /* TIM4 interrupt Init */
;;;789      NVIC_SetPriority(TIM4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08001718:    f000f928    ..(.    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x0800171c:    4605        .F      MOV      r5,r0
        0x0800171e:    2200        ."      MOVS     r2,#0
        0x08001720:    4611        .F      MOV      r1,r2
        0x08001722:    f000f902    ....    BL       NVIC_EncodePriority ; 0x800192a
        0x08001726:    4604        .F      MOV      r4,r0
        0x08001728:    4621        !F      MOV      r1,r4
        0x0800172a:    201e        .       MOVS     r0,#0x1e
        0x0800172c:    f000f926    ..&.    BL       NVIC_SetPriority ; 0x800197c
;;;790      NVIC_EnableIRQ(TIM4_IRQn);
        0x08001730:    201e        .       MOVS     r0,#0x1e
        0x08001732:    f000f8ef    ....    BL       NVIC_EnableIRQ ; 0x8001914
;;;791    
;;;792      /* USER CODE BEGIN TIM4_Init 1 */
;;;793    
;;;794      /* USER CODE END TIM4_Init 1 */
;;;795      TIM_InitStruct.Prescaler = 0;
        0x08001736:    2000        .       MOVS     r0,#0
        0x08001738:    f8ad0018    ....    STRH     r0,[sp,#0x18]
;;;796      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x0800173c:    9007        ..      STR      r0,[sp,#0x1c]
;;;797      TIM_InitStruct.Autoreload = 8;
        0x0800173e:    2008        .       MOVS     r0,#8
        0x08001740:    9008        ..      STR      r0,[sp,#0x20]
;;;798      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08001742:    2000        .       MOVS     r0,#0
        0x08001744:    9009        ..      STR      r0,[sp,#0x24]
;;;799      LL_TIM_Init(TIM4, &TIM_InitStruct);
        0x08001746:    a906        ..      ADD      r1,sp,#0x18
        0x08001748:    482f        /H      LDR      r0,[pc,#188] ; [0x8001808] = 0x40000800
        0x0800174a:    f7fffb73    ..s.    BL       LL_TIM_Init ; 0x8000e34
;;;800      LL_TIM_DisableARRPreload(TIM4);
        0x0800174e:    482e        .H      LDR      r0,[pc,#184] ; [0x8001808] = 0x40000800
        0x08001750:    f7fffa83    ....    BL       LL_TIM_DisableARRPreload ; 0x8000c5a
;;;801      LL_TIM_SetEncoderMode(TIM4, LL_TIM_ENCODERMODE_X2_TI1);
        0x08001754:    2001        .       MOVS     r0,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
        0x08001756:    492c        ,I      LDR      r1,[pc,#176] ; [0x8001808] = 0x40000800
        0x08001758:    6889        .h      LDR      r1,[r1,#8]
        0x0800175a:    f0210107    !...    BIC      r1,r1,#7
        0x0800175e:    4301        .C      ORRS     r1,r1,r0
        0x08001760:    4a29        )J      LDR      r2,[pc,#164] ; [0x8001808] = 0x40000800
        0x08001762:    6091        .`      STR      r1,[r2,#8]
;;;2550   }
        0x08001764:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;802      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08001766:    0402        ..      LSLS     r2,r0,#16
        0x08001768:    2101        .!      MOVS     r1,#1
        0x0800176a:    4827        'H      LDR      r0,[pc,#156] ; [0x8001808] = 0x40000800
        0x0800176c:    f7fffa94    ....    BL       LL_TIM_IC_SetActiveInput ; 0x8000c98
;;;803      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ICPSC_DIV1);
        0x08001770:    2200        ."      MOVS     r2,#0
        0x08001772:    2101        .!      MOVS     r1,#1
        0x08001774:    4824        $H      LDR      r0,[pc,#144] ; [0x8001808] = 0x40000800
        0x08001776:    f7fffb27    ..'.    BL       LL_TIM_IC_SetPrescaler ; 0x8000dc8
;;;804      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_FILTER_FDIV32_N8);
        0x0800177a:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x0800177e:    2101        .!      MOVS     r1,#1
        0x08001780:    4821        !H      LDR      r0,[pc,#132] ; [0x8001808] = 0x40000800
        0x08001782:    f7fffabf    ....    BL       LL_TIM_IC_SetFilter ; 0x8000d04
;;;805      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_POLARITY_RISING);
        0x08001786:    2200        ."      MOVS     r2,#0
        0x08001788:    2101        .!      MOVS     r1,#1
        0x0800178a:    481f        .H      LDR      r0,[pc,#124] ; [0x8001808] = 0x40000800
        0x0800178c:    f7fffaf0    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000d70
;;;806      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08001790:    f44f3280    O..2    MOV      r2,#0x10000
        0x08001794:    2110        .!      MOVS     r1,#0x10
        0x08001796:    481c        .H      LDR      r0,[pc,#112] ; [0x8001808] = 0x40000800
        0x08001798:    f7fffa7e    ..~.    BL       LL_TIM_IC_SetActiveInput ; 0x8000c98
;;;807      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ICPSC_DIV1);
        0x0800179c:    2200        ."      MOVS     r2,#0
        0x0800179e:    2110        .!      MOVS     r1,#0x10
        0x080017a0:    4819        .H      LDR      r0,[pc,#100] ; [0x8001808] = 0x40000800
        0x080017a2:    f7fffb11    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000dc8
;;;808      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_FILTER_FDIV32_N8);
        0x080017a6:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x080017aa:    2110        .!      MOVS     r1,#0x10
        0x080017ac:    4816        .H      LDR      r0,[pc,#88] ; [0x8001808] = 0x40000800
        0x080017ae:    f7fffaa9    ....    BL       LL_TIM_IC_SetFilter ; 0x8000d04
;;;809      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_POLARITY_RISING);
        0x080017b2:    2200        ."      MOVS     r2,#0
        0x080017b4:    2110        .!      MOVS     r1,#0x10
        0x080017b6:    4814        .H      LDR      r0,[pc,#80] ; [0x8001808] = 0x40000800
        0x080017b8:    f7fffada    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000d70
;;;810      LL_TIM_SetTriggerOutput(TIM4, LL_TIM_TRGO_UPDATE);
        0x080017bc:    2120         !      MOVS     r1,#0x20
        0x080017be:    4812        .H      LDR      r0,[pc,#72] ; [0x8001808] = 0x40000800
        0x080017c0:    f7fffc17    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;811      LL_TIM_EnableMasterSlaveMode(TIM4);
        0x080017c4:    4810        .H      LDR      r0,[pc,#64] ; [0x8001808] = 0x40000800
        0x080017c6:    f7fffa5c    ..\.    BL       LL_TIM_EnableMasterSlaveMode ; 0x8000c82
;;;812      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x080017ca:    f44f3280    O..2    MOV      r2,#0x10000
        0x080017ce:    1211        ..      ASRS     r1,r2,#8
        0x080017d0:    480d        .H      LDR      r0,[pc,#52] ; [0x8001808] = 0x40000800
        0x080017d2:    f7fffa61    ..a.    BL       LL_TIM_IC_SetActiveInput ; 0x8000c98
;;;813      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ICPSC_DIV1);
        0x080017d6:    2200        ."      MOVS     r2,#0
        0x080017d8:    f44f7180    O..q    MOV      r1,#0x100
        0x080017dc:    480a        .H      LDR      r0,[pc,#40] ; [0x8001808] = 0x40000800
        0x080017de:    f7fffaf3    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000dc8
;;;814      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_FILTER_FDIV32_N8);
        0x080017e2:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x080017e6:    f44f7180    O..q    MOV      r1,#0x100
        0x080017ea:    4807        .H      LDR      r0,[pc,#28] ; [0x8001808] = 0x40000800
        0x080017ec:    f7fffa8a    ....    BL       LL_TIM_IC_SetFilter ; 0x8000d04
;;;815      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_POLARITY_RISING);
        0x080017f0:    2200        ."      MOVS     r2,#0
        0x080017f2:    f44f7180    O..q    MOV      r1,#0x100
        0x080017f6:    4804        .H      LDR      r0,[pc,#16] ; [0x8001808] = 0x40000800
        0x080017f8:    f7fffaba    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000d70
;;;816      /* USER CODE BEGIN TIM4_Init 2 */
;;;817    
;;;818      /* USER CODE END TIM4_Init 2 */
;;;819    
;;;820    }
        0x080017fc:    b00b        ..      ADD      sp,sp,#0x2c
        0x080017fe:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001800:    0401c0c1    ....    DCD    67223745
        0x08001804:    40010c00    ...@    DCD    1073810432
        0x08001808:    40000800    ...@    DCD    1073743872
    $t
    i.MX_USART2_UART_Init
    MX_USART2_UART_Init
;;;821    
;;;822    /**
;;;823      * @brief USART2 Initialization Function
;;;824      * @param None
;;;825      * @retval None
;;;826      */
;;;827    static void MX_USART2_UART_Init(void)
;;;828    {
        0x0800180c:    b530        0.      PUSH     {r4,r5,lr}
        0x0800180e:    b08b        ..      SUB      sp,sp,#0x2c
;;;829    
;;;830      /* USER CODE BEGIN USART2_Init 0 */
;;;831    
;;;832      /* USER CODE END USART2_Init 0 */
;;;833    
;;;834      LL_USART_InitTypeDef USART_InitStruct = {0};
        0x08001810:    2118        .!      MOVS     r1,#0x18
        0x08001812:    a805        ..      ADD      r0,sp,#0x14
        0x08001814:    f7fefcbe    ....    BL       __aeabi_memclr ; 0x8000194
;;;835    
;;;836      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x08001818:    2114        .!      MOVS     r1,#0x14
        0x0800181a:    4668        hF      MOV      r0,sp
        0x0800181c:    f7fefcba    ....    BL       __aeabi_memclr ; 0x8000194
;;;837    
;;;838      /* Peripheral clock enable */
;;;839      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);
        0x08001820:    f44f3000    O..0    MOV      r0,#0x20000
        0x08001824:    f7fff802    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;840      
;;;841      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08001828:    2004        .       MOVS     r0,#4
        0x0800182a:    f7fff80d    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;842      /**USART2 GPIO Configuration  
;;;843      PA2   ------> USART2_TX
;;;844      PA3   ------> USART2_RX 
;;;845      */
;;;846      GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
        0x0800182e:    f2404004    @..@    MOV      r0,#0x404
        0x08001832:    9000        ..      STR      r0,[sp,#0]
;;;847      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x08001834:    2009        .       MOVS     r0,#9
        0x08001836:    9001        ..      STR      r0,[sp,#4]
;;;848      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x08001838:    2003        .       MOVS     r0,#3
        0x0800183a:    9002        ..      STR      r0,[sp,#8]
;;;849      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x0800183c:    2000        .       MOVS     r0,#0
        0x0800183e:    9003        ..      STR      r0,[sp,#0xc]
;;;850      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001840:    4669        iF      MOV      r1,sp
        0x08001842:    4831        1H      LDR      r0,[pc,#196] ; [0x8001908] = 0x40010800
        0x08001844:    f7fff87e    ..~.    BL       LL_GPIO_Init ; 0x8000944
;;;851    
;;;852      GPIO_InitStruct.Pin = LL_GPIO_PIN_3;
        0x08001848:    f6400008    @...    MOV      r0,#0x808
        0x0800184c:    9000        ..      STR      r0,[sp,#0]
;;;853      GPIO_InitStruct.Mode = LL_GPIO_MODE_FLOATING;
        0x0800184e:    2004        .       MOVS     r0,#4
        0x08001850:    9001        ..      STR      r0,[sp,#4]
;;;854      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001852:    4669        iF      MOV      r1,sp
        0x08001854:    482c        ,H      LDR      r0,[pc,#176] ; [0x8001908] = 0x40010800
        0x08001856:    f7fff875    ..u.    BL       LL_GPIO_Init ; 0x8000944
;;;855    
;;;856      /* USART2 DMA Init */
;;;857      
;;;858      /* USART2_RX Init */
;;;859      LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_6, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);
        0x0800185a:    2200        ."      MOVS     r2,#0
        0x0800185c:    2106        .!      MOVS     r1,#6
        0x0800185e:    482b        +H      LDR      r0,[pc,#172] ; [0x800190c] = 0x40020000
        0x08001860:    f7fff810    ....    BL       LL_DMA_SetDataTransferDirection ; 0x8000884
;;;860    
;;;861      LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_6, LL_DMA_PRIORITY_LOW);
        0x08001864:    2200        ."      MOVS     r2,#0
        0x08001866:    2106        .!      MOVS     r1,#6
        0x08001868:    4828        (H      LDR      r0,[pc,#160] ; [0x800190c] = 0x40020000
        0x0800186a:    f7fefffb    ....    BL       LL_DMA_SetChannelPriorityLevel ; 0x8000864
;;;862    
;;;863      LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_6, LL_DMA_MODE_NORMAL);
        0x0800186e:    2200        ."      MOVS     r2,#0
        0x08001870:    2106        .!      MOVS     r1,#6
        0x08001872:    4826        &H      LDR      r0,[pc,#152] ; [0x800190c] = 0x40020000
        0x08001874:    f7fff836    ..6.    BL       LL_DMA_SetMode ; 0x80008e4
;;;864    
;;;865      LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_6, LL_DMA_PERIPH_NOINCREMENT);
        0x08001878:    2200        ."      MOVS     r2,#0
        0x0800187a:    2106        .!      MOVS     r1,#6
        0x0800187c:    4823        #H      LDR      r0,[pc,#140] ; [0x800190c] = 0x40020000
        0x0800187e:    f7fff841    ..A.    BL       LL_DMA_SetPeriphIncMode ; 0x8000904
;;;866    
;;;867      LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_6, LL_DMA_MEMORY_INCREMENT);
        0x08001882:    2280        ."      MOVS     r2,#0x80
        0x08001884:    2106        .!      MOVS     r1,#6
        0x08001886:    4821        !H      LDR      r0,[pc,#132] ; [0x800190c] = 0x40020000
        0x08001888:    f7fff80c    ....    BL       LL_DMA_SetMemoryIncMode ; 0x80008a4
;;;868    
;;;869      LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_6, LL_DMA_PDATAALIGN_BYTE);
        0x0800188c:    2200        ."      MOVS     r2,#0
        0x0800188e:    2106        .!      MOVS     r1,#6
        0x08001890:    481e        .H      LDR      r0,[pc,#120] ; [0x800190c] = 0x40020000
        0x08001892:    f7fff847    ..G.    BL       LL_DMA_SetPeriphSize ; 0x8000924
;;;870    
;;;871      LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_6, LL_DMA_MDATAALIGN_BYTE);
        0x08001896:    2200        ."      MOVS     r2,#0
        0x08001898:    2106        .!      MOVS     r1,#6
        0x0800189a:    481c        .H      LDR      r0,[pc,#112] ; [0x800190c] = 0x40020000
        0x0800189c:    f7fff812    ....    BL       LL_DMA_SetMemorySize ; 0x80008c4
;;;872    
;;;873      /* USART2 interrupt Init */
;;;874      NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x080018a0:    f000f864    ..d.    BL       NVIC_GetPriorityGrouping ; 0x800196c
        0x080018a4:    4605        .F      MOV      r5,r0
        0x080018a6:    2200        ."      MOVS     r2,#0
        0x080018a8:    4611        .F      MOV      r1,r2
        0x080018aa:    f000f83e    ..>.    BL       NVIC_EncodePriority ; 0x800192a
        0x080018ae:    4604        .F      MOV      r4,r0
        0x080018b0:    4621        !F      MOV      r1,r4
        0x080018b2:    2026        &       MOVS     r0,#0x26
        0x080018b4:    f000f862    ..b.    BL       NVIC_SetPriority ; 0x800197c
;;;875      NVIC_EnableIRQ(USART2_IRQn);
        0x080018b8:    2026        &       MOVS     r0,#0x26
        0x080018ba:    f000f82b    ..+.    BL       NVIC_EnableIRQ ; 0x8001914
;;;876    
;;;877      /* USER CODE BEGIN USART2_Init 1 */
;;;878    
;;;879      /* USER CODE END USART2_Init 1 */
;;;880      USART_InitStruct.BaudRate = 115200;
        0x080018be:    f44f30e1    O..0    MOV      r0,#0x1c200
        0x080018c2:    9005        ..      STR      r0,[sp,#0x14]
;;;881      USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
        0x080018c4:    2000        .       MOVS     r0,#0
        0x080018c6:    9006        ..      STR      r0,[sp,#0x18]
;;;882      USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
        0x080018c8:    9007        ..      STR      r0,[sp,#0x1c]
;;;883      USART_InitStruct.Parity = LL_USART_PARITY_NONE;
        0x080018ca:    9008        ..      STR      r0,[sp,#0x20]
;;;884      USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
        0x080018cc:    200c        .       MOVS     r0,#0xc
        0x080018ce:    9009        ..      STR      r0,[sp,#0x24]
;;;885      USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
        0x080018d0:    2000        .       MOVS     r0,#0
        0x080018d2:    900a        ..      STR      r0,[sp,#0x28]
;;;886      LL_USART_Init(USART2, &USART_InitStruct);
        0x080018d4:    a905        ..      ADD      r1,sp,#0x14
        0x080018d6:    480e        .H      LDR      r0,[pc,#56] ; [0x8001910] = 0x40004400
        0x080018d8:    f7fffb92    ....    BL       LL_USART_Init ; 0x8001000
;;;887      LL_USART_ConfigAsyncMode(USART2);
        0x080018dc:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1549     CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
        0x080018de:    480c        .H      LDR      r0,[pc,#48] ; [0x8001910] = 0x40004400
        0x080018e0:    6900        .i      LDR      r0,[r0,#0x10]
        0x080018e2:    f4204090     ..@    BIC      r0,r0,#0x4800
        0x080018e6:    490a        .I      LDR      r1,[pc,#40] ; [0x8001910] = 0x40004400
        0x080018e8:    6108        .a      STR      r0,[r1,#0x10]
;;;1550     CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
        0x080018ea:    4608        .F      MOV      r0,r1
        0x080018ec:    6940        @i      LDR      r0,[r0,#0x14]
        0x080018ee:    f020002a     .*.    BIC      r0,r0,#0x2a
        0x080018f2:    6148        Ha      STR      r0,[r1,#0x14]
;;;1551   }
        0x080018f4:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;888      LL_USART_Enable(USART2);
        0x080018f6:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;431      SET_BIT(USARTx->CR1, USART_CR1_UE);
        0x080018f8:    4608        .F      MOV      r0,r1
        0x080018fa:    68c0        .h      LDR      r0,[r0,#0xc]
        0x080018fc:    f4405000    @..P    ORR      r0,r0,#0x2000
        0x08001900:    60c8        .`      STR      r0,[r1,#0xc]
;;;432    }
        0x08001902:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;893    }
        0x08001904:    b00b        ..      ADD      sp,sp,#0x2c
        0x08001906:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001908:    40010800    ...@    DCD    1073809408
        0x0800190c:    40020000    ...@    DCD    1073872896
        0x08001910:    40004400    .D.@    DCD    1073759232
    $t
    i.NVIC_EnableIRQ
    NVIC_EnableIRQ
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08001914:    f000021f    ....    AND      r2,r0,#0x1f
        0x08001918:    2101        .!      MOVS     r1,#1
        0x0800191a:    4091        .@      LSLS     r1,r1,r2
        0x0800191c:    0942        B.      LSRS     r2,r0,#5
        0x0800191e:    0092        ..      LSLS     r2,r2,#2
        0x08001920:    f10222e0    ..."    ADD      r2,r2,#0xe000e000
        0x08001924:    f8c21100    ....    STR      r1,[r2,#0x100]
;;;1455   }
        0x08001928:    4770        pG      BX       lr
    i.NVIC_EncodePriority
    NVIC_EncodePriority
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
;;;1526     if ((int32_t)(IRQn) < 0)
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1533     }
;;;1534   }
;;;1535   
;;;1536   
;;;1537   /**
;;;1538     \brief   Get Interrupt Priority
;;;1539     \details Reads the priority of an interrupt.
;;;1540              The interrupt number can be positive to specify an external (device specific) interrupt,
;;;1541              or negative to specify an internal (core) interrupt.
;;;1542     \param [in]   IRQn  Interrupt number.
;;;1543     \return             Interrupt Priority.
;;;1544                         Value is aligned automatically to the implemented priority bits of the microcontroller.
;;;1545    */
;;;1546   __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
;;;1547   {
;;;1548   
;;;1549     if ((int32_t)(IRQn) < 0)
;;;1550     {
;;;1551       return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
;;;1552     }
;;;1553     else
;;;1554     {
;;;1555       return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
;;;1556     }
;;;1557   }
;;;1558   
;;;1559   
;;;1560   /**
;;;1561     \brief   Encode Priority
;;;1562     \details Encodes the priority for an interrupt with the given priority group,
;;;1563              preemptive priority value, and subpriority value.
;;;1564              In case of a conflict between priority grouping and available
;;;1565              priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
;;;1566     \param [in]     PriorityGroup  Used priority group.
;;;1567     \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
;;;1568     \param [in]       SubPriority  Subpriority value (starting from 0).
;;;1569     \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
;;;1570    */
;;;1571   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
;;;1572   {
        0x0800192a:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0800192c:    4603        .F      MOV      r3,r0
        0x0800192e:    460c        .F      MOV      r4,r1
;;;1573     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
        0x08001930:    f0030107    ....    AND      r1,r3,#7
;;;1574     uint32_t PreemptPriorityBits;
;;;1575     uint32_t SubPriorityBits;
;;;1576   
;;;1577     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
        0x08001934:    f1c10007    ....    RSB      r0,r1,#7
        0x08001938:    2804        .(      CMP      r0,#4
        0x0800193a:    d901        ..      BLS      0x8001940 ; NVIC_EncodePriority + 22
        0x0800193c:    2004        .       MOVS     r0,#4
        0x0800193e:    e001        ..      B        0x8001944 ; NVIC_EncodePriority + 26
        0x08001940:    f1c10007    ....    RSB      r0,r1,#7
        0x08001944:    4606        .F      MOV      r6,r0
;;;1578     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
        0x08001946:    1d08        ..      ADDS     r0,r1,#4
        0x08001948:    2807        .(      CMP      r0,#7
        0x0800194a:    d201        ..      BCS      0x8001950 ; NVIC_EncodePriority + 38
        0x0800194c:    2000        .       MOVS     r0,#0
        0x0800194e:    e000        ..      B        0x8001952 ; NVIC_EncodePriority + 40
        0x08001950:    1ec8        ..      SUBS     r0,r1,#3
        0x08001952:    4605        .F      MOV      r5,r0
;;;1579   
;;;1580     return (
        0x08001954:    2001        .       MOVS     r0,#1
        0x08001956:    40b0        .@      LSLS     r0,r0,r6
        0x08001958:    1e40        @.      SUBS     r0,r0,#1
        0x0800195a:    4020         @      ANDS     r0,r0,r4
        0x0800195c:    40a8        .@      LSLS     r0,r0,r5
        0x0800195e:    2701        .'      MOVS     r7,#1
        0x08001960:    40af        .@      LSLS     r7,r7,r5
        0x08001962:    1e7f        ..      SUBS     r7,r7,#1
        0x08001964:    4017        .@      ANDS     r7,r7,r2
        0x08001966:    4338        8C      ORRS     r0,r0,r7
;;;1581              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1582              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1583            );
;;;1584   }
        0x08001968:    bdf0        ..      POP      {r4-r7,pc}
        0x0800196a:    0000        ..      MOVS     r0,r0
    i.NVIC_GetPriorityGrouping
    NVIC_GetPriorityGrouping
;;; ../Drivers/CMSIS/Include/core_cm3.h (1443)
        0x0800196c:    4802        .H      LDR      r0,[pc,#8] ; [0x8001978] = 0xe000ed0c
        0x0800196e:    6800        .h      LDR      r0,[r0,#0]
        0x08001970:    f3c02002    ...     UBFX     r0,r0,#8,#3
;;;1444   }
        0x08001974:    4770        pG      BX       lr
    $d
        0x08001976:    0000        ..      DCW    0
        0x08001978:    e000ed0c    ....    DCD    3758157068
    $t
    i.NVIC_SetPriority
    NVIC_SetPriority
;;;1445   
;;;1446   
;;;1447   /**
;;;1448     \brief   Enable External Interrupt
;;;1449     \details Enables a device-specific interrupt in the NVIC interrupt controller.
;;;1450     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
;;;1453   {
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1455   }
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
        0x0800197c:    b510        ..      PUSH     {r4,lr}
;;;1526     if ((int32_t)(IRQn) < 0)
        0x0800197e:    2800        .(      CMP      r0,#0
        0x08001980:    da07        ..      BGE      0x8001992 ; NVIC_SetPriority + 22
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x08001982:    070a        ..      LSLS     r2,r1,#28
        0x08001984:    0e14        ..      LSRS     r4,r2,#24
        0x08001986:    4a05        .J      LDR      r2,[pc,#20] ; [0x800199c] = 0xe000ed18
        0x08001988:    f000030f    ....    AND      r3,r0,#0xf
        0x0800198c:    1f1b        ..      SUBS     r3,r3,#4
        0x0800198e:    54d4        .T      STRB     r4,[r2,r3]
        0x08001990:    e003        ..      B        0x800199a ; NVIC_SetPriority + 30
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x08001992:    070a        ..      LSLS     r2,r1,#28
        0x08001994:    0e13        ..      LSRS     r3,r2,#24
        0x08001996:    4a02        .J      LDR      r2,[pc,#8] ; [0x80019a0] = 0xe000e400
        0x08001998:    5413        .T      STRB     r3,[r2,r0]
;;;1533     }
;;;1534   }
        0x0800199a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800199c:    e000ed18    ....    DCD    3758157080
        0x080019a0:    e000e400    ....    DCD    3758154752
    $t
    i.OC1Config
    OC1Config
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;766    {
        0x080019a4:    b570        p.      PUSH     {r4-r6,lr}
        0x080019a6:    4602        .F      MOV      r2,r0
;;;767      uint32_t tmpccmr1 = 0U;
        0x080019a8:    2400        .$      MOVS     r4,#0
;;;768      uint32_t tmpccer = 0U;
        0x080019aa:    2300        .#      MOVS     r3,#0
;;;769      uint32_t tmpcr2 = 0U;
        0x080019ac:    2500        .%      MOVS     r5,#0
;;;770    
;;;771      /* Check the parameters */
;;;772      assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;773      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;774      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;775      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;776      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;777      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;778    
;;;779      /* Disable the Channel 1: Reset the CC1E Bit */
;;;780      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
        0x080019ae:    6a10        .j      LDR      r0,[r2,#0x20]
        0x080019b0:    f0200001     ...    BIC      r0,r0,#1
        0x080019b4:    6210        .b      STR      r0,[r2,#0x20]
;;;781    
;;;782      /* Get the TIMx CCER register value */
;;;783      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x080019b6:    6a13        .j      LDR      r3,[r2,#0x20]
;;;784    
;;;785      /* Get the TIMx CR2 register value */
;;;786      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x080019b8:    6855        Uh      LDR      r5,[r2,#4]
;;;787    
;;;788      /* Get the TIMx CCMR1 register value */
;;;789      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x080019ba:    6994        .i      LDR      r4,[r2,#0x18]
;;;790    
;;;791      /* Reset Capture/Compare selection Bits */
;;;792      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
        0x080019bc:    f0240403    $...    BIC      r4,r4,#3
;;;793    
;;;794      /* Set the Output Compare Mode */
;;;795      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
        0x080019c0:    f0240070    $.p.    BIC      r0,r4,#0x70
        0x080019c4:    680e        .h      LDR      r6,[r1,#0]
        0x080019c6:    ea400406    @...    ORR      r4,r0,r6
;;;796    
;;;797      /* Set the Output Compare Polarity */
;;;798      MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
        0x080019ca:    f0230002    #...    BIC      r0,r3,#2
        0x080019ce:    690e        .i      LDR      r6,[r1,#0x10]
        0x080019d0:    ea400306    @...    ORR      r3,r0,r6
;;;799    
;;;800      /* Set the Output State */
;;;801      MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
        0x080019d4:    f0230001    #...    BIC      r0,r3,#1
        0x080019d8:    684e        Nh      LDR      r6,[r1,#4]
        0x080019da:    ea400306    @...    ORR      r3,r0,r6
;;;802    
;;;803      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x080019de:    480f        .H      LDR      r0,[pc,#60] ; [0x8001a1c] = 0x40012c00
        0x080019e0:    4282        .B      CMP      r2,r0
        0x080019e2:    d113        ..      BNE      0x8001a0c ; OC1Config + 104
;;;804      {
;;;805        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;806        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;807    
;;;808        /* Set the complementary output Polarity */
;;;809        MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
        0x080019e4:    f0230008    #...    BIC      r0,r3,#8
        0x080019e8:    694e        Ni      LDR      r6,[r1,#0x14]
        0x080019ea:    ea400386    @...    ORR      r3,r0,r6,LSL #2
;;;810    
;;;811        /* Set the complementary output State */
;;;812        MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
        0x080019ee:    f0230004    #...    BIC      r0,r3,#4
        0x080019f2:    688e        .h      LDR      r6,[r1,#8]
        0x080019f4:    ea400386    @...    ORR      r3,r0,r6,LSL #2
;;;813    
;;;814        /* Set the Output Idle state */
;;;815        MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
        0x080019f8:    f4257080    %..p    BIC      r0,r5,#0x100
        0x080019fc:    698e        .i      LDR      r6,[r1,#0x18]
        0x080019fe:    ea400506    @...    ORR      r5,r0,r6
;;;816    
;;;817        /* Set the complementary output Idle state */
;;;818        MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
        0x08001a02:    f4257000    %..p    BIC      r0,r5,#0x200
        0x08001a06:    69ce        .i      LDR      r6,[r1,#0x1c]
        0x08001a08:    ea400546    @.F.    ORR      r5,r0,r6,LSL #1
;;;819      }
;;;820    
;;;821      /* Write to TIMx CR2 */
;;;822      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001a0c:    6055        U`      STR      r5,[r2,#4]
;;;823    
;;;824      /* Write to TIMx CCMR1 */
;;;825      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x08001a0e:    6194        .a      STR      r4,[r2,#0x18]
;;;826    
;;;827      /* Set the Capture Compare Register value */
;;;828      LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001a10:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
        0x08001a12:    6350        Pc      STR      r0,[r2,#0x34]
;;;1998   }
        0x08001a14:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;831      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001a16:    6213        .b      STR      r3,[r2,#0x20]
;;;832    
;;;833      return SUCCESS;
        0x08001a18:    2001        .       MOVS     r0,#1
;;;834    }
        0x08001a1a:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001a1c:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC2Config
    OC2Config
;;;835    
;;;836    /**
;;;837      * @brief  Configure the TIMx output channel 2.
;;;838      * @param  TIMx Timer Instance
;;;839      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
;;;840      * @retval An ErrorStatus enumeration value:
;;;841      *          - SUCCESS: TIMx registers are de-initialized
;;;842      *          - ERROR: not applicable
;;;843      */
;;;844    static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;845    {
        0x08001a20:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08001a24:    4604        .F      MOV      r4,r0
        0x08001a26:    460d        .F      MOV      r5,r1
;;;846      uint32_t tmpccmr1 = 0U;
        0x08001a28:    2700        .'      MOVS     r7,#0
;;;847      uint32_t tmpccer = 0U;
        0x08001a2a:    2600        .&      MOVS     r6,#0
;;;848      uint32_t tmpcr2 = 0U;
        0x08001a2c:    46b0        .F      MOV      r8,r6
;;;849    
;;;850      /* Check the parameters */
;;;851      assert_param(IS_TIM_CC2_INSTANCE(TIMx));
;;;852      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;853      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;854      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;855      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;856      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;857    
;;;858      /* Disable the Channel 2: Reset the CC2E Bit */
;;;859      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
        0x08001a2e:    6a20         j      LDR      r0,[r4,#0x20]
        0x08001a30:    f0200010     ...    BIC      r0,r0,#0x10
        0x08001a34:    6220         b      STR      r0,[r4,#0x20]
;;;860    
;;;861      /* Get the TIMx CCER register value */
;;;862      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x08001a36:    6a26        &j      LDR      r6,[r4,#0x20]
;;;863    
;;;864      /* Get the TIMx CR2 register value */
;;;865      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001a38:    f8d48004    ....    LDR      r8,[r4,#4]
;;;866    
;;;867      /* Get the TIMx CCMR1 register value */
;;;868      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x08001a3c:    69a7        .i      LDR      r7,[r4,#0x18]
;;;869    
;;;870      /* Reset Capture/Compare selection Bits */
;;;871      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
        0x08001a3e:    f4277740    '.@w    BIC      r7,r7,#0x300
;;;872    
;;;873      /* Select the Output Compare Mode */
;;;874      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
        0x08001a42:    f42740e0    '..@    BIC      r0,r7,#0x7000
        0x08001a46:    6829        )h      LDR      r1,[r5,#0]
        0x08001a48:    ea402701    @..'    ORR      r7,r0,r1,LSL #8
;;;875    
;;;876      /* Set the Output Compare Polarity */
;;;877      MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
        0x08001a4c:    f0260020    &. .    BIC      r0,r6,#0x20
        0x08001a50:    6929        )i      LDR      r1,[r5,#0x10]
        0x08001a52:    ea401601    @...    ORR      r6,r0,r1,LSL #4
;;;878    
;;;879      /* Set the Output State */
;;;880      MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
        0x08001a56:    f0260010    &...    BIC      r0,r6,#0x10
        0x08001a5a:    6869        ih      LDR      r1,[r5,#4]
        0x08001a5c:    ea401601    @...    ORR      r6,r0,r1,LSL #4
;;;881    
;;;882      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001a60:    4810        .H      LDR      r0,[pc,#64] ; [0x8001aa4] = 0x40012c00
        0x08001a62:    4284        .B      CMP      r4,r0
        0x08001a64:    d113        ..      BNE      0x8001a8e ; OC2Config + 110
;;;883      {
;;;884        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;885        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;886    
;;;887        /* Set the complementary output Polarity */
;;;888        MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
        0x08001a66:    f0260080    &...    BIC      r0,r6,#0x80
        0x08001a6a:    6969        ii      LDR      r1,[r5,#0x14]
        0x08001a6c:    ea401681    @...    ORR      r6,r0,r1,LSL #6
;;;889    
;;;890        /* Set the complementary output State */
;;;891        MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
        0x08001a70:    f0260040    &.@.    BIC      r0,r6,#0x40
        0x08001a74:    68a9        .h      LDR      r1,[r5,#8]
        0x08001a76:    ea401681    @...    ORR      r6,r0,r1,LSL #6
;;;892    
;;;893        /* Set the Output Idle state */
;;;894        MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
        0x08001a7a:    f4286080    (..`    BIC      r0,r8,#0x400
        0x08001a7e:    69a9        .i      LDR      r1,[r5,#0x18]
        0x08001a80:    ea400881    @...    ORR      r8,r0,r1,LSL #2
;;;895    
;;;896        /* Set the complementary output Idle state */
;;;897        MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
        0x08001a84:    f4286000    (..`    BIC      r0,r8,#0x800
        0x08001a88:    69e9        .i      LDR      r1,[r5,#0x1c]
        0x08001a8a:    ea4008c1    @...    ORR      r8,r0,r1,LSL #3
;;;898      }
;;;899    
;;;900      /* Write to TIMx CR2 */
;;;901      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001a8e:    f8c48004    ....    STR      r8,[r4,#4]
;;;902    
;;;903      /* Write to TIMx CCMR1 */
;;;904      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x08001a92:    61a7        .a      STR      r7,[r4,#0x18]
;;;905    
;;;906      /* Set the Capture Compare Register value */
;;;907      LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001a94:    4620         F      MOV      r0,r4
        0x08001a96:    68e9        .h      LDR      r1,[r5,#0xc]
        0x08001a98:    f7fffaa2    ....    BL       LL_TIM_OC_SetCompareCH2 ; 0x8000fe0
;;;908    
;;;909      /* Write to TIMx CCER */
;;;910      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001a9c:    6226        &b      STR      r6,[r4,#0x20]
;;;911    
;;;912      return SUCCESS;
        0x08001a9e:    2001        .       MOVS     r0,#1
;;;913    }
        0x08001aa0:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x08001aa4:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC3Config
    OC3Config
;;;914    
;;;915    /**
;;;916      * @brief  Configure the TIMx output channel 3.
;;;917      * @param  TIMx Timer Instance
;;;918      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
;;;919      * @retval An ErrorStatus enumeration value:
;;;920      *          - SUCCESS: TIMx registers are de-initialized
;;;921      *          - ERROR: not applicable
;;;922      */
;;;923    static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;924    {
        0x08001aa8:    b570        p.      PUSH     {r4-r6,lr}
        0x08001aaa:    4602        .F      MOV      r2,r0
;;;925      uint32_t tmpccmr2 = 0U;
        0x08001aac:    2400        .$      MOVS     r4,#0
;;;926      uint32_t tmpccer = 0U;
        0x08001aae:    2300        .#      MOVS     r3,#0
;;;927      uint32_t tmpcr2 = 0U;
        0x08001ab0:    2500        .%      MOVS     r5,#0
;;;928    
;;;929      /* Check the parameters */
;;;930      assert_param(IS_TIM_CC3_INSTANCE(TIMx));
;;;931      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;932      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;933      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;934      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;935      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;936    
;;;937      /* Disable the Channel 3: Reset the CC3E Bit */
;;;938      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
        0x08001ab2:    6a10        .j      LDR      r0,[r2,#0x20]
        0x08001ab4:    f4207080     ..p    BIC      r0,r0,#0x100
        0x08001ab8:    6210        .b      STR      r0,[r2,#0x20]
;;;939    
;;;940      /* Get the TIMx CCER register value */
;;;941      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x08001aba:    6a13        .j      LDR      r3,[r2,#0x20]
;;;942    
;;;943      /* Get the TIMx CR2 register value */
;;;944      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001abc:    6855        Uh      LDR      r5,[r2,#4]
;;;945    
;;;946      /* Get the TIMx CCMR2 register value */
;;;947      tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x08001abe:    69d4        .i      LDR      r4,[r2,#0x1c]
;;;948    
;;;949      /* Reset Capture/Compare selection Bits */
;;;950      CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
        0x08001ac0:    f0240403    $...    BIC      r4,r4,#3
;;;951    
;;;952      /* Select the Output Compare Mode */
;;;953      MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
        0x08001ac4:    f0240070    $.p.    BIC      r0,r4,#0x70
        0x08001ac8:    680e        .h      LDR      r6,[r1,#0]
        0x08001aca:    ea400406    @...    ORR      r4,r0,r6
;;;954    
;;;955      /* Set the Output Compare Polarity */
;;;956      MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
        0x08001ace:    f4237000    #..p    BIC      r0,r3,#0x200
        0x08001ad2:    690e        .i      LDR      r6,[r1,#0x10]
        0x08001ad4:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;957    
;;;958      /* Set the Output State */
;;;959      MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
        0x08001ad8:    f4237080    #..p    BIC      r0,r3,#0x100
        0x08001adc:    684e        Nh      LDR      r6,[r1,#4]
        0x08001ade:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;960    
;;;961      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001ae2:    480f        .H      LDR      r0,[pc,#60] ; [0x8001b20] = 0x40012c00
        0x08001ae4:    4282        .B      CMP      r2,r0
        0x08001ae6:    d113        ..      BNE      0x8001b10 ; OC3Config + 104
;;;962      {
;;;963        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;964        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;965    
;;;966        /* Set the complementary output Polarity */
;;;967        MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
        0x08001ae8:    f4236000    #..`    BIC      r0,r3,#0x800
        0x08001aec:    694e        Ni      LDR      r6,[r1,#0x14]
        0x08001aee:    ea402386    @..#    ORR      r3,r0,r6,LSL #10
;;;968    
;;;969        /* Set the complementary output State */
;;;970        MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
        0x08001af2:    f4236080    #..`    BIC      r0,r3,#0x400
        0x08001af6:    688e        .h      LDR      r6,[r1,#8]
        0x08001af8:    ea402386    @..#    ORR      r3,r0,r6,LSL #10
;;;971    
;;;972        /* Set the Output Idle state */
;;;973        MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
        0x08001afc:    f4255080    %..P    BIC      r0,r5,#0x1000
        0x08001b00:    698e        .i      LDR      r6,[r1,#0x18]
        0x08001b02:    ea401506    @...    ORR      r5,r0,r6,LSL #4
;;;974    
;;;975        /* Set the complementary output Idle state */
;;;976        MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
        0x08001b06:    f4255000    %..P    BIC      r0,r5,#0x2000
        0x08001b0a:    69ce        .i      LDR      r6,[r1,#0x1c]
        0x08001b0c:    ea401546    @.F.    ORR      r5,r0,r6,LSL #5
;;;977      }
;;;978    
;;;979      /* Write to TIMx CR2 */
;;;980      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001b10:    6055        U`      STR      r5,[r2,#4]
;;;981    
;;;982      /* Write to TIMx CCMR2 */
;;;983      LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x08001b12:    61d4        .a      STR      r4,[r2,#0x1c]
;;;984    
;;;985      /* Set the Capture Compare Register value */
;;;986      LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001b14:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
        0x08001b16:    63d0        .c      STR      r0,[r2,#0x3c]
;;;2026   }
        0x08001b18:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;989      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001b1a:    6213        .b      STR      r3,[r2,#0x20]
;;;990    
;;;991      return SUCCESS;
        0x08001b1c:    2001        .       MOVS     r0,#1
;;;992    }
        0x08001b1e:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001b20:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC4Config
    OC4Config
;;;993    
;;;994    /**
;;;995      * @brief  Configure the TIMx output channel 4.
;;;996      * @param  TIMx Timer Instance
;;;997      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
;;;998      * @retval An ErrorStatus enumeration value:
;;;999      *          - SUCCESS: TIMx registers are de-initialized
;;;1000     *          - ERROR: not applicable
;;;1001     */
;;;1002   static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;1003   {
        0x08001b24:    b570        p.      PUSH     {r4-r6,lr}
        0x08001b26:    4602        .F      MOV      r2,r0
;;;1004     uint32_t tmpccmr2 = 0U;
        0x08001b28:    2300        .#      MOVS     r3,#0
;;;1005     uint32_t tmpccer = 0U;
        0x08001b2a:    2400        .$      MOVS     r4,#0
;;;1006     uint32_t tmpcr2 = 0U;
        0x08001b2c:    2500        .%      MOVS     r5,#0
;;;1007   
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;1010     assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;1011     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;1012     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;1013     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;1014     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;1015   
;;;1016     /* Disable the Channel 4: Reset the CC4E Bit */
;;;1017     CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
        0x08001b2e:    6a10        .j      LDR      r0,[r2,#0x20]
        0x08001b30:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x08001b34:    6210        .b      STR      r0,[r2,#0x20]
;;;1018   
;;;1019     /* Get the TIMx CCER register value */
;;;1020     tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x08001b36:    6a14        .j      LDR      r4,[r2,#0x20]
;;;1021   
;;;1022     /* Get the TIMx CR2 register value */
;;;1023     tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
        0x08001b38:    6855        Uh      LDR      r5,[r2,#4]
;;;1024   
;;;1025     /* Get the TIMx CCMR2 register value */
;;;1026     tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x08001b3a:    69d3        .i      LDR      r3,[r2,#0x1c]
;;;1027   
;;;1028     /* Reset Capture/Compare selection Bits */
;;;1029     CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
        0x08001b3c:    f4237340    #.@s    BIC      r3,r3,#0x300
;;;1030   
;;;1031     /* Select the Output Compare Mode */
;;;1032     MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
        0x08001b40:    f42340e0    #..@    BIC      r0,r3,#0x7000
        0x08001b44:    680e        .h      LDR      r6,[r1,#0]
        0x08001b46:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;1033   
;;;1034     /* Set the Output Compare Polarity */
;;;1035     MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
        0x08001b4a:    f4245000    $..P    BIC      r0,r4,#0x2000
        0x08001b4e:    690e        .i      LDR      r6,[r1,#0x10]
        0x08001b50:    ea403406    @..4    ORR      r4,r0,r6,LSL #12
;;;1036   
;;;1037     /* Set the Output State */
;;;1038     MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
        0x08001b54:    f4245080    $..P    BIC      r0,r4,#0x1000
        0x08001b58:    684e        Nh      LDR      r6,[r1,#4]
        0x08001b5a:    ea403406    @..4    ORR      r4,r0,r6,LSL #12
;;;1039   
;;;1040     if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001b5e:    4808        .H      LDR      r0,[pc,#32] ; [0x8001b80] = 0x40012c00
        0x08001b60:    4282        .B      CMP      r2,r0
        0x08001b62:    d104        ..      BNE      0x8001b6e ; OC4Config + 74
;;;1041     {
;;;1042       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;1043       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;1044   
;;;1045       /* Set the Output Idle state */
;;;1046       MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
        0x08001b64:    f4254080    %..@    BIC      r0,r5,#0x4000
        0x08001b68:    698e        .i      LDR      r6,[r1,#0x18]
        0x08001b6a:    ea401586    @...    ORR      r5,r0,r6,LSL #6
;;;1047     }
;;;1048   
;;;1049     /* Write to TIMx CR2 */
;;;1050     LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001b6e:    6055        U`      STR      r5,[r2,#4]
;;;1051   
;;;1052     /* Write to TIMx CCMR2 */
;;;1053     LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x08001b70:    61d3        .a      STR      r3,[r2,#0x1c]
;;;1054   
;;;1055     /* Set the Capture Compare Register value */
;;;1056     LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001b72:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
        0x08001b74:    6410        .d      STR      r0,[r2,#0x40]
;;;2040   }
        0x08001b76:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;1059     LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001b78:    6214        .b      STR      r4,[r2,#0x20]
;;;1060   
;;;1061     return SUCCESS;
        0x08001b7a:    2001        .       MOVS     r0,#1
;;;1062   }
        0x08001b7c:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001b7e:    0000        ..      DCW    0
        0x08001b80:    40012c00    .,.@    DCD    1073818624
    $t
    i.PendSV_Handler
    PendSV_Handler
;;; .\../Src/stm32f1xx_it.c
;;;143    }
        0x08001b84:    4770        pG      BX       lr
        0x08001b86:    0000        ..      MOVS     r0,r0
    i.RCC_GetHCLKClockFreq
    RCC_GetHCLKClockFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;388    {
        0x08001b88:    4601        .F      MOV      r1,r0
;;;389      /* HCLK clock frequency */
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
        0x08001b8a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1116     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
        0x08001b8c:    4804        .H      LDR      r0,[pc,#16] ; [0x8001ba0] = 0x40021000
        0x08001b8e:    6840        @h      LDR      r0,[r0,#4]
        0x08001b90:    f00000f0    ....    AND      r0,r0,#0xf0
        0x08001b94:    0900        ..      LSRS     r0,r0,#4
        0x08001b96:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001ba4] = 0x80030d0
        0x08001b98:    5c12        .\      LDRB     r2,[r2,r0]
        0x08001b9a:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;391    }
        0x08001b9e:    4770        pG      BX       lr
    $d
        0x08001ba0:    40021000    ...@    DCD    1073876992
        0x08001ba4:    080030d0    .0..    DCD    134230224
    $t
    i.RCC_GetPCLK1ClockFreq
    RCC_GetPCLK1ClockFreq
;;;392    
;;;393    /**
;;;394      * @brief  Return PCLK1 clock frequency
;;;395      * @param  HCLK_Frequency HCLK clock frequency
;;;396      * @retval PCLK1 clock frequency (in Hz)
;;;397      */
;;;398    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
;;;399    {
        0x08001ba8:    4601        .F      MOV      r1,r0
;;;400      /* PCLK1 clock frequency */
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
        0x08001baa:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1131     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
        0x08001bac:    4805        .H      LDR      r0,[pc,#20] ; [0x8001bc4] = 0x40021000
        0x08001bae:    6840        @h      LDR      r0,[r0,#4]
        0x08001bb0:    f40060e0    ...`    AND      r0,r0,#0x700
        0x08001bb4:    4a04        .J      LDR      r2,[pc,#16] ; [0x8001bc8] = 0x80030e0
        0x08001bb6:    eb022010    ...     ADD      r0,r2,r0,LSR #8
        0x08001bba:    7802        .x      LDRB     r2,[r0,#0]
        0x08001bbc:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;402    }
        0x08001bc0:    4770        pG      BX       lr
    $d
        0x08001bc2:    0000        ..      DCW    0
        0x08001bc4:    40021000    ...@    DCD    1073876992
        0x08001bc8:    080030e0    .0..    DCD    134230240
    $t
    i.RCC_GetPCLK2ClockFreq
    RCC_GetPCLK2ClockFreq
;;;403    
;;;404    /**
;;;405      * @brief  Return PCLK2 clock frequency
;;;406      * @param  HCLK_Frequency HCLK clock frequency
;;;407      * @retval PCLK2 clock frequency (in Hz)
;;;408      */
;;;409    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
;;;410    {
        0x08001bcc:    4601        .F      MOV      r1,r0
;;;411      /* PCLK2 clock frequency */
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
        0x08001bce:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1146     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
        0x08001bd0:    4805        .H      LDR      r0,[pc,#20] ; [0x8001be8] = 0x40021000
        0x08001bd2:    6840        @h      LDR      r0,[r0,#4]
        0x08001bd4:    f4005060    ..`P    AND      r0,r0,#0x3800
        0x08001bd8:    4a04        .J      LDR      r2,[pc,#16] ; [0x8001bec] = 0x80030e0
        0x08001bda:    eb0220d0    ...     ADD      r0,r2,r0,LSR #11
        0x08001bde:    7802        .x      LDRB     r2,[r0,#0]
        0x08001be0:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;413    }
        0x08001be4:    4770        pG      BX       lr
    $d
        0x08001be6:    0000        ..      DCW    0
        0x08001be8:    40021000    ...@    DCD    1073876992
        0x08001bec:    080030e0    .0..    DCD    134230240
    $t
    i.RCC_GetSystemClockFreq
    RCC_GetSystemClockFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c (356)
        0x08001bf0:    b510        ..      PUSH     {r4,lr}
;;;357      uint32_t frequency = 0U;
        0x08001bf2:    2400        .$      MOVS     r4,#0
;;;358    
;;;359      /* Get SYSCLK source -------------------------------------------------------*/
;;;360      switch (LL_RCC_GetSysClkSource())
        0x08001bf4:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001bf6:    480b        .H      LDR      r0,[pc,#44] ; [0x8001c24] = 0x40021000
        0x08001bf8:    6840        @h      LDR      r0,[r0,#4]
        0x08001bfa:    f000000c    ....    AND      r0,r0,#0xc
        0x08001bfe:    b120         .      CBZ      r0,0x8001c0a ; RCC_GetSystemClockFreq + 26
        0x08001c00:    2804        .(      CMP      r0,#4
        0x08001c02:    d004        ..      BEQ      0x8001c0e ; RCC_GetSystemClockFreq + 30
        0x08001c04:    2808        .(      CMP      r0,#8
        0x08001c06:    d108        ..      BNE      0x8001c1a ; RCC_GetSystemClockFreq + 42
        0x08001c08:    e003        ..      B        0x8001c12 ; RCC_GetSystemClockFreq + 34
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;363          frequency = HSI_VALUE;
        0x08001c0a:    4c07        .L      LDR      r4,[pc,#28] ; [0x8001c28] = 0x7a1200
;;;364          break;
        0x08001c0c:    e007        ..      B        0x8001c1e ; RCC_GetSystemClockFreq + 46
;;;365    
;;;366        case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;367          frequency = HSE_VALUE;
        0x08001c0e:    4c06        .L      LDR      r4,[pc,#24] ; [0x8001c28] = 0x7a1200
;;;368          break;
        0x08001c10:    e005        ..      B        0x8001c1e ; RCC_GetSystemClockFreq + 46
;;;369    
;;;370        case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;371          frequency = RCC_PLL_GetFreqDomain_SYS();
        0x08001c12:    f000f80b    ....    BL       RCC_PLL_GetFreqDomain_SYS ; 0x8001c2c
        0x08001c16:    4604        .F      MOV      r4,r0
;;;372          break;
        0x08001c18:    e001        ..      B        0x8001c1e ; RCC_GetSystemClockFreq + 46
;;;373    
;;;374        default:
;;;375          frequency = HSI_VALUE;
        0x08001c1a:    4c03        .L      LDR      r4,[pc,#12] ; [0x8001c28] = 0x7a1200
;;;376          break;
        0x08001c1c:    bf00        ..      NOP      
        0x08001c1e:    bf00        ..      NOP      
;;;377      }
;;;378    
;;;379      return frequency;
        0x08001c20:    4620         F      MOV      r0,r4
;;;380    }
        0x08001c22:    bd10        ..      POP      {r4,pc}
    $d
        0x08001c24:    40021000    ...@    DCD    1073876992
        0x08001c28:    007a1200    ..z.    DCD    8000000
    $t
    i.RCC_PLL_GetFreqDomain_SYS
    RCC_PLL_GetFreqDomain_SYS
;;;381    
;;;382    /**
;;;383      * @brief  Return HCLK clock frequency
;;;384      * @param  SYSCLK_Frequency SYSCLK clock frequency
;;;385      * @retval HCLK clock frequency (in Hz)
;;;386      */
;;;387    uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
;;;388    {
;;;389      /* HCLK clock frequency */
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
;;;391    }
;;;392    
;;;393    /**
;;;394      * @brief  Return PCLK1 clock frequency
;;;395      * @param  HCLK_Frequency HCLK clock frequency
;;;396      * @retval PCLK1 clock frequency (in Hz)
;;;397      */
;;;398    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
;;;399    {
;;;400      /* PCLK1 clock frequency */
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
;;;402    }
;;;403    
;;;404    /**
;;;405      * @brief  Return PCLK2 clock frequency
;;;406      * @param  HCLK_Frequency HCLK clock frequency
;;;407      * @retval PCLK2 clock frequency (in Hz)
;;;408      */
;;;409    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
;;;410    {
;;;411      /* PCLK2 clock frequency */
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
;;;413    }
;;;414    
;;;415    /**
;;;416      * @brief  Return PLL clock frequency used for system domain
;;;417      * @retval PLL clock frequency (in Hz)
;;;418      */
;;;419    uint32_t RCC_PLL_GetFreqDomain_SYS(void)
;;;420    {
;;;421      uint32_t pllinputfreq = 0U, pllsource = 0U;
        0x08001c2c:    2100        .!      MOVS     r1,#0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c (421)
        0x08001c2e:    2200        ."      MOVS     r2,#0
;;;422    
;;;423      /* PLL_VCO = (HSE_VALUE, HSI_VALUE or PLL2 / PLL Predivider) * PLL Multiplicator */
;;;424    
;;;425      /* Get PLL source */
;;;426      pllsource = LL_RCC_PLL_GetMainSource();
        0x08001c30:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1543     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
        0x08001c32:    4811        .H      LDR      r0,[pc,#68] ; [0x8001c78] = 0x40021000
        0x08001c34:    6840        @h      LDR      r0,[r0,#4]
        0x08001c36:    f4003080    ...0    AND      r0,r0,#0x10000
        0x08001c3a:    4602        .F      MOV      r2,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;428      switch (pllsource)
        0x08001c3c:    b11a        ..      CBZ      r2,0x8001c46 ; RCC_PLL_GetFreqDomain_SYS + 26
        0x08001c3e:    f5b23f80    ...?    CMP      r2,#0x10000
        0x08001c42:    d10c        ..      BNE      0x8001c5e ; RCC_PLL_GetFreqDomain_SYS + 50
        0x08001c44:    e001        ..      B        0x8001c4a ; RCC_PLL_GetFreqDomain_SYS + 30
;;;429      {
;;;430        case LL_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
;;;431          pllinputfreq = HSI_VALUE / 2U;
        0x08001c46:    490d        .I      LDR      r1,[pc,#52] ; [0x8001c7c] = 0x3d0900
;;;432          break;
        0x08001c48:    e00b        ..      B        0x8001c62 ; RCC_PLL_GetFreqDomain_SYS + 54
;;;433    
;;;434        case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
;;;435          pllinputfreq = HSE_VALUE / (LL_RCC_PLL_GetPrediv() + 1U);
        0x08001c4a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1605     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos);
        0x08001c4c:    480a        .H      LDR      r0,[pc,#40] ; [0x8001c78] = 0x40021000
        0x08001c4e:    6840        @h      LDR      r0,[r0,#4]
        0x08001c50:    f3c04040    ..@@    UBFX     r0,r0,#17,#1
        0x08001c54:    1c40        @.      ADDS     r0,r0,#1
        0x08001c56:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8001c80] = 0x7a1200
        0x08001c58:    fbb3f1f0    ....    UDIV     r1,r3,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;436          break;
        0x08001c5c:    e001        ..      B        0x8001c62 ; RCC_PLL_GetFreqDomain_SYS + 54
;;;437    
;;;438    #if defined(RCC_PLL2_SUPPORT)
;;;439        case LL_RCC_PLLSOURCE_PLL2:       /* PLL2 used as PLL clock source */
;;;440          pllinputfreq = RCC_PLL2_GetFreqClockFreq() / (LL_RCC_PLL_GetPrediv() + 1U);
;;;441          break;
;;;442    #endif /* RCC_PLL2_SUPPORT */
;;;443    
;;;444        default:
;;;445          pllinputfreq = HSI_VALUE / 2U;
        0x08001c5e:    4907        .I      LDR      r1,[pc,#28] ; [0x8001c7c] = 0x3d0900
;;;446          break;
        0x08001c60:    bf00        ..      NOP      
        0x08001c62:    bf00        ..      NOP      
;;;447      }
;;;448      return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator());
        0x08001c64:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1572     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMULL));
        0x08001c66:    4804        .H      LDR      r0,[pc,#16] ; [0x8001c78] = 0x40021000
        0x08001c68:    6840        @h      LDR      r0,[r0,#4]
        0x08001c6a:    f4001070    ..p.    AND      r0,r0,#0x3c0000
        0x08001c6e:    2302        .#      MOVS     r3,#2
        0x08001c70:    eb034090    ...@    ADD      r0,r3,r0,LSR #18
        0x08001c74:    4348        HC      MULS     r0,r1,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;449    }
        0x08001c76:    4770        pG      BX       lr
    $d
        0x08001c78:    40021000    ...@    DCD    1073876992
        0x08001c7c:    003d0900    ..=.    DCD    4000000
        0x08001c80:    007a1200    ..z.    DCD    8000000
    $t
    i.SVC_Handler
    SVC_Handler
;;; .\../Src/stm32f1xx_it.c
;;;130    }
        0x08001c84:    4770        pG      BX       lr
        0x08001c86:    0000        ..      MOVS     r0,r0
    i.SysTick_Handler
    SysTick_Handler
;;;131    
;;;132    /**
;;;133      * @brief This function handles Pendable request for system service.
;;;134      */
;;;135    void PendSV_Handler(void)
;;;136    {
;;;137      /* USER CODE BEGIN PendSV_IRQn 0 */
;;;138    
;;;139      /* USER CODE END PendSV_IRQn 0 */
;;;140      /* USER CODE BEGIN PendSV_IRQn 1 */
;;;141    
;;;142      /* USER CODE END PendSV_IRQn 1 */
;;;143    }
;;;144    
;;;145    /**
;;;146      * @brief This function handles System tick timer.
;;;147      */
;;;148    void SysTick_Handler(void)
;;;149    {
;;;150      /* USER CODE BEGIN SysTick_IRQn 0 */
;;;151    
;;;152      /* USER CODE END SysTick_IRQn 0 */
;;;153      
;;;154      /* USER CODE BEGIN SysTick_IRQn 1 */
;;;155    
;;;156    /*
;;;157    #if  defined ( _SIMU )
;;;158    
;;;159    //simulate spindle
;;;160    	if(++tacho_cnt == 1800 ) {
;;;161    		tacho_debug = 1;
;;;162    		tacho_cnt = 0;
;;;163    		TIM4_IRQHandler();
;;;164    	}
;;;165    	if(++TIM4->CNT > TIM4->ARR) {
;;;166    		TIM4->CNT = 0; // overflow emulation
;;;167    		encoder = true;
;;;168    		TIM4_IRQHandler();
;;;169    	}
;;;170    #endif
;;;171    */
;;;172    //      if(auto_mode_delay > 0)
;;;173    //              auto_mode_delay--;
;;;174    	for(int a = 0; a<BT_TOTAL;a++){
        0x08001c88:    2000        .       MOVS     r0,#0
;;; .\../Src/stm32f1xx_it.c (174)
        0x08001c8a:    e00e        ..      B        0x8001caa ; SysTick_Handler + 34
        0x08001c8c:    4908        .I      LDR      r1,[pc,#32] ; [0x8001cb0] = 0x200004ec
        0x08001c8e:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001c92:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001c94:    b141        A.      CBZ      r1,0x8001ca8 ; SysTick_Handler + 32
        0x08001c96:    4906        .I      LDR      r1,[pc,#24] ; [0x8001cb0] = 0x200004ec
        0x08001c98:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001c9c:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001c9e:    1c49        I.      ADDS     r1,r1,#1
        0x08001ca0:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001cb0] = 0x200004ec
        0x08001ca2:    eb021240    ..@.    ADD      r2,r2,r0,LSL #5
        0x08001ca6:    6111        .a      STR      r1,[r2,#0x10]
        0x08001ca8:    1c40        @.      ADDS     r0,r0,#1
        0x08001caa:    2801        .(      CMP      r0,#1
        0x08001cac:    dbee        ..      BLT      0x8001c8c ; SysTick_Handler + 4
;;;175    		if( bt[a].buttons_mstick > 0 )
;;;176    			bt[a].buttons_mstick++;
;;;177    	}
;;;178      /* USER CODE END SysTick_IRQn 1 */
;;;179    }
        0x08001cae:    4770        pG      BX       lr
    $d
        0x08001cb0:    200004ec    ...     DCD    536872172
    $t
    i.SystemClock_Config
    SystemClock_Config
;;; .\../Src/main.c
;;;458    {
        0x08001cb4:    b510        ..      PUSH     {r4,lr}
;;;459      LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
        0x08001cb6:    2002        .       MOVS     r0,#2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;488      MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
        0x08001cb8:    4942        BI      LDR      r1,[pc,#264] ; [0x8001dc4] = 0x40022000
        0x08001cba:    6809        .h      LDR      r1,[r1,#0]
        0x08001cbc:    f0210107    !...    BIC      r1,r1,#7
        0x08001cc0:    4301        .C      ORRS     r1,r1,r0
        0x08001cc2:    4a40        @J      LDR      r2,[pc,#256] ; [0x8001dc4] = 0x40022000
        0x08001cc4:    6011        .`      STR      r1,[r2,#0]
;;;489    }
        0x08001cc6:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;461       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
        0x08001cc8:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;501      return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
        0x08001cca:    4610        .F      MOV      r0,r2
        0x08001ccc:    6800        .h      LDR      r0,[r0,#0]
        0x08001cce:    f0000007    ....    AND      r0,r0,#7
        0x08001cd2:    2802        .(      CMP      r0,#2
        0x08001cd4:    d001        ..      BEQ      0x8001cda ; SystemClock_Config + 38
;;; .\../Src/main.c
;;;463        Error_Handler();  
        0x08001cd6:    f7fefd22    ..".    BL       Error_Handler ; 0x800071e
;;;464      }
;;;465      LL_RCC_HSE_Enable();
        0x08001cda:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;792      SET_BIT(RCC->CR, RCC_CR_HSEON);
        0x08001cdc:    483a        :H      LDR      r0,[pc,#232] ; [0x8001dc8] = 0x40021000
        0x08001cde:    6800        .h      LDR      r0,[r0,#0]
        0x08001ce0:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x08001ce4:    4938        8I      LDR      r1,[pc,#224] ; [0x8001dc8] = 0x40021000
        0x08001ce6:    6008        .`      STR      r0,[r1,#0]
;;;793    }
        0x08001ce8:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;468      while(LL_RCC_HSE_IsReady() != 1)
        0x08001cea:    bf00        ..      NOP      
        0x08001cec:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;812      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
        0x08001cee:    4836        6H      LDR      r0,[pc,#216] ; [0x8001dc8] = 0x40021000
        0x08001cf0:    6800        .h      LDR      r0,[r0,#0]
        0x08001cf2:    f3c04040    ..@@    UBFX     r0,r0,#17,#1
        0x08001cf6:    2800        .(      CMP      r0,#0
        0x08001cf8:    d0f8        ..      BEQ      0x8001cec ; SystemClock_Config + 56
;;; .\../Src/main.c
;;;472      LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE_DIV_1, LL_RCC_PLL_MUL_9);
        0x08001cfa:    f44f3080    O..0    MOV      r0,#0x10000
        0x08001cfe:    f44f11e0    O...    MOV      r1,#0x1c0000
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1495     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
        0x08001d02:    4a31        1J      LDR      r2,[pc,#196] ; [0x8001dc8] = 0x40021000
        0x08001d04:    6852        Rh      LDR      r2,[r2,#4]
        0x08001d06:    f422127c    ".|.    BIC      r2,r2,#0x3f0000
        0x08001d0a:    f4003340    ..@3    AND      r3,r0,#0x30000
        0x08001d0e:    430b        .C      ORRS     r3,r3,r1
        0x08001d10:    431a        .C      ORRS     r2,r2,r3
        0x08001d12:    4b2d        -K      LDR      r3,[pc,#180] ; [0x8001dc8] = 0x40021000
        0x08001d14:    605a        Z`      STR      r2,[r3,#4]
;;;1496                (Source & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | PLLMul);
;;;1497   #if defined(RCC_CFGR2_PREDIV1)
;;;1498   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1499     MODIFY_REG(RCC->CFGR2, (RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC),
;;;1500                (Source & RCC_CFGR2_PREDIV1) | ((Source & (RCC_CFGR2_PREDIV1SRC << 4U)) >> 4U));
;;;1501   #else
;;;1502     MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV1, (Source & RCC_CFGR2_PREDIV1));
;;;1503   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1504   #endif /*RCC_CFGR2_PREDIV1*/
;;;1505   }
        0x08001d16:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;473      LL_RCC_PLL_Enable();
        0x08001d18:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1405     SET_BIT(RCC->CR, RCC_CR_PLLON);
        0x08001d1a:    4618        .F      MOV      r0,r3
        0x08001d1c:    6800        .h      LDR      r0,[r0,#0]
        0x08001d1e:    f0407080    @..p    ORR      r0,r0,#0x1000000
        0x08001d22:    4619        .F      MOV      r1,r3
        0x08001d24:    6008        .`      STR      r0,[r1,#0]
;;;1406   }
        0x08001d26:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;476      while(LL_RCC_PLL_IsReady() != 1)
        0x08001d28:    bf00        ..      NOP      
        0x08001d2a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1426     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
        0x08001d2c:    4826        &H      LDR      r0,[pc,#152] ; [0x8001dc8] = 0x40021000
        0x08001d2e:    6800        .h      LDR      r0,[r0,#0]
        0x08001d30:    f3c06040    ..@`    UBFX     r0,r0,#25,#1
        0x08001d34:    2800        .(      CMP      r0,#0
        0x08001d36:    d0f8        ..      BEQ      0x8001d2a ; SystemClock_Config + 118
;;; .\../Src/main.c
;;;480      LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
        0x08001d38:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1065     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
        0x08001d3a:    4923        #I      LDR      r1,[pc,#140] ; [0x8001dc8] = 0x40021000
        0x08001d3c:    6849        Ih      LDR      r1,[r1,#4]
        0x08001d3e:    f02101f0    !...    BIC      r1,r1,#0xf0
        0x08001d42:    4301        .C      ORRS     r1,r1,r0
        0x08001d44:    4a20         J      LDR      r2,[pc,#128] ; [0x8001dc8] = 0x40021000
        0x08001d46:    6051        Q`      STR      r1,[r2,#4]
;;;1066   }
        0x08001d48:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;481      LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);
        0x08001d4a:    1510        ..      ASRS     r0,r2,#20
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1081     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
        0x08001d4c:    4611        .F      MOV      r1,r2
        0x08001d4e:    6849        Ih      LDR      r1,[r1,#4]
        0x08001d50:    f42161e0    !..a    BIC      r1,r1,#0x700
        0x08001d54:    4301        .C      ORRS     r1,r1,r0
        0x08001d56:    6051        Q`      STR      r1,[r2,#4]
;;;1082   }
        0x08001d58:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;482      LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);
        0x08001d5a:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1097     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
        0x08001d5c:    4611        .F      MOV      r1,r2
        0x08001d5e:    6849        Ih      LDR      r1,[r1,#4]
        0x08001d60:    f4215160    !.`Q    BIC      r1,r1,#0x3800
        0x08001d64:    4301        .C      ORRS     r1,r1,r0
        0x08001d66:    6051        Q`      STR      r1,[r2,#4]
;;;1098   }
        0x08001d68:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;483      LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
        0x08001d6a:    2002        .       MOVS     r0,#2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1032     MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
        0x08001d6c:    4611        .F      MOV      r1,r2
        0x08001d6e:    6849        Ih      LDR      r1,[r1,#4]
        0x08001d70:    f0210103    !...    BIC      r1,r1,#3
        0x08001d74:    4301        .C      ORRS     r1,r1,r0
        0x08001d76:    6051        Q`      STR      r1,[r2,#4]
;;;1033   }
        0x08001d78:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;486      while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
        0x08001d7a:    bf00        ..      NOP      
        0x08001d7c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001d7e:    4812        .H      LDR      r0,[pc,#72] ; [0x8001dc8] = 0x40021000
        0x08001d80:    6840        @h      LDR      r0,[r0,#4]
        0x08001d82:    f000000c    ....    AND      r0,r0,#0xc
        0x08001d86:    2808        .(      CMP      r0,#8
        0x08001d88:    d1f8        ..      BNE      0x8001d7c ; SystemClock_Config + 200
;;; .\../Src/main.c
;;;490      LL_Init1msTick(72000000);
        0x08001d8a:    4810        .H      LDR      r0,[pc,#64] ; [0x8001dcc] = 0x44aa200
        0x08001d8c:    f7feff0e    ....    BL       LL_Init1msTick ; 0x8000bac
;;;491      LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001d90:    2004        .       MOVS     r0,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;262      if (Source == LL_SYSTICK_CLKSOURCE_HCLK)
        0x08001d92:    2804        .(      CMP      r0,#4
        0x08001d94:    d108        ..      BNE      0x8001da8 ; SystemClock_Config + 244
;;;263      {
;;;264        SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001d96:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001d9a:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001d9c:    f0410104    A...    ORR      r1,r1,#4
        0x08001da0:    f04f22e0    O.."    MOV      r2,#0xe000e000
        0x08001da4:    6111        .a      STR      r1,[r2,#0x10]
        0x08001da6:    e007        ..      B        0x8001db8 ; SystemClock_Config + 260
;;;265      }
;;;266      else
;;;267      {
;;;268        CLEAR_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001da8:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001dac:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001dae:    f0210104    !...    BIC      r1,r1,#4
        0x08001db2:    f04f22e0    O.."    MOV      r2,#0xe000e000
        0x08001db6:    6111        .a      STR      r1,[r2,#0x10]
;;;269      }
;;;270    }
        0x08001db8:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;492      LL_SetSystemCoreClock(72000000);
        0x08001dba:    4804        .H      LDR      r0,[pc,#16] ; [0x8001dcc] = 0x44aa200
        0x08001dbc:    f7feff16    ....    BL       LL_SetSystemCoreClock ; 0x8000bec
;;;493    }
        0x08001dc0:    bd10        ..      POP      {r4,pc}
    $d
        0x08001dc2:    0000        ..      DCW    0
        0x08001dc4:    40022000    . .@    DCD    1073881088
        0x08001dc8:    40021000    ...@    DCD    1073876992
        0x08001dcc:    044aa200    ..J.    DCD    72000000
    $t
    i.SystemInit
    SystemInit
;;; .\../Src/system_stm32f1xx.c
;;;179      RCC->CR |= 0x00000001U;
        0x08001dd0:    4811        .H      LDR      r0,[pc,#68] ; [0x8001e18] = 0x40021000
        0x08001dd2:    6800        .h      LDR      r0,[r0,#0]
        0x08001dd4:    f0400001    @...    ORR      r0,r0,#1
        0x08001dd8:    490f        .I      LDR      r1,[pc,#60] ; [0x8001e18] = 0x40021000
        0x08001dda:    6008        .`      STR      r0,[r1,#0]
;;;180    
;;;181      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;182    #if !defined(STM32F105xC) && !defined(STM32F107xC)
;;;183      RCC->CFGR &= 0xF8FF0000U;
        0x08001ddc:    4608        .F      MOV      r0,r1
        0x08001dde:    6840        @h      LDR      r0,[r0,#4]
        0x08001de0:    490e        .I      LDR      r1,[pc,#56] ; [0x8001e1c] = 0xf8ff0000
        0x08001de2:    4008        .@      ANDS     r0,r0,r1
        0x08001de4:    490c        .I      LDR      r1,[pc,#48] ; [0x8001e18] = 0x40021000
        0x08001de6:    6048        H`      STR      r0,[r1,#4]
;;;184    #else
;;;185      RCC->CFGR &= 0xF0FF0000U;
;;;186    #endif /* STM32F105xC */   
;;;187      
;;;188      /* Reset HSEON, CSSON and PLLON bits */
;;;189      RCC->CR &= 0xFEF6FFFFU;
        0x08001de8:    4608        .F      MOV      r0,r1
        0x08001dea:    6800        .h      LDR      r0,[r0,#0]
        0x08001dec:    490c        .I      LDR      r1,[pc,#48] ; [0x8001e20] = 0xfef6ffff
        0x08001dee:    4008        .@      ANDS     r0,r0,r1
        0x08001df0:    4909        .I      LDR      r1,[pc,#36] ; [0x8001e18] = 0x40021000
        0x08001df2:    6008        .`      STR      r0,[r1,#0]
;;;190    
;;;191      /* Reset HSEBYP bit */
;;;192      RCC->CR &= 0xFFFBFFFFU;
        0x08001df4:    4608        .F      MOV      r0,r1
        0x08001df6:    6800        .h      LDR      r0,[r0,#0]
        0x08001df8:    f4202080     ..     BIC      r0,r0,#0x40000
        0x08001dfc:    6008        .`      STR      r0,[r1,#0]
;;;193    
;;;194      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;195      RCC->CFGR &= 0xFF80FFFFU;
        0x08001dfe:    4608        .F      MOV      r0,r1
        0x08001e00:    6840        @h      LDR      r0,[r0,#4]
        0x08001e02:    f42000fe     ...    BIC      r0,r0,#0x7f0000
        0x08001e06:    6048        H`      STR      r0,[r1,#4]
;;;196    
;;;197    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;198      /* Reset PLL2ON and PLL3ON bits */
;;;199      RCC->CR &= 0xEBFFFFFFU;
;;;200    
;;;201      /* Disable all interrupts and clear pending bits  */
;;;202      RCC->CIR = 0x00FF0000U;
;;;203    
;;;204      /* Reset CFGR2 register */
;;;205      RCC->CFGR2 = 0x00000000U;
;;;206    #elif defined(STM32F100xB) || defined(STM32F100xE)
;;;207      /* Disable all interrupts and clear pending bits  */
;;;208      RCC->CIR = 0x009F0000U;
;;;209    
;;;210      /* Reset CFGR2 register */
;;;211      RCC->CFGR2 = 0x00000000U;      
;;;212    #else
;;;213      /* Disable all interrupts and clear pending bits  */
;;;214      RCC->CIR = 0x009F0000U;
        0x08001e08:    f44f001f    O...    MOV      r0,#0x9f0000
        0x08001e0c:    6088        .`      STR      r0,[r1,#8]
;;;215    #endif /* STM32F105xC */
;;;216        
;;;217    #if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
;;;218      #ifdef DATA_IN_ExtSRAM
;;;219        SystemInit_ExtMemCtl(); 
;;;220      #endif /* DATA_IN_ExtSRAM */
;;;221    #endif 
;;;222    
;;;223    #ifdef VECT_TAB_SRAM
;;;224      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;225    #else
;;;226      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
        0x08001e0e:    03c8        ..      LSLS     r0,r1,#15
        0x08001e10:    4904        .I      LDR      r1,[pc,#16] ; [0x8001e24] = 0xe000ed08
        0x08001e12:    6008        .`      STR      r0,[r1,#0]
;;;227    #endif 
;;;228    }
        0x08001e14:    4770        pG      BX       lr
    $d
        0x08001e16:    0000        ..      DCW    0
        0x08001e18:    40021000    ...@    DCD    1073876992
        0x08001e1c:    f8ff0000    ....    DCD    4177461248
        0x08001e20:    fef6ffff    ....    DCD    4277600255
        0x08001e24:    e000ed08    ....    DCD    3758157064
    $t
    i.TIM1_UP_IRQHandler
    TIM1_UP_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;230    {
        0x08001e28:    b510        ..      PUSH     {r4,lr}
;;;231      /* USER CODE BEGIN TIM1_UP_IRQn 0 */
;;;232    
;;;233      /* USER CODE END TIM1_UP_IRQn 0 */
;;;234      /* USER CODE BEGIN TIM1_UP_IRQn 1 */
;;;235      if(LL_TIM_IsActiveFlag_UPDATE(TIM1) == 1)
        0x08001e2a:    4806        .H      LDR      r0,[pc,#24] ; [0x8001e44] = 0x40012c00
        0x08001e2c:    f7fff844    ..D.    BL       LL_TIM_IsActiveFlag_UPDATE ; 0x8000eb8
        0x08001e30:    2801        .(      CMP      r0,#1
        0x08001e32:    d105        ..      BNE      0x8001e40 ; TIM1_UP_IRQHandler + 24
;;;236      {
;;;237        /* Clear the update interrupt flag*/
;;;238        LL_TIM_ClearFlag_UPDATE(TIM1);
        0x08001e34:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001e36:    1ec0        ..      SUBS     r0,r0,#3
        0x08001e38:    4902        .I      LDR      r1,[pc,#8] ; [0x8001e44] = 0x40012c00
        0x08001e3a:    6108        .a      STR      r0,[r1,#0x10]
;;;2933   }
        0x08001e3c:    bf00        ..      NOP      
        0x08001e3e:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;242    }
        0x08001e40:    bd10        ..      POP      {r4,pc}
    $d
        0x08001e42:    0000        ..      DCW    0
        0x08001e44:    40012c00    .,.@    DCD    1073818624
    $t
    i.TIM2_IRQHandler
    TIM2_IRQHandler
;;;243    
;;;244    /**
;;;245      * @brief This function handles TIM2 global interrupt.
;;;246      */
;;;247    void TIM2_IRQHandler(void)
;;;248    {
        0x08001e48:    b510        ..      PUSH     {r4,lr}
;;;249      /* USER CODE BEGIN TIM2_IRQn 0 */
;;;250    // prescaler=((((speed=72000000)/((period=20000)/(1/hz=1)))+0,5)-1)
;;;251    //	if ( async_z == 1) {
;;;252    	if(TIM3->SMCR == 0x16) { // TIM3 connected to TIM2 as SLAVE
        0x08001e4a:    480f        .H      LDR      r0,[pc,#60] ; [0x8001e88] = 0x40000408
        0x08001e4c:    6800        .h      LDR      r0,[r0,#0]
        0x08001e4e:    2816        .(      CMP      r0,#0x16
        0x08001e50:    d10c        ..      BNE      0x8001e6c ; TIM2_IRQHandler + 36
;;;253    //	if ( state.async_z == 1) {
;;;254    //		state.f_encoder = encoder;
;;;255    //		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
;;;256    //		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;257    //		LED_GPIO_Port->BRR = LED_Pin;
;;;258    //    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
;;;259    //    LL_GPIO_TogglePin( LED_GPIO_Port, LED_Pin);
;;;260    
;;;261    		state.function(&state);
        0x08001e52:    480e        .H      LDR      r0,[pc,#56] ; [0x8001e8c] = 0x20000044
        0x08001e54:    6801        .h      LDR      r1,[r0,#0]
        0x08001e56:    4788        .G      BLX      r1
;;;262    
;;;263    		TIM2->ARR = state.z_period;
        0x08001e58:    480c        .H      LDR      r0,[pc,#48] ; [0x8001e8c] = 0x20000044
        0x08001e5a:    7b00        .{      LDRB     r0,[r0,#0xc]
        0x08001e5c:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08001e60:    62c8        .b      STR      r0,[r1,#0x2c]
;;;264    		TIM2->EGR |= TIM_EGR_UG;
        0x08001e62:    4608        .F      MOV      r0,r1
        0x08001e64:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001e66:    f0400001    @...    ORR      r0,r0,#1
        0x08001e6a:    6148        Ha      STR      r0,[r1,#0x14]
;;;265    
;;;266    //		state.set_pulse_function(&state);
;;;267    //		text_buffer[tbc++] = TIM2->ARR;
;;;268    	}
;;;269    
;;;270      /* USER CODE END TIM2_IRQn 0 */
;;;271      /* USER CODE BEGIN TIM2_IRQn 1 */
;;;272      /* Check whether update interrupt is pending */
;;;273      if(LL_TIM_IsActiveFlag_UPDATE(TIM2) == 1)
        0x08001e6c:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001e70:    f7fff822    ..".    BL       LL_TIM_IsActiveFlag_UPDATE ; 0x8000eb8
        0x08001e74:    2801        .(      CMP      r0,#1
        0x08001e76:    d106        ..      BNE      0x8001e86 ; TIM2_IRQHandler + 62
;;;274      {
;;;275        /* Clear the update interrupt flag*/
;;;276        LL_TIM_ClearFlag_UPDATE(TIM2);
        0x08001e78:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001e7a:    1ec0        ..      SUBS     r0,r0,#3
        0x08001e7c:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08001e80:    6108        .a      STR      r0,[r1,#0x10]
;;;2933   }
        0x08001e82:    bf00        ..      NOP      
        0x08001e84:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;279    }
        0x08001e86:    bd10        ..      POP      {r4,pc}
    $d
        0x08001e88:    40000408    ...@    DCD    1073742856
        0x08001e8c:    20000044    D..     DCD    536870980
    $t
    i.TIM3_IRQHandler
    TIM3_IRQHandler
;;;280    
;;;281    /**
;;;282      * @brief This function handles TIM3 global interrupt.
;;;283      */
;;;284    void TIM3_IRQHandler(void)
;;;285    {
;;;286      /* USER CODE BEGIN TIM3_IRQn 0 */
;;;287    
;;;288      /* USER CODE END TIM3_IRQn 0 */
;;;289      /* USER CODE BEGIN TIM3_IRQn 1 */
;;;290    
;;;291      /* USER CODE END TIM3_IRQn 1 */
;;;292    }
        0x08001e90:    4770        pG      BX       lr
        0x08001e92:    0000        ..      MOVS     r0,r0
    i.TIM4_IRQHandler
    TIM4_IRQHandler
;;;293    
;;;294    /**
;;;295      * @brief This function handles TIM4 global interrupt.
;;;296      */
;;;297    void TIM4_IRQHandler(void)
;;;298    {
        0x08001e94:    b510        ..      PUSH     {r4,lr}
;;;299      /* USER CODE BEGIN TIM4_IRQn 0 */
;;;300    //	_Bool dir = t4cr1[TIM_CR1_DIR_Pos];
;;;301    //	if(t4sr[TIM_SR_CC3IF_Pos]){
;;;302    //		do_fsm_wait_tacho(&state);
;;;303    //	}
;;;304    	if (state.sync == true) {
        0x08001e96:    480d        .H      LDR      r0,[pc,#52] ; [0x8001ecc] = 0x20000044
        0x08001e98:    7c00        .|      LDRB     r0,[r0,#0x10]
        0x08001e9a:    2801        .(      CMP      r0,#1
        0x08001e9c:    d112        ..      BNE      0x8001ec4 ; TIM4_IRQHandler + 48
;;;305    		state.spindle_dir = t4cr1[TIM_CR1_DIR_Pos];
        0x08001e9e:    480c        .H      LDR      r0,[pc,#48] ; [0x8001ed0] = 0x42010000
        0x08001ea0:    6900        .i      LDR      r0,[r0,#0x10]
        0x08001ea2:    b108        ..      CBZ      r0,0x8001ea8 ; TIM4_IRQHandler + 20
        0x08001ea4:    2001        .       MOVS     r0,#1
        0x08001ea6:    e000        ..      B        0x8001eaa ; TIM4_IRQHandler + 22
        0x08001ea8:    2000        .       MOVS     r0,#0
        0x08001eaa:    4908        .I      LDR      r1,[pc,#32] ; [0x8001ecc] = 0x20000044
        0x08001eac:    73c8        .s      STRB     r0,[r1,#0xf]
;;;306    //		state.f_encoder = encoder;
;;;307    		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
        0x08001eae:    4809        .H      LDR      r0,[pc,#36] ; [0x8001ed4] = 0x4201020c
        0x08001eb0:    6800        .h      LDR      r0,[r0,#0]
        0x08001eb2:    b108        ..      CBZ      r0,0x8001eb8 ; TIM4_IRQHandler + 36
        0x08001eb4:    2001        .       MOVS     r0,#1
        0x08001eb6:    e000        ..      B        0x8001eba ; TIM4_IRQHandler + 38
        0x08001eb8:    2000        .       MOVS     r0,#0
        0x08001eba:    4904        .I      LDR      r1,[pc,#16] ; [0x8001ecc] = 0x20000044
        0x08001ebc:    7388        .s      STRB     r0,[r1,#0xe]
;;;308    		state.function(&state);
        0x08001ebe:    4608        .F      MOV      r0,r1
        0x08001ec0:    6801        .h      LDR      r1,[r0,#0]
        0x08001ec2:    4788        .G      BLX      r1
;;;309    	}
;;;310    //	TIM4->SR &= ~TIM_SR_UIF; //   . 
;;;311    
;;;312      /* USER CODE END TIM4_IRQn 0 */
;;;313      /* USER CODE BEGIN TIM4_IRQn 1 */
;;;314      /* Check whether update interrupt is pending */
;;;315    //	if(LL_TIM_IsActiveFlag_CC2OVR(TIM4) == 1){
;;;316    //		TIM4->SR = 0;
;;;317    //	}
;;;318    	TIM4->SR = 0;
        0x08001ec4:    2000        .       MOVS     r0,#0
        0x08001ec6:    4904        .I      LDR      r1,[pc,#16] ; [0x8001ed8] = 0x40000810
        0x08001ec8:    6008        .`      STR      r0,[r1,#0]
;;;319    /*
;;;320    	if(LL_TIM_IsActiveFlag_CC2(TIM4) == 1)
;;;321        LL_TIM_ClearFlag_CC2(TIM4);
;;;322    	if(LL_TIM_IsActiveFlag_CC3(TIM4) == 1)
;;;323        LL_TIM_ClearFlag_CC3(TIM4);
;;;324    	if(LL_TIM_IsActiveFlag_UPDATE(TIM4) == 1)
;;;325      {
;;;326        LL_TIM_ClearFlag_UPDATE(TIM4); //Clear the update interrupt flag
;;;327      }
;;;328    */
;;;329      /* USER CODE END TIM4_IRQn 1 */
;;;330    }
        0x08001eca:    bd10        ..      POP      {r4,pc}
    $d
        0x08001ecc:    20000044    D..     DCD    536870980
        0x08001ed0:    42010000    ...B    DCD    1107361792
        0x08001ed4:    4201020c    ...B    DCD    1107362316
        0x08001ed8:    40000810    ...@    DCD    1073743888
    $t
    i.Transfer_Complete_Callback
    Transfer_Complete_Callback
;;; .\..\Src\i2c_interface.c
;;;321    {
        0x08001edc:    b510        ..      PUSH     {r4,lr}
;;;322      /* Generate Stop condition */
;;;323    	while(!LL_I2C_IsActiveFlag_BTF(I2C2))
        0x08001ede:    bf00        ..      NOP      
        0x08001ee0:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
        0x08001ee2:    480f        .H      LDR      r0,[pc,#60] ; [0x8001f20] = 0x40005800
        0x08001ee4:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001ee6:    f3c00080    ....    UBFX     r0,r0,#2,#1
        0x08001eea:    2800        .(      CMP      r0,#0
        0x08001eec:    d0f8        ..      BEQ      0x8001ee0 ; Transfer_Complete_Callback + 4
;;; .\..\Src\i2c_interface.c
;;;326      LL_I2C_GenerateStopCondition(I2C2);
        0x08001eee:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1596     SET_BIT(I2Cx->CR1, I2C_CR1_STOP);
        0x08001ef0:    480b        .H      LDR      r0,[pc,#44] ; [0x8001f20] = 0x40005800
        0x08001ef2:    6800        .h      LDR      r0,[r0,#0]
        0x08001ef4:    f4407000    @..p    ORR      r0,r0,#0x200
        0x08001ef8:    4909        .I      LDR      r1,[pc,#36] ; [0x8001f20] = 0x40005800
        0x08001efa:    6008        .`      STR      r0,[r1,#0]
;;;1597   }
        0x08001efc:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;327      LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x08001efe:    4809        .H      LDR      r0,[pc,#36] ; [0x8001f24] = 0x40020000
        0x08001f00:    2104        .!      MOVS     r1,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;491      CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x08001f02:    1e4a        J.      SUBS     r2,r1,#1
        0x08001f04:    4b08        .K      LDR      r3,[pc,#32] ; [0x8001f28] = 0x80030e8
        0x08001f06:    5c9a        .\      LDRB     r2,[r3,r2]
        0x08001f08:    5882        .X      LDR      r2,[r0,r2]
        0x08001f0a:    f0220301    "...    BIC      r3,r2,#1
        0x08001f0e:    1e4a        J.      SUBS     r2,r1,#1
        0x08001f10:    4c05        .L      LDR      r4,[pc,#20] ; [0x8001f28] = 0x80030e8
        0x08001f12:    5ca2        .\      LDRB     r2,[r4,r2]
        0x08001f14:    5083        .P      STR      r3,[r0,r2]
;;;492    }
        0x08001f16:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;329      ubTransferComplete = 1;
        0x08001f18:    2001        .       MOVS     r0,#1
        0x08001f1a:    4904        .I      LDR      r1,[pc,#16] ; [0x8001f2c] = 0x20000017
        0x08001f1c:    7008        .p      STRB     r0,[r1,#0]
;;;330    }
        0x08001f1e:    bd10        ..      POP      {r4,pc}
    $d
        0x08001f20:    40005800    .X.@    DCD    1073764352
        0x08001f24:    40020000    ...@    DCD    1073872896
        0x08001f28:    080030e8    .0..    DCD    134230248
        0x08001f2c:    20000017    ...     DCD    536870935
    $t
    i.Transfer_Error_Callback
    Transfer_Error_Callback
;;;331    
;;;332    /**
;;;333      * @brief  DMA transfer error callback
;;;334      * @note   This function is executed when the transfer error interrupt
;;;335      *         is generated during DMA transfer
;;;336      * @retval None
;;;337      */
;;;338    void Transfer_Error_Callback()
;;;339    {
;;;340      /* Disable DMA1_Channel4_IRQn */
;;;341      NVIC_DisableIRQ(DMA1_Channel4_IRQn);
        0x08001f30:    200e        .       MOVS     r0,#0xe
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08001f32:    2101        .!      MOVS     r1,#1
        0x08001f34:    4081        .@      LSLS     r1,r1,r0
        0x08001f36:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001f44] = 0xe000e180
        0x08001f38:    0943        C.      LSRS     r3,r0,#5
        0x08001f3a:    f8421023    B.#.    STR      r1,[r2,r3,LSL #2]
;;;1466   }
        0x08001f3e:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;343      while(1){};
        0x08001f40:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c (343)
        0x08001f42:    e7fe        ..      B        0x8001f42 ; Transfer_Error_Callback + 18
    $d
        0x08001f44:    e000e180    ....    DCD    3758154112
    $t
    i.USART2_IRQHandler
    USART2_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;381    {
        0x08001f48:    b510        ..      PUSH     {r4,lr}
;;;382      /* USER CODE BEGIN USART2_IRQn 0 */
;;;383      if(LL_USART_IsActiveFlag_RXNE(USART2) && LL_USART_IsEnabledIT_RXNE(USART2))
        0x08001f4a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1859     return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
        0x08001f4c:    4806        .H      LDR      r0,[pc,#24] ; [0x8001f68] = 0x40004400
        0x08001f4e:    6800        .h      LDR      r0,[r0,#0]
        0x08001f50:    f3c01040    ..@.    UBFX     r0,r0,#5,#1
        0x08001f54:    b138        8.      CBZ      r0,0x8001f66 ; USART2_IRQHandler + 30
        0x08001f56:    bf00        ..      NOP      
;;;1860   }
;;;1861   
;;;1862   /**
;;;1863     * @brief  Check if the USART Transmission Complete Flag is set or not
;;;1864     * @rmtoll SR           TC            LL_USART_IsActiveFlag_TC
;;;1865     * @param  USARTx USART Instance
;;;1866     * @retval State of bit (1 or 0).
;;;1867     */
;;;1868   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
;;;1869   {
;;;1870     return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
;;;1871   }
;;;1872   
;;;1873   /**
;;;1874     * @brief  Check if the USART Transmit Data Register Empty Flag is set or not
;;;1875     * @rmtoll SR           TXE           LL_USART_IsActiveFlag_TXE
;;;1876     * @param  USARTx USART Instance
;;;1877     * @retval State of bit (1 or 0).
;;;1878     */
;;;1879   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
;;;1880   {
;;;1881     return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
;;;1882   }
;;;1883   
;;;1884   /**
;;;1885     * @brief  Check if the USART LIN Break Detection Flag is set or not
;;;1886     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;1887     *         LIN feature is supported by the USARTx instance.
;;;1888     * @rmtoll SR           LBD           LL_USART_IsActiveFlag_LBD
;;;1889     * @param  USARTx USART Instance
;;;1890     * @retval State of bit (1 or 0).
;;;1891     */
;;;1892   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx)
;;;1893   {
;;;1894     return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
;;;1895   }
;;;1896   
;;;1897   /**
;;;1898     * @brief  Check if the USART CTS Flag is set or not
;;;1899     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;1900     *         Hardware Flow control feature is supported by the USARTx instance.
;;;1901     * @rmtoll SR           CTS           LL_USART_IsActiveFlag_nCTS
;;;1902     * @param  USARTx USART Instance
;;;1903     * @retval State of bit (1 or 0).
;;;1904     */
;;;1905   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx)
;;;1906   {
;;;1907     return (READ_BIT(USARTx->SR, USART_SR_CTS) == (USART_SR_CTS));
;;;1908   }
;;;1909   
;;;1910   /**
;;;1911     * @brief  Check if the USART Send Break Flag is set or not
;;;1912     * @rmtoll CR1          SBK           LL_USART_IsActiveFlag_SBK
;;;1913     * @param  USARTx USART Instance
;;;1914     * @retval State of bit (1 or 0).
;;;1915     */
;;;1916   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx)
;;;1917   {
;;;1918     return (READ_BIT(USARTx->CR1, USART_CR1_SBK) == (USART_CR1_SBK));
;;;1919   }
;;;1920   
;;;1921   /**
;;;1922     * @brief  Check if the USART Receive Wake Up from mute mode Flag is set or not
;;;1923     * @rmtoll CR1          RWU           LL_USART_IsActiveFlag_RWU
;;;1924     * @param  USARTx USART Instance
;;;1925     * @retval State of bit (1 or 0).
;;;1926     */
;;;1927   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx)
;;;1928   {
;;;1929     return (READ_BIT(USARTx->CR1, USART_CR1_RWU) == (USART_CR1_RWU));
;;;1930   }
;;;1931   
;;;1932   /**
;;;1933     * @brief  Clear Parity Error Flag
;;;1934     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1935     *         register followed by a read access to the USARTx_DR register.
;;;1936     * @note   Please also consider that when clearing this flag, other flags as 
;;;1937     *         NE, FE, ORE, IDLE would also be cleared.
;;;1938     * @rmtoll SR           PE            LL_USART_ClearFlag_PE
;;;1939     * @param  USARTx USART Instance
;;;1940     * @retval None
;;;1941     */
;;;1942   __STATIC_INLINE void LL_USART_ClearFlag_PE(USART_TypeDef *USARTx)
;;;1943   {
;;;1944     __IO uint32_t tmpreg;
;;;1945     tmpreg = USARTx->SR;
;;;1946     (void) tmpreg;
;;;1947     tmpreg = USARTx->DR;
;;;1948     (void) tmpreg;
;;;1949   }
;;;1950   
;;;1951   /**
;;;1952     * @brief  Clear Framing Error Flag
;;;1953     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1954     *         register followed by a read access to the USARTx_DR register.
;;;1955     * @note   Please also consider that when clearing this flag, other flags as 
;;;1956     *         PE, NE, ORE, IDLE would also be cleared.
;;;1957     * @rmtoll SR           FE            LL_USART_ClearFlag_FE
;;;1958     * @param  USARTx USART Instance
;;;1959     * @retval None
;;;1960     */
;;;1961   __STATIC_INLINE void LL_USART_ClearFlag_FE(USART_TypeDef *USARTx)
;;;1962   {
;;;1963     __IO uint32_t tmpreg;
;;;1964     tmpreg = USARTx->SR;
;;;1965     (void) tmpreg;
;;;1966     tmpreg = USARTx->DR;
;;;1967     (void) tmpreg;
;;;1968   }
;;;1969   
;;;1970   /**
;;;1971     * @brief  Clear Noise detected Flag
;;;1972     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1973     *         register followed by a read access to the USARTx_DR register.
;;;1974     * @note   Please also consider that when clearing this flag, other flags as 
;;;1975     *         PE, FE, ORE, IDLE would also be cleared.
;;;1976     * @rmtoll SR           NF            LL_USART_ClearFlag_NE
;;;1977     * @param  USARTx USART Instance
;;;1978     * @retval None
;;;1979     */
;;;1980   __STATIC_INLINE void LL_USART_ClearFlag_NE(USART_TypeDef *USARTx)
;;;1981   {
;;;1982     __IO uint32_t tmpreg;
;;;1983     tmpreg = USARTx->SR;
;;;1984     (void) tmpreg;
;;;1985     tmpreg = USARTx->DR;
;;;1986     (void) tmpreg;
;;;1987   }
;;;1988   
;;;1989   /**
;;;1990     * @brief  Clear OverRun Error Flag
;;;1991     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1992     *         register followed by a read access to the USARTx_DR register.
;;;1993     * @note   Please also consider that when clearing this flag, other flags as 
;;;1994     *         PE, NE, FE, IDLE would also be cleared.
;;;1995     * @rmtoll SR           ORE           LL_USART_ClearFlag_ORE
;;;1996     * @param  USARTx USART Instance
;;;1997     * @retval None
;;;1998     */
;;;1999   __STATIC_INLINE void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
;;;2000   {
;;;2001     __IO uint32_t tmpreg;
;;;2002     tmpreg = USARTx->SR;
;;;2003     (void) tmpreg;
;;;2004     tmpreg = USARTx->DR;
;;;2005     (void) tmpreg;
;;;2006   }
;;;2007   
;;;2008   /**
;;;2009     * @brief  Clear IDLE line detected Flag
;;;2010     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;2011     *         register followed by a read access to the USARTx_DR register.
;;;2012     * @note   Please also consider that when clearing this flag, other flags as 
;;;2013     *         PE, NE, FE, ORE would also be cleared.
;;;2014     * @rmtoll SR           IDLE          LL_USART_ClearFlag_IDLE
;;;2015     * @param  USARTx USART Instance
;;;2016     * @retval None
;;;2017     */
;;;2018   __STATIC_INLINE void LL_USART_ClearFlag_IDLE(USART_TypeDef *USARTx)
;;;2019   {
;;;2020     __IO uint32_t tmpreg;
;;;2021     tmpreg = USARTx->SR;
;;;2022     (void) tmpreg;
;;;2023     tmpreg = USARTx->DR;
;;;2024     (void) tmpreg;
;;;2025   }
;;;2026   
;;;2027   /**
;;;2028     * @brief  Clear Transmission Complete Flag
;;;2029     * @rmtoll SR           TC            LL_USART_ClearFlag_TC
;;;2030     * @param  USARTx USART Instance
;;;2031     * @retval None
;;;2032     */
;;;2033   __STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
;;;2034   {
;;;2035     WRITE_REG(USARTx->SR , ~(USART_SR_TC));
;;;2036   }
;;;2037   
;;;2038   /**
;;;2039     * @brief  Clear RX Not Empty Flag
;;;2040     * @rmtoll SR           RXNE          LL_USART_ClearFlag_RXNE
;;;2041     * @param  USARTx USART Instance
;;;2042     * @retval None
;;;2043     */
;;;2044   __STATIC_INLINE void LL_USART_ClearFlag_RXNE(USART_TypeDef *USARTx)
;;;2045   {
;;;2046     WRITE_REG(USARTx->SR , ~(USART_SR_RXNE));
;;;2047   }
;;;2048   
;;;2049   /**
;;;2050     * @brief  Clear LIN Break Detection Flag
;;;2051     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2052     *         LIN feature is supported by the USARTx instance.
;;;2053     * @rmtoll SR           LBD           LL_USART_ClearFlag_LBD
;;;2054     * @param  USARTx USART Instance
;;;2055     * @retval None
;;;2056     */
;;;2057   __STATIC_INLINE void LL_USART_ClearFlag_LBD(USART_TypeDef *USARTx)
;;;2058   {
;;;2059     WRITE_REG(USARTx->SR , ~(USART_SR_LBD));
;;;2060   }
;;;2061   
;;;2062   /**
;;;2063     * @brief  Clear CTS Interrupt Flag
;;;2064     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;2065     *         Hardware Flow control feature is supported by the USARTx instance.
;;;2066     * @rmtoll SR           CTS           LL_USART_ClearFlag_nCTS
;;;2067     * @param  USARTx USART Instance
;;;2068     * @retval None
;;;2069     */
;;;2070   __STATIC_INLINE void LL_USART_ClearFlag_nCTS(USART_TypeDef *USARTx)
;;;2071   {
;;;2072     WRITE_REG(USARTx->SR , ~(USART_SR_CTS));
;;;2073   }
;;;2074   
;;;2075   /**
;;;2076     * @}
;;;2077     */
;;;2078   
;;;2079   /** @defgroup USART_LL_EF_IT_Management IT_Management
;;;2080     * @{
;;;2081     */
;;;2082   
;;;2083   /**
;;;2084     * @brief  Enable IDLE Interrupt
;;;2085     * @rmtoll CR1          IDLEIE        LL_USART_EnableIT_IDLE
;;;2086     * @param  USARTx USART Instance
;;;2087     * @retval None
;;;2088     */
;;;2089   __STATIC_INLINE void LL_USART_EnableIT_IDLE(USART_TypeDef *USARTx)
;;;2090   {
;;;2091     SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @brief  Enable RX Not Empty Interrupt
;;;2096     * @rmtoll CR1          RXNEIE        LL_USART_EnableIT_RXNE
;;;2097     * @param  USARTx USART Instance
;;;2098     * @retval None
;;;2099     */
;;;2100   __STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
;;;2101   {
;;;2102     SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
;;;2103   }
;;;2104   
;;;2105   /**
;;;2106     * @brief  Enable Transmission Complete Interrupt
;;;2107     * @rmtoll CR1          TCIE          LL_USART_EnableIT_TC
;;;2108     * @param  USARTx USART Instance
;;;2109     * @retval None
;;;2110     */
;;;2111   __STATIC_INLINE void LL_USART_EnableIT_TC(USART_TypeDef *USARTx)
;;;2112   {
;;;2113     SET_BIT(USARTx->CR1, USART_CR1_TCIE);
;;;2114   }
;;;2115   
;;;2116   /**
;;;2117     * @brief  Enable TX Empty Interrupt
;;;2118     * @rmtoll CR1          TXEIE         LL_USART_EnableIT_TXE
;;;2119     * @param  USARTx USART Instance
;;;2120     * @retval None
;;;2121     */
;;;2122   __STATIC_INLINE void LL_USART_EnableIT_TXE(USART_TypeDef *USARTx)
;;;2123   {
;;;2124     SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
;;;2125   }
;;;2126   
;;;2127   /**
;;;2128     * @brief  Enable Parity Error Interrupt
;;;2129     * @rmtoll CR1          PEIE          LL_USART_EnableIT_PE
;;;2130     * @param  USARTx USART Instance
;;;2131     * @retval None
;;;2132     */
;;;2133   __STATIC_INLINE void LL_USART_EnableIT_PE(USART_TypeDef *USARTx)
;;;2134   {
;;;2135     SET_BIT(USARTx->CR1, USART_CR1_PEIE);
;;;2136   }
;;;2137   
;;;2138   /**
;;;2139     * @brief  Enable LIN Break Detection Interrupt
;;;2140     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2141     *         LIN feature is supported by the USARTx instance.
;;;2142     * @rmtoll CR2          LBDIE         LL_USART_EnableIT_LBD
;;;2143     * @param  USARTx USART Instance
;;;2144     * @retval None
;;;2145     */
;;;2146   __STATIC_INLINE void LL_USART_EnableIT_LBD(USART_TypeDef *USARTx)
;;;2147   {
;;;2148     SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
;;;2149   }
;;;2150   
;;;2151   /**
;;;2152     * @brief  Enable Error Interrupt
;;;2153     * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
;;;2154     *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register).
;;;2155     *           0: Interrupt is inhibited
;;;2156     *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.
;;;2157     * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
;;;2158     * @param  USARTx USART Instance
;;;2159     * @retval None
;;;2160     */
;;;2161   __STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
;;;2162   {
;;;2163     SET_BIT(USARTx->CR3, USART_CR3_EIE);
;;;2164   }
;;;2165   
;;;2166   /**
;;;2167     * @brief  Enable CTS Interrupt
;;;2168     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;2169     *         Hardware Flow control feature is supported by the USARTx instance.
;;;2170     * @rmtoll CR3          CTSIE         LL_USART_EnableIT_CTS
;;;2171     * @param  USARTx USART Instance
;;;2172     * @retval None
;;;2173     */
;;;2174   __STATIC_INLINE void LL_USART_EnableIT_CTS(USART_TypeDef *USARTx)
;;;2175   {
;;;2176     SET_BIT(USARTx->CR3, USART_CR3_CTSIE);
;;;2177   }
;;;2178   
;;;2179   /**
;;;2180     * @brief  Disable IDLE Interrupt
;;;2181     * @rmtoll CR1          IDLEIE        LL_USART_DisableIT_IDLE
;;;2182     * @param  USARTx USART Instance
;;;2183     * @retval None
;;;2184     */
;;;2185   __STATIC_INLINE void LL_USART_DisableIT_IDLE(USART_TypeDef *USARTx)
;;;2186   {
;;;2187     CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
;;;2188   }
;;;2189   
;;;2190   /**
;;;2191     * @brief  Disable RX Not Empty Interrupt
;;;2192     * @rmtoll CR1          RXNEIE        LL_USART_DisableIT_RXNE
;;;2193     * @param  USARTx USART Instance
;;;2194     * @retval None
;;;2195     */
;;;2196   __STATIC_INLINE void LL_USART_DisableIT_RXNE(USART_TypeDef *USARTx)
;;;2197   {
;;;2198     CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
;;;2199   }
;;;2200   
;;;2201   /**
;;;2202     * @brief  Disable Transmission Complete Interrupt
;;;2203     * @rmtoll CR1          TCIE          LL_USART_DisableIT_TC
;;;2204     * @param  USARTx USART Instance
;;;2205     * @retval None
;;;2206     */
;;;2207   __STATIC_INLINE void LL_USART_DisableIT_TC(USART_TypeDef *USARTx)
;;;2208   {
;;;2209     CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
;;;2210   }
;;;2211   
;;;2212   /**
;;;2213     * @brief  Disable TX Empty Interrupt
;;;2214     * @rmtoll CR1          TXEIE         LL_USART_DisableIT_TXE
;;;2215     * @param  USARTx USART Instance
;;;2216     * @retval None
;;;2217     */
;;;2218   __STATIC_INLINE void LL_USART_DisableIT_TXE(USART_TypeDef *USARTx)
;;;2219   {
;;;2220     CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE);
;;;2221   }
;;;2222   
;;;2223   /**
;;;2224     * @brief  Disable Parity Error Interrupt
;;;2225     * @rmtoll CR1          PEIE          LL_USART_DisableIT_PE
;;;2226     * @param  USARTx USART Instance
;;;2227     * @retval None
;;;2228     */
;;;2229   __STATIC_INLINE void LL_USART_DisableIT_PE(USART_TypeDef *USARTx)
;;;2230   {
;;;2231     CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
;;;2232   }
;;;2233   
;;;2234   /**
;;;2235     * @brief  Disable LIN Break Detection Interrupt
;;;2236     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2237     *         LIN feature is supported by the USARTx instance.
;;;2238     * @rmtoll CR2          LBDIE         LL_USART_DisableIT_LBD
;;;2239     * @param  USARTx USART Instance
;;;2240     * @retval None
;;;2241     */
;;;2242   __STATIC_INLINE void LL_USART_DisableIT_LBD(USART_TypeDef *USARTx)
;;;2243   {
;;;2244     CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
;;;2245   }
;;;2246   
;;;2247   /**
;;;2248     * @brief  Disable Error Interrupt
;;;2249     * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
;;;2250     *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register).
;;;2251     *           0: Interrupt is inhibited
;;;2252     *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.
;;;2253     * @rmtoll CR3          EIE           LL_USART_DisableIT_ERROR
;;;2254     * @param  USARTx USART Instance
;;;2255     * @retval None
;;;2256     */
;;;2257   __STATIC_INLINE void LL_USART_DisableIT_ERROR(USART_TypeDef *USARTx)
;;;2258   {
;;;2259     CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
;;;2260   }
;;;2261   
;;;2262   /**
;;;2263     * @brief  Disable CTS Interrupt
;;;2264     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;2265     *         Hardware Flow control feature is supported by the USARTx instance.
;;;2266     * @rmtoll CR3          CTSIE         LL_USART_DisableIT_CTS
;;;2267     * @param  USARTx USART Instance
;;;2268     * @retval None
;;;2269     */
;;;2270   __STATIC_INLINE void LL_USART_DisableIT_CTS(USART_TypeDef *USARTx)
;;;2271   {
;;;2272     CLEAR_BIT(USARTx->CR3, USART_CR3_CTSIE);
;;;2273   }
;;;2274   
;;;2275   /**
;;;2276     * @brief  Check if the USART IDLE Interrupt  source is enabled or disabled.
;;;2277     * @rmtoll CR1          IDLEIE        LL_USART_IsEnabledIT_IDLE
;;;2278     * @param  USARTx USART Instance
;;;2279     * @retval State of bit (1 or 0).
;;;2280     */
;;;2281   __STATIC_INLINE uint32_t LL_USART_IsEnabledIT_IDLE(USART_TypeDef *USARTx)
;;;2282   {
;;;2283     return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
;;;2284   }
;;;2285   
;;;2286   /**
;;;2287     * @brief  Check if the USART RX Not Empty Interrupt is enabled or disabled.
;;;2288     * @rmtoll CR1          RXNEIE        LL_USART_IsEnabledIT_RXNE
;;;2289     * @param  USARTx USART Instance
;;;2290     * @retval State of bit (1 or 0).
;;;2291     */
;;;2292   __STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx)
;;;2293   {
;;;2294     return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
        0x08001f58:    4803        .H      LDR      r0,[pc,#12] ; [0x8001f68] = 0x40004400
        0x08001f5a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08001f5c:    f3c01040    ..@.    UBFX     r0,r0,#5,#1
        0x08001f60:    b108        ..      CBZ      r0,0x8001f66 ; USART2_IRQHandler + 30
;;; .\../Src/stm32f1xx_it.c
;;;387        USART_CharReception_Callback();
        0x08001f62:    f000f803    ....    BL       USART_CharReception_Callback ; 0x8001f6c
;;;388      }
;;;389    
;;;390      /* USER CODE END USART2_IRQn 0 */
;;;391      /* USER CODE BEGIN USART2_IRQn 1 */
;;;392    
;;;393      /* USER CODE END USART2_IRQn 1 */
;;;394    }
        0x08001f66:    bd10        ..      POP      {r4,pc}
    $d
        0x08001f68:    40004400    .D.@    DCD    1073759232
    $t
    i.USART_CharReception_Callback
    USART_CharReception_Callback
;;; .\../Src/main.c
;;;203    {
        0x08001f6c:    b510        ..      PUSH     {r4,lr}
;;;204    	uint8_t *ptemp;
;;;205    
;;;206      /* Read Received character. RXNE flag is cleared by reading of DR register */
;;;207      pBufferReadyForReception[uwNbReceivedChars++] = LL_USART_ReceiveData8(USART2);
        0x08001f6e:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2470     return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
        0x08001f70:    4a13        .J      LDR      r2,[pc,#76] ; [0x8001fc0] = 0x40004400
        0x08001f72:    6852        Rh      LDR      r2,[r2,#4]
        0x08001f74:    b2d2        ..      UXTB     r2,r2
        0x08001f76:    4b13        .K      LDR      r3,[pc,#76] ; [0x8001fc4] = 0x200004dc
        0x08001f78:    6819        .h      LDR      r1,[r3,#0]
        0x08001f7a:    1c4b        K.      ADDS     r3,r1,#1
        0x08001f7c:    4c11        .L      LDR      r4,[pc,#68] ; [0x8001fc4] = 0x200004dc
        0x08001f7e:    6023        #`      STR      r3,[r4,#0]
        0x08001f80:    4b11        .K      LDR      r3,[pc,#68] ; [0x8001fc8] = 0x200004e8
        0x08001f82:    681b        .h      LDR      r3,[r3,#0]
        0x08001f84:    545a        ZT      STRB     r2,[r3,r1]
;;; .\../Src/main.c
;;;210      if (uwNbReceivedChars >= RX_BUFFER_SIZE)
        0x08001f86:    4621        !F      MOV      r1,r4
        0x08001f88:    6809        .h      LDR      r1,[r1,#0]
        0x08001f8a:    290c        .)      CMP      r1,#0xc
        0x08001f8c:    d30d        ..      BCC      0x8001faa ; USART_CharReception_Callback + 62
;;;211      {
;;;212        /* Set Buffer swap indication */
;;;213        uwBufferReadyIndication = 1;
        0x08001f8e:    2101        .!      MOVS     r1,#1
        0x08001f90:    4a0e        .J      LDR      r2,[pc,#56] ; [0x8001fcc] = 0x200004e0
        0x08001f92:    6011        .`      STR      r1,[r2,#0]
;;;214    
;;;215        /* Swap buffers for next bytes to be received */
;;;216        ptemp = pBufferReadyForUser;
        0x08001f94:    490e        .I      LDR      r1,[pc,#56] ; [0x8001fd0] = 0x200004e4
        0x08001f96:    6808        .h      LDR      r0,[r1,#0]
;;;217        pBufferReadyForUser = pBufferReadyForReception;
        0x08001f98:    490b        .I      LDR      r1,[pc,#44] ; [0x8001fc8] = 0x200004e8
        0x08001f9a:    6809        .h      LDR      r1,[r1,#0]
        0x08001f9c:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8001fd0] = 0x200004e4
        0x08001f9e:    6011        .`      STR      r1,[r2,#0]
;;;218        pBufferReadyForReception = ptemp;
        0x08001fa0:    4909        .I      LDR      r1,[pc,#36] ; [0x8001fc8] = 0x200004e8
        0x08001fa2:    6008        .`      STR      r0,[r1,#0]
;;;219        uwNbReceivedChars = 0;
        0x08001fa4:    2100        .!      MOVS     r1,#0
        0x08001fa6:    4622        "F      MOV      r2,r4
        0x08001fa8:    6011        .`      STR      r1,[r2,#0]
;;;220      }
;;;221    
;;;222      /* Echo received character on TX */
;;;223      LL_USART_TransmitData8(USART2, pBufferReadyForReception[uwNbReceivedChars-1]);
        0x08001faa:    4a06        .J      LDR      r2,[pc,#24] ; [0x8001fc4] = 0x200004dc
        0x08001fac:    6812        .h      LDR      r2,[r2,#0]
        0x08001fae:    1e52        R.      SUBS     r2,r2,#1
        0x08001fb0:    4b05        .K      LDR      r3,[pc,#20] ; [0x8001fc8] = 0x200004e8
        0x08001fb2:    681b        .h      LDR      r3,[r3,#0]
        0x08001fb4:    5c99        .\      LDRB     r1,[r3,r2]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2493     USARTx->DR = Value;
        0x08001fb6:    4a02        .J      LDR      r2,[pc,#8] ; [0x8001fc0] = 0x40004400
        0x08001fb8:    6051        Q`      STR      r1,[r2,#4]
;;;2494   }
        0x08001fba:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;224    }
        0x08001fbc:    bd10        ..      POP      {r4,pc}
    $d
        0x08001fbe:    0000        ..      DCW    0
        0x08001fc0:    40004400    .D.@    DCD    1073759232
        0x08001fc4:    200004dc    ...     DCD    536872156
        0x08001fc8:    200004e8    ...     DCD    536872168
        0x08001fcc:    200004e0    ...     DCD    536872160
        0x08001fd0:    200004e4    ...     DCD    536872164
    $t
    i.__scatterload_copy
    __scatterload_copy
        0x08001fd4:    e002        ..      B        0x8001fdc ; __scatterload_copy + 8
        0x08001fd6:    c808        ..      LDM      r0!,{r3}
        0x08001fd8:    1f12        ..      SUBS     r2,r2,#4
        0x08001fda:    c108        ..      STM      r1!,{r3}
        0x08001fdc:    2a00        .*      CMP      r2,#0
        0x08001fde:    d1fa        ..      BNE      0x8001fd6 ; __scatterload_copy + 2
        0x08001fe0:    4770        pG      BX       lr
    i.__scatterload_null
    __scatterload_null
        0x08001fe2:    4770        pG      BX       lr
    i.__scatterload_zeroinit
    __scatterload_zeroinit
        0x08001fe4:    2000        .       MOVS     r0,#0
        0x08001fe6:    e001        ..      B        0x8001fec ; __scatterload_zeroinit + 8
        0x08001fe8:    c101        ..      STM      r1!,{r0}
        0x08001fea:    1f12        ..      SUBS     r2,r2,#4
        0x08001fec:    2a00        .*      CMP      r2,#0
        0x08001fee:    d1fb        ..      BNE      0x8001fe8 ; __scatterload_zeroinit + 4
        0x08001ff0:    4770        pG      BX       lr
        0x08001ff2:    0000        ..      MOVS     r0,r0
    i.do_fsm_menu
    do_fsm_menu
;;; .\..\Src\fsm.c
;;;69     {
        0x08001ff4:    b570        p.      PUSH     {r4-r6,lr}
        0x08001ff6:    4604        .F      MOV      r4,r0
;;;70     	uint8_t level = Thread_Info[Menu_Step].level;
        0x08001ff8:    4875        uH      LDR      r0,[pc,#468] ; [0x80021d0] = 0x200000b4
        0x08001ffa:    4976        vI      LDR      r1,[pc,#472] ; [0x80021d4] = 0x200004d4
        0x08001ffc:    7809        .x      LDRB     r1,[r1,#0]
        0x08001ffe:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08002002:    7c45        E|      LDRB     r5,[r0,#0x11]
;;;71     #ifdef _SIMU
;;;72     	buttons_flag_set = long_press_start_Msk;
        0x08002004:    2001        .       MOVS     r0,#1
        0x08002006:    4974        tI      LDR      r1,[pc,#464] ; [0x80021d8] = 0x200005dc
        0x08002008:    6008        .`      STR      r0,[r1,#0]
;;;73     #endif	
;;;74     	switch(buttons_flag_set) {
        0x0800200a:    4608        .F      MOV      r0,r1
        0x0800200c:    6800        .h      LDR      r0,[r0,#0]
        0x0800200e:    2808        .(      CMP      r0,#8
        0x08002010:    d077        w.      BEQ      0x8002102 ; do_fsm_menu + 270
        0x08002012:    dc06        ..      BGT      0x8002022 ; do_fsm_menu + 46
        0x08002014:    2801        .(      CMP      r0,#1
        0x08002016:    d07f        ..      BEQ      0x8002118 ; do_fsm_menu + 292
        0x08002018:    2802        .(      CMP      r0,#2
        0x0800201a:    d070        p.      BEQ      0x80020fe ; do_fsm_menu + 266
        0x0800201c:    2804        .(      CMP      r0,#4
        0x0800201e:    d110        ..      BNE      0x8002042 ; do_fsm_menu + 78
        0x08002020:    e01a        ..      B        0x8002058 ; do_fsm_menu + 100
        0x08002022:    2811        .(      CMP      r0,#0x11
        0x08002024:    d077        w.      BEQ      0x8002116 ; do_fsm_menu + 290
        0x08002026:    2840        @(      CMP      r0,#0x40
        0x08002028:    d00c        ..      BEQ      0x8002044 ; do_fsm_menu + 80
        0x0800202a:    f5b06f80    ...o    CMP      r0,#0x400
        0x0800202e:    d1f6        ..      BNE      0x800201e ; do_fsm_menu + 42
;;;75     	case single_click_Msk3: {
;;;76     		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x08002030:    486a        jH      LDR      r0,[pc,#424] ; [0x80021dc] = 0x200000a1
        0x08002032:    7800        .x      LDRB     r0,[r0,#0]
        0x08002034:    f0800001    ....    EOR      r0,r0,#1
        0x08002038:    4968        hI      LDR      r1,[pc,#416] ; [0x80021dc] = 0x200000a1
        0x0800203a:    7008        .p      STRB     r0,[r1,#0]
;;;77     		menu_changed = 1;
        0x0800203c:    2001        .       MOVS     r0,#1
        0x0800203e:    4968        hI      LDR      r1,[pc,#416] ; [0x80021e0] = 0x200000a4
        0x08002040:    6008        .`      STR      r0,[r1,#0]
;;;78     		break;
        0x08002042:    e0c3        ..      B        0x80021cc ; do_fsm_menu + 472
;;;79     	}
;;;80     	case single_click_Msk2: {
;;;81     		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x08002044:    4865        eH      LDR      r0,[pc,#404] ; [0x80021dc] = 0x200000a1
        0x08002046:    7800        .x      LDRB     r0,[r0,#0]
        0x08002048:    f0800001    ....    EOR      r0,r0,#1
        0x0800204c:    4963        cI      LDR      r1,[pc,#396] ; [0x80021dc] = 0x200000a1
        0x0800204e:    7008        .p      STRB     r0,[r1,#0]
;;;82     		menu_changed = 1;
        0x08002050:    2001        .       MOVS     r0,#1
        0x08002052:    4963        cI      LDR      r1,[pc,#396] ; [0x80021e0] = 0x200000a4
        0x08002054:    6008        .`      STR      r0,[r1,#0]
;;;83     		break;
        0x08002056:    e0b9        ..      B        0x80021cc ; do_fsm_menu + 472
;;;84     	}
;;;85     	case single_click_Msk: {
;;;86     		if(z_axis.end_pos != 0) {
        0x08002058:    4862        bH      LDR      r0,[pc,#392] ; [0x80021e4] = 0x200005e0
        0x0800205a:    6840        @h      LDR      r0,[r0,#4]
        0x0800205c:    b1e0        ..      CBZ      r0,0x8002098 ; do_fsm_menu + 164
;;;87     			// first pass of thread cut was complete, so just use single click
;;;88     			//	to switch between modes to process all other cuts
;;;89     
;;;90     //			z_move(feed_direction, z_axis.end_pos, s->main_feed_direction == feed_direction ? true : false, true);
;;;91     			if(demo)
        0x0800205e:    4862        bH      LDR      r0,[pc,#392] ; [0x80021e8] = 0x20000041
        0x08002060:    7800        .x      LDRB     r0,[r0,#0]
        0x08002062:    b140        @.      CBZ      r0,0x8002076 ; do_fsm_menu + 130
;;;92     				z_move(feed_direction, z_axis.end_pos, false, true); //test case, always async
        0x08002064:    485f        _H      LDR      r0,[pc,#380] ; [0x80021e4] = 0x200005e0
        0x08002066:    2301        .#      MOVS     r3,#1
        0x08002068:    2200        ."      MOVS     r2,#0
        0x0800206a:    6841        Ah      LDR      r1,[r0,#4]
        0x0800206c:    485b        [H      LDR      r0,[pc,#364] ; [0x80021dc] = 0x200000a1
        0x0800206e:    7800        .x      LDRB     r0,[r0,#0]
        0x08002070:    f000ffde    ....    BL       z_move ; 0x8003030
        0x08002074:    e040        @.      B        0x80020f8 ; do_fsm_menu + 260
;;;93     			else
;;;94     				z_move(feed_direction, z_axis.end_pos, s->main_feed_direction == feed_direction ? true : false, true);
        0x08002076:    7c60        `|      LDRB     r0,[r4,#0x11]
        0x08002078:    4b58        XK      LDR      r3,[pc,#352] ; [0x80021dc] = 0x200000a1
        0x0800207a:    781b        .x      LDRB     r3,[r3,#0]
        0x0800207c:    4298        .B      CMP      r0,r3
        0x0800207e:    d101        ..      BNE      0x8002084 ; do_fsm_menu + 144
        0x08002080:    2001        .       MOVS     r0,#1
        0x08002082:    e000        ..      B        0x8002086 ; do_fsm_menu + 146
        0x08002084:    2000        .       MOVS     r0,#0
        0x08002086:    4602        .F      MOV      r2,r0
        0x08002088:    4856        VH      LDR      r0,[pc,#344] ; [0x80021e4] = 0x200005e0
        0x0800208a:    2301        .#      MOVS     r3,#1
        0x0800208c:    6841        Ah      LDR      r1,[r0,#4]
        0x0800208e:    4853        SH      LDR      r0,[pc,#332] ; [0x80021dc] = 0x200000a1
        0x08002090:    7800        .x      LDRB     r0,[r0,#0]
        0x08002092:    f000ffcd    ....    BL       z_move ; 0x8003030
        0x08002096:    e02f        /.      B        0x80020f8 ; do_fsm_menu + 260
;;;95     //			z_move(feed_direction, 400*2, false, true);
;;;96     		} else { // controller in initial state, scroll menu
;;;97     			s->function = do_fsm_menu_lps;
        0x08002098:    4854        TH      LDR      r0,[pc,#336] ; [0x80021ec] = 0x8002205
        0x0800209a:    6020         `      STR      r0,[r4,#0]
;;;98     			for (int a = Menu_Step+1; a<Menu_size; a++) {
        0x0800209c:    494d        MI      LDR      r1,[pc,#308] ; [0x80021d4] = 0x200004d4
        0x0800209e:    7809        .x      LDRB     r1,[r1,#0]
        0x080020a0:    1c48        H.      ADDS     r0,r1,#1
        0x080020a2:    e00c        ..      B        0x80020be ; do_fsm_menu + 202
;;;99     				if(Thread_Info[a].level == level) {
        0x080020a4:    494a        JI      LDR      r1,[pc,#296] ; [0x80021d0] = 0x200000b4
        0x080020a6:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x080020aa:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x080020ac:    42a9        .B      CMP      r1,r5
        0x080020ae:    d105        ..      BNE      0x80020bc ; do_fsm_menu + 200
;;;100    					Menu_Step = a;
        0x080020b0:    4a48        HJ      LDR      r2,[pc,#288] ; [0x80021d4] = 0x200004d4
        0x080020b2:    7010        .p      STRB     r0,[r2,#0]
;;;101    					menu_changed = 1;
        0x080020b4:    2101        .!      MOVS     r1,#1
        0x080020b6:    4a4a        JJ      LDR      r2,[pc,#296] ; [0x80021e0] = 0x200000a4
        0x080020b8:    6011        .`      STR      r1,[r2,#0]
;;;102    					break;
        0x080020ba:    e004        ..      B        0x80020c6 ; do_fsm_menu + 210
        0x080020bc:    1c40        @.      ADDS     r0,r0,#1
        0x080020be:    494c        LI      LDR      r1,[pc,#304] ; [0x80021f0] = 0x8003142
        0x080020c0:    7809        .x      LDRB     r1,[r1,#0]
        0x080020c2:    4288        .B      CMP      r0,r1
        0x080020c4:    dbee        ..      BLT      0x80020a4 ; do_fsm_menu + 176
        0x080020c6:    bf00        ..      NOP      
;;;103    				}
;;;104    			}
;;;105    			if(menu_changed != 1) {
        0x080020c8:    4845        EH      LDR      r0,[pc,#276] ; [0x80021e0] = 0x200000a4
        0x080020ca:    6800        .h      LDR      r0,[r0,#0]
        0x080020cc:    2801        .(      CMP      r0,#1
        0x080020ce:    d013        ..      BEQ      0x80020f8 ; do_fsm_menu + 260
;;;106    				for (int a = 0; a<Menu_Step; a++) {
        0x080020d0:    2000        .       MOVS     r0,#0
        0x080020d2:    e00c        ..      B        0x80020ee ; do_fsm_menu + 250
;;;107    					if(Thread_Info[a].level == level) {
        0x080020d4:    493e        >I      LDR      r1,[pc,#248] ; [0x80021d0] = 0x200000b4
        0x080020d6:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x080020da:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x080020dc:    42a9        .B      CMP      r1,r5
        0x080020de:    d105        ..      BNE      0x80020ec ; do_fsm_menu + 248
;;;108    						Menu_Step = a;
        0x080020e0:    4a3c        <J      LDR      r2,[pc,#240] ; [0x80021d4] = 0x200004d4
        0x080020e2:    7010        .p      STRB     r0,[r2,#0]
;;;109    						menu_changed = 1;
        0x080020e4:    2101        .!      MOVS     r1,#1
        0x080020e6:    4a3e        >J      LDR      r2,[pc,#248] ; [0x80021e0] = 0x200000a4
        0x080020e8:    6011        .`      STR      r1,[r2,#0]
;;;110    						break;
        0x080020ea:    e004        ..      B        0x80020f6 ; do_fsm_menu + 258
        0x080020ec:    1c40        @.      ADDS     r0,r0,#1
        0x080020ee:    4939        9I      LDR      r1,[pc,#228] ; [0x80021d4] = 0x200004d4
        0x080020f0:    7809        .x      LDRB     r1,[r1,#0]
        0x080020f2:    4288        .B      CMP      r0,r1
        0x080020f4:    dbee        ..      BLT      0x80020d4 ; do_fsm_menu + 224
        0x080020f6:    bf00        ..      NOP      
;;;111    					}
;;;112    				}
;;;113    			}
;;;114    		}
;;;115    		break;
        0x080020f8:    e068        h.      B        0x80021cc ; do_fsm_menu + 472
        0x080020fa:    e002        ..      B        0x8002102 ; do_fsm_menu + 270
        0x080020fc:    e00c        ..      B        0x8002118 ; do_fsm_menu + 292
        0x080020fe:    e05e        ^.      B        0x80021be ; do_fsm_menu + 458
        0x08002100:    e009        ..      B        0x8002116 ; do_fsm_menu + 290
;;;116    	}
;;;117    	case double_click_Msk: {
;;;118    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x08002102:    4836        6H      LDR      r0,[pc,#216] ; [0x80021dc] = 0x200000a1
        0x08002104:    7800        .x      LDRB     r0,[r0,#0]
        0x08002106:    f0800001    ....    EOR      r0,r0,#1
        0x0800210a:    4934        4I      LDR      r1,[pc,#208] ; [0x80021dc] = 0x200000a1
        0x0800210c:    7008        .p      STRB     r0,[r1,#0]
;;;119    		menu_changed = 1;
        0x0800210e:    2001        .       MOVS     r0,#1
        0x08002110:    4933        3I      LDR      r1,[pc,#204] ; [0x80021e0] = 0x200000a4
        0x08002112:    6008        .`      STR      r0,[r1,#0]
;;;120    		break;
        0x08002114:    e05a        Z.      B        0x80021cc ; do_fsm_menu + 472
;;;121    	}
;;;122    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;123    		// todo check if it work
;;;124    		break;
        0x08002116:    e059        Y.      B        0x80021cc ; do_fsm_menu + 472
;;;125    	}
;;;126    	case long_press_start_Msk: {
;;;127    		if(s->function == do_fsm_menu_lps){
        0x08002118:    4934        4I      LDR      r1,[pc,#208] ; [0x80021ec] = 0x8002205
        0x0800211a:    6820         h      LDR      r0,[r4,#0]
        0x0800211c:    4288        .B      CMP      r0,r1
        0x0800211e:    d14d        M.      BNE      0x80021bc ; do_fsm_menu + 456
;;;128    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
        0x08002120:    482b        +H      LDR      r0,[pc,#172] ; [0x80021d0] = 0x200000b4
        0x08002122:    492c        ,I      LDR      r1,[pc,#176] ; [0x80021d4] = 0x200004d4
        0x08002124:    7809        .x      LDRB     r1,[r1,#0]
        0x08002126:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x0800212a:    6800        .h      LDR      r0,[r0,#0]
        0x0800212c:    b360        `.      CBZ      r0,0x8002188 ; do_fsm_menu + 404
;;;129    
;;;130    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
        0x0800212e:    4828        (H      LDR      r0,[pc,#160] ; [0x80021d0] = 0x200000b4
        0x08002130:    4928        (I      LDR      r1,[pc,#160] ; [0x80021d4] = 0x200004d4
        0x08002132:    7809        .x      LDRB     r1,[r1,#0]
        0x08002134:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08002138:    6800        .h      LDR      r0,[r0,#0]
        0x0800213a:    492a        *I      LDR      r1,[pc,#168] ; [0x80021e4] = 0x200005e0
        0x0800213c:    60c8        .`      STR      r0,[r1,#0xc]
;;;131    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
        0x0800213e:    bf00        ..      NOP      
;;;132    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
        0x08002140:    4608        .F      MOV      r0,r1
        0x08002142:    68c6        .h      LDR      r6,[r0,#0xc]
        0x08002144:    4632        2F      MOV      r2,r6
        0x08002146:    2300        .#      MOVS     r3,#0
        0x08002148:    4618        .F      MOV      r0,r3
        0x0800214a:    f04f6161    O.aa    MOV      r1,#0xe100000
        0x0800214e:    f7fdffe9    ....    BL       __aeabi_uldivmod ; 0x8000124
        0x08002152:    4a24        $J      LDR      r2,[pc,#144] ; [0x80021e4] = 0x200005e0
        0x08002154:    e9c20106    ....    STRD     r0,r1,[r2,#0x18]
;;;133    				// 200*step_divider*z_feed_screw(mm)*len(mm) = desired length in steps, in my case its 200*2*1*x
;;;134    
;;;135    				
;;;136    				MOTOR_X_Enable();
        0x08002158:    f2402002    @..     MOV      r0,#0x202
        0x0800215c:    4925        %I      LDR      r1,[pc,#148] ; [0x80021f4] = 0x40010810
        0x0800215e:    6008        .`      STR      r0,[r1,#0]
;;;137    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x08002160:    4925        %I      LDR      r1,[pc,#148] ; [0x80021f8] = 0x40010c10
        0x08002162:    6008        .`      STR      r0,[r1,#0]
;;;138    //				LL_mDelay(2);
;;;139    				if(demo){
        0x08002164:    4820         H      LDR      r0,[pc,#128] ; [0x80021e8] = 0x20000041
        0x08002166:    7800        .x      LDRB     r0,[r0,#0]
        0x08002168:    b130        0.      CBZ      r0,0x8002178 ; do_fsm_menu + 388
;;;140    					G01(steps_x,steps_z,0);
        0x0800216a:    2200        ."      MOVS     r2,#0
        0x0800216c:    f44f7196    O..q    MOV      r1,#0x12c
        0x08002170:    2001        .       MOVS     r0,#1
        0x08002172:    f7fefad7    ....    BL       G01 ; 0x8000724
        0x08002176:    e006        ..      B        0x8002186 ; do_fsm_menu + 402
;;;141    //					z_move(feed_direction, steps, false, true); //test case, move async 10mm
;;;142    //					z_move(feed_direction, 31, false, true); //test case, move async 10mm
;;;143    				}
;;;144    				else
;;;145    					z_move(feed_direction, 0, true, true);
        0x08002178:    2301        .#      MOVS     r3,#1
        0x0800217a:    461a        .F      MOV      r2,r3
        0x0800217c:    2100        .!      MOVS     r1,#0
        0x0800217e:    4817        .H      LDR      r0,[pc,#92] ; [0x80021dc] = 0x200000a1
        0x08002180:    7800        .x      LDRB     r0,[r0,#0]
        0x08002182:    f000ff55    ..U.    BL       z_move ; 0x8003030
;;;146    
;;;147    				//do_fsm_move_start
;;;148    			} else { // goto submenu
        0x08002186:    e019        ..      B        0x80021bc ; do_fsm_menu + 456
;;;149    				for (int a = 0; a<Menu_size; a++) {
        0x08002188:    2000        .       MOVS     r0,#0
        0x0800218a:    e012        ..      B        0x80021b2 ; do_fsm_menu + 446
;;;150    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
        0x0800218c:    4910        .I      LDR      r1,[pc,#64] ; [0x80021d0] = 0x200000b4
        0x0800218e:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08002192:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x08002194:    4a0e        .J      LDR      r2,[pc,#56] ; [0x80021d0] = 0x200000b4
        0x08002196:    4b0f        .K      LDR      r3,[pc,#60] ; [0x80021d4] = 0x200004d4
        0x08002198:    781b        .x      LDRB     r3,[r3,#0]
        0x0800219a:    eb021243    ..C.    ADD      r2,r2,r3,LSL #5
        0x0800219e:    7912        .y      LDRB     r2,[r2,#4]
        0x080021a0:    4291        .B      CMP      r1,r2
        0x080021a2:    d105        ..      BNE      0x80021b0 ; do_fsm_menu + 444
;;;151    						Menu_Step = a;
        0x080021a4:    4a0b        .J      LDR      r2,[pc,#44] ; [0x80021d4] = 0x200004d4
        0x080021a6:    7010        .p      STRB     r0,[r2,#0]
;;;152    						menu_changed = 1;
        0x080021a8:    2101        .!      MOVS     r1,#1
        0x080021aa:    4a0d        .J      LDR      r2,[pc,#52] ; [0x80021e0] = 0x200000a4
        0x080021ac:    6011        .`      STR      r1,[r2,#0]
;;;153    						break;
        0x080021ae:    e004        ..      B        0x80021ba ; do_fsm_menu + 454
        0x080021b0:    1c40        @.      ADDS     r0,r0,#1
        0x080021b2:    490f        .I      LDR      r1,[pc,#60] ; [0x80021f0] = 0x8003142
        0x080021b4:    7809        .x      LDRB     r1,[r1,#0]
        0x080021b6:    4288        .B      CMP      r0,r1
        0x080021b8:    dbe8        ..      BLT      0x800218c ; do_fsm_menu + 408
        0x080021ba:    bf00        ..      NOP      
;;;154    					}
;;;155    				}
;;;156    			}
;;;157    		} 
;;;158    /* todo prolong
;;;159    		else if(s->function == do_fsm_main_cut_back){
;;;160    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
;;;161    		}
;;;162    */
;;;163    		break;
        0x080021bc:    e006        ..      B        0x80021cc ; do_fsm_menu + 472
;;;164    	}
;;;165    	case long_press_end_Msk: {
;;;166    		if(s->function == do_fsm_move)
        0x080021be:    490f        .I      LDR      r1,[pc,#60] ; [0x80021fc] = 0x8002209
        0x080021c0:    6820         h      LDR      r0,[r4,#0]
        0x080021c2:    4288        .B      CMP      r0,r1
        0x080021c4:    d101        ..      BNE      0x80021ca ; do_fsm_menu + 470
;;;167    			s->function = do_long_press_end_callback;
        0x080021c6:    480e        .H      LDR      r0,[pc,#56] ; [0x8002200] = 0x80024f9
        0x080021c8:    6020         `      STR      r0,[r4,#0]
;;;168    		break;
        0x080021ca:    bf00        ..      NOP      
        0x080021cc:    bf00        ..      NOP      
;;;169    	}
;;;170    	}
;;;171    }
        0x080021ce:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080021d0:    200000b4    ...     DCD    536871092
        0x080021d4:    200004d4    ...     DCD    536872148
        0x080021d8:    200005dc    ...     DCD    536872412
        0x080021dc:    200000a1    ...     DCD    536871073
        0x080021e0:    200000a4    ...     DCD    536871076
        0x080021e4:    200005e0    ...     DCD    536872416
        0x080021e8:    20000041    A..     DCD    536870977
        0x080021ec:    08002205    ."..    DCD    134226437
        0x080021f0:    08003142    B1..    DCD    134230338
        0x080021f4:    40010810    ...@    DCD    1073809424
        0x080021f8:    40010c10    ...@    DCD    1073810448
        0x080021fc:    08002209    ."..    DCD    134226441
        0x08002200:    080024f9    .$..    DCD    134227193
    $t
    i.do_fsm_menu_lps
    do_fsm_menu_lps
;;;172    
;;;173    void do_fsm_menu_lps(state_t* s)
;;;174    {
;;;175    }
        0x08002204:    4770        pG      BX       lr
        0x08002206:    0000        ..      MOVS     r0,r0
    i.do_fsm_move
    do_fsm_move
;;;176    
;;;177    /*
;;;178    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;179    {
;;;180    	MOTOR_Z_SetPulse();
;;;181    	--z_axis.current_pos;
;;;182    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;183    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;184    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;185    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;186    		z_axis.end_pos += prolong_fixpart;
;;;187    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;188    		// when long_press end, get back to 46 mode to proceed
;;;189    	}
;;;190    }
;;;191    */
;;;192    
;;;193    void do_fsm_wait_sclick(state_t* s)
;;;194    {
;;;195    }
;;;196    
;;;197    void z_move(uint32_t direction, uint32_t length, bool sync, bool autostart){
;;;198    	MOTOR_X_Enable();
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;200    
;;;201    	if(direction == feed_direction_left) {
;;;202    		feed_direction = feed_direction_left;
;;;203    		MOTOR_Z_Reverse();
;;;204    		MOTOR_X_Reverse();
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
;;;207    		MOTOR_Z_Forward();
;;;208    		MOTOR_X_Forward();
;;;209    	}
;;;210    	LL_mDelay(2);
;;;211    
;;;212    	state.sync = sync;
;;;213    	if(sync){
;;;214    		state.main_feed_direction = feed_direction;
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
;;;218    	z_axis.end_pos = length;
;;;219    	if(z_axis.end_pos > 0){
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
;;;228    }
;;;229    
;;;230    //---------------------------------------------------------------------------------------------
;;;231    void do_fsm_move_start(state_t* s){
;;;232    	if(s->sync && !s->f_tacho){
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
;;;242    			s->function = do_fsm_ramp_up;
;;;243    			s->async_z = 0;
;;;244    			s->syncbase = TIM4; 									// sync with spindle
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;247    
;;;248    // disable TACHO events, we dont need'em until next start			
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
;;;261    //			LL_TIM_EnableCounter(TIM3);
;;;262    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;263    //			LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;264    
;;;265    //			TIM3->SR = 0;
;;;266    //			LL_TIM_EnableCounter(TIM3);
;;;267    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;268    //			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;269    
;;;270    			
;;;271    //			LL_TIM_EnableCounter(TIM2); /* Enable counter */
;;;272    
;;;273    //			MOTOR_Z_AllowPulse();
;;;274    //			MOTOR_X_AllowPulse();
;;;275    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;276    
;;;277    			TIM2->ARR = 10;
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
;;;280    
;;;281    
;;;282    //			TIM2->ARR = 1;
;;;283    //			LL_TIM_EnableCounter(TIM2);
;;;284    
;;;285    //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
;;;286    //			TIM3->SR = 0;
;;;287    //			LL_TIM_EnableCounter(TIM3);
;;;288    //			LL_TIM_GenerateEvent_TRIG(TIM2); // start first step on motor
;;;289    	//		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;290    //			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;291    			s->async_z = 1;
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
        0x08002208:    b510        ..      PUSH     {r4,lr}
        0x0800220a:    4604        .F      MOV      r4,r0
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
        0x0800220c:    4811        .H      LDR      r0,[pc,#68] ; [0x8002254] = 0x200005e0
        0x0800220e:    6840        @h      LDR      r0,[r0,#4]
        0x08002210:    4910        .I      LDR      r1,[pc,#64] ; [0x8002254] = 0x200005e0
        0x08002212:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08002216:    1a41        A.      SUBS     r1,r0,r1
        0x08002218:    480e        .H      LDR      r0,[pc,#56] ; [0x8002254] = 0x200005e0
        0x0800221a:    6800        .h      LDR      r0,[r0,#0]
        0x0800221c:    1c40        @.      ADDS     r0,r0,#1
        0x0800221e:    4a0d        .J      LDR      r2,[pc,#52] ; [0x8002254] = 0x200005e0
        0x08002220:    6010        .`      STR      r0,[r2,#0]
        0x08002222:    4281        .B      CMP      r1,r0
        0x08002224:    d303        ..      BCC      0x800222e ; do_fsm_move + 38
;;;314    		z_axis_move2(s);
        0x08002226:    4620         F      MOV      r0,r4
        0x08002228:    f000fe96    ....    BL       z_axis_move2 ; 0x8002f58
        0x0800222c:    e011        ..      B        0x8002252 ; do_fsm_move + 74
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
        0x0800222e:    4620         F      MOV      r0,r4
        0x08002230:    f000feac    ....    BL       z_axis_ramp_down2 ; 0x8002f8c
        0x08002234:    b158        X.      CBZ      r0,0x800224e ; do_fsm_move + 70
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
        0x08002236:    4807        .H      LDR      r0,[pc,#28] ; [0x8002254] = 0x200005e0
        0x08002238:    6840        @h      LDR      r0,[r0,#4]
        0x0800223a:    4906        .I      LDR      r1,[pc,#24] ; [0x8002254] = 0x200005e0
        0x0800223c:    6809        .h      LDR      r1,[r1,#0]
        0x0800223e:    4288        .B      CMP      r0,r1
        0x08002240:    d003        ..      BEQ      0x800224a ; do_fsm_move + 66
;;;318    				z_axis.end_pos = z_axis.current_pos;
        0x08002242:    4804        .H      LDR      r0,[pc,#16] ; [0x8002254] = 0x200005e0
        0x08002244:    6800        .h      LDR      r0,[r0,#0]
        0x08002246:    4903        .I      LDR      r1,[pc,#12] ; [0x8002254] = 0x200005e0
        0x08002248:    6048        H`      STR      r0,[r1,#4]
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
        0x0800224a:    4803        .H      LDR      r0,[pc,#12] ; [0x8002258] = 0x8002291
        0x0800224c:    6020         `      STR      r0,[r4,#0]
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
        0x0800224e:    4803        .H      LDR      r0,[pc,#12] ; [0x800225c] = 0x80023d9
        0x08002250:    6020         `      STR      r0,[r4,#0]
;;;323    	}
;;;324    }
        0x08002252:    bd10        ..      POP      {r4,pc}
    $d
        0x08002254:    200005e0    ...     DCD    536872416
        0x08002258:    08002291    ."..    DCD    134226577
        0x0800225c:    080023d9    .#..    DCD    134226905
    $t
    i.do_fsm_move_async
    do_fsm_move_async
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
;;;340    //	if(s->spindle_dir)	
;;;341    		z_axis.current_pos++;
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
;;;346    			z_axis.end_pos = z_axis.current_pos;
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
;;;349    	}
;;;350    }
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
;;;436    		if( rs2 < z_axis.end_pos) {
;;;437    			s->z_period = slew_speed_period;
;;;438    			s->function = do_fsm_move_async;
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
;;;442    			s->function = do_fsm_ramp_down_async;
;;;443    			z_axis.ramp_step--;
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
;;;448    	}
;;;449    }
;;;450    
;;;451    void do_fsm_move_async(state_t* s)
;;;452    {
;;;453    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;454    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;455    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
        0x08002260:    4a09        .J      LDR      r2,[pc,#36] ; [0x8002288] = 0x200005e0
        0x08002262:    6852        Rh      LDR      r2,[r2,#4]
        0x08002264:    4b08        .K      LDR      r3,[pc,#32] ; [0x8002288] = 0x200005e0
        0x08002266:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x0800226a:    1ad2        ..      SUBS     r2,r2,r3
        0x0800226c:    1e51        Q.      SUBS     r1,r2,#1
;;;456    	if( ++z_axis.current_pos < pre ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
        0x0800226e:    4a06        .J      LDR      r2,[pc,#24] ; [0x8002288] = 0x200005e0
        0x08002270:    6812        .h      LDR      r2,[r2,#0]
        0x08002272:    1c52        R.      ADDS     r2,r2,#1
        0x08002274:    4b04        .K      LDR      r3,[pc,#16] ; [0x8002288] = 0x200005e0
        0x08002276:    601a        .`      STR      r2,[r3,#0]
        0x08002278:    428a        .B      CMP      r2,r1
        0x0800227a:    d202        ..      BCS      0x8002282 ; do_fsm_move_async + 34
;;;457    		s->z_period = slew_speed_period;
        0x0800227c:    2232        2"      MOVS     r2,#0x32
        0x0800227e:    7302        .s      STRB     r2,[r0,#0xc]
        0x08002280:    e001        ..      B        0x8002286 ; do_fsm_move_async + 38
;;;458    	} else {
;;;459    		s->function = do_fsm_ramp_down_async;
        0x08002282:    4a02        .J      LDR      r2,[pc,#8] ; [0x800228c] = 0x8002411
        0x08002284:    6002        .`      STR      r2,[r0,#0]
;;;460    	}
;;;461    }
        0x08002286:    4770        pG      BX       lr
    $d
        0x08002288:    200005e0    ...     DCD    536872416
        0x0800228c:    08002411    .$..    DCD    134226961
    $t
    i.do_fsm_move_end
    do_fsm_move_end
;;; .\..\Src\fsm.c (352)
        0x08002290:    b510        ..      PUSH     {r4,lr}
        0x08002292:    4604        .F      MOV      r4,r0
;;;353    	s->async_z = 0;
        0x08002294:    2000        .       MOVS     r0,#0
        0x08002296:    6060        ``      STR      r0,[r4,#4]
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
        0x08002298:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
        0x0800229a:    491a        .I      LDR      r1,[pc,#104] ; [0x8002304] = 0x40000400
        0x0800229c:    6889        .h      LDR      r1,[r1,#8]
        0x0800229e:    f0210107    !...    BIC      r1,r1,#7
        0x080022a2:    4301        .C      ORRS     r1,r1,r0
        0x080022a4:    4a17        .J      LDR      r2,[pc,#92] ; [0x8002304] = 0x40000400
        0x080022a6:    6091        .`      STR      r1,[r2,#8]
;;;2597   }
        0x080022a8:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;357    	if (s->sync) {
        0x080022aa:    7c20         |      LDRB     r0,[r4,#0x10]
        0x080022ac:    b138        8.      CBZ      r0,0x80022be ; do_fsm_move_end + 46
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
        0x080022ae:    2000        .       MOVS     r0,#0
        0x080022b0:    4915        .I      LDR      r1,[pc,#84] ; [0x8002308] = 0x42010180
        0x080022b2:    6008        .`      STR      r0,[r1,#0]
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x080022b4:    1591        ..      ASRS     r1,r2,#22
        0x080022b6:    4815        .H      LDR      r0,[pc,#84] ; [0x800230c] = 0x40000800
        0x080022b8:    f7fefcc7    ....    BL       LL_TIM_CC_DisableChannel ; 0x8000c4a
        0x080022bc:    e00a        ..      B        0x80022d4 ; do_fsm_move_end + 68
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
        0x080022be:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1038     CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x080022c0:    f04f4080    O..@    MOV      r0,#0x40000000
        0x080022c4:    6800        .h      LDR      r0,[r0,#0]
        0x080022c6:    f0200001     ...    BIC      r0,r0,#1
        0x080022ca:    f04f4180    O..A    MOV      r1,#0x40000000
        0x080022ce:    6008        .`      STR      r0,[r1,#0]
;;;1039   }
        0x080022d0:    bf00        ..      NOP      
        0x080022d2:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
        0x080022d4:    2000        .       MOVS     r0,#0
        0x080022d6:    6160        `a      STR      r0,[r4,#0x14]
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
        0x080022d8:    2002        .       MOVS     r0,#2
        0x080022da:    f7feff2d    ..-.    BL       LL_mDelay ; 0x8001138
;;;368      MOTOR_Z_Disable();
        0x080022de:    f2402002    @..     MOV      r0,#0x202
        0x080022e2:    490b        .I      LDR      r1,[pc,#44] ; [0x8002310] = 0x40010c14
        0x080022e4:    6008        .`      STR      r0,[r1,#0]
;;;369      MOTOR_X_Disable();
        0x080022e6:    490b        .I      LDR      r1,[pc,#44] ; [0x8002314] = 0x40010814
        0x080022e8:    6008        .`      STR      r0,[r1,#0]
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
        0x080022ea:    480b        .H      LDR      r0,[pc,#44] ; [0x8002318] = 0x200000a1
        0x080022ec:    7800        .x      LDRB     r0,[r0,#0]
        0x080022ee:    f0800001    ....    EOR      r0,r0,#1
        0x080022f2:    4909        .I      LDR      r1,[pc,#36] ; [0x8002318] = 0x200000a1
        0x080022f4:    7008        .p      STRB     r0,[r1,#0]
;;;372    	menu_changed = 1; 													//update menu
        0x080022f6:    2001        .       MOVS     r0,#1
        0x080022f8:    4908        .I      LDR      r1,[pc,#32] ; [0x800231c] = 0x200000a4
        0x080022fa:    6008        .`      STR      r0,[r1,#0]
;;;373    	s->function = do_fsm_wait_sclick;
        0x080022fc:    4808        .H      LDR      r0,[pc,#32] ; [0x8002320] = 0x80024f5
        0x080022fe:    6020         `      STR      r0,[r4,#0]
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
        0x08002300:    bd10        ..      POP      {r4,pc}
    $d
        0x08002302:    0000        ..      DCW    0
        0x08002304:    40000400    ...@    DCD    1073742848
        0x08002308:    42010180    ...B    DCD    1107362176
        0x0800230c:    40000800    ...@    DCD    1073743872
        0x08002310:    40010c14    ...@    DCD    1073810452
        0x08002314:    40010814    ...@    DCD    1073809428
        0x08002318:    200000a1    ...     DCD    536871073
        0x0800231c:    200000a4    ...     DCD    536871076
        0x08002320:    080024f5    .$..    DCD    134227189
    $t
    i.do_fsm_move_start
    do_fsm_move_start
;;; .\..\Src\fsm.c (231)
        0x08002324:    b510        ..      PUSH     {r4,lr}
        0x08002326:    4604        .F      MOV      r4,r0
;;;232    	if(s->sync && !s->f_tacho){
        0x08002328:    7c20         |      LDRB     r0,[r4,#0x10]
        0x0800232a:    b150        P.      CBZ      r0,0x8002342 ; do_fsm_move_start + 30
        0x0800232c:    7ba0        .{      LDRB     r0,[r4,#0xe]
        0x0800232e:    b940        @.      CBNZ     r0,0x8002342 ; do_fsm_move_start + 30
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
        0x08002330:    f2af000f    ....    ADR      r0,{pc}-0xb ; 0x8002325
        0x08002334:    6020         `      STR      r0,[r4,#0]
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x08002336:    f44f7180    O..q    MOV      r1,#0x100
        0x0800233a:    4822        "H      LDR      r0,[pc,#136] ; [0x80023c4] = 0x40000800
        0x0800233c:    f7fefc89    ....    BL       LL_TIM_CC_EnableChannel ; 0x8000c52
        0x08002340:    bd10        ..      POP      {r4,pc}
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
        0x08002342:    7ba0        .{      LDRB     r0,[r4,#0xe]
        0x08002344:    b910        ..      CBNZ     r0,0x800234c ; do_fsm_move_start + 40
        0x08002346:    7c20         |      LDRB     r0,[r4,#0x10]
        0x08002348:    2800        .(      CMP      r0,#0
        0x0800234a:    d138        8.      BNE      0x80023be ; do_fsm_move_start + 154
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
        0x0800234c:    7c20         |      LDRB     r0,[r4,#0x10]
        0x0800234e:    b1c0        ..      CBZ      r0,0x8002382 ; do_fsm_move_start + 94
        0x08002350:    7ba0        .{      LDRB     r0,[r4,#0xe]
        0x08002352:    b1b0        ..      CBZ      r0,0x8002382 ; do_fsm_move_start + 94
;;;242    			s->function = do_fsm_ramp_up;
        0x08002354:    481c        .H      LDR      r0,[pc,#112] ; [0x80023c8] = 0x800245d
        0x08002356:    6020         `      STR      r0,[r4,#0]
;;;243    			s->async_z = 0;
        0x08002358:    2000        .       MOVS     r0,#0
        0x0800235a:    6060        ``      STR      r0,[r4,#4]
;;;244    			s->syncbase = TIM4; 									// sync with spindle
        0x0800235c:    4819        .H      LDR      r0,[pc,#100] ; [0x80023c4] = 0x40000800
        0x0800235e:    6160        `a      STR      r0,[r4,#0x14]
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
        0x08002360:    2030        0       MOVS     r0,#0x30
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x08002362:    491a        .I      LDR      r1,[pc,#104] ; [0x80023cc] = 0x40000400
        0x08002364:    6889        .h      LDR      r1,[r1,#8]
        0x08002366:    f0210170    !.p.    BIC      r1,r1,#0x70
        0x0800236a:    4301        .C      ORRS     r1,r1,r0
        0x0800236c:    4a17        .J      LDR      r2,[pc,#92] ; [0x80023cc] = 0x40000400
        0x0800236e:    6091        .`      STR      r1,[r2,#8]
;;;2619   }
        0x08002370:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x08002372:    1591        ..      ASRS     r1,r2,#22
        0x08002374:    4813        .H      LDR      r0,[pc,#76] ; [0x80023c4] = 0x40000800
        0x08002376:    f7fefc68    ..h.    BL       LL_TIM_CC_DisableChannel ; 0x8000c4a
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
        0x0800237a:    2001        .       MOVS     r0,#1
        0x0800237c:    4914        .I      LDR      r1,[pc,#80] ; [0x80023d0] = 0x42010180
        0x0800237e:    6008        .`      STR      r0,[r1,#0]
        0x08002380:    e01d        ..      B        0x80023be ; do_fsm_move_start + 154
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
        0x08002382:    4814        .H      LDR      r0,[pc,#80] ; [0x80023d4] = 0x8002481
        0x08002384:    6020         `      STR      r0,[r4,#0]
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
        0x08002386:    f04f4080    O..@    MOV      r0,#0x40000000
        0x0800238a:    6160        `a      STR      r0,[r4,#0x14]
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
        0x0800238c:    f6406029    @.)`    MOV      r0,#0xe29
        0x08002390:    490e        .I      LDR      r1,[pc,#56] ; [0x80023cc] = 0x40000400
        0x08002392:    312c        ,1      ADDS     r1,r1,#0x2c
        0x08002394:    6008        .`      STR      r0,[r1,#0]
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
        0x08002396:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08002398:    480c        .H      LDR      r0,[pc,#48] ; [0x80023cc] = 0x40000400
        0x0800239a:    6940        @i      LDR      r0,[r0,#0x14]
        0x0800239c:    f0400001    @...    ORR      r0,r0,#1
        0x080023a0:    490a        .I      LDR      r1,[pc,#40] ; [0x80023cc] = 0x40000400
        0x080023a2:    6148        Ha      STR      r0,[r1,#0x14]
;;;3713   }
        0x080023a4:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;277    			TIM2->ARR = 10;
        0x080023a6:    200a        .       MOVS     r0,#0xa
        0x080023a8:    0741        A.      LSLS     r1,r0,#29
        0x080023aa:    62c8        .b      STR      r0,[r1,#0x2c]
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
        0x080023ac:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x080023ae:    0740        @.      LSLS     r0,r0,#29
        0x080023b0:    6800        .h      LDR      r0,[r0,#0]
        0x080023b2:    f0400001    @...    ORR      r0,r0,#1
        0x080023b6:    6008        .`      STR      r0,[r1,#0]
;;;1028   }
        0x080023b8:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;291    			s->async_z = 1;
        0x080023ba:    2001        .       MOVS     r0,#1
        0x080023bc:    6060        ``      STR      r0,[r4,#4]
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
        0x080023be:    bf00        ..      NOP      
        0x080023c0:    e7be        ..      B        0x8002340 ; do_fsm_move_start + 28
    $d
        0x080023c2:    0000        ..      DCW    0
        0x080023c4:    40000800    ...@    DCD    1073743872
        0x080023c8:    0800245d    ]$..    DCD    134227037
        0x080023cc:    40000400    ...@    DCD    1073742848
        0x080023d0:    42010180    ...B    DCD    1107362176
        0x080023d4:    08002481    .$..    DCD    134227073
    $t
    i.do_fsm_ramp_down
    do_fsm_ramp_down
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
        0x080023d8:    b500        ..      PUSH     {lr}
        0x080023da:    4603        .F      MOV      r3,r0
;;;340    //	if(s->spindle_dir)	
;;;341    		z_axis.current_pos++;
        0x080023dc:    480a        .H      LDR      r0,[pc,#40] ; [0x8002408] = 0x200005e0
        0x080023de:    6800        .h      LDR      r0,[r0,#0]
        0x080023e0:    1c40        @.      ADDS     r0,r0,#1
        0x080023e2:    4909        .I      LDR      r1,[pc,#36] ; [0x8002408] = 0x200005e0
        0x080023e4:    6008        .`      STR      r0,[r1,#0]
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
        0x080023e6:    4618        .F      MOV      r0,r3
        0x080023e8:    f000fdd0    ....    BL       z_axis_ramp_down2 ; 0x8002f8c
        0x080023ec:    b158        X.      CBZ      r0,0x8002406 ; do_fsm_ramp_down + 46
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
        0x080023ee:    4806        .H      LDR      r0,[pc,#24] ; [0x8002408] = 0x200005e0
        0x080023f0:    6840        @h      LDR      r0,[r0,#4]
        0x080023f2:    4905        .I      LDR      r1,[pc,#20] ; [0x8002408] = 0x200005e0
        0x080023f4:    6809        .h      LDR      r1,[r1,#0]
        0x080023f6:    4288        .B      CMP      r0,r1
        0x080023f8:    d003        ..      BEQ      0x8002402 ; do_fsm_ramp_down + 42
;;;346    			z_axis.end_pos = z_axis.current_pos;
        0x080023fa:    4803        .H      LDR      r0,[pc,#12] ; [0x8002408] = 0x200005e0
        0x080023fc:    6800        .h      LDR      r0,[r0,#0]
        0x080023fe:    4902        .I      LDR      r1,[pc,#8] ; [0x8002408] = 0x200005e0
        0x08002400:    6048        H`      STR      r0,[r1,#4]
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
        0x08002402:    4802        .H      LDR      r0,[pc,#8] ; [0x800240c] = 0x8002291
        0x08002404:    6018        .`      STR      r0,[r3,#0]
;;;349    	}
;;;350    }
        0x08002406:    bd00        ..      POP      {pc}
    $d
        0x08002408:    200005e0    ...     DCD    536872416
        0x0800240c:    08002291    ."..    DCD    134226577
    $t
    i.do_fsm_ramp_down_async
    do_fsm_ramp_down_async
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
;;;436    		if( rs2 < z_axis.end_pos) {
;;;437    			s->z_period = slew_speed_period;
;;;438    			s->function = do_fsm_move_async;
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
;;;442    			s->function = do_fsm_ramp_down_async;
;;;443    			z_axis.ramp_step--;
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
;;;448    	}
;;;449    }
;;;450    
;;;451    void do_fsm_move_async(state_t* s)
;;;452    {
;;;453    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;454    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;455    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
;;;456    	if( ++z_axis.current_pos < pre ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;457    		s->z_period = slew_speed_period;
;;;458    	} else {
;;;459    		s->function = do_fsm_ramp_down_async;
;;;460    	}
;;;461    }
;;;462    
;;;463    void do_fsm_ramp_down_async(state_t* s)
;;;464    {
;;;465    	z_axis.current_pos++;
        0x08002410:    490f        .I      LDR      r1,[pc,#60] ; [0x8002450] = 0x200005e0
        0x08002412:    6809        .h      LDR      r1,[r1,#0]
        0x08002414:    1c49        I.      ADDS     r1,r1,#1
        0x08002416:    4a0e        .J      LDR      r2,[pc,#56] ; [0x8002450] = 0x200005e0
        0x08002418:    6011        .`      STR      r1,[r2,#0]
;;;466    
;;;467    	s->z_period = async_ramp_profile[--z_axis.ramp_step];
        0x0800241a:    4611        .F      MOV      r1,r2
        0x0800241c:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08002420:    1e49        I.      SUBS     r1,r1,#1
        0x08002422:    b2c9        ..      UXTB     r1,r1
        0x08002424:    f8821028    ..(.    STRB     r1,[r2,#0x28]
        0x08002428:    4a0a        .J      LDR      r2,[pc,#40] ; [0x8002454] = 0x20000018
        0x0800242a:    5c51        Q\      LDRB     r1,[r2,r1]
        0x0800242c:    7301        .s      STRB     r1,[r0,#0xc]
;;;468    	if (z_axis.ramp_step == 0) {
        0x0800242e:    4908        .I      LDR      r1,[pc,#32] ; [0x8002450] = 0x200005e0
        0x08002430:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x08002434:    b959        Y.      CBNZ     r1,0x800244e ; do_fsm_ramp_down_async + 62
;;;469    //	} else {
;;;470    // for last step there is no need to wail long, motor can be start to disabled after 145 processor ticks, so with prescaler =145 and more ARR = 1 is enought
;;;471    //		s->z_period = 2; 
;;;472    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED); // stop pulse generation on timer
;;;473    		if(z_axis.end_pos != z_axis.current_pos) {
        0x08002436:    4906        .I      LDR      r1,[pc,#24] ; [0x8002450] = 0x200005e0
        0x08002438:    6849        Ih      LDR      r1,[r1,#4]
        0x0800243a:    4a05        .J      LDR      r2,[pc,#20] ; [0x8002450] = 0x200005e0
        0x0800243c:    6812        .h      LDR      r2,[r2,#0]
        0x0800243e:    4291        .B      CMP      r1,r2
        0x08002440:    d003        ..      BEQ      0x800244a ; do_fsm_ramp_down_async + 58
;;;474    			z_axis.end_pos = z_axis.current_pos;
        0x08002442:    4903        .I      LDR      r1,[pc,#12] ; [0x8002450] = 0x200005e0
        0x08002444:    6809        .h      LDR      r1,[r1,#0]
        0x08002446:    4a02        .J      LDR      r2,[pc,#8] ; [0x8002450] = 0x200005e0
        0x08002448:    6051        Q`      STR      r1,[r2,#4]
;;;475    		}
;;;476    		s->function = do_fsm_move_end;
        0x0800244a:    4903        .I      LDR      r1,[pc,#12] ; [0x8002458] = 0x8002291
        0x0800244c:    6001        .`      STR      r1,[r0,#0]
;;;477    //		do_fsm_move_end(s);
;;;478    	}
;;;479    }
        0x0800244e:    4770        pG      BX       lr
    $d
        0x08002450:    200005e0    ...     DCD    536872416
        0x08002454:    20000018    ...     DCD    536870936
        0x08002458:    08002291    ."..    DCD    134226577
    $t
    i.do_fsm_ramp_up
    do_fsm_ramp_up
;;; .\..\Src\fsm.c (302)
        0x0800245c:    b510        ..      PUSH     {r4,lr}
        0x0800245e:    4604        .F      MOV      r4,r0
;;;303    	z_axis.current_pos++;
        0x08002460:    4805        .H      LDR      r0,[pc,#20] ; [0x8002478] = 0x200005e0
        0x08002462:    6800        .h      LDR      r0,[r0,#0]
        0x08002464:    1c40        @.      ADDS     r0,r0,#1
        0x08002466:    4904        .I      LDR      r1,[pc,#16] ; [0x8002478] = 0x200005e0
        0x08002468:    6008        .`      STR      r0,[r1,#0]
;;;304    	if(z_axis_ramp_up2(s)) {
        0x0800246a:    4620         F      MOV      r0,r4
        0x0800246c:    f000fdae    ....    BL       z_axis_ramp_up2 ; 0x8002fcc
        0x08002470:    b108        ..      CBZ      r0,0x8002476 ; do_fsm_ramp_up + 26
;;;305    		s->function = do_fsm_move;
        0x08002472:    4802        .H      LDR      r0,[pc,#8] ; [0x800247c] = 0x8002209
        0x08002474:    6020         `      STR      r0,[r4,#0]
;;;306    	}
;;;307    }
        0x08002476:    bd10        ..      POP      {r4,pc}
    $d
        0x08002478:    200005e0    ...     DCD    536872416
        0x0800247c:    08002209    ."..    DCD    134226441
    $t
    i.do_fsm_ramp_up_async
    do_fsm_ramp_up_async
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
;;;340    //	if(s->spindle_dir)	
;;;341    		z_axis.current_pos++;
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
;;;346    			z_axis.end_pos = z_axis.current_pos;
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
;;;349    	}
;;;350    }
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
        0x08002480:    b530        0.      PUSH     {r4,r5,lr}
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
        0x08002482:    4b18        .K      LDR      r3,[pc,#96] ; [0x80024e4] = 0x200005e0
        0x08002484:    681b        .h      LDR      r3,[r3,#0]
        0x08002486:    1c5b        [.      ADDS     r3,r3,#1
        0x08002488:    4c16        .L      LDR      r4,[pc,#88] ; [0x80024e4] = 0x200005e0
        0x0800248a:    6023        #`      STR      r3,[r4,#0]
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
        0x0800248c:    4623        #F      MOV      r3,r4
        0x0800248e:    f8934028    ..(@    LDRB     r4,[r3,#0x28]
        0x08002492:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x08002496:    1c5b        [.      ADDS     r3,r3,#1
        0x08002498:    4d12        .M      LDR      r5,[pc,#72] ; [0x80024e4] = 0x200005e0
        0x0800249a:    f8853028    ..(0    STRB     r3,[r5,#0x28]
        0x0800249e:    4b12        .K      LDR      r3,[pc,#72] ; [0x80024e8] = 0x20000018
        0x080024a0:    5d19        .]      LDRB     r1,[r3,r4]
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
        0x080024a2:    462b        +F      MOV      r3,r5
        0x080024a4:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x080024a8:    005a        Z.      LSLS     r2,r3,#1
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
        0x080024aa:    2932        2)      CMP      r1,#0x32
        0x080024ac:    db03        ..      BLT      0x80024b6 ; do_fsm_ramp_up_async + 54
        0x080024ae:    462b        +F      MOV      r3,r5
        0x080024b0:    685b        [h      LDR      r3,[r3,#4]
        0x080024b2:    4293        .B      CMP      r3,r2
        0x080024b4:    d813        ..      BHI      0x80024de ; do_fsm_ramp_up_async + 94
;;;436    		if( rs2 < z_axis.end_pos) {
        0x080024b6:    4b0b        .K      LDR      r3,[pc,#44] ; [0x80024e4] = 0x200005e0
        0x080024b8:    685b        [h      LDR      r3,[r3,#4]
        0x080024ba:    4293        .B      CMP      r3,r2
        0x080024bc:    d904        ..      BLS      0x80024c8 ; do_fsm_ramp_up_async + 72
;;;437    			s->z_period = slew_speed_period;
        0x080024be:    2332        2#      MOVS     r3,#0x32
        0x080024c0:    7303        .s      STRB     r3,[r0,#0xc]
;;;438    			s->function = do_fsm_move_async;
        0x080024c2:    4b0a        .K      LDR      r3,[pc,#40] ; [0x80024ec] = 0x8002261
        0x080024c4:    6003        .`      STR      r3,[r0,#0]
        0x080024c6:    e00b        ..      B        0x80024e0 ; do_fsm_ramp_up_async + 96
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
        0x080024c8:    7301        .s      STRB     r1,[r0,#0xc]
;;;442    			s->function = do_fsm_ramp_down_async;
        0x080024ca:    4b09        .K      LDR      r3,[pc,#36] ; [0x80024f0] = 0x8002411
        0x080024cc:    6003        .`      STR      r3,[r0,#0]
;;;443    			z_axis.ramp_step--;
        0x080024ce:    4b05        .K      LDR      r3,[pc,#20] ; [0x80024e4] = 0x200005e0
        0x080024d0:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x080024d4:    1e5b        [.      SUBS     r3,r3,#1
        0x080024d6:    4c03        .L      LDR      r4,[pc,#12] ; [0x80024e4] = 0x200005e0
        0x080024d8:    f8843028    ..(0    STRB     r3,[r4,#0x28]
        0x080024dc:    e000        ..      B        0x80024e0 ; do_fsm_ramp_up_async + 96
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
        0x080024de:    7301        .s      STRB     r1,[r0,#0xc]
;;;448    	}
;;;449    }
        0x080024e0:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080024e2:    0000        ..      DCW    0
        0x080024e4:    200005e0    ...     DCD    536872416
        0x080024e8:    20000018    ...     DCD    536870936
        0x080024ec:    08002261    a"..    DCD    134226529
        0x080024f0:    08002411    .$..    DCD    134226961
    $t
    i.do_fsm_wait_sclick
    do_fsm_wait_sclick
;;; .\..\Src\fsm.c (195)
        0x080024f4:    4770        pG      BX       lr
        0x080024f6:    0000        ..      MOVS     r0,r0
    i.do_long_press_end_callback
    do_long_press_end_callback
;;;196    
;;;197    void z_move(uint32_t direction, uint32_t length, bool sync, bool autostart){
;;;198    	MOTOR_X_Enable();
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;200    
;;;201    	if(direction == feed_direction_left) {
;;;202    		feed_direction = feed_direction_left;
;;;203    		MOTOR_Z_Reverse();
;;;204    		MOTOR_X_Reverse();
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
;;;207    		MOTOR_Z_Forward();
;;;208    		MOTOR_X_Forward();
;;;209    	}
;;;210    	LL_mDelay(2);
;;;211    
;;;212    	state.sync = sync;
;;;213    	if(sync){
;;;214    		state.main_feed_direction = feed_direction;
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
;;;218    	z_axis.end_pos = length;
;;;219    	if(z_axis.end_pos > 0){
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
;;;228    }
;;;229    
;;;230    //---------------------------------------------------------------------------------------------
;;;231    void do_fsm_move_start(state_t* s){
;;;232    	if(s->sync && !s->f_tacho){
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
;;;242    			s->function = do_fsm_ramp_up;
;;;243    			s->async_z = 0;
;;;244    			s->syncbase = TIM4; 									// sync with spindle
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;247    
;;;248    // disable TACHO events, we dont need'em until next start			
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
;;;261    //			LL_TIM_EnableCounter(TIM3);
;;;262    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;263    //			LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;264    
;;;265    //			TIM3->SR = 0;
;;;266    //			LL_TIM_EnableCounter(TIM3);
;;;267    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;268    //			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;269    
;;;270    			
;;;271    //			LL_TIM_EnableCounter(TIM2); /* Enable counter */
;;;272    
;;;273    //			MOTOR_Z_AllowPulse();
;;;274    //			MOTOR_X_AllowPulse();
;;;275    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;276    
;;;277    			TIM2->ARR = 10;
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
;;;280    
;;;281    
;;;282    //			TIM2->ARR = 1;
;;;283    //			LL_TIM_EnableCounter(TIM2);
;;;284    
;;;285    //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
;;;286    //			TIM3->SR = 0;
;;;287    //			LL_TIM_EnableCounter(TIM3);
;;;288    //			LL_TIM_GenerateEvent_TRIG(TIM2); // start first step on motor
;;;289    	//		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;290    //			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;291    			s->async_z = 1;
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
        0x080024f8:    b510        ..      PUSH     {r4,lr}
        0x080024fa:    4604        .F      MOV      r4,r0
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
        0x080024fc:    4809        .H      LDR      r0,[pc,#36] ; [0x8002524] = 0x200005e0
        0x080024fe:    6840        @h      LDR      r0,[r0,#4]
        0x08002500:    b948        H.      CBNZ     r0,0x8002516 ; do_long_press_end_callback + 30
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
        0x08002502:    4808        .H      LDR      r0,[pc,#32] ; [0x8002524] = 0x200005e0
        0x08002504:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002508:    4906        .I      LDR      r1,[pc,#24] ; [0x8002524] = 0x200005e0
        0x0800250a:    6809        .h      LDR      r1,[r1,#0]
        0x0800250c:    4408        .D      ADD      r0,r0,r1
        0x0800250e:    f0400001    @...    ORR      r0,r0,#1
        0x08002512:    4904        .I      LDR      r1,[pc,#16] ; [0x8002524] = 0x200005e0
        0x08002514:    6048        H`      STR      r0,[r1,#4]
;;;333    	s->function = do_fsm_move;
        0x08002516:    4804        .H      LDR      r0,[pc,#16] ; [0x8002528] = 0x8002209
        0x08002518:    6020         `      STR      r0,[r4,#0]
;;;334    	do_fsm_move(s);
        0x0800251a:    4620         F      MOV      r0,r4
        0x0800251c:    f7fffe74    ..t.    BL       do_fsm_move ; 0x8002208
;;;335    }
        0x08002520:    bd10        ..      POP      {r4,pc}
    $d
        0x08002522:    0000        ..      DCW    0
        0x08002524:    200005e0    ...     DCD    536872416
        0x08002528:    08002209    ."..    DCD    134226441
    $t
    i.dxdz_callback
    dxdz_callback
;;; ../Inc/fsm.h
;;;94     __STATIC_INLINE void dxdz_callback(state_t* s){
        0x0800252c:    b510        ..      PUSH     {r4,lr}
        0x0800252e:    4604        .F      MOV      r4,r0
;;;95     	TIM3->CCER = 0;	//	LL_TIM_CC_DisableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x08002530:    2000        .       MOVS     r0,#0
        0x08002532:    4910        .I      LDR      r1,[pc,#64] ; [0x8002574] = 0x40000420
        0x08002534:    6008        .`      STR      r0,[r1,#0]
;;;96     	s->e2 = s->err;
        0x08002536:    6c60        `l      LDR      r0,[r4,#0x44]
        0x08002538:    64a0        .d      STR      r0,[r4,#0x48]
;;;97     	if (s->e2 > -s->dx)	{ 
        0x0800253a:    6aa1        .j      LDR      r1,[r4,#0x28]
        0x0800253c:    4249        IB      RSBS     r1,r1,#0
        0x0800253e:    6ca0        .l      LDR      r0,[r4,#0x48]
        0x08002540:    4288        .B      CMP      r0,r1
        0x08002542:    dd08        ..      BLE      0x8002556 ; dxdz_callback + 42
;;;98     		s->err -= s->dz; 
        0x08002544:    6ae1        .j      LDR      r1,[r4,#0x2c]
        0x08002546:    6c60        `l      LDR      r0,[r4,#0x44]
        0x08002548:    1a40        @.      SUBS     r0,r0,r1
        0x0800254a:    6460        `d      STR      r0,[r4,#0x44]
;;;99     		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x0800254c:    2101        .!      MOVS     r1,#1
        0x0800254e:    4809        .H      LDR      r0,[pc,#36] ; [0x8002574] = 0x40000420
        0x08002550:    3820         8      SUBS     r0,r0,#0x20
        0x08002552:    f7fefb7e    ..~.    BL       LL_TIM_CC_EnableChannel ; 0x8000c52
;;;100    	}
;;;101    	if (s->e2 < s->dz)	{ 
        0x08002556:    6ae1        .j      LDR      r1,[r4,#0x2c]
        0x08002558:    6ca0        .l      LDR      r0,[r4,#0x48]
        0x0800255a:    4288        .B      CMP      r0,r1
        0x0800255c:    da09        ..      BGE      0x8002572 ; dxdz_callback + 70
;;;102    		s->err += s->dx; 
        0x0800255e:    6aa1        .j      LDR      r1,[r4,#0x28]
        0x08002560:    6c60        `l      LDR      r0,[r4,#0x44]
        0x08002562:    4408        .D      ADD      r0,r0,r1
        0x08002564:    6460        `d      STR      r0,[r4,#0x44]
;;;103    		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3); 
        0x08002566:    f44f7180    O..q    MOV      r1,#0x100
        0x0800256a:    4802        .H      LDR      r0,[pc,#8] ; [0x8002574] = 0x40000420
        0x0800256c:    3820         8      SUBS     r0,r0,#0x20
        0x0800256e:    f7fefb70    ..p.    BL       LL_TIM_CC_EnableChannel ; 0x8000c52
;;;104    	}
;;;105    }
        0x08002572:    bd10        ..      POP      {r4,pc}
    $d
        0x08002574:    40000420     ..@    DCD    1073742880
    $t
    i.dzdx_init
    dzdx_init
;;; .\..\Src\fsm.c
;;;481    void dzdx_init(int dx, int dz, state_t* s) {
        0x08002578:    b530        0.      PUSH     {r4,r5,lr}
;;;482    	s->dx = abs(dx); 
        0x0800257a:    1e03        ..      SUBS     r3,r0,#0
        0x0800257c:    db01        ..      BLT      0x8002582 ; dzdx_init + 10
        0x0800257e:    461c        .F      MOV      r4,r3
        0x08002580:    e000        ..      B        0x8002584 ; dzdx_init + 12
        0x08002582:    425c        \B      RSBS     r4,r3,#0
        0x08002584:    6294        .b      STR      r4,[r2,#0x28]
;;;483    	s->sx = dx > 0 ? 1 : -1;
        0x08002586:    2800        .(      CMP      r0,#0
        0x08002588:    dd01        ..      BLE      0x800258e ; dzdx_init + 22
        0x0800258a:    2301        .#      MOVS     r3,#1
        0x0800258c:    e001        ..      B        0x8002592 ; dzdx_init + 26
        0x0800258e:    f04f33ff    O..3    MOV      r3,#0xffffffff
        0x08002592:    6313        .c      STR      r3,[r2,#0x30]
;;;484      s->dz = abs(dz);
        0x08002594:    1e0b        ..      SUBS     r3,r1,#0
        0x08002596:    db01        ..      BLT      0x800259c ; dzdx_init + 36
        0x08002598:    461c        .F      MOV      r4,r3
        0x0800259a:    e000        ..      B        0x800259e ; dzdx_init + 38
        0x0800259c:    425c        \B      RSBS     r4,r3,#0
        0x0800259e:    62d4        .b      STR      r4,[r2,#0x2c]
;;;485    	s->sz = dz > 0 ? 1 : -1; 
        0x080025a0:    2900        .)      CMP      r1,#0
        0x080025a2:    dd01        ..      BLE      0x80025a8 ; dzdx_init + 48
        0x080025a4:    2301        .#      MOVS     r3,#1
        0x080025a6:    e001        ..      B        0x80025ac ; dzdx_init + 52
        0x080025a8:    f04f33ff    O..3    MOV      r3,#0xffffffff
        0x080025ac:    6353        Sc      STR      r3,[r2,#0x34]
;;;486      s->e2 = s->err = (s->dx > s->dz ? s->dx : -s->dz)/2;
        0x080025ae:    e9d2450a    ...E    LDRD     r4,r5,[r2,#0x28]
        0x080025b2:    42ac        .B      CMP      r4,r5
        0x080025b4:    dd01        ..      BLE      0x80025ba ; dzdx_init + 66
        0x080025b6:    6a94        .j      LDR      r4,[r2,#0x28]
        0x080025b8:    e001        ..      B        0x80025be ; dzdx_init + 70
        0x080025ba:    6ad4        .j      LDR      r4,[r2,#0x2c]
        0x080025bc:    4264        dB      RSBS     r4,r4,#0
        0x080025be:    4623        #F      MOV      r3,r4
        0x080025c0:    eb0474d3    ...t    ADD      r4,r4,r3,LSR #31
        0x080025c4:    1064        d.      ASRS     r4,r4,#1
        0x080025c6:    6454        Td      STR      r4,[r2,#0x44]
        0x080025c8:    6494        .d      STR      r4,[r2,#0x48]
;;;487    	s->set_pulse_function = dxdz_callback;
        0x080025ca:    4b01        .K      LDR      r3,[pc,#4] ; [0x80025d0] = 0x800252d
        0x080025cc:    6593        .e      STR      r3,[r2,#0x58]
;;;488    }
        0x080025ce:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080025d0:    0800252d    -%..    DCD    134227245
    $t
    i.gc_execute_line
    gc_execute_line
;;; .\..\Src\gcode.c
;;;164    {
        0x080025d4:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x080025d8:    4680        .F      MOV      r8,r0
;;;165    //	double feed_rate;
;;;166    //	double extrudeLength;
;;;167    	int char_counter = 0;
        0x080025da:    2000        .       MOVS     r0,#0
        0x080025dc:    9003        ..      STR      r0,[sp,#0xc]
;;;168    	char letter;
;;;169    	double value;
;;;170    //	int pause_value = 0;
;;;171    //	uint8_t radius_mode = false;
;;;172    
;;;173    	gc.status_code = GCSTATUS_OK;
        0x080025de:    49bf        .I      LDR      r1,[pc,#764] ; [0x80028dc] = 0x20000510
        0x080025e0:    7008        .p      STRB     r0,[r1,#0]
;;;174    	
;;;175    	if (line[0] == ';'
        0x080025e2:    f8980000    ....    LDRB     r0,[r8,#0]
        0x080025e6:    283b        ;(      CMP      r0,#0x3b
        0x080025e8:    d007        ..      BEQ      0x80025fa ; gc_execute_line + 38
;;;176    		|| line[0] == '('
        0x080025ea:    f8980000    ....    LDRB     r0,[r8,#0]
        0x080025ee:    2828        ((      CMP      r0,#0x28
        0x080025f0:    d003        ..      BEQ      0x80025fa ; gc_execute_line + 38
;;;177    		|| line[0] == '%'
        0x080025f2:    f8980000    ....    LDRB     r0,[r8,#0]
        0x080025f6:    2825        %(      CMP      r0,#0x25
        0x080025f8:    d103        ..      BNE      0x8002602 ; gc_execute_line + 46
;;;178    		)
;;;179    		return GCSTATUS_OK;	// comments
        0x080025fa:    2000        .       MOVS     r0,#0
        0x080025fc:    b004        ..      ADD      sp,sp,#0x10
        0x080025fe:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;180    
;;;181    	// Pass 1: Commands
;;;182    	while (next_statement(&letter, &value, line, &char_counter))
        0x08002602:    e0ec        ..      B        0x80027de ; gc_execute_line + 522
;;;183    	{
;;;184    		int int_value = (int)value;
        0x08002604:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x08002608:    f7fdff68    ..h.    BL       __aeabi_d2iz ; 0x80004dc
        0x0800260c:    4604        .F      MOV      r4,r0
;;;185    		switch (letter)
        0x0800260e:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x08002612:    2847        G(      CMP      r0,#0x47
        0x08002614:    d004        ..      BEQ      0x8002620 ; gc_execute_line + 76
        0x08002616:    284d        M(      CMP      r0,#0x4d
        0x08002618:    d072        r.      BEQ      0x8002700 ; gc_execute_line + 300
        0x0800261a:    284e        N(      CMP      r0,#0x4e
        0x0800261c:    d1ff        ..      BNE      0x800261e ; gc_execute_line + 74
;;;186    		{
;;;187    		case 'N':
;;;188    			break;
        0x0800261e:    e0d6        ..      B        0x80027ce ; gc_execute_line + 506
;;;189    		case 'G':
;;;190    			switch (int_value)
        0x08002620:    2c28        (,      CMP      r4,#0x28
        0x08002622:    d05d        ].      BEQ      0x80026e0 ; gc_execute_line + 268
        0x08002624:    dc12        ..      BGT      0x800264c ; gc_execute_line + 120
        0x08002626:    2c11        .,      CMP      r4,#0x11
        0x08002628:    d05b        [.      BEQ      0x80026e2 ; gc_execute_line + 270
        0x0800262a:    dc06        ..      BGT      0x800263a ; gc_execute_line + 102
        0x0800262c:    2c05        .,      CMP      r4,#5
        0x0800262e:    d25e        ^.      BCS      0x80026ee ; gc_execute_line + 282
        0x08002630:    e8dff004    ....    TBB      [pc,r4]
    $d
        0x08002634:    302b2621    !&+0    DCD    808134177
        0x08002638:    0035        5.      DCW    53
    $t
        0x0800263a:    2c14        .,      CMP      r4,#0x14
        0x0800263c:    d034        4.      BEQ      0x80026a8 ; gc_execute_line + 212
        0x0800263e:    2c15        .,      CMP      r4,#0x15
        0x08002640:    d036        6.      BEQ      0x80026b0 ; gc_execute_line + 220
        0x08002642:    2c1c        .,      CMP      r4,#0x1c
        0x08002644:    d039        9.      BEQ      0x80026ba ; gc_execute_line + 230
        0x08002646:    2c1e        .,      CMP      r4,#0x1e
        0x08002648:    d151        Q.      BNE      0x80026ee ; gc_execute_line + 282
        0x0800264a:    e035        5.      B        0x80026b8 ; gc_execute_line + 228
        0x0800264c:    2c5b        [,      CMP      r4,#0x5b
        0x0800264e:    d03d        =.      BEQ      0x80026cc ; gc_execute_line + 248
        0x08002650:    dc08        ..      BGT      0x8002664 ; gc_execute_line + 144
        0x08002652:    2c31        1,      CMP      r4,#0x31
        0x08002654:    d049        I.      BEQ      0x80026ea ; gc_execute_line + 278
        0x08002656:    2c40        @,      CMP      r4,#0x40
        0x08002658:    d041        A.      BEQ      0x80026de ; gc_execute_line + 266
        0x0800265a:    2c50        P,      CMP      r4,#0x50
        0x0800265c:    d046        F.      BEQ      0x80026ec ; gc_execute_line + 280
        0x0800265e:    2c5a        Z,      CMP      r4,#0x5a
        0x08002660:    d145        E.      BNE      0x80026ee ; gc_execute_line + 282
        0x08002662:    e02f        /.      B        0x80026c4 ; gc_execute_line + 240
        0x08002664:    2c5c        \,      CMP      r4,#0x5c
        0x08002666:    d035        5.      BEQ      0x80026d4 ; gc_execute_line + 256
        0x08002668:    2c5e        ^,      CMP      r4,#0x5e
        0x0800266a:    d03b        ;.      BEQ      0x80026e4 ; gc_execute_line + 272
        0x0800266c:    2c61        a,      CMP      r4,#0x61
        0x0800266e:    d03b        ;.      BEQ      0x80026e8 ; gc_execute_line + 276
        0x08002670:    2c62        b,      CMP      r4,#0x62
        0x08002672:    d13c        <.      BNE      0x80026ee ; gc_execute_line + 282
        0x08002674:    e037        7.      B        0x80026e6 ; gc_execute_line + 274
;;;191    			{
;;;192    			case 0: gc.next_action = NEXT_ACTION_SEEK_G0; break;
        0x08002676:    2005        .       MOVS     r0,#5
        0x08002678:    4998        .I      LDR      r1,[pc,#608] ; [0x80028dc] = 0x20000510
        0x0800267a:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x0800267e:    e03d        =.      B        0x80026fc ; gc_execute_line + 296
;;;193    			case 1: gc.next_action = NEXT_ACTION_LINEAR_G1; break;
        0x08002680:    2006        .       MOVS     r0,#6
        0x08002682:    4996        .I      LDR      r1,[pc,#600] ; [0x80028dc] = 0x20000510
        0x08002684:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x08002688:    e038        8.      B        0x80026fc ; gc_execute_line + 296
;;;194    			case 2: gc.next_action = NEXT_ACTION_CW_ARC; break;
        0x0800268a:    200b        .       MOVS     r0,#0xb
        0x0800268c:    4993        .I      LDR      r1,[pc,#588] ; [0x80028dc] = 0x20000510
        0x0800268e:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x08002692:    e033        3.      B        0x80026fc ; gc_execute_line + 296
;;;195    			case 3: gc.next_action = NEXT_ACTION_CCW_ARC; break;
        0x08002694:    200c        .       MOVS     r0,#0xc
        0x08002696:    4991        .I      LDR      r1,[pc,#580] ; [0x80028dc] = 0x20000510
        0x08002698:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x0800269c:    e02e        ..      B        0x80026fc ; gc_execute_line + 296
;;;196    			case 4: gc.next_action = NEXT_ACTION_DWELL_G4; break;
        0x0800269e:    2001        .       MOVS     r0,#1
        0x080026a0:    498e        .I      LDR      r1,[pc,#568] ; [0x80028dc] = 0x20000510
        0x080026a2:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x080026a6:    e029        ).      B        0x80026fc ; gc_execute_line + 296
;;;197    			case 20: gc.inches_mode = true; break;
        0x080026a8:    2001        .       MOVS     r0,#1
        0x080026aa:    498c        .I      LDR      r1,[pc,#560] ; [0x80028dc] = 0x20000510
        0x080026ac:    7048        Hp      STRB     r0,[r1,#1]
        0x080026ae:    e025        %.      B        0x80026fc ; gc_execute_line + 296
;;;198    			case 21: gc.inches_mode = false; break;
        0x080026b0:    2000        .       MOVS     r0,#0
        0x080026b2:    498a        .I      LDR      r1,[pc,#552] ; [0x80028dc] = 0x20000510
        0x080026b4:    7048        Hp      STRB     r0,[r1,#1]
        0x080026b6:    e021        !.      B        0x80026fc ; gc_execute_line + 296
;;;199    			case 30:
;;;200    			case 28: gc.next_action = NEXT_ACTION_GO_HOME_G28; break;
        0x080026b8:    bf00        ..      NOP      
        0x080026ba:    2002        .       MOVS     r0,#2
        0x080026bc:    4987        .I      LDR      r1,[pc,#540] ; [0x80028dc] = 0x20000510
        0x080026be:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x080026c2:    e01b        ..      B        0x80026fc ; gc_execute_line + 296
;;;201    			case 90: gc.absolute_mode = true; break;
        0x080026c4:    2001        .       MOVS     r0,#1
        0x080026c6:    4985        .I      LDR      r1,[pc,#532] ; [0x80028dc] = 0x20000510
        0x080026c8:    7088        .p      STRB     r0,[r1,#2]
        0x080026ca:    e017        ..      B        0x80026fc ; gc_execute_line + 296
;;;202    			case 91: gc.absolute_mode = false; break;
        0x080026cc:    2000        .       MOVS     r0,#0
        0x080026ce:    4983        .I      LDR      r1,[pc,#524] ; [0x80028dc] = 0x20000510
        0x080026d0:    7088        .p      STRB     r0,[r1,#2]
        0x080026d2:    e013        ..      B        0x80026fc ; gc_execute_line + 296
;;;203    			case 92: gc.next_action = NEXT_ACTION_RESET_XYZ_G92; break;
        0x080026d4:    2003        .       MOVS     r0,#3
        0x080026d6:    4981        .I      LDR      r1,[pc,#516] ; [0x80028dc] = 0x20000510
        0x080026d8:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x080026dc:    e00e        ..      B        0x80026fc ; gc_execute_line + 296
;;;204    			case 64:
;;;205    			case 40:
        0x080026de:    bf00        ..      NOP      
;;;206    			case 17:	// G17    X-Y
        0x080026e0:    bf00        ..      NOP      
;;;207    			case 94:	// Feedrate per minute
        0x080026e2:    bf00        ..      NOP      
;;;208    			case 98:	// Feedrate per minute (group type A)
        0x080026e4:    bf00        ..      NOP      
;;;209    			case 97:	// Constant spindle speed M T Takes an S address integer, which is interpreted as rev/min (rpm). The default speed mode per system parameter if no mode is programmed. 
        0x080026e6:    bf00        ..      NOP      
;;;210    			case 49:	// Tool length offset compensation cancel
        0x080026e8:    bf00        ..      NOP      
;;;211    			case 80:	// Cancel canned cycle
        0x080026ea:    bf00        ..      NOP      
;;;212    				break;
        0x080026ec:    e006        ..      B        0x80026fc ; gc_execute_line + 296
;;;213    			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
        0x080026ee:    2003        .       MOVS     r0,#3
        0x080026f0:    497a        zI      LDR      r1,[pc,#488] ; [0x80028dc] = 0x20000510
        0x080026f2:    7008        .p      STRB     r0,[r1,#0]
        0x080026f4:    4608        .F      MOV      r0,r1
        0x080026f6:    7800        .x      LDRB     r0,[r0,#0]
        0x080026f8:    e780        ..      B        0x80025fc ; gc_execute_line + 40
        0x080026fa:    e001        ..      B        0x8002700 ; gc_execute_line + 300
        0x080026fc:    bf00        ..      NOP      
;;;214    			}
;;;215    			break;
        0x080026fe:    e066        f.      B        0x80027ce ; gc_execute_line + 506
;;;216    		case 'M':
;;;217    			switch (int_value)
        0x08002700:    2c31        1,      CMP      r4,#0x31
        0x08002702:    d04c        L.      BEQ      0x800279e ; gc_execute_line + 458
        0x08002704:    dc17        ..      BGT      0x8002736 ; gc_execute_line + 354
        0x08002706:    2c08        .,      CMP      r4,#8
        0x08002708:    d04b        K.      BEQ      0x80027a2 ; gc_execute_line + 462
        0x0800270a:    dc07        ..      BGT      0x800271c ; gc_execute_line + 328
        0x0800270c:    2c07        .,      CMP      r4,#7
        0x0800270e:    d256        V.      BCS      0x80027be ; gc_execute_line + 490
        0x08002710:    e8dff004    ....    TBB      [pc,r4]
    $d
        0x08002714:    3a333231    123:    DCD    976433713
        0x08002718:    00523e55    U>R.    DCD    5389909
    $t
        0x0800271c:    2c18        .,      CMP      r4,#0x18
        0x0800271e:    d03c        <.      BEQ      0x800279a ; gc_execute_line + 454
        0x08002720:    dc04        ..      BGT      0x800272c ; gc_execute_line + 344
        0x08002722:    2c09        .,      CMP      r4,#9
        0x08002724:    d03e        >.      BEQ      0x80027a4 ; gc_execute_line + 464
        0x08002726:    2c17        .,      CMP      r4,#0x17
        0x08002728:    d149        I.      BNE      0x80027be ; gc_execute_line + 490
        0x0800272a:    e035        5.      B        0x8002798 ; gc_execute_line + 452
        0x0800272c:    2c1e        .,      CMP      r4,#0x1e
        0x0800272e:    d025        %.      BEQ      0x800277c ; gc_execute_line + 424
        0x08002730:    2c30        0,      CMP      r4,#0x30
        0x08002732:    d144        D.      BNE      0x80027be ; gc_execute_line + 490
        0x08002734:    e034        4.      B        0x80027a0 ; gc_execute_line + 460
        0x08002736:    2c6e        n,      CMP      r4,#0x6e
        0x08002738:    d039        9.      BEQ      0x80027ae ; gc_execute_line + 474
        0x0800273a:    dc0e        ..      BGT      0x800275a ; gc_execute_line + 390
        0x0800273c:    2c6a        j,      CMP      r4,#0x6a
        0x0800273e:    d033        3.      BEQ      0x80027a8 ; gc_execute_line + 468
        0x08002740:    dc06        ..      BGT      0x8002750 ; gc_execute_line + 380
        0x08002742:    2c34        4,      CMP      r4,#0x34
        0x08002744:    d02a        *.      BEQ      0x800279c ; gc_execute_line + 456
        0x08002746:    2c3c        <,      CMP      r4,#0x3c
        0x08002748:    d019        ..      BEQ      0x800277e ; gc_execute_line + 426
        0x0800274a:    2c69        i,      CMP      r4,#0x69
        0x0800274c:    d137        7.      BNE      0x80027be ; gc_execute_line + 490
        0x0800274e:    e02a        *.      B        0x80027a6 ; gc_execute_line + 466
        0x08002750:    2c6b        k,      CMP      r4,#0x6b
        0x08002752:    d02a        *.      BEQ      0x80027aa ; gc_execute_line + 470
        0x08002754:    2c6c        l,      CMP      r4,#0x6c
        0x08002756:    d132        2.      BNE      0x80027be ; gc_execute_line + 490
        0x08002758:    e028        (.      B        0x80027ac ; gc_execute_line + 472
        0x0800275a:    2c8c        .,      CMP      r4,#0x8c
        0x0800275c:    d029        ).      BEQ      0x80027b2 ; gc_execute_line + 478
        0x0800275e:    dc04        ..      BGT      0x800276a ; gc_execute_line + 406
        0x08002760:    2c70        p,      CMP      r4,#0x70
        0x08002762:    d007        ..      BEQ      0x8002774 ; gc_execute_line + 416
        0x08002764:    2c71        q,      CMP      r4,#0x71
        0x08002766:    d12a        *.      BNE      0x80027be ; gc_execute_line + 490
        0x08002768:    e022        ".      B        0x80027b0 ; gc_execute_line + 476
        0x0800276a:    2c8d        .,      CMP      r4,#0x8d
        0x0800276c:    d022        ".      BEQ      0x80027b4 ; gc_execute_line + 480
        0x0800276e:    2c8e        .,      CMP      r4,#0x8e
        0x08002770:    d125        %.      BNE      0x80027be ; gc_execute_line + 490
        0x08002772:    e020         .      B        0x80027b6 ; gc_execute_line + 482
;;;218    			{
;;;219    			case 112: // Emergency Stop 
;;;220    			case 0:
        0x08002774:    bf00        ..      NOP      
;;;221    			case 1:
        0x08002776:    bf00        ..      NOP      
;;;222    			case 2:
        0x08002778:    bf00        ..      NOP      
;;;223    			case 30:
        0x0800277a:    bf00        ..      NOP      
;;;224    			case 60:
        0x0800277c:    bf00        ..      NOP      
;;;225    				gc.next_action = NEXT_ACTION_STOP;
        0x0800277e:    2004        .       MOVS     r0,#4
        0x08002780:    4956        VI      LDR      r1,[pc,#344] ; [0x80028dc] = 0x20000510
        0x08002782:    f8810042    ..B.    STRB     r0,[r1,#0x42]
;;;226    				break;
        0x08002786:    e020         .      B        0x80027ca ; gc_execute_line + 502
;;;227    			case 3: gc.spindle_on = 1; break;
        0x08002788:    2001        .       MOVS     r0,#1
        0x0800278a:    4954        TI      LDR      r1,[pc,#336] ; [0x80028dc] = 0x20000510
        0x0800278c:    70c8        .p      STRB     r0,[r1,#3]
        0x0800278e:    e01c        ..      B        0x80027ca ; gc_execute_line + 502
;;;228    			//	case 4: gc.spindle_direction = -1; break;
;;;229    			case 5: gc.spindle_on = 0; break;
        0x08002790:    2000        .       MOVS     r0,#0
        0x08002792:    4952        RI      LDR      r1,[pc,#328] ; [0x80028dc] = 0x20000510
        0x08002794:    70c8        .p      STRB     r0,[r1,#3]
        0x08002796:    e018        ..      B        0x80027ca ; gc_execute_line + 502
;;;230    			case 23: // Thread gradual pullout ON
;;;231    			case 24: // Thread gradual pullout OFF
        0x08002798:    bf00        ..      NOP      
;;;232    			case 52: // Unload Last tool from spindle
        0x0800279a:    bf00        ..      NOP      
;;;233    			case 49: // Feedrate override NOT allowed
        0x0800279c:    bf00        ..      NOP      
;;;234    			case 48: // Feedrate override allowed
        0x0800279e:    bf00        ..      NOP      
;;;235    			case 8:  // Coolant on
        0x080027a0:    bf00        ..      NOP      
;;;236    			case 9:  // Coolant off
        0x080027a2:    bf00        ..      NOP      
;;;237    			case 105: // M105: Get Extruder Temperature Example: M105 Request the temperature of the current extruder and the build base in degrees Celsius. The temperatures are returned to the host computer. For example, the line sent to the host in response to this command looks like 
        0x080027a4:    bf00        ..      NOP      
;;;238    			case 106: // M106: Fan On Example: M106 S127 Turn on the cooling fan at half speed. Optional parameter 'S' declares the PWM value (0-255) 
        0x080027a6:    bf00        ..      NOP      
;;;239    			case 107: // Fan Off 
        0x080027a8:    bf00        ..      NOP      
;;;240    			case 108: // M108: Set Extruder Speed  Sets speed of extruder motor. (Deprecated in current firmware, see M113) 
        0x080027aa:    bf00        ..      NOP      
;;;241    			case 110: // Set Current Line Number 
        0x080027ac:    bf00        ..      NOP      
;;;242    			case 113: // Set Extruder PWM 
        0x080027ae:    bf00        ..      NOP      
;;;243    			case 140: // Bed Temperature (Fast) Example: M140 S55 Set the temperature of the build bed to 55oC 
        0x080027b0:    bf00        ..      NOP      
;;;244    			case 141: //Chamber Temperature (Fast) Example: M141 S30 Set the temperature of the chamber to 30oC
        0x080027b2:    bf00        ..      NOP      
;;;245    			case 142: // Holding Pressure Example: M142 S1 Set the holding pressure of the bed to 1 bar. 
        0x080027b4:    bf00        ..      NOP      
;;;246    			case 6:
        0x080027b6:    bf00        ..      NOP      
;;;247    				return gc.status_code;
        0x080027b8:    4848        HH      LDR      r0,[pc,#288] ; [0x80028dc] = 0x20000510
        0x080027ba:    7800        .x      LDRB     r0,[r0,#0]
        0x080027bc:    e71e        ..      B        0x80025fc ; gc_execute_line + 40
;;;248    			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
        0x080027be:    2003        .       MOVS     r0,#3
        0x080027c0:    4946        FI      LDR      r1,[pc,#280] ; [0x80028dc] = 0x20000510
        0x080027c2:    7008        .p      STRB     r0,[r1,#0]
        0x080027c4:    4608        .F      MOV      r0,r1
        0x080027c6:    7800        .x      LDRB     r0,[r0,#0]
        0x080027c8:    e718        ..      B        0x80025fc ; gc_execute_line + 40
        0x080027ca:    bf00        ..      NOP      
;;;249    			}
;;;250    			break;
        0x080027cc:    bf00        ..      NOP      
        0x080027ce:    bf00        ..      NOP      
;;;251    		}
;;;252    		if (gc.status_code)
        0x080027d0:    4842        BH      LDR      r0,[pc,#264] ; [0x80028dc] = 0x20000510
        0x080027d2:    7800        .x      LDRB     r0,[r0,#0]
        0x080027d4:    b110        ..      CBZ      r0,0x80027dc ; gc_execute_line + 520
;;;253    			return (gc.status_code);
        0x080027d6:    4841        AH      LDR      r0,[pc,#260] ; [0x80028dc] = 0x20000510
        0x080027d8:    7800        .x      LDRB     r0,[r0,#0]
        0x080027da:    e70f        ..      B        0x80025fc ; gc_execute_line + 40
;;;254    	}
        0x080027dc:    bf00        ..      NOP      
        0x080027de:    ab03        ..      ADD      r3,sp,#0xc
        0x080027e0:    4642        BF      MOV      r2,r8
        0x080027e2:    4669        iF      MOV      r1,sp
        0x080027e4:    a802        ..      ADD      r0,sp,#8
        0x080027e6:    f000f985    ....    BL       next_statement ; 0x8002af4
        0x080027ea:    2800        .(      CMP      r0,#0
        0x080027ec:    f47faf0a    ....    BNE      0x8002604 ; gc_execute_line + 48
;;;255    	if (gc.status_code)
        0x080027f0:    483a        :H      LDR      r0,[pc,#232] ; [0x80028dc] = 0x20000510
        0x080027f2:    7800        .x      LDRB     r0,[r0,#0]
        0x080027f4:    b110        ..      CBZ      r0,0x80027fc ; gc_execute_line + 552
;;;256    		return(gc.status_code);
        0x080027f6:    4839        9H      LDR      r0,[pc,#228] ; [0x80028dc] = 0x20000510
        0x080027f8:    7800        .x      LDRB     r0,[r0,#0]
        0x080027fa:    e6ff        ..      B        0x80025fc ; gc_execute_line + 40
;;;257    
;;;258    	char_counter = 0;
        0x080027fc:    2000        .       MOVS     r0,#0
        0x080027fe:    9003        ..      STR      r0,[sp,#0xc]
;;;259    
;;;260    	// Pass 2: Parameters
;;;261    	while (next_statement(&letter, &value, line, &char_counter))
        0x08002800:    e061        a.      B        0x80028c6 ; gc_execute_line + 754
;;;262    	{
;;;263    		double unit_millimeters_value = to_millimeters(value);
        0x08002802:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x08002806:    f000fb8f    ....    BL       to_millimeters ; 0x8002f28
        0x0800280a:    4604        .F      MOV      r4,r0
        0x0800280c:    460d        .F      MOV      r5,r1
;;;264    		switch (letter)
        0x0800280e:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x08002812:    3846        F8      SUBS     r0,r0,#0x46
        0x08002814:    2815        .(      CMP      r0,#0x15
        0x08002816:    d24e        N.      BCS      0x80028b6 ; gc_execute_line + 738
        0x08002818:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0800281c:    464d4a0b    .JMF    DCD    1179470347
        0x08002820:    4c4d4847    GHML    DCD    1280133191
        0x08002824:    4d4d4d4b    KMMM    DCD    1296911691
        0x08002828:    4d4d1849    I.MM    DCD    1296898121
        0x0800282c:    22214d4d    MM!"    DCD    572607821
        0x08002830:    0023        #.      DCW    35
    $t
;;;265    		{
;;;266    //		case 'E': extrudeLength = value; break;
;;;267    		case 'F':
;;;268    			if (gc.next_action == NEXT_ACTION_SEEK_G0)
        0x08002832:    482a        *H      LDR      r0,[pc,#168] ; [0x80028dc] = 0x20000510
        0x08002834:    f8900042    ..B.    LDRB     r0,[r0,#0x42]
        0x08002838:    2805        .(      CMP      r0,#5
        0x0800283a:    d103        ..      BNE      0x8002844 ; gc_execute_line + 624
;;;269    				gc.seek_rate = unit_millimeters_value;
        0x0800283c:    4827        'H      LDR      r0,[pc,#156] ; [0x80028dc] = 0x20000510
        0x0800283e:    e9c04504    ...E    STRD     r4,r5,[r0,#0x10]
        0x08002842:    e002        ..      B        0x800284a ; gc_execute_line + 630
;;;270    			else
;;;271    				gc.feed_rate = unit_millimeters_value; // millimeters pr min
        0x08002844:    4825        %H      LDR      r0,[pc,#148] ; [0x80028dc] = 0x20000510
        0x08002846:    e9c04502    ...E    STRD     r4,r5,[r0,#8]
;;;272    			//	if (unit_millimeters_value > SM_MAX_FEEDRATE)
;;;273    			//		FAIL(GCSTATUS_UNSOPORTED_FEEDRATE);
;;;274    			break;
        0x0800284a:    e03a        :.      B        0x80028c2 ; gc_execute_line + 750
;;;275    //		case 'P': pause_value = (int)value; break;
;;;276    		case 'S': gc.s_value = (int16_t)value; break;
        0x0800284c:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x08002850:    f7fdfe44    ..D.    BL       __aeabi_d2iz ; 0x80004dc
        0x08002854:    b200        ..      SXTH     r0,r0
        0x08002856:    4921        !I      LDR      r1,[pc,#132] ; [0x80028dc] = 0x20000510
        0x08002858:    f8a10040    ..@.    STRH     r0,[r1,#0x40]
        0x0800285c:    e031        1.      B        0x80028c2 ; gc_execute_line + 750
;;;277    		case 'X':
;;;278    		case 'Y':
        0x0800285e:    bf00        ..      NOP      
;;;279    		case 'Z':
        0x08002860:    bf00        ..      NOP      
;;;280    			if (gc.absolute_mode)
        0x08002862:    481e        .H      LDR      r0,[pc,#120] ; [0x80028dc] = 0x20000510
        0x08002864:    7880        .x      LDRB     r0,[r0,#2]
        0x08002866:    b140        @.      CBZ      r0,0x800287a ; gc_execute_line + 678
;;;281    				gc.position[letter - 'X'] = unit_millimeters_value;
        0x08002868:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x0800286c:    3858        X8      SUBS     r0,r0,#0x58
        0x0800286e:    491b        .I      LDR      r1,[pc,#108] ; [0x80028dc] = 0x20000510
        0x08002870:    3128        (1      ADDS     r1,r1,#0x28
        0x08002872:    eb0100c0    ....    ADD      r0,r1,r0,LSL #3
        0x08002876:    c030        0.      STM      r0!,{r4,r5}
        0x08002878:    e015        ..      B        0x80028a6 ; gc_execute_line + 722
;;;282    			else
;;;283    				gc.position[letter - 'X'] += unit_millimeters_value;
        0x0800287a:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x0800287e:    3858        X8      SUBS     r0,r0,#0x58
        0x08002880:    4916        .I      LDR      r1,[pc,#88] ; [0x80028dc] = 0x20000510
        0x08002882:    3128        (1      ADDS     r1,r1,#0x28
        0x08002884:    eb0100c0    ....    ADD      r0,r1,r0,LSL #3
        0x08002888:    4622        "F      MOV      r2,r4
        0x0800288a:    462b        +F      MOV      r3,r5
        0x0800288c:    e9d06100    ...a    LDRD     r6,r1,[r0,#0]
        0x08002890:    4630        0F      MOV      r0,r6
        0x08002892:    f7fdfc8a    ....    BL       __aeabi_dadd ; 0x80001aa
        0x08002896:    f89d2008    ...     LDRB     r2,[sp,#8]
        0x0800289a:    3a58        X:      SUBS     r2,r2,#0x58
        0x0800289c:    4b0f        .K      LDR      r3,[pc,#60] ; [0x80028dc] = 0x20000510
        0x0800289e:    3328        (3      ADDS     r3,r3,#0x28
        0x080028a0:    eb0302c2    ....    ADD      r2,r3,r2,LSL #3
        0x080028a4:    c203        ..      STM      r2!,{r0,r1}
;;;284    			break;
        0x080028a6:    e00c        ..      B        0x80028c2 ; gc_execute_line + 750
;;;285    		case 'I':
;;;286    		case 'J':
        0x080028a8:    bf00        ..      NOP      
;;;287    		case 'K':
        0x080028aa:    bf00        ..      NOP      
;;;288    //			offset[letter - 'I'] = unit_millimeters_value;
;;;289    			break;
        0x080028ac:    e009        ..      B        0x80028c2 ; gc_execute_line + 750
;;;290    		case 'R':
;;;291    //			radius = unit_millimeters_value;
;;;292    //			radius_mode = true;
;;;293    			break;
        0x080028ae:    e008        ..      B        0x80028c2 ; gc_execute_line + 750
;;;294    		case 'G':
;;;295    		case 'N':
        0x080028b0:    bf00        ..      NOP      
;;;296    		case 'M':
        0x080028b2:    bf00        ..      NOP      
;;;297    			break;
        0x080028b4:    e005        ..      B        0x80028c2 ; gc_execute_line + 750
;;;298    		default:
;;;299    			FAIL(GCSTATUS_UNSUPPORTED_PARAM);
        0x080028b6:    2005        .       MOVS     r0,#5
        0x080028b8:    4908        .I      LDR      r1,[pc,#32] ; [0x80028dc] = 0x20000510
        0x080028ba:    7008        .p      STRB     r0,[r1,#0]
        0x080028bc:    4608        .F      MOV      r0,r1
        0x080028be:    7800        .x      LDRB     r0,[r0,#0]
        0x080028c0:    e69c        ..      B        0x80025fc ; gc_execute_line + 40
        0x080028c2:    bf00        ..      NOP      
;;;300    		}
;;;301    	}
        0x080028c4:    bf00        ..      NOP      
        0x080028c6:    ab03        ..      ADD      r3,sp,#0xc
        0x080028c8:    4642        BF      MOV      r2,r8
        0x080028ca:    4669        iF      MOV      r1,sp
        0x080028cc:    a802        ..      ADD      r0,sp,#8
        0x080028ce:    f000f911    ....    BL       next_statement ; 0x8002af4
        0x080028d2:    2800        .(      CMP      r0,#0
        0x080028d4:    d195        ..      BNE      0x8002802 ; gc_execute_line + 558
;;;302    	
;;;303    	return(gc.status_code);
        0x080028d6:    4801        .H      LDR      r0,[pc,#4] ; [0x80028dc] = 0x20000510
        0x080028d8:    7800        .x      LDRB     r0,[r0,#0]
        0x080028da:    e68f        ..      B        0x80025fc ; gc_execute_line + 40
    $d
        0x080028dc:    20000510    ...     DCD    536872208
    $t
    i.init_buttons
    init_buttons
;;; .\..\Src\buttons.c
;;;11     void init_buttons(void){
        0x080028e0:    b510        ..      PUSH     {r4,lr}
;;;12     
;;;13     	bt[0].clk_mode = 10;
        0x080028e2:    200a        .       MOVS     r0,#0xa
        0x080028e4:    4906        .I      LDR      r1,[pc,#24] ; [0x8002900] = 0x200004ec
        0x080028e6:    61c8        .a      STR      r0,[r1,#0x1c]
;;;14     	bt[0].GPIOx = BUTTON_1_GPIO_Port;
        0x080028e8:    4806        .H      LDR      r0,[pc,#24] ; [0x8002904] = 0x40010800
        0x080028ea:    6008        .`      STR      r0,[r1,#0]
;;;15     	bt[0].button_pin = BUTTON_1_Pin;
        0x080028ec:    4806        .H      LDR      r0,[pc,#24] ; [0x8002908] = 0x4010001
        0x080028ee:    6048        H`      STR      r0,[r1,#4]
;;;16     	bt[0].buttons = bt[0].buttons_mask = LL_GPIO_IsInputPinSet(bt[0].GPIOx,BUTTON_1_Pin); //bt[0].GPIOx->IDR & bt[0].button_pin;
        0x080028f0:    6808        .h      LDR      r0,[r1,#0]
        0x080028f2:    4905        .I      LDR      r1,[pc,#20] ; [0x8002908] = 0x4010001
        0x080028f4:    f7fef8b7    ....    BL       LL_GPIO_IsInputPinSet ; 0x8000a66
        0x080028f8:    4901        .I      LDR      r1,[pc,#4] ; [0x8002900] = 0x200004ec
        0x080028fa:    6188        .a      STR      r0,[r1,#0x18]
        0x080028fc:    60c8        .`      STR      r0,[r1,#0xc]
;;;17     	return;
;;;18     	bt[1] = bt[0];
;;;19     	bt[1].clk_mode = 10;
;;;20     	bt[1].GPIOx = BUTTON_2_GPIO_Port;
;;;21     	bt[1].button_pin = BUTTON_2_Pin;
;;;22     	bt[1].buttons = bt[1].buttons_mask = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;23     
;;;24     	if(device_ready == 1){
;;;25     //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);		
;;;26     		reqest_sample_i2c_dma();
;;;27     //		while(ubTransferComplete == 0){
;;;28     //		}
;;;29     	}
;;;30     	bt[2].clk_mode = 10;
;;;31     	bt[2].button_pin = 0x02; // button_c code
;;;32     	bt[2].buttons = bt[2].buttons_mask = dma_data[5]&bt[2].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;33     	
;;;34     	bt[3].clk_mode = 10;
;;;35     	bt[3].button_pin = 0x01; // button_c code
;;;36     	bt[3].buttons = bt[3].buttons_mask = dma_data[5]&bt[3].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;37     
;;;38     }
        0x080028fe:    bd10        ..      POP      {r4,pc}
    $d
        0x08002900:    200004ec    ...     DCD    536872172
        0x08002904:    40010800    ...@    DCD    1073809408
        0x08002908:    04010001    ....    DCD    67174401
    $t
    i.main
    main
;;; .\../Src/main.c
;;;236    {
        0x0800290c:    b51f        ..      PUSH     {r0-r4,lr}
;;;237      /* USER CODE BEGIN 1 */
;;;238    //	z_axis.mode = fsm_menu_lps;
;;;239    	rs = 11;
        0x0800290e:    200b        .       MOVS     r0,#0xb
        0x08002910:    4965        eI      LDR      r1,[pc,#404] ; [0x8002aa8] = 0x200000b0
        0x08002912:    6008        .`      STR      r0,[r1,#0]
;;;240    
;;;241    	char code[] = "G01 X.2 Z100F10";
        0x08002914:    a365        e.      ADR      r3,{pc}+0x198 ; 0x8002aac
        0x08002916:    e9d31200    ....    LDRD     r1,r2,[r3,#0]
        0x0800291a:    e9d30302    ....    LDRD     r0,r3,[r3,#8]
        0x0800291e:    e9cd0302    ....    STRD     r0,r3,[sp,#8]
        0x08002922:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
;;;242    	gc_execute_line(code);
        0x08002926:    4668        hF      MOV      r0,sp
        0x08002928:    f7fffe54    ..T.    BL       gc_execute_line ; 0x80025d4
;;;243    //	z_axis.end_pos = 50;
;;;244    //	z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;245    
;;;246    //	state.main_feed_direction = 1;
;;;247    
;;;248    	//	do_fsm_move_start(&state);
;;;249    	//	do_fsm_wait_tacho(&state);
;;;250    	
;;;251    //	TIM4_IRQHandler();
;;;252      /* USER CODE END 1 */
;;;253    
;;;254      /* MCU Configuration--------------------------------------------------------*/
;;;255    
;;;256      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;257      
;;;258    
;;;259      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_AFIO);
        0x0800292c:    2001        .       MOVS     r0,#1
        0x0800292e:    f7fdff8b    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;260      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
        0x08002932:    f04f5080    O..P    MOV      r0,#0x10000000
        0x08002936:    f7fdff79    ..y.    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;261    
;;;262      NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
        0x0800293a:    2003        .       MOVS     r0,#3
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1425     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
        0x0800293c:    4602        .F      MOV      r2,r0
;;;1426   
;;;1427     reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
        0x0800293e:    4b5f        _K      LDR      r3,[pc,#380] ; [0x8002abc] = 0xe000ed0c
        0x08002940:    6819        .h      LDR      r1,[r3,#0]
;;;1428     reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
        0x08002942:    f64f03ff    O...    MOV      r3,#0xf8ff
        0x08002946:    4019        .@      ANDS     r1,r1,r3
;;;1429     reg_value  =  (reg_value                                   |
        0x08002948:    4b5d        ]K      LDR      r3,[pc,#372] ; [0x8002ac0] = 0x5fa0000
        0x0800294a:    430b        .C      ORRS     r3,r3,r1
        0x0800294c:    ea432102    C..!    ORR      r1,r3,r2,LSL #8
;;;1430                   ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
;;;1431                   (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
;;;1432     SCB->AIRCR =  reg_value;
        0x08002950:    4b5a        ZK      LDR      r3,[pc,#360] ; [0x8002abc] = 0xe000ed0c
        0x08002952:    6019        .`      STR      r1,[r3,#0]
;;;1433   }
        0x08002954:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;268      LL_GPIO_AF_Remap_SWJ_NOJTAG();
        0x08002956:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;1597     CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
        0x08002958:    485a        ZH      LDR      r0,[pc,#360] ; [0x8002ac4] = 0x40010000
        0x0800295a:    6840        @h      LDR      r0,[r0,#4]
        0x0800295c:    f02060e0     ..`    BIC      r0,r0,#0x7000000
        0x08002960:    4958        XI      LDR      r1,[pc,#352] ; [0x8002ac4] = 0x40010000
        0x08002962:    6048        H`      STR      r0,[r1,#4]
;;;1598     SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);
        0x08002964:    4608        .F      MOV      r0,r1
        0x08002966:    6840        @h      LDR      r0,[r0,#4]
        0x08002968:    f0407000    @..p    ORR      r0,r0,#0x2000000
        0x0800296c:    6048        H`      STR      r0,[r1,#4]
;;;1599   }
        0x0800296e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;274      SystemClock_Config();
        0x08002970:    f7fff9a0    ....    BL       SystemClock_Config ; 0x8001cb4
;;;275    
;;;276      /* USER CODE BEGIN SysInit */
;;;277    	LL_SYSTICK_EnableIT();
        0x08002974:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;291      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
        0x08002976:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x0800297a:    6900        .i      LDR      r0,[r0,#0x10]
        0x0800297c:    f0400002    @...    ORR      r0,r0,#2
        0x08002980:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08002984:    6108        .a      STR      r0,[r1,#0x10]
;;;292    }
        0x08002986:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;281      MX_GPIO_Init();
        0x08002988:    f7fefc18    ....    BL       MX_GPIO_Init ; 0x80011bc
;;;282      MX_DMA_Init();
        0x0800298c:    f7fefbe8    ....    BL       MX_DMA_Init ; 0x8001160
;;;283      MX_I2C2_Init();
        0x08002990:    f7fefc8e    ....    BL       MX_I2C2_Init ; 0x80012b0
;;;284      MX_TIM1_Init();
        0x08002994:    f7fefd24    ..$.    BL       MX_TIM1_Init ; 0x80013e0
;;;285      MX_TIM2_Init();
        0x08002998:    f7fefd8c    ....    BL       MX_TIM2_Init ; 0x80014b4
;;;286      MX_TIM3_Init();
        0x0800299c:    f7fefdde    ....    BL       MX_TIM3_Init ; 0x800155c
;;;287      MX_TIM4_Init();
        0x080029a0:    f7fefea0    ....    BL       MX_TIM4_Init ; 0x80016e4
;;;288      MX_USART2_UART_Init();
        0x080029a4:    f7feff32    ..2.    BL       MX_USART2_UART_Init ; 0x800180c
;;;289      /* USER CODE BEGIN 2 */
;;;290    	// Timers post init:
;;;291    	LL_TIM_GenerateEvent_UPDATE(TIM2);
        0x080029a8:    f04f4080    O..@    MOV      r0,#0x40000000
        0x080029ac:    f7fef96e    ..n.    BL       LL_TIM_GenerateEvent_UPDATE ; 0x8000c8c
;;;292    //  LL_TIM_CC_EnableChannel(TIM2, LL_TIM_CHANNEL_CH1); // if we need output on leg
;;;293      LL_TIM_ClearFlag_UPDATE(TIM2);
        0x080029b0:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x080029b2:    f06f0001    o...    MVN      r0,#1
        0x080029b6:    f04f4180    O..A    MOV      r1,#0x40000000
        0x080029ba:    6108        .a      STR      r0,[r1,#0x10]
;;;2933   }
        0x080029bc:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;294    	LL_TIM_EnableIT_UPDATE(TIM2);
        0x080029be:    4608        .F      MOV      r0,r1
        0x080029c0:    f7fef95a    ..Z.    BL       LL_TIM_EnableIT_UPDATE ; 0x8000c78
;;;295    
;;;296    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;297    
;;;298    
;;;299    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;300    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1);
;;;301    //	TIM3->SR = 0;
;;;302    //	TIM2->SR = 0;
;;;303    	TIM3->ARR = 0;
        0x080029c4:    2000        .       MOVS     r0,#0
        0x080029c6:    4940        @I      LDR      r1,[pc,#256] ; [0x8002ac8] = 0x4000042c
        0x080029c8:    6008        .`      STR      r0,[r1,#0]
;;;304    	LL_TIM_GenerateEvent_UPDATE(TIM3);
        0x080029ca:    483f        ?H      LDR      r0,[pc,#252] ; [0x8002ac8] = 0x4000042c
        0x080029cc:    382c        ,8      SUBS     r0,r0,#0x2c
        0x080029ce:    f7fef95d    ..].    BL       LL_TIM_GenerateEvent_UPDATE ; 0x8000c8c
;;;305    	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x080029d2:    f2401001    @...    MOV      r0,#0x101
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1493     SET_BIT(TIMx->CCER, Channels);
        0x080029d6:    493c        <I      LDR      r1,[pc,#240] ; [0x8002ac8] = 0x4000042c
        0x080029d8:    392c        ,9      SUBS     r1,r1,#0x2c
        0x080029da:    6a09        .j      LDR      r1,[r1,#0x20]
        0x080029dc:    4301        .C      ORRS     r1,r1,r0
        0x080029de:    4a3a        :J      LDR      r2,[pc,#232] ; [0x8002ac8] = 0x4000042c
        0x080029e0:    3a2c        ,:      SUBS     r2,r2,#0x2c
        0x080029e2:    6211        .b      STR      r1,[r2,#0x20]
;;;1494   }
        0x080029e4:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;306    	TIM3->SR = 0;
        0x080029e6:    2000        .       MOVS     r0,#0
        0x080029e8:    4937        7I      LDR      r1,[pc,#220] ; [0x8002ac8] = 0x4000042c
        0x080029ea:    391c        .9      SUBS     r1,r1,#0x1c
        0x080029ec:    6008        .`      STR      r0,[r1,#0]
;;;307    	LL_TIM_EnableIT_UPDATE(TIM3);
        0x080029ee:    4610        .F      MOV      r0,r2
        0x080029f0:    f7fef942    ..B.    BL       LL_TIM_EnableIT_UPDATE ; 0x8000c78
;;;308    
;;;309    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;310    
;;;311    
;;;312    
;;;313    	if(LL_GPIO_IsInputPinSet(BUTTON_1_GPIO_Port, BUTTON_1_Pin)){
        0x080029f4:    4835        5H      LDR      r0,[pc,#212] ; [0x8002acc] = 0x4010001
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x080029f6:    4936        6I      LDR      r1,[pc,#216] ; [0x8002ad0] = 0x40010800
        0x080029f8:    6889        .h      LDR      r1,[r1,#8]
        0x080029fa:    f3c0220f    ..."    UBFX     r2,r0,#8,#16
        0x080029fe:    4011        .@      ANDS     r1,r1,r2
        0x08002a00:    f3c0220f    ..."    UBFX     r2,r0,#8,#16
        0x08002a04:    4291        .B      CMP      r1,r2
        0x08002a06:    d101        ..      BNE      0x8002a0c ; main + 256
        0x08002a08:    2101        .!      MOVS     r1,#1
        0x08002a0a:    e000        ..      B        0x8002a0e ; main + 258
        0x08002a0c:    2100        .!      MOVS     r1,#0
        0x08002a0e:    b111        ..      CBZ      r1,0x8002a16 ; main + 266
;;; .\../Src/main.c
;;;314    		demo = true;
        0x08002a10:    2001        .       MOVS     r0,#1
        0x08002a12:    4930        0I      LDR      r1,[pc,#192] ; [0x8002ad4] = 0x20000041
        0x08002a14:    7008        .p      STRB     r0,[r1,#0]
;;;315    	}
;;;316    //	MOTOR_Z_Disable();
;;;317    //	MOTOR_X_Disable();
;;;318    //  
;;;319    #ifndef _SIMU
;;;320    	Activate_I2C_Master();
;;;321    	init_screen(I2C2);
;;;322    //	update_screen();
;;;323    //	i2c_device_init(I2C2);
;;;324    	LL_mDelay(250);
;;;325    #endif
;;;326    	init_buttons();
        0x08002a16:    f7ffff63    ..c.    BL       init_buttons ; 0x80028e0
;;;327      /* USER CODE END 2 */
;;;328    
;;;329      /* Infinite loop */
;;;330      /* USER CODE BEGIN WHILE */
;;;331    
;;;332    
;;;333    ///// from STM examples:
;;;334    //  /**************************/
;;;335    //  /* Start pulse generation */
;;;336    //  /**************************/
;;;337    //  /* Enable channel 1 */
;;;338    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;339    //  
;;;340    //  /* Enable TIM3 outputs */
;;;341    //  LL_TIM_EnableAllOutputs(TIM3);
;;;342    //  
;;;343    //  /* Enable auto-reload register preload */
;;;344    //  LL_TIM_EnableARRPreload(TIM3);
;;;345    
;;;346    //  /* Force update generation */
;;;347    //  LL_TIM_GenerateEvent_UPDATE(TIM3);  
;;;348    
;;;349    
;;;350    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;351    
;;;352    
;;;353    
;;;354    
;;;355    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;356    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;357    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;358    
;;;359    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;360    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;361    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;362    
;;;363    
;;;364    //	MOTOR_X_BlockPulse(); // LL_TIM_OC_SetCompareCH3(TIM3, 0);
;;;365    //	MOTOR_Z_BlockPulse(); // LL_TIM_OC_SetCompareCH3(TIM3, 0);
;;;366    
;;;367    //LL_TIM_EnableCounter(TIM3);
;;;368    
;;;369    
;;;370    //TIM3->SR = 0;
;;;371    //TIM3->EGR |= TIM_EGR_UG;
;;;372    //		LL_TIM_GenerateEvent_UPDATE(TIM3); /* Force update generation */
;;;373    
;;;374    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1);
;;;375    	//GPIOB->BSRR
;;;376    //	LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_0);
;;;377    //	LL_mDelay(50);
;;;378    //	LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_0);
;;;379    //	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;380    	
;;;381    //	LL_TIM_EnableAllOutputs(TIM3);
;;;382    //MOTOR_X_AllowPulse();
;;;383    //MOTOR_Z_AllowPulse();
;;;384    //		LL_mDelay(50);
;;;385    //	LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;386      LL_TIM_EnableIT_CC3(TIM4);													// enable interrupts for TACHO events from encoder
        0x08002a1a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
        0x08002a1c:    482e        .H      LDR      r0,[pc,#184] ; [0x8002ad8] = 0x40000800
        0x08002a1e:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002a20:    f0400008    @...    ORR      r0,r0,#8
        0x08002a24:    492c        ,I      LDR      r1,[pc,#176] ; [0x8002ad8] = 0x40000800
        0x08002a26:    60c8        .`      STR      r0,[r1,#0xc]
;;;3303   }
        0x08002a28:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;387      LL_TIM_EnableCounter(TIM4); 												//Enable timer 4
        0x08002a2a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x08002a2c:    4608        .F      MOV      r0,r1
        0x08002a2e:    6800        .h      LDR      r0,[r0,#0]
        0x08002a30:    f0400001    @...    ORR      r0,r0,#1
        0x08002a34:    6008        .`      STR      r0,[r1,#0]
;;;1028   }
        0x08002a36:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;389    	TIM4->SR = 0; 																			// reset interrup flags
        0x08002a38:    2000        .       MOVS     r0,#0
        0x08002a3a:    4927        'I      LDR      r1,[pc,#156] ; [0x8002ad8] = 0x40000800
        0x08002a3c:    3110        .1      ADDS     r1,r1,#0x10
        0x08002a3e:    6008        .`      STR      r0,[r1,#0]
;;;390    
;;;391    //	LL_TIM_EnableIT_UPDATE(TIM1);
;;;392    //	LL_TIM_EnableIT_UPDATE(TIM2);
;;;393    //	LL_TIM_EnableCounter(TIM2);
;;;394    	
;;;395    //	do_fsm_move_start(&state);
;;;396    
;;;397    	
;;;398      /* Enable counter */
;;;399    //  LL_TIM_EnableCounter(TIM2);
;;;400      /* Force update generation */
;;;401    //  LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;402    
;;;403    // init buttons
;;;404    //	LL_mDelay(5);
;;;405    	do_fsm_menu(&state);
        0x08002a40:    4826        &H      LDR      r0,[pc,#152] ; [0x8002adc] = 0x20000044
        0x08002a42:    f7fffad7    ....    BL       do_fsm_menu ; 0x8001ff4
;;;406    //	LL_mDelay(5);
;;;407    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;408    	LED_GPIO_Port->BSRR = LED_Pin; // led off
        0x08002a46:    4826        &H      LDR      r0,[pc,#152] ; [0x8002ae0] = 0x4200020
        0x08002a48:    4926        &I      LDR      r1,[pc,#152] ; [0x8002ae4] = 0x40011000
        0x08002a4a:    6108        .a      STR      r0,[r1,#0x10]
;;;409    	while (1) {
        0x08002a4c:    e02b        +.      B        0x8002aa6 ; main + 410
;;;410        /* USER CODE END WHILE */
;;;411    
;;;412        /* USER CODE BEGIN 3 */
;;;413    #ifndef _SIMU		
;;;414    //		reqest_sample_i2c_dma(); // init reqest to joystick by DMA, when process_button complete i2c done its job
;;;415    #endif		
;;;416    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;417    		process_button();
        0x08002a4e:    f000f88b    ....    BL       process_button ; 0x8002b68
;;;418    //		process_joystick();
;;;419    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;420    
;;;421    
;;;422    //		uint8_t level = Thread_Info[Menu_Step].level;
;;;423    
;;;424    //		if(auto_mode == true) {
;;;425    //			if ( auto_mode_delay == 0 ) {
;;;426    //				buttons_flag_set = single_click_Msk; //
;;;427    //			}
;;;428    //		}
;;;429    
;;;430    		if(buttons_flag_set) {
        0x08002a52:    4825        %H      LDR      r0,[pc,#148] ; [0x8002ae8] = 0x200005dc
        0x08002a54:    6800        .h      LDR      r0,[r0,#0]
        0x08002a56:    b128        (.      CBZ      r0,0x8002a64 ; main + 344
;;;431    			do_fsm_menu(&state);
        0x08002a58:    4820         H      LDR      r0,[pc,#128] ; [0x8002adc] = 0x20000044
        0x08002a5a:    f7fffacb    ....    BL       do_fsm_menu ; 0x8001ff4
;;;432    			buttons_flag_set = 0; // reset button flags
        0x08002a5e:    2000        .       MOVS     r0,#0
        0x08002a60:    4921        !I      LDR      r1,[pc,#132] ; [0x8002ae8] = 0x200005dc
        0x08002a62:    6008        .`      STR      r0,[r1,#0]
;;;433    		}
;;;434    
;;;435    		if(z_axis.ramp_step != rs) {
        0x08002a64:    4821        !H      LDR      r0,[pc,#132] ; [0x8002aec] = 0x200005e0
        0x08002a66:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002a6a:    490f        .I      LDR      r1,[pc,#60] ; [0x8002aa8] = 0x200000b0
        0x08002a6c:    6809        .h      LDR      r1,[r1,#0]
        0x08002a6e:    4288        .B      CMP      r0,r1
        0x08002a70:    d007        ..      BEQ      0x8002a82 ; main + 374
;;;436    			rs = z_axis.ramp_step;
        0x08002a72:    481e        .H      LDR      r0,[pc,#120] ; [0x8002aec] = 0x200005e0
        0x08002a74:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002a78:    490b        .I      LDR      r1,[pc,#44] ; [0x8002aa8] = 0x200000b0
        0x08002a7a:    6008        .`      STR      r0,[r1,#0]
;;;437    			menu_changed = 1;
        0x08002a7c:    2001        .       MOVS     r0,#1
        0x08002a7e:    491c        .I      LDR      r1,[pc,#112] ; [0x8002af0] = 0x200000a4
        0x08002a80:    6008        .`      STR      r0,[r1,#0]
;;;438    		}
;;;439    
;;;440    		if(z_axis.current_pos != rs) {
        0x08002a82:    481a        .H      LDR      r0,[pc,#104] ; [0x8002aec] = 0x200005e0
        0x08002a84:    6800        .h      LDR      r0,[r0,#0]
        0x08002a86:    4908        .I      LDR      r1,[pc,#32] ; [0x8002aa8] = 0x200000b0
        0x08002a88:    6809        .h      LDR      r1,[r1,#0]
        0x08002a8a:    4288        .B      CMP      r0,r1
        0x08002a8c:    d003        ..      BEQ      0x8002a96 ; main + 394
;;;441    			rs = z_axis.current_pos;
        0x08002a8e:    4817        .H      LDR      r0,[pc,#92] ; [0x8002aec] = 0x200005e0
        0x08002a90:    6800        .h      LDR      r0,[r0,#0]
        0x08002a92:    4905        .I      LDR      r1,[pc,#20] ; [0x8002aa8] = 0x200000b0
        0x08002a94:    6008        .`      STR      r0,[r1,#0]
;;;442    //			menu_changed = 1;
;;;443    		}
;;;444    
;;;445    // update display info
;;;446    		if(menu_changed == 1){ // haltodo && hi2c2.hdmatx->State == HAL_DMA_STATE_READY) {
        0x08002a96:    4816        .H      LDR      r0,[pc,#88] ; [0x8002af0] = 0x200000a4
        0x08002a98:    6800        .h      LDR      r0,[r0,#0]
        0x08002a9a:    2801        .(      CMP      r0,#1
        0x08002a9c:    d103        ..      BNE      0x8002aa6 ; main + 410
;;;447    			menu_changed = update_screen();
        0x08002a9e:    f000fa59    ..Y.    BL       update_screen ; 0x8002f54
        0x08002aa2:    4913        .I      LDR      r1,[pc,#76] ; [0x8002af0] = 0x200000a4
        0x08002aa4:    6008        .`      STR      r0,[r1,#0]
        0x08002aa6:    e7d2        ..      B        0x8002a4e ; main + 322
    $d
        0x08002aa8:    200000b0    ...     DCD    536871088
        0x08002aac:    20313047    G01     DCD    540094535
        0x08002ab0:    20322e58    X.2     DCD    540159576
        0x08002ab4:    3030315a    Z100    DCD    808464730
        0x08002ab8:    00303146    F10.    DCD    3158342
        0x08002abc:    e000ed0c    ....    DCD    3758157068
        0x08002ac0:    05fa0000    ....    DCD    100270080
        0x08002ac4:    40010000    ...@    DCD    1073807360
        0x08002ac8:    4000042c    ,..@    DCD    1073742892
        0x08002acc:    04010001    ....    DCD    67174401
        0x08002ad0:    40010800    ...@    DCD    1073809408
        0x08002ad4:    20000041    A..     DCD    536870977
        0x08002ad8:    40000800    ...@    DCD    1073743872
        0x08002adc:    20000044    D..     DCD    536870980
        0x08002ae0:    04200020     . .    DCD    69206048
        0x08002ae4:    40011000    ...@    DCD    1073811456
        0x08002ae8:    200005dc    ...     DCD    536872412
        0x08002aec:    200005e0    ...     DCD    536872416
        0x08002af0:    200000a4    ...     DCD    536871076
    $t
    i.next_statement
    next_statement
;;; .\..\Src\gcode.c
;;;126    {
        0x08002af4:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08002af8:    4606        .F      MOV      r6,r0
        0x08002afa:    460f        .F      MOV      r7,r1
        0x08002afc:    4615        .F      MOV      r5,r2
        0x08002afe:    461c        .F      MOV      r4,r3
;;;127    	while (line[*char_counter] == ' ') (*char_counter)++;
        0x08002b00:    e002        ..      B        0x8002b08 ; next_statement + 20
        0x08002b02:    6820         h      LDR      r0,[r4,#0]
        0x08002b04:    1c40        @.      ADDS     r0,r0,#1
        0x08002b06:    6020         `      STR      r0,[r4,#0]
        0x08002b08:    6820         h      LDR      r0,[r4,#0]
        0x08002b0a:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002b0c:    2820         (      CMP      r0,#0x20
        0x08002b0e:    d0f8        ..      BEQ      0x8002b02 ; next_statement + 14
;;;128    
;;;129    	if (line[*char_counter] == 0 || line[*char_counter] == ';' ||
        0x08002b10:    6820         h      LDR      r0,[r4,#0]
        0x08002b12:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002b14:    b158        X.      CBZ      r0,0x8002b2e ; next_statement + 58
        0x08002b16:    6820         h      LDR      r0,[r4,#0]
        0x08002b18:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002b1a:    283b        ;(      CMP      r0,#0x3b
        0x08002b1c:    d007        ..      BEQ      0x8002b2e ; next_statement + 58
;;;130    		line[*char_counter] == '\n' || line[*char_counter] == '\r') return false;
        0x08002b1e:    6820         h      LDR      r0,[r4,#0]
        0x08002b20:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002b22:    280a        .(      CMP      r0,#0xa
        0x08002b24:    d003        ..      BEQ      0x8002b2e ; next_statement + 58
        0x08002b26:    6820         h      LDR      r0,[r4,#0]
        0x08002b28:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002b2a:    280d        .(      CMP      r0,#0xd
        0x08002b2c:    d102        ..      BNE      0x8002b34 ; next_statement + 64
        0x08002b2e:    2000        .       MOVS     r0,#0
        0x08002b30:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;131    	*letter = line[*char_counter];
        0x08002b34:    6820         h      LDR      r0,[r4,#0]
        0x08002b36:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002b38:    7030        0p      STRB     r0,[r6,#0]
;;;132    	if ((*letter < 'A') || (*letter > 'Z'))
        0x08002b3a:    7830        0x      LDRB     r0,[r6,#0]
        0x08002b3c:    2841        A(      CMP      r0,#0x41
        0x08002b3e:    db02        ..      BLT      0x8002b46 ; next_statement + 82
        0x08002b40:    7830        0x      LDRB     r0,[r6,#0]
        0x08002b42:    285a        Z(      CMP      r0,#0x5a
        0x08002b44:    dd04        ..      BLE      0x8002b50 ; next_statement + 92
;;;133    	{
;;;134    		gc.status_code = GCSTATUS_EXPECTED_COMMAND_LETTER;
        0x08002b46:    2002        .       MOVS     r0,#2
        0x08002b48:    4906        .I      LDR      r1,[pc,#24] ; [0x8002b64] = 0x20000510
        0x08002b4a:    7008        .p      STRB     r0,[r1,#0]
;;;135    		return false;
        0x08002b4c:    2000        .       MOVS     r0,#0
        0x08002b4e:    e7ef        ..      B        0x8002b30 ; next_statement + 60
;;;136    	}
;;;137    	(*char_counter)++;
        0x08002b50:    6820         h      LDR      r0,[r4,#0]
        0x08002b52:    1c40        @.      ADDS     r0,r0,#1
        0x08002b54:    6020         `      STR      r0,[r4,#0]
;;;138    	return read_double(line, char_counter, double_ptr);
        0x08002b56:    463a        :F      MOV      r2,r7
        0x08002b58:    4621        !F      MOV      r1,r4
        0x08002b5a:    4628        (F      MOV      r0,r5
        0x08002b5c:    f000f930    ..0.    BL       read_double ; 0x8002dc0
        0x08002b60:    e7e6        ..      B        0x8002b30 ; next_statement + 60
    $d
        0x08002b62:    0000        ..      DCW    0
        0x08002b64:    20000510    ...     DCD    536872208
    $t
    i.process_button
    process_button
;;; .\..\Src\buttons.c
;;;57     {
        0x08002b68:    b570        p.      PUSH     {r4-r6,lr}
;;;58     	for(int a =0; a<BT_TOTAL;a++){
        0x08002b6a:    2400        .$      MOVS     r4,#0
        0x08002b6c:    e11c        ..      B        0x8002da8 ; process_button + 576
;;;59     	/*
;;;60     	click Nondeterministic finite automaton(NFA):
;;;61     	10.    
;;;62     	20.  ,  .   > 1000   ,   30
;;;63     	30.  long_press_start,   40
;;;64     	40.   ,   50
;;;65     	50.  ,    200   70,   60
;;;66     	60.   < 1000   CLICK,      long_press_end,   10
;;;67     	70.   200,    -,   100,     60,     80
;;;68     	80.   ,   90
;;;69     	90.  ,  DOUBLE_CLICK,   10
;;;70     	*/
;;;71      
;;;72     //	#if defined ( _SIMU )
;;;73     //		uint32_t tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin;
;;;74     //	#else
;;;75     		uint32_t tmp_buttons;
;;;76     		if(bt[a].GPIOx != 0)
        0x08002b6e:    4891        .H      LDR      r0,[pc,#580] ; [0x8002db4] = 0x200004ec
        0x08002b70:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002b74:    6800        .h      LDR      r0,[r0,#0]
        0x08002b76:    b158        X.      CBZ      r0,0x8002b90 ; process_button + 40
;;;77     			tmp_buttons = LL_GPIO_IsInputPinSet(bt[a].GPIOx,bt[a].button_pin);
        0x08002b78:    4a8e        .J      LDR      r2,[pc,#568] ; [0x8002db4] = 0x200004ec
        0x08002b7a:    eb021244    ..D.    ADD      r2,r2,r4,LSL #5
        0x08002b7e:    6851        Qh      LDR      r1,[r2,#4]
        0x08002b80:    4a8c        .J      LDR      r2,[pc,#560] ; [0x8002db4] = 0x200004ec
        0x08002b82:    eb021244    ..D.    ADD      r2,r2,r4,LSL #5
        0x08002b86:    6810        .h      LDR      r0,[r2,#0]
        0x08002b88:    f7fdff6d    ..m.    BL       LL_GPIO_IsInputPinSet ; 0x8000a66
        0x08002b8c:    4605        .F      MOV      r5,r0
        0x08002b8e:    e007        ..      B        0x8002ba0 ; process_button + 56
;;;78     //			tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin; //BUTTON_1_GPIO_Port->IDR & bt[a].button_pin;
;;;79     		else{
;;;80     			
;;;81     //			if(ubTransferComplete == 0)
;;;82     //				continue;
;;;83     			//	dma_delay = 0;
;;;84     //	while(hi2c2->hdmarx->State != HAL_DMA_STATE_READY){
;;;85     //		dma_delay++;
;;;86     //		HAL_Delay(1);
;;;87     //	}
;;;88     //	dma_delay2 = dma_delay;
;;;89     
;;;90     			tmp_buttons = dma_data[5] & bt[a].button_pin;
        0x08002b90:    4889        .H      LDR      r0,[pc,#548] ; [0x8002db8] = 0x20000011
        0x08002b92:    7940        @y      LDRB     r0,[r0,#5]
        0x08002b94:    4987        .I      LDR      r1,[pc,#540] ; [0x8002db4] = 0x200004ec
        0x08002b96:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002b9a:    6849        Ih      LDR      r1,[r1,#4]
        0x08002b9c:    ea000501    ....    AND      r5,r0,r1
;;;91     		}
;;;92     //	#endif
;;;93     
;;;94     //		if(z_axis.current_pos < 20)
;;;95     //			tmp_buttons = 0;
;;;96     		
;;;97     		if( tmp_buttons != bt[a].buttons ) { // start debounce
        0x08002ba0:    4884        .H      LDR      r0,[pc,#528] ; [0x8002db4] = 0x200004ec
        0x08002ba2:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002ba6:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002ba8:    42a8        .B      CMP      r0,r5
        0x08002baa:    d009        ..      BEQ      0x8002bc0 ; process_button + 88
;;;98     			bt[a].buttons = tmp_buttons;
        0x08002bac:    4881        .H      LDR      r0,[pc,#516] ; [0x8002db4] = 0x200004ec
        0x08002bae:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002bb2:    60c5        .`      STR      r5,[r0,#0xc]
;;;99     			// reset debounce counter and start count every one ms
;;;100    			bt[a].buttons_mstick = 1;
        0x08002bb4:    2001        .       MOVS     r0,#1
        0x08002bb6:    497f        .I      LDR      r1,[pc,#508] ; [0x8002db4] = 0x200004ec
        0x08002bb8:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002bbc:    6108        .a      STR      r0,[r1,#0x10]
        0x08002bbe:    bd70        p.      POP      {r4-r6,pc}
;;;101    			return;
;;;102    		}
;;;103    
;;;104    		if( bt[a].buttons_mstick > DEBOUNCE_MS ) {
        0x08002bc0:    487c        |H      LDR      r0,[pc,#496] ; [0x8002db4] = 0x200004ec
        0x08002bc2:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002bc6:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002bc8:    2814        .(      CMP      r0,#0x14
        0x08002bca:    d971        q.      BLS      0x8002cb0 ; process_button + 328
;;;105    			switch(bt[a].clk_mode) {
        0x08002bcc:    4879        yH      LDR      r0,[pc,#484] ; [0x8002db4] = 0x200004ec
        0x08002bce:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002bd2:    69c0        .i      LDR      r0,[r0,#0x1c]
        0x08002bd4:    2832        2(      CMP      r0,#0x32
        0x08002bd6:    d063        c.      BEQ      0x8002ca0 ; process_button + 312
        0x08002bd8:    dc08        ..      BGT      0x8002bec ; process_button + 132
        0x08002bda:    280a        .(      CMP      r0,#0xa
        0x08002bdc:    d00f        ..      BEQ      0x8002bfe ; process_button + 150
        0x08002bde:    2814        .(      CMP      r0,#0x14
        0x08002be0:    d019        ..      BEQ      0x8002c16 ; process_button + 174
        0x08002be2:    281e        .(      CMP      r0,#0x1e
        0x08002be4:    d038        8.      BEQ      0x8002c58 ; process_button + 240
        0x08002be6:    2828        ((      CMP      r0,#0x28
        0x08002be8:    d114        ..      BNE      0x8002c14 ; process_button + 172
        0x08002bea:    e044        D.      B        0x8002c76 ; process_button + 270
        0x08002bec:    283c        <(      CMP      r0,#0x3c
        0x08002bee:    d066        f.      BEQ      0x8002cbe ; process_button + 342
        0x08002bf0:    2846        F(      CMP      r0,#0x46
        0x08002bf2:    d075        u.      BEQ      0x8002ce0 ; process_button + 376
        0x08002bf4:    2850        P(      CMP      r0,#0x50
        0x08002bf6:    d074        t.      BEQ      0x8002ce2 ; process_button + 378
        0x08002bf8:    285a        Z(      CMP      r0,#0x5a
        0x08002bfa:    d1f5        ..      BNE      0x8002be8 ; process_button + 128
        0x08002bfc:    e0be        ..      B        0x8002d7c ; process_button + 532
;;;106    			case 10: {
;;;107    				if ( tmp_buttons & bt[a].button_pin ) {   // released
        0x08002bfe:    486d        mH      LDR      r0,[pc,#436] ; [0x8002db4] = 0x200004ec
        0x08002c00:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c04:    6840        @h      LDR      r0,[r0,#4]
        0x08002c06:    4028        (@      ANDS     r0,r0,r5
        0x08002c08:    b920         .      CBNZ     r0,0x8002c14 ; process_button + 172
;;;108    				} else { // pressed
;;;109    //					buttons_mstick = 1;
;;;110    					bt[a].clk_mode = 20;
        0x08002c0a:    2014        .       MOVS     r0,#0x14
        0x08002c0c:    4969        iI      LDR      r1,[pc,#420] ; [0x8002db4] = 0x200004ec
        0x08002c0e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c12:    61c8        .a      STR      r0,[r1,#0x1c]
;;;111    				}
;;;112    				break;
        0x08002c14:    e0c6        ..      B        0x8002da4 ; process_button + 572
;;;113    			}
;;;114    			case 20: {
;;;115    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x08002c16:    4867        gH      LDR      r0,[pc,#412] ; [0x8002db4] = 0x200004ec
        0x08002c18:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c1c:    6840        @h      LDR      r0,[r0,#4]
        0x08002c1e:    4028        (@      ANDS     r0,r0,r5
        0x08002c20:    b128        (.      CBZ      r0,0x8002c2e ; process_button + 198
;;;116    					bt[a].clk_mode = 50;
        0x08002c22:    2032        2       MOVS     r0,#0x32
        0x08002c24:    4963        cI      LDR      r1,[pc,#396] ; [0x8002db4] = 0x200004ec
        0x08002c26:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c2a:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002c2c:    e007        ..      B        0x8002c3e ; process_button + 214
;;;117    				} else {
;;;118    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002c2e:    4861        aH      LDR      r0,[pc,#388] ; [0x8002db4] = 0x200004ec
        0x08002c30:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c34:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002c36:    495f        _I      LDR      r1,[pc,#380] ; [0x8002db4] = 0x200004ec
        0x08002c38:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c3c:    6088        .`      STR      r0,[r1,#8]
;;;119    				}
;;;120    				if (bt[a].downTime > HOLDTIME_MS ) { // long press detected
        0x08002c3e:    485d        ]H      LDR      r0,[pc,#372] ; [0x8002db4] = 0x200004ec
        0x08002c40:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c44:    6880        .h      LDR      r0,[r0,#8]
        0x08002c46:    f5b07ffa    ....    CMP      r0,#0x1f4
        0x08002c4a:    d904        ..      BLS      0x8002c56 ; process_button + 238
;;;121    					bt[a].clk_mode = 30;
        0x08002c4c:    201e        .       MOVS     r0,#0x1e
        0x08002c4e:    4959        YI      LDR      r1,[pc,#356] ; [0x8002db4] = 0x200004ec
        0x08002c50:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c54:    61c8        .a      STR      r0,[r1,#0x1c]
;;;122    				}
;;;123    				break;
        0x08002c56:    e0a5        ..      B        0x8002da4 ; process_button + 572
;;;124    			}
;;;125    			case 30: { // long_press_start event
;;;126    				buttons_flag_setbb[(a<<2)+long_press_start_Pos]  = 1; //long_press_start = 1;
        0x08002c58:    2001        .       MOVS     r0,#1
        0x08002c5a:    2100        .!      MOVS     r1,#0
        0x08002c5c:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002c60:    4a56        VJ      LDR      r2,[pc,#344] ; [0x8002dbc] = 0x2200b000
        0x08002c62:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002c66:    f8c10b80    ....    STR      r0,[r1,#0xb80]
;;;127    				bt[a].clk_mode = 40;
        0x08002c6a:    2028        (       MOVS     r0,#0x28
        0x08002c6c:    4951        QI      LDR      r1,[pc,#324] ; [0x8002db4] = 0x200004ec
        0x08002c6e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c72:    61c8        .a      STR      r0,[r1,#0x1c]
;;;128    				break;
        0x08002c74:    e096        ..      B        0x8002da4 ; process_button + 572
;;;129    			}
;;;130    			case 40: {
;;;131    				if ( tmp_buttons & bt[a].button_pin ) { //released
        0x08002c76:    484f        OH      LDR      r0,[pc,#316] ; [0x8002db4] = 0x200004ec
        0x08002c78:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c7c:    6840        @h      LDR      r0,[r0,#4]
        0x08002c7e:    4028        (@      ANDS     r0,r0,r5
        0x08002c80:    b128        (.      CBZ      r0,0x8002c8e ; process_button + 294
;;;132    					bt[a].clk_mode = 50;
        0x08002c82:    2032        2       MOVS     r0,#0x32
        0x08002c84:    494b        KI      LDR      r1,[pc,#300] ; [0x8002db4] = 0x200004ec
        0x08002c86:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c8a:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002c8c:    e007        ..      B        0x8002c9e ; process_button + 310
;;;133    				} else {
;;;134    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002c8e:    4849        IH      LDR      r0,[pc,#292] ; [0x8002db4] = 0x200004ec
        0x08002c90:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c94:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002c96:    4947        GI      LDR      r1,[pc,#284] ; [0x8002db4] = 0x200004ec
        0x08002c98:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c9c:    6088        .`      STR      r0,[r1,#8]
;;;135    				}
;;;136    				break;
        0x08002c9e:    e081        ..      B        0x8002da4 ; process_button + 572
;;;137    			}
;;;138    			case 50: {
;;;139    				bt[a].clk_mode = bt[a].downTime < CLICKTIME_MS ? 70 : 60;
        0x08002ca0:    4844        DH      LDR      r0,[pc,#272] ; [0x8002db4] = 0x200004ec
        0x08002ca2:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002ca6:    6880        .h      LDR      r0,[r0,#8]
        0x08002ca8:    28fa        .(      CMP      r0,#0xfa
        0x08002caa:    d202        ..      BCS      0x8002cb2 ; process_button + 330
        0x08002cac:    2046        F       MOVS     r0,#0x46
        0x08002cae:    e001        ..      B        0x8002cb4 ; process_button + 332
        0x08002cb0:    e079        y.      B        0x8002da6 ; process_button + 574
        0x08002cb2:    203c        <       MOVS     r0,#0x3c
        0x08002cb4:    493f        ?I      LDR      r1,[pc,#252] ; [0x8002db4] = 0x200004ec
        0x08002cb6:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002cba:    61c8        .a      STR      r0,[r1,#0x1c]
;;;140    				break;
        0x08002cbc:    e072        r.      B        0x8002da4 ; process_button + 572
;;;141    			}
;;;142    			case 60: {//60 if tick count < 1000 generate CLICK event, else generate long_press_end event, go to 10 state
;;;143    				if(bt[a].downTime < HOLDTIME_MS) { //single CLICK event
        0x08002cbe:    483d        =H      LDR      r0,[pc,#244] ; [0x8002db4] = 0x200004ec
        0x08002cc0:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002cc4:    6880        .h      LDR      r0,[r0,#8]
        0x08002cc6:    f5b07ffa    ....    CMP      r0,#0x1f4
        0x08002cca:    d20b        ..      BCS      0x8002ce4 ; process_button + 380
;;;144    					buttons_flag_setbb[(a<<2)+single_click_Pos]  = 1; //single_click = 1;
        0x08002ccc:    2001        .       MOVS     r0,#1
        0x08002cce:    2102        .!      MOVS     r1,#2
        0x08002cd0:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002cd4:    4a39        9J      LDR      r2,[pc,#228] ; [0x8002dbc] = 0x2200b000
        0x08002cd6:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002cda:    f8c10b80    ....    STR      r0,[r1,#0xb80]
        0x08002cde:    e009        ..      B        0x8002cf4 ; process_button + 396
        0x08002ce0:    e017        ..      B        0x8002d12 ; process_button + 426
        0x08002ce2:    e036        6.      B        0x8002d52 ; process_button + 490
;;;145    				} else { //  long_press_end event
;;;146    					buttons_flag_setbb[(a<<2)+long_press_end_Pos]  = 1; //long_press_end = 1;
        0x08002ce4:    2001        .       MOVS     r0,#1
        0x08002ce6:    eb000184    ....    ADD      r1,r0,r4,LSL #2
        0x08002cea:    4a34        4J      LDR      r2,[pc,#208] ; [0x8002dbc] = 0x2200b000
        0x08002cec:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002cf0:    f8c10b80    ....    STR      r0,[r1,#0xb80]
;;;147    				}
;;;148    				bt[a].downTime = bt[a].buttons_mstick = 0;
        0x08002cf4:    2000        .       MOVS     r0,#0
        0x08002cf6:    492f        /I      LDR      r1,[pc,#188] ; [0x8002db4] = 0x200004ec
        0x08002cf8:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002cfc:    6108        .a      STR      r0,[r1,#0x10]
        0x08002cfe:    492d        -I      LDR      r1,[pc,#180] ; [0x8002db4] = 0x200004ec
        0x08002d00:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d04:    6088        .`      STR      r0,[r1,#8]
;;;149    				bt[a].clk_mode = 10;
        0x08002d06:    200a        .       MOVS     r0,#0xa
        0x08002d08:    492a        *I      LDR      r1,[pc,#168] ; [0x8002db4] = 0x200004ec
        0x08002d0a:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d0e:    61c8        .a      STR      r0,[r1,#0x1c]
;;;150    				break;
        0x08002d10:    e048        H.      B        0x8002da4 ; process_button + 572
;;;151    			}
;;;152    			case 70: { //70.   200,    -,    100,     60,     80
;;;153    				if ( tmp_buttons & bt[a].button_pin ) {
        0x08002d12:    4828        (H      LDR      r0,[pc,#160] ; [0x8002db4] = 0x200004ec
        0x08002d14:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d18:    6840        @h      LDR      r0,[r0,#4]
        0x08002d1a:    4028        (@      ANDS     r0,r0,r5
        0x08002d1c:    b198        ..      CBZ      r0,0x8002d46 ; process_button + 478
;;;154    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002d1e:    4825        %H      LDR      r0,[pc,#148] ; [0x8002db4] = 0x200004ec
        0x08002d20:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d24:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002d26:    4923        #I      LDR      r1,[pc,#140] ; [0x8002db4] = 0x200004ec
        0x08002d28:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d2c:    6088        .`      STR      r0,[r1,#8]
;;;155    					if( bt[a].downTime > DOUBLECLICK_GAP_MS ) {
        0x08002d2e:    4821        !H      LDR      r0,[pc,#132] ; [0x8002db4] = 0x200004ec
        0x08002d30:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d34:    6880        .h      LDR      r0,[r0,#8]
        0x08002d36:    2896        .(      CMP      r0,#0x96
        0x08002d38:    d90a        ..      BLS      0x8002d50 ; process_button + 488
;;;156    						bt[a].clk_mode = 60;
        0x08002d3a:    203c        <       MOVS     r0,#0x3c
        0x08002d3c:    491d        .I      LDR      r1,[pc,#116] ; [0x8002db4] = 0x200004ec
        0x08002d3e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d42:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002d44:    e004        ..      B        0x8002d50 ; process_button + 488
;;;157    					}
;;;158    				} else {
;;;159    					bt[a].clk_mode = 80;
        0x08002d46:    2050        P       MOVS     r0,#0x50
        0x08002d48:    491a        .I      LDR      r1,[pc,#104] ; [0x8002db4] = 0x200004ec
        0x08002d4a:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d4e:    61c8        .a      STR      r0,[r1,#0x1c]
;;;160    				}
;;;161    				break;
        0x08002d50:    e028        (.      B        0x8002da4 ; process_button + 572
;;;162    			}
;;;163    			case 80: {
;;;164    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x08002d52:    4818        .H      LDR      r0,[pc,#96] ; [0x8002db4] = 0x200004ec
        0x08002d54:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d58:    6840        @h      LDR      r0,[r0,#4]
        0x08002d5a:    4028        (@      ANDS     r0,r0,r5
        0x08002d5c:    b128        (.      CBZ      r0,0x8002d6a ; process_button + 514
;;;165    					bt[a].clk_mode = 90;
        0x08002d5e:    205a        Z       MOVS     r0,#0x5a
        0x08002d60:    4914        .I      LDR      r1,[pc,#80] ; [0x8002db4] = 0x200004ec
        0x08002d62:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d66:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002d68:    e007        ..      B        0x8002d7a ; process_button + 530
;;;166    				} else {
;;;167    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002d6a:    4812        .H      LDR      r0,[pc,#72] ; [0x8002db4] = 0x200004ec
        0x08002d6c:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d70:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002d72:    4910        .I      LDR      r1,[pc,#64] ; [0x8002db4] = 0x200004ec
        0x08002d74:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d78:    6088        .`      STR      r0,[r1,#8]
;;;168    				}
;;;169    				break;
        0x08002d7a:    e013        ..      B        0x8002da4 ; process_button + 572
;;;170    			}
;;;171    			case 90: { //  DOUBLE_CLICK
;;;172    				buttons_flag_setbb[(a<<2)+double_click_Pos]  = 1; //double_click = 1;
        0x08002d7c:    2001        .       MOVS     r0,#1
        0x08002d7e:    2103        .!      MOVS     r1,#3
        0x08002d80:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002d84:    4a0d        .J      LDR      r2,[pc,#52] ; [0x8002dbc] = 0x2200b000
        0x08002d86:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002d8a:    f8c10b80    ....    STR      r0,[r1,#0xb80]
;;;173    				bt[a].clk_mode = 10;
        0x08002d8e:    200a        .       MOVS     r0,#0xa
        0x08002d90:    4908        .I      LDR      r1,[pc,#32] ; [0x8002db4] = 0x200004ec
        0x08002d92:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d96:    61c8        .a      STR      r0,[r1,#0x1c]
;;;174    				bt[a].buttons_mstick = 0;
        0x08002d98:    2000        .       MOVS     r0,#0
        0x08002d9a:    4906        .I      LDR      r1,[pc,#24] ; [0x8002db4] = 0x200004ec
        0x08002d9c:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002da0:    6108        .a      STR      r0,[r1,#0x10]
;;;175    				break;
        0x08002da2:    bf00        ..      NOP      
        0x08002da4:    bf00        ..      NOP      
        0x08002da6:    1c64        d.      ADDS     r4,r4,#1
        0x08002da8:    2c01        .,      CMP      r4,#1
        0x08002daa:    f6ffaee0    ....    BLT      0x8002b6e ; process_button + 6
;;;176    			}
;;;177    			}
;;;178    		}
;;;179    	}
;;;180    //	ubTransferComplete = 0;
;;;181    }
        0x08002dae:    bf00        ..      NOP      
        0x08002db0:    e705        ..      B        0x8002bbe ; process_button + 86
    $d
        0x08002db2:    0000        ..      DCW    0
        0x08002db4:    200004ec    ...     DCD    536872172
        0x08002db8:    20000011    ...     DCD    536870929
        0x08002dbc:    2200b000    ..."    DCD    570470400
    $t
    i.read_double
    read_double
;;; .\..\Src\gcode.c
;;;111    {
        0x08002dc0:    b5f8        ..      PUSH     {r3-r7,lr}
        0x08002dc2:    4604        .F      MOV      r4,r0
        0x08002dc4:    460d        .F      MOV      r5,r1
        0x08002dc6:    4617        .F      MOV      r7,r2
;;;112    	char *start = line + *char_counter;
        0x08002dc8:    6828        (h      LDR      r0,[r5,#0]
        0x08002dca:    1906        ..      ADDS     r6,r0,r4
;;;113    	char *end;
;;;114    
;;;115    	*double_ptr = strtod_M(start, &end);
        0x08002dcc:    4669        iF      MOV      r1,sp
        0x08002dce:    4630        0F      MOV      r0,r6
        0x08002dd0:    f000f812    ....    BL       strtod_M ; 0x8002df8
        0x08002dd4:    e9c70100    ....    STRD     r0,r1,[r7,#0]
;;;116    	if (end == start)
        0x08002dd8:    9800        ..      LDR      r0,[sp,#0]
        0x08002dda:    42b0        .B      CMP      r0,r6
        0x08002ddc:    d104        ..      BNE      0x8002de8 ; read_double + 40
;;;117    	{
;;;118    		gc.status_code = GCSTATUS_BAD_NUMBER_FORMAT;
        0x08002dde:    2001        .       MOVS     r0,#1
        0x08002de0:    4904        .I      LDR      r1,[pc,#16] ; [0x8002df4] = 0x20000510
        0x08002de2:    7008        .p      STRB     r0,[r1,#0]
;;;119    		return false;
        0x08002de4:    2000        .       MOVS     r0,#0
        0x08002de6:    bdf8        ..      POP      {r3-r7,pc}
;;;120    	}
;;;121    	*char_counter = (int)(end - line);
        0x08002de8:    9800        ..      LDR      r0,[sp,#0]
        0x08002dea:    1b00        ..      SUBS     r0,r0,r4
        0x08002dec:    6028        (`      STR      r0,[r5,#0]
;;;122    	return true;
        0x08002dee:    2001        .       MOVS     r0,#1
        0x08002df0:    e7f9        ..      B        0x8002de6 ; read_double + 38
    $d
        0x08002df2:    0000        ..      DCW    0
        0x08002df4:    20000510    ...     DCD    536872208
    $t
    i.strtod_M
    strtod_M
;;; .\..\Src\gcode.c (51)
        0x08002df8:    e92d4ff0    -..O    PUSH     {r4-r11,lr}
        0x08002dfc:    b087        ..      SUB      sp,sp,#0x1c
        0x08002dfe:    4681        .F      MOV      r9,r0
        0x08002e00:    468b        .F      MOV      r11,r1
;;;52     	double number = 0.0;
        0x08002e02:    2100        .!      MOVS     r1,#0
        0x08002e04:    460d        .F      MOV      r5,r1
        0x08002e06:    460e        .F      MOV      r6,r1
;;;53     	double div = 0.0;
        0x08002e08:    460f        .F      MOV      r7,r1
        0x08002e0a:    4688        .F      MOV      r8,r1
;;;54     	bool negative = false;
        0x08002e0c:    2000        .       MOVS     r0,#0
        0x08002e0e:    9005        ..      STR      r0,[sp,#0x14]
;;;55     	bool plus = false;
        0x08002e10:    9004        ..      STR      r0,[sp,#0x10]
;;;56     	bool skip = true;
        0x08002e12:    f04f0a01    O...    MOV      r10,#1
;;;57     	char c;
;;;58     	while ((c = *str) != 0)
        0x08002e16:    e06f        o.      B        0x8002ef8 ; strtod_M + 256
;;;59     	{
;;;60     		if (c == '+')
        0x08002e18:    2c2b        +,      CMP      r4,#0x2b
        0x08002e1a:    d10a        ..      BNE      0x8002e32 ; strtod_M + 58
;;;61     		{
;;;62     			if (skip && !plus)
        0x08002e1c:    f1ba0f00    ....    CMP      r10,#0
        0x08002e20:    d006        ..      BEQ      0x8002e30 ; strtod_M + 56
        0x08002e22:    9804        ..      LDR      r0,[sp,#0x10]
        0x08002e24:    b920         .      CBNZ     r0,0x8002e30 ; strtod_M + 56
;;;63     			{
;;;64     				plus = true;
        0x08002e26:    2001        .       MOVS     r0,#1
        0x08002e28:    9004        ..      STR      r0,[sp,#0x10]
;;;65     				skip = false;
        0x08002e2a:    f04f0a00    O...    MOV      r10,#0
        0x08002e2e:    e061        a.      B        0x8002ef4 ; strtod_M + 252
;;;66     			}
;;;67     			else
;;;68     				break;
        0x08002e30:    e066        f.      B        0x8002f00 ; strtod_M + 264
;;;69     		}
;;;70     		else if (skip && !negative && c == '-')
        0x08002e32:    f1ba0f00    ....    CMP      r10,#0
        0x08002e36:    d00e        ..      BEQ      0x8002e56 ; strtod_M + 94
        0x08002e38:    9805        ..      LDR      r0,[sp,#0x14]
        0x08002e3a:    b960        `.      CBNZ     r0,0x8002e56 ; strtod_M + 94
        0x08002e3c:    2c2d        -,      CMP      r4,#0x2d
        0x08002e3e:    d10a        ..      BNE      0x8002e56 ; strtod_M + 94
;;;71     		{
;;;72     			if (skip && !negative)
        0x08002e40:    f1ba0f00    ....    CMP      r10,#0
        0x08002e44:    d006        ..      BEQ      0x8002e54 ; strtod_M + 92
        0x08002e46:    9805        ..      LDR      r0,[sp,#0x14]
        0x08002e48:    b920         .      CBNZ     r0,0x8002e54 ; strtod_M + 92
;;;73     			{
;;;74     				negative = true;
        0x08002e4a:    2001        .       MOVS     r0,#1
        0x08002e4c:    9005        ..      STR      r0,[sp,#0x14]
;;;75     				skip = false;
        0x08002e4e:    f04f0a00    O...    MOV      r10,#0
        0x08002e52:    e04f        O.      B        0x8002ef4 ; strtod_M + 252
;;;76     			}
;;;77     			else
;;;78     				break;
        0x08002e54:    e054        T.      B        0x8002f00 ; strtod_M + 264
;;;79     		}
;;;80     		else if (c == '.')
        0x08002e56:    2c2e        .,      CMP      r4,#0x2e
        0x08002e58:    d10b        ..      BNE      0x8002e72 ; strtod_M + 122
;;;81     		{
;;;82     			if (div == 0.0)
        0x08002e5a:    2200        ."      MOVS     r2,#0
        0x08002e5c:    4613        .F      MOV      r3,r2
        0x08002e5e:    4638        8F      MOV      r0,r7
        0x08002e60:    4641        AF      MOV      r1,r8
        0x08002e62:    f7fdfb5b    ..[.    BL       __aeabi_cdcmpeq ; 0x800051c
        0x08002e66:    d103        ..      BNE      0x8002e70 ; strtod_M + 120
;;;83     				div = 1.0;
        0x08002e68:    2700        .'      MOVS     r7,#0
        0x08002e6a:    f8df80b4    ....    LDR      r8,[pc,#180] ; [0x8002f20] = 0x3ff00000
        0x08002e6e:    e041        A.      B        0x8002ef4 ; strtod_M + 252
;;;84     			else
;;;85     				break;
        0x08002e70:    e046        F.      B        0x8002f00 ; strtod_M + 264
;;;86     		}
;;;87     		else if (c >= '0' && c <= '9')
        0x08002e72:    2c30        0,      CMP      r4,#0x30
        0x08002e74:    db3a        :.      BLT      0x8002eec ; strtod_M + 244
        0x08002e76:    2c39        9,      CMP      r4,#0x39
        0x08002e78:    dc38        8.      BGT      0x8002eec ; strtod_M + 244
;;;88     		{
;;;89     			skip = false;
        0x08002e7a:    f04f0a00    O...    MOV      r10,#0
;;;90     			if (div == 0.0)
        0x08002e7e:    2200        ."      MOVS     r2,#0
        0x08002e80:    4613        .F      MOV      r3,r2
        0x08002e82:    4638        8F      MOV      r0,r7
        0x08002e84:    4641        AF      MOV      r1,r8
        0x08002e86:    f7fdfb49    ..I.    BL       __aeabi_cdcmpeq ; 0x800051c
        0x08002e8a:    d114        ..      BNE      0x8002eb6 ; strtod_M + 190
;;;91     				number = number * 10.0 + (double)(c - '0');
        0x08002e8c:    f1a40030    ..0.    SUB      r0,r4,#0x30
        0x08002e90:    f7fdfb13    ....    BL       __aeabi_i2d ; 0x80004ba
        0x08002e94:    2200        ."      MOVS     r2,#0
        0x08002e96:    4b23        #K      LDR      r3,[pc,#140] ; [0x8002f24] = 0x40240000
        0x08002e98:    e9cd0102    ....    STRD     r0,r1,[sp,#8]
        0x08002e9c:    4628        (F      MOV      r0,r5
        0x08002e9e:    4631        1F      MOV      r1,r6
        0x08002ea0:    f7fdfa2a    ..*.    BL       __aeabi_dmul ; 0x80002f8
        0x08002ea4:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x08002ea8:    e9dd2302    ...#    LDRD     r2,r3,[sp,#8]
        0x08002eac:    f7fdf97d    ..}.    BL       __aeabi_dadd ; 0x80001aa
        0x08002eb0:    4605        .F      MOV      r5,r0
        0x08002eb2:    460e        .F      MOV      r6,r1
        0x08002eb4:    e01e        ..      B        0x8002ef4 ; strtod_M + 252
;;;92     			else
;;;93     			{
;;;94     				div *= 10.0;
        0x08002eb6:    2200        ."      MOVS     r2,#0
        0x08002eb8:    4b1a        .K      LDR      r3,[pc,#104] ; [0x8002f24] = 0x40240000
        0x08002eba:    4638        8F      MOV      r0,r7
        0x08002ebc:    4641        AF      MOV      r1,r8
        0x08002ebe:    f7fdfa1b    ....    BL       __aeabi_dmul ; 0x80002f8
        0x08002ec2:    4607        .F      MOV      r7,r0
        0x08002ec4:    4688        .F      MOV      r8,r1
;;;95     				number += ((double)(c - '0') / div);
        0x08002ec6:    f1a40030    ..0.    SUB      r0,r4,#0x30
        0x08002eca:    f7fdfaf6    ....    BL       __aeabi_i2d ; 0x80004ba
        0x08002ece:    463a        :F      MOV      r2,r7
        0x08002ed0:    4643        CF      MOV      r3,r8
        0x08002ed2:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x08002ed6:    f7fdfa81    ....    BL       __aeabi_ddiv ; 0x80003dc
        0x08002eda:    462a        *F      MOV      r2,r5
        0x08002edc:    4633        3F      MOV      r3,r6
        0x08002ede:    e9cd0102    ....    STRD     r0,r1,[sp,#8]
        0x08002ee2:    f7fdf962    ..b.    BL       __aeabi_dadd ; 0x80001aa
        0x08002ee6:    4605        .F      MOV      r5,r0
        0x08002ee8:    460e        .F      MOV      r6,r1
        0x08002eea:    e003        ..      B        0x8002ef4 ; strtod_M + 252
;;;96     			}
;;;97     		}
;;;98     		else if (!skip)
        0x08002eec:    f1ba0f00    ....    CMP      r10,#0
        0x08002ef0:    d100        ..      BNE      0x8002ef4 ; strtod_M + 252
;;;99     		{
;;;100    			break;
        0x08002ef2:    e005        ..      B        0x8002f00 ; strtod_M + 264
;;;101    		}
;;;102    		str++;
        0x08002ef4:    f1090901    ....    ADD      r9,r9,#1
        0x08002ef8:    f8994000    ...@    LDRB     r4,[r9,#0]
        0x08002efc:    2c00        .,      CMP      r4,#0
        0x08002efe:    d18b        ..      BNE      0x8002e18 ; strtod_M + 32
        0x08002f00:    bf00        ..      NOP      
;;;103    	}
;;;104    
;;;105    	if (negative) number = -number;
        0x08002f02:    9805        ..      LDR      r0,[sp,#0x14]
        0x08002f04:    b108        ..      CBZ      r0,0x8002f0a ; strtod_M + 274
        0x08002f06:    f0864600    ...F    EOR      r6,r6,#0x80000000
;;;106    	if (endptr != NULL) *endptr = (char *)str;
        0x08002f0a:    f1bb0f00    ....    CMP      r11,#0
        0x08002f0e:    d001        ..      BEQ      0x8002f14 ; strtod_M + 284
        0x08002f10:    f8cb9000    ....    STR      r9,[r11,#0]
;;;107    	return number;
        0x08002f14:    4628        (F      MOV      r0,r5
        0x08002f16:    4631        1F      MOV      r1,r6
;;;108    }
        0x08002f18:    b007        ..      ADD      sp,sp,#0x1c
        0x08002f1a:    e8bd8ff0    ....    POP      {r4-r11,pc}
    $d
        0x08002f1e:    0000        ..      DCW    0
        0x08002f20:    3ff00000    ...?    DCD    1072693248
        0x08002f24:    40240000    ..$@    DCD    1076101120
    $t
    i.to_millimeters
    to_millimeters
;;;109    
;;;110    static int read_double(char *line, int *char_counter, double *double_ptr)
;;;111    {
;;;112    	char *start = line + *char_counter;
;;;113    	char *end;
;;;114    
;;;115    	*double_ptr = strtod_M(start, &end);
;;;116    	if (end == start)
;;;117    	{
;;;118    		gc.status_code = GCSTATUS_BAD_NUMBER_FORMAT;
;;;119    		return false;
;;;120    	}
;;;121    	*char_counter = (int)(end - line);
;;;122    	return true;
;;;123    }
;;;124    
;;;125    static int next_statement(char *letter, double *double_ptr, char *line, int *char_counter)
;;;126    {
;;;127    	while (line[*char_counter] == ' ') (*char_counter)++;
;;;128    
;;;129    	if (line[*char_counter] == 0 || line[*char_counter] == ';' ||
;;;130    		line[*char_counter] == '\n' || line[*char_counter] == '\r') return false;
;;;131    	*letter = line[*char_counter];
;;;132    	if ((*letter < 'A') || (*letter > 'Z'))
;;;133    	{
;;;134    		gc.status_code = GCSTATUS_EXPECTED_COMMAND_LETTER;
;;;135    		return false;
;;;136    	}
;;;137    	(*char_counter)++;
;;;138    	return read_double(line, char_counter, double_ptr);
;;;139    }
;;;140    
;;;141    void gc_init(void)
;;;142    {
;;;143    	memset(&gc, 0, sizeof(gc));
;;;144    	gc.feed_rate = SM_DEFAULT_FEED_RATE;
;;;145    	gc.seek_rate = SM_DEFAULT_SEEK_RATE;
;;;146    	gc.absolute_mode = true;
;;;147    	// gc.startPosX = commonValues.startX;
;;;148    	// gc.startPosY = commonValues.startY;
;;;149    	// gc.startPosZ = commonValues.startZ;
;;;150    	gc.extruder_k = 1;
;;;151    	// commonValues.extruder_k;
;;;152    	gc.next_action = NEXT_ACTION_DEFAULT;
;;;153    }
;;;154    
;;;155    static double to_millimeters(double value)
;;;156    {
        0x08002f28:    b570        p.      PUSH     {r4-r6,lr}
        0x08002f2a:    4604        .F      MOV      r4,r0
        0x08002f2c:    460d        .F      MOV      r5,r1
;;;157    	return (gc.inches_mode ? (value * MM_PER_INCH) : value);
        0x08002f2e:    4807        .H      LDR      r0,[pc,#28] ; [0x8002f4c] = 0x20000510
        0x08002f30:    7840        @x      LDRB     r0,[r0,#1]
        0x08002f32:    b138        8.      CBZ      r0,0x8002f44 ; to_millimeters + 28
        0x08002f34:    f04f3266    O.f2    MOV      r2,#0x66666666
        0x08002f38:    4b05        .K      LDR      r3,[pc,#20] ; [0x8002f50] = 0x40396666
        0x08002f3a:    4620         F      MOV      r0,r4
        0x08002f3c:    4629        )F      MOV      r1,r5
        0x08002f3e:    f7fdf9db    ....    BL       __aeabi_dmul ; 0x80002f8
        0x08002f42:    bd70        p.      POP      {r4-r6,pc}
        0x08002f44:    4620         F      MOV      r0,r4
        0x08002f46:    4629        )F      MOV      r1,r5
        0x08002f48:    e7fb        ..      B        0x8002f42 ; to_millimeters + 26
    $d
        0x08002f4a:    0000        ..      DCW    0
        0x08002f4c:    20000510    ...     DCD    536872208
        0x08002f50:    40396666    ff9@    DCD    1077503590
    $t
    i.update_screen
    update_screen
;;; .\..\Src\screen.c
;;;86     	return 0;
        0x08002f54:    2000        .       MOVS     r0,#0
;;;87     }
        0x08002f56:    4770        pG      BX       lr
    i.z_axis_move2
    z_axis_move2
;;; .\..\Src\fsm.c
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
        0x08002f58:    4a0b        .J      LDR      r2,[pc,#44] ; [0x8002f88] = 0x200005e0
        0x08002f5a:    68d2        .h      LDR      r2,[r2,#0xc]
        0x08002f5c:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8002f88] = 0x200005e0
        0x08002f5e:    691b        .i      LDR      r3,[r3,#0x10]
        0x08002f60:    18d1        ..      ADDS     r1,r2,r3
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08002f62:    2201        ."      MOVS     r2,#1
        0x08002f64:    ebc26211    ...b    RSB      r2,r2,r1,LSR #24
        0x08002f68:    6943        Ci      LDR      r3,[r0,#0x14]
        0x08002f6a:    62da        .b      STR      r2,[r3,#0x2c]
;;;416    	s->syncbase->CNT = 0;
        0x08002f6c:    2200        ."      MOVS     r2,#0
        0x08002f6e:    6943        Ci      LDR      r3,[r0,#0x14]
        0x08002f70:    625a        Zb      STR      r2,[r3,#0x24]
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
        0x08002f72:    6942        Bi      LDR      r2,[r0,#0x14]
        0x08002f74:    6952        Ri      LDR      r2,[r2,#0x14]
        0x08002f76:    f0420201    B...    ORR      r2,r2,#1
        0x08002f7a:    6943        Ci      LDR      r3,[r0,#0x14]
        0x08002f7c:    615a        Za      STR      r2,[r3,#0x14]
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
        0x08002f7e:    f021427f    !..B    BIC      r2,r1,#0xff000000
        0x08002f82:    4b01        .K      LDR      r3,[pc,#4] ; [0x8002f88] = 0x200005e0
        0x08002f84:    611a        .a      STR      r2,[r3,#0x10]
;;;419    }
        0x08002f86:    4770        pG      BX       lr
    $d
        0x08002f88:    200005e0    ...     DCD    536872416
    $t
    i.z_axis_ramp_down2
    z_axis_ramp_down2
;;; .\..\Src\fsm.c (398)
        0x08002f8c:    4601        .F      MOV      r1,r0
;;;399    	if (z_axis.ramp_step == 0)
        0x08002f8e:    480d        .H      LDR      r0,[pc,#52] ; [0x8002fc4] = 0x200005e0
        0x08002f90:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002f94:    b908        ..      CBNZ     r0,0x8002f9a ; z_axis_ramp_down2 + 14
;;;400    		return true;
        0x08002f96:    2001        .       MOVS     r0,#1
        0x08002f98:    4770        pG      BX       lr
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
        0x08002f9a:    480a        .H      LDR      r0,[pc,#40] ; [0x8002fc4] = 0x200005e0
        0x08002f9c:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002fa0:    1e40        @.      SUBS     r0,r0,#1
        0x08002fa2:    b2c0        ..      UXTB     r0,r0
        0x08002fa4:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002fc4] = 0x200005e0
        0x08002fa6:    f8820028    ..(.    STRB     r0,[r2,#0x28]
        0x08002faa:    4a07        .J      LDR      r2,[pc,#28] ; [0x8002fc8] = 0x20000038
        0x08002fac:    5c10        .\      LDRB     r0,[r2,r0]
        0x08002fae:    694a        Ji      LDR      r2,[r1,#0x14]
        0x08002fb0:    62d0        .b      STR      r0,[r2,#0x2c]
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
        0x08002fb2:    4804        .H      LDR      r0,[pc,#16] ; [0x8002fc4] = 0x200005e0
        0x08002fb4:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002fb8:    b908        ..      CBNZ     r0,0x8002fbe ; z_axis_ramp_down2 + 50
;;;408    		return true;
        0x08002fba:    2001        .       MOVS     r0,#1
        0x08002fbc:    e7ec        ..      B        0x8002f98 ; z_axis_ramp_down2 + 12
;;;409    	return false;
        0x08002fbe:    2000        .       MOVS     r0,#0
        0x08002fc0:    e7ea        ..      B        0x8002f98 ; z_axis_ramp_down2 + 12
    $d
        0x08002fc2:    0000        ..      DCW    0
        0x08002fc4:    200005e0    ...     DCD    536872416
        0x08002fc8:    20000038    8..     DCD    536870968
    $t
    i.z_axis_ramp_up2
    z_axis_ramp_up2
;;; .\..\Src\fsm.c (380)
        0x08002fcc:    4601        .F      MOV      r1,r0
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
        0x08002fce:    4816        .H      LDR      r0,[pc,#88] ; [0x8003028] = 0x200005e0
        0x08002fd0:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002fd4:    4b15        .K      LDR      r3,[pc,#84] ; [0x800302c] = 0x20000038
        0x08002fd6:    5c18        .\      LDRB     r0,[r3,r0]
        0x08002fd8:    0602        ..      LSLS     r2,r0,#24
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
        0x08002fda:    4813        .H      LDR      r0,[pc,#76] ; [0x8003028] = 0x200005e0
        0x08002fdc:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002fde:    4290        .B      CMP      r0,r2
        0x08002fe0:    d804        ..      BHI      0x8002fec ; z_axis_ramp_up2 + 32
        0x08002fe2:    4811        .H      LDR      r0,[pc,#68] ; [0x8003028] = 0x200005e0
        0x08002fe4:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002fe8:    2805        .(      CMP      r0,#5
        0x08002fea:    d10e        ..      BNE      0x800300a ; z_axis_ramp_up2 + 62
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
        0x08002fec:    480e        .H      LDR      r0,[pc,#56] ; [0x8003028] = 0x200005e0
        0x08002fee:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002ff0:    2301        .#      MOVS     r3,#1
        0x08002ff2:    ebc36010    ...`    RSB      r0,r3,r0,LSR #24
        0x08002ff6:    694b        Ki      LDR      r3,[r1,#0x14]
        0x08002ff8:    62d8        .b      STR      r0,[r3,#0x2c]
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
        0x08002ffa:    480b        .H      LDR      r0,[pc,#44] ; [0x8003028] = 0x200005e0
        0x08002ffc:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002ffe:    f020407f     ..@    BIC      r0,r0,#0xff000000
        0x08003002:    4b09        .K      LDR      r3,[pc,#36] ; [0x8003028] = 0x200005e0
        0x08003004:    6118        .a      STR      r0,[r3,#0x10]
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
        0x08003006:    2001        .       MOVS     r0,#1
        0x08003008:    4770        pG      BX       lr
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
        0x0800300a:    4807        .H      LDR      r0,[pc,#28] ; [0x8003028] = 0x200005e0
        0x0800300c:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08003010:    1c40        @.      ADDS     r0,r0,#1
        0x08003012:    4b05        .K      LDR      r3,[pc,#20] ; [0x8003028] = 0x200005e0
        0x08003014:    f8830028    ..(.    STRB     r0,[r3,#0x28]
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
        0x08003018:    2001        .       MOVS     r0,#1
        0x0800301a:    ebc06012    ...`    RSB      r0,r0,r2,LSR #24
        0x0800301e:    694b        Ki      LDR      r3,[r1,#0x14]
        0x08003020:    62d8        .b      STR      r0,[r3,#0x2c]
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
        0x08003022:    2000        .       MOVS     r0,#0
        0x08003024:    e7f0        ..      B        0x8003008 ; z_axis_ramp_up2 + 60
    $d
        0x08003026:    0000        ..      DCW    0
        0x08003028:    200005e0    ...     DCD    536872416
        0x0800302c:    20000038    8..     DCD    536870968
    $t
    i.z_move
    z_move
;;; .\..\Src\fsm.c (197)
        0x08003030:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08003034:    4605        .F      MOV      r5,r0
        0x08003036:    460e        .F      MOV      r6,r1
        0x08003038:    4614        .F      MOV      r4,r2
        0x0800303a:    461f        .F      MOV      r7,r3
;;;198    	MOTOR_X_Enable();
        0x0800303c:    f2402002    @..     MOV      r0,#0x202
        0x08003040:    491c        .I      LDR      r1,[pc,#112] ; [0x80030b4] = 0x40010810
        0x08003042:    6008        .`      STR      r0,[r1,#0]
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x08003044:    491c        .I      LDR      r1,[pc,#112] ; [0x80030b8] = 0x40010c10
        0x08003046:    6008        .`      STR      r0,[r1,#0]
;;;200    
;;;201    	if(direction == feed_direction_left) {
        0x08003048:    b95d        ].      CBNZ     r5,0x8003062 ; z_move + 50
;;;202    		feed_direction = feed_direction_left;
        0x0800304a:    2000        .       MOVS     r0,#0
        0x0800304c:    491b        .I      LDR      r1,[pc,#108] ; [0x80030bc] = 0x200000a1
        0x0800304e:    7008        .p      STRB     r0,[r1,#0]
;;;203    		MOTOR_Z_Reverse();
        0x08003050:    f2480080    H...    MOV      r0,#0x8080
        0x08003054:    4917        .I      LDR      r1,[pc,#92] ; [0x80030b4] = 0x40010810
        0x08003056:    1d09        ..      ADDS     r1,r1,#4
        0x08003058:    6008        .`      STR      r0,[r1,#0]
;;;204    		MOTOR_X_Reverse();
        0x0800305a:    4819        .H      LDR      r0,[pc,#100] ; [0x80030c0] = 0x4800080
        0x0800305c:    4919        .I      LDR      r1,[pc,#100] ; [0x80030c4] = 0x40011000
        0x0800305e:    6148        Ha      STR      r0,[r1,#0x14]
        0x08003060:    e009        ..      B        0x8003076 ; z_move + 70
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
        0x08003062:    2001        .       MOVS     r0,#1
        0x08003064:    4915        .I      LDR      r1,[pc,#84] ; [0x80030bc] = 0x200000a1
        0x08003066:    7008        .p      STRB     r0,[r1,#0]
;;;207    		MOTOR_Z_Forward();
        0x08003068:    f2480080    H...    MOV      r0,#0x8080
        0x0800306c:    4911        .I      LDR      r1,[pc,#68] ; [0x80030b4] = 0x40010810
        0x0800306e:    6008        .`      STR      r0,[r1,#0]
;;;208    		MOTOR_X_Forward();
        0x08003070:    4813        .H      LDR      r0,[pc,#76] ; [0x80030c0] = 0x4800080
        0x08003072:    4914        .I      LDR      r1,[pc,#80] ; [0x80030c4] = 0x40011000
        0x08003074:    6108        .a      STR      r0,[r1,#0x10]
;;;209    	}
;;;210    	LL_mDelay(2);
        0x08003076:    2002        .       MOVS     r0,#2
        0x08003078:    f7fef85e    ..^.    BL       LL_mDelay ; 0x8001138
;;;211    
;;;212    	state.sync = sync;
        0x0800307c:    4812        .H      LDR      r0,[pc,#72] ; [0x80030c8] = 0x20000044
        0x0800307e:    7404        .t      STRB     r4,[r0,#0x10]
;;;213    	if(sync){
        0x08003080:    b11c        ..      CBZ      r4,0x800308a ; z_move + 90
;;;214    		state.main_feed_direction = feed_direction;
        0x08003082:    480e        .H      LDR      r0,[pc,#56] ; [0x80030bc] = 0x200000a1
        0x08003084:    7800        .x      LDRB     r0,[r0,#0]
        0x08003086:    4910        .I      LDR      r1,[pc,#64] ; [0x80030c8] = 0x20000044
        0x08003088:    7448        Ht      STRB     r0,[r1,#0x11]
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
        0x0800308a:    2000        .       MOVS     r0,#0
        0x0800308c:    490f        .I      LDR      r1,[pc,#60] ; [0x80030cc] = 0x200005e0
        0x0800308e:    6008        .`      STR      r0,[r1,#0]
;;;218    	z_axis.end_pos = length;
        0x08003090:    4608        .F      MOV      r0,r1
        0x08003092:    6046        F`      STR      r6,[r0,#4]
;;;219    	if(z_axis.end_pos > 0){
        0x08003094:    6840        @h      LDR      r0,[r0,#4]
        0x08003096:    b128        (.      CBZ      r0,0x80030a4 ; z_move + 116
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
        0x08003098:    4608        .F      MOV      r0,r1
        0x0800309a:    6840        @h      LDR      r0,[r0,#4]
        0x0800309c:    f0200001     ...    BIC      r0,r0,#1
        0x080030a0:    6048        H`      STR      r0,[r1,#4]
        0x080030a2:    e002        ..      B        0x80030aa ; z_move + 122
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
        0x080030a4:    2001        .       MOVS     r0,#1
        0x080030a6:    4908        .I      LDR      r1,[pc,#32] ; [0x80030c8] = 0x20000044
        0x080030a8:    7408        .t      STRB     r0,[r1,#0x10]
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
        0x080030aa:    4807        .H      LDR      r0,[pc,#28] ; [0x80030c8] = 0x20000044
        0x080030ac:    f7fff93a    ..:.    BL       do_fsm_move_start ; 0x8002324
;;;228    }
        0x080030b0:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x080030b4:    40010810    ...@    DCD    1073809424
        0x080030b8:    40010c10    ...@    DCD    1073810448
        0x080030bc:    200000a1    ...     DCD    536871073
        0x080030c0:    04800080    ....    DCD    75497600
        0x080030c4:    40011000    ...@    DCD    1073811456
        0x080030c8:    20000044    D..     DCD    536870980
        0x080030cc:    200005e0    ...     DCD    536872416
    $d.realdata
    .constdata
    AHBPrescTable
        0x080030d0:    00000000    ....    DCD    0
        0x080030d4:    00000000    ....    DCD    0
        0x080030d8:    04030201    ....    DCD    67305985
        0x080030dc:    09080706    ....    DCD    151521030
    APBPrescTable
        0x080030e0:    00000000    ....    DCD    0
        0x080030e4:    04030201    ....    DCD    67305985
    .constdata
    CHANNEL_OFFSET_TAB
        0x080030e8:    44301c08    ..0D    DCD    1144003592
        0x080030ec:    6c58        Xl      DCW    27736
        0x080030ee:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x080030ef:    00          .       DCB    0
        0x080030f0:    04000000    ....    DCD    67108864
        0x080030f4:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x080030f6:    0000        ..      DCW    0
        0x080030f8:    00000008    ....    DCD    8
        0x080030fc:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x080030fd:    000008      ...     DCB    0,0,8
        0x08003100:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x08003104:    06040200    ....    DCD    100925952
        0x08003108:    0a08        ..      DCW    2568
        0x0800310a:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x0800310b:    00          .       DCB    0
        0x0800310c:    04030201    ....    DCD    67305985
        0x08003110:    00000605    ....    DCD    1541
        0x08003114:    00000000    ....    DCD    0
    .constdata
    CHANNEL_OFFSET_TAB
        0x08003118:    44301c08    ..0D    DCD    1144003592
        0x0800311c:    6c58        Xl      DCW    27736
        0x0800311e:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x0800311f:    00          .       DCB    0
        0x08003120:    04000000    ....    DCD    67108864
        0x08003124:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x08003126:    0000        ..      DCW    0
        0x08003128:    00000008    ....    DCD    8
        0x0800312c:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x0800312d:    000008      ...     DCB    0,0,8
        0x08003130:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x08003134:    06040200    ....    DCD    100925952
        0x08003138:    0a08        ..      DCW    2568
        0x0800313a:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x0800313b:    00          .       DCB    0
        0x0800313c:    04030201    ....    DCD    67305985
        0x08003140:    0605        ..      DCW    1541
    Menu_size
        0x08003142:    0021        !.      DCW    33
        0x08003144:    00000000    ....    DCD    0
    enc_setup
        0x08003148:    00000000    ....    DCD    0
        0x0800314c:    00090000    ....    DCD    589824
    Region$$Table$$Base
        0x08003150:    08003170    p1..    DCD    134230384
        0x08003154:    20000000    ...     DCD    536870912
        0x08003158:    000004ec    ....    DCD    1260
        0x0800315c:    0800068c    ....    DCD    134219404
        0x08003160:    0800330c    .3..    DCD    134230796
        0x08003164:    200004ec    ...     DCD    536872172
        0x08003168:    000006dc    ....    DCD    1756
        0x0800316c:    08001fe4    ....    DCD    134225892
    Region$$Table$$Limit

** Section #2 'RW_IRAM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 412 bytes (alignment 4)
    Address: 0x20000000


** Section #3 'RW_IRAM1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 1756 bytes (alignment 8)
    Address: 0x200004ec


** Section #4 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #5 '.debug_frame' (SHT_PROGBITS)
    Size   : 3940 bytes


** Section #6 '.debug_info' (SHT_PROGBITS)
    Size   : 206976 bytes


** Section #7 '.debug_line' (SHT_PROGBITS)
    Size   : 26144 bytes


** Section #8 '.debug_loc' (SHT_PROGBITS)
    Size   : 8184 bytes


** Section #9 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 530448 bytes


** Section #10 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 3284 bytes


** Section #11 '.symtab' (SHT_SYMTAB)
    Size   : 10112 bytes (alignment 4)
    String table #12 '.strtab'
    Last local symbol no. 447


** Section #12 '.strtab' (SHT_STRTAB)
    Size   : 8616 bytes


** Section #13 '.note' (SHT_NOTE)
    Size   : 28 bytes (alignment 4)


** Section #14 '.comment' (SHT_PROGBITS)
    Size   : 25660 bytes


** Section #15 '.shstrtab' (SHT_STRTAB)
    Size   : 156 bytes


