
========================================================================

** ELF Header Information

    File Name: C:\STM32\project\efeed\MDK-ARM\efeed\efeed.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x080000ed
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_SOFT (0x05000202)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Soft float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 1
    Section header entries: 16

    Program header offset: 643612 (0x0009d21c)
    Section header offset: 643644 (0x0009d23c)

    Section header string table index: 15

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 5156 bytes (2704 bytes in file)
    Virtual address: 0x08000000 (Alignment 8)


========================================================================

** Section #1 'ER_IROM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 2652 bytes (alignment 4)
    Address: 0x08000000

    $d.realdata
    RESET
    __Vectors
        0x08000000:    20000708    ...     DCD    536872712
        0x08000004:    08000101    ....    DCD    134217985
        0x08000008:    08000109    ....    DCD    134217993
        0x0800000c:    0800010b    ....    DCD    134217995
        0x08000010:    0800010d    ....    DCD    134217997
        0x08000014:    0800010f    ....    DCD    134217999
        0x08000018:    08000111    ....    DCD    134218001
        0x0800001c:    00000000    ....    DCD    0
        0x08000020:    00000000    ....    DCD    0
        0x08000024:    00000000    ....    DCD    0
        0x08000028:    00000000    ....    DCD    0
        0x0800002c:    08000513    ....    DCD    134219027
        0x08000030:    08000115    ....    DCD    134218005
        0x08000034:    00000000    ....    DCD    0
        0x08000038:    08000511    ....    DCD    134219025
        0x0800003c:    08000541    A...    DCD    134219073
        0x08000040:    0800011b    ....    DCD    134218011
        0x08000044:    0800011b    ....    DCD    134218011
        0x08000048:    0800011b    ....    DCD    134218011
        0x0800004c:    0800011b    ....    DCD    134218011
        0x08000050:    0800011b    ....    DCD    134218011
        0x08000054:    0800011b    ....    DCD    134218011
        0x08000058:    0800011b    ....    DCD    134218011
        0x0800005c:    0800011b    ....    DCD    134218011
        0x08000060:    0800011b    ....    DCD    134218011
        0x08000064:    0800011b    ....    DCD    134218011
        0x08000068:    0800011b    ....    DCD    134218011
        0x0800006c:    0800011b    ....    DCD    134218011
        0x08000070:    0800011b    ....    DCD    134218011
        0x08000074:    0800011b    ....    DCD    134218011
        0x08000078:    08000191    ....    DCD    134218129
        0x0800007c:    0800011b    ....    DCD    134218011
        0x08000080:    0800011b    ....    DCD    134218011
        0x08000084:    080001b9    ....    DCD    134218169
        0x08000088:    0800011b    ....    DCD    134218011
        0x0800008c:    0800011b    ....    DCD    134218011
        0x08000090:    0800011b    ....    DCD    134218011
        0x08000094:    0800011b    ....    DCD    134218011
        0x08000098:    0800011b    ....    DCD    134218011
        0x0800009c:    0800011b    ....    DCD    134218011
        0x080000a0:    0800011b    ....    DCD    134218011
        0x080000a4:    08000651    Q...    DCD    134219345
        0x080000a8:    0800011b    ....    DCD    134218011
        0x080000ac:    0800011b    ....    DCD    134218011
        0x080000b0:    08000669    i...    DCD    134219369
        0x080000b4:    08000695    ....    DCD    134219413
        0x080000b8:    080006e5    ....    DCD    134219493
        0x080000bc:    0800011b    ....    DCD    134218011
        0x080000c0:    0800011b    ....    DCD    134218011
        0x080000c4:    080002b5    ....    DCD    134218421
        0x080000c8:    080002b1    ....    DCD    134218417
        0x080000cc:    0800011b    ....    DCD    134218011
        0x080000d0:    0800011b    ....    DCD    134218011
        0x080000d4:    0800011b    ....    DCD    134218011
        0x080000d8:    08000751    Q...    DCD    134219601
        0x080000dc:    0800011b    ....    DCD    134218011
        0x080000e0:    0800011b    ....    DCD    134218011
        0x080000e4:    0800011b    ....    DCD    134218011
        0x080000e8:    0800011b    ....    DCD    134218011
    $t
    .ARM.Collect$$$$00000000
    .ARM.Collect$$$$00000001
    __Vectors_End
    __main
    _main_stk
        0x080000ec:    f8dfd00c    ....    LDR      sp,__lit__00000000 ; [0x80000fc] = 0x20000708
    .ARM.Collect$$$$00000004
    _main_scatterload
        0x080000f0:    f000f83c    ..<.    BL       __scatterload ; 0x800016c
    .ARM.Collect$$$$00000008
    .ARM.Collect$$$$0000000A
    .ARM.Collect$$$$0000000B
    __main_after_scatterload
    _main_clock
    _main_cpp_init
    _main_init
        0x080000f4:    4800        .H      LDR      r0,[pc,#0] ; [0x80000f8] = 0x80007c9
        0x080000f6:    4700        .G      BX       r0
    $d
        0x080000f8:    080007c9    ....    DCD    134219721
    .ARM.Collect$$$$00002712
    __lit__00000000
    .ARM.Collect$$$$0000000D
    .ARM.Collect$$$$0000000F
    __rt_final_cpp
    __rt_final_exit
        0x080000fc:    20000708    ...     DCD    536872712
    $t
    .text
    Reset_Handler
;;;150                     LDR     R0, =SystemInit
        0x08000100:    4806        .H      LDR      r0,[pc,#24] ; [0x800011c] = 0x8000609
;;;151                     BLX     R0
        0x08000102:    4780        .G      BLX      r0
;;;152                     LDR     R0, =__main
        0x08000104:    4806        .H      LDR      r0,[pc,#24] ; [0x8000120] = 0x80000ed
;;;153                     BX      R0
        0x08000106:    4700        .G      BX       r0
    NMI_Handler
;;;154                     ENDP
;;;155    
;;;156    ; Dummy Exception Handlers (infinite loops which can be modified)
;;;157    
;;;158    NMI_Handler     PROC
;;;159                    EXPORT  NMI_Handler                [WEAK]
;;;160                    B       .
        0x08000108:    e7fe        ..      B        NMI_Handler ; 0x8000108
    HardFault_Handler
;;;161                    ENDP
;;;162    HardFault_Handler\
;;;163                    PROC
;;;164                    EXPORT  HardFault_Handler          [WEAK]
;;;165                    B       .
        0x0800010a:    e7fe        ..      B        HardFault_Handler ; 0x800010a
    MemManage_Handler
;;;166                    ENDP
;;;167    MemManage_Handler\
;;;168                    PROC
;;;169                    EXPORT  MemManage_Handler          [WEAK]
;;;170                    B       .
        0x0800010c:    e7fe        ..      B        MemManage_Handler ; 0x800010c
    BusFault_Handler
;;;171                    ENDP
;;;172    BusFault_Handler\
;;;173                    PROC
;;;174                    EXPORT  BusFault_Handler           [WEAK]
;;;175                    B       .
        0x0800010e:    e7fe        ..      B        BusFault_Handler ; 0x800010e
    UsageFault_Handler
;;;176                    ENDP
;;;177    UsageFault_Handler\
;;;178                    PROC
;;;179                    EXPORT  UsageFault_Handler         [WEAK]
;;;180                    B       .
        0x08000110:    e7fe        ..      B        UsageFault_Handler ; 0x8000110
;;;181                    ENDP
;;;182    SVC_Handler     PROC
;;;183                    EXPORT  SVC_Handler                [WEAK]
;;;184                    B       .
        0x08000112:    e7fe        ..      B        0x8000112 ; UsageFault_Handler + 2
    DebugMon_Handler
;;;185                    ENDP
;;;186    DebugMon_Handler\
;;;187                    PROC
;;;188                    EXPORT  DebugMon_Handler           [WEAK]
;;;189                    B       .
        0x08000114:    e7fe        ..      B        DebugMon_Handler ; 0x8000114
;;;190                    ENDP
;;;191    PendSV_Handler  PROC
;;;192                    EXPORT  PendSV_Handler             [WEAK]
;;;193                    B       .
        0x08000116:    e7fe        ..      B        0x8000116 ; DebugMon_Handler + 2
;;;194                    ENDP
;;;195    SysTick_Handler PROC
;;;196                    EXPORT  SysTick_Handler            [WEAK]
;;;197                    B       .
        0x08000118:    e7fe        ..      B        0x8000118 ; DebugMon_Handler + 4
    ADC1_2_IRQHandler
    CAN1_RX1_IRQHandler
    CAN1_SCE_IRQHandler
    DMA1_Channel1_IRQHandler
    DMA1_Channel2_IRQHandler
    DMA1_Channel3_IRQHandler
    DMA1_Channel5_IRQHandler
    DMA1_Channel6_IRQHandler
    EXTI0_IRQHandler
    EXTI15_10_IRQHandler
    EXTI1_IRQHandler
    EXTI2_IRQHandler
    EXTI3_IRQHandler
    EXTI4_IRQHandler
    EXTI9_5_IRQHandler
    FLASH_IRQHandler
    I2C1_ER_IRQHandler
    I2C1_EV_IRQHandler
    PVD_IRQHandler
    RCC_IRQHandler
    RTC_Alarm_IRQHandler
    RTC_IRQHandler
    SPI1_IRQHandler
    SPI2_IRQHandler
    TAMPER_IRQHandler
    TIM1_BRK_IRQHandler
    TIM1_CC_IRQHandler
    TIM1_TRG_COM_IRQHandler
    USART1_IRQHandler
    USART3_IRQHandler
    USBWakeUp_IRQHandler
    USB_HP_CAN1_TX_IRQHandler
    USB_LP_CAN1_RX0_IRQHandler
    WWDG_IRQHandler
;;;198                    ENDP
;;;199    
;;;200    Default_Handler PROC
;;;201    
;;;202                    EXPORT  WWDG_IRQHandler            [WEAK]
;;;203                    EXPORT  PVD_IRQHandler             [WEAK]
;;;204                    EXPORT  TAMPER_IRQHandler          [WEAK]
;;;205                    EXPORT  RTC_IRQHandler             [WEAK]
;;;206                    EXPORT  FLASH_IRQHandler           [WEAK]
;;;207                    EXPORT  RCC_IRQHandler             [WEAK]
;;;208                    EXPORT  EXTI0_IRQHandler           [WEAK]
;;;209                    EXPORT  EXTI1_IRQHandler           [WEAK]
;;;210                    EXPORT  EXTI2_IRQHandler           [WEAK]
;;;211                    EXPORT  EXTI3_IRQHandler           [WEAK]
;;;212                    EXPORT  EXTI4_IRQHandler           [WEAK]
;;;213                    EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
;;;214                    EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
;;;215                    EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
;;;216                    EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
;;;217                    EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
;;;218                    EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
;;;219                    EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
;;;220                    EXPORT  ADC1_2_IRQHandler          [WEAK]
;;;221                    EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
;;;222                    EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
;;;223                    EXPORT  CAN1_RX1_IRQHandler        [WEAK]
;;;224                    EXPORT  CAN1_SCE_IRQHandler        [WEAK]
;;;225                    EXPORT  EXTI9_5_IRQHandler         [WEAK]
;;;226                    EXPORT  TIM1_BRK_IRQHandler        [WEAK]
;;;227                    EXPORT  TIM1_UP_IRQHandler         [WEAK]
;;;228                    EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
;;;229                    EXPORT  TIM1_CC_IRQHandler         [WEAK]
;;;230                    EXPORT  TIM2_IRQHandler            [WEAK]
;;;231                    EXPORT  TIM3_IRQHandler            [WEAK]
;;;232                    EXPORT  TIM4_IRQHandler            [WEAK]
;;;233                    EXPORT  I2C1_EV_IRQHandler         [WEAK]
;;;234                    EXPORT  I2C1_ER_IRQHandler         [WEAK]
;;;235                    EXPORT  I2C2_EV_IRQHandler         [WEAK]
;;;236                    EXPORT  I2C2_ER_IRQHandler         [WEAK]
;;;237                    EXPORT  SPI1_IRQHandler            [WEAK]
;;;238                    EXPORT  SPI2_IRQHandler            [WEAK]
;;;239                    EXPORT  USART1_IRQHandler          [WEAK]
;;;240                    EXPORT  USART2_IRQHandler          [WEAK]
;;;241                    EXPORT  USART3_IRQHandler          [WEAK]
;;;242                    EXPORT  EXTI15_10_IRQHandler       [WEAK]
;;;243                    EXPORT  RTC_Alarm_IRQHandler        [WEAK]
;;;244                    EXPORT  USBWakeUp_IRQHandler       [WEAK]
;;;245    
;;;246    WWDG_IRQHandler
;;;247    PVD_IRQHandler
;;;248    TAMPER_IRQHandler
;;;249    RTC_IRQHandler
;;;250    FLASH_IRQHandler
;;;251    RCC_IRQHandler
;;;252    EXTI0_IRQHandler
;;;253    EXTI1_IRQHandler
;;;254    EXTI2_IRQHandler
;;;255    EXTI3_IRQHandler
;;;256    EXTI4_IRQHandler
;;;257    DMA1_Channel1_IRQHandler
;;;258    DMA1_Channel2_IRQHandler
;;;259    DMA1_Channel3_IRQHandler
;;;260    DMA1_Channel4_IRQHandler
;;;261    DMA1_Channel5_IRQHandler
;;;262    DMA1_Channel6_IRQHandler
;;;263    DMA1_Channel7_IRQHandler
;;;264    ADC1_2_IRQHandler
;;;265    USB_HP_CAN1_TX_IRQHandler
;;;266    USB_LP_CAN1_RX0_IRQHandler
;;;267    CAN1_RX1_IRQHandler
;;;268    CAN1_SCE_IRQHandler
;;;269    EXTI9_5_IRQHandler
;;;270    TIM1_BRK_IRQHandler
;;;271    TIM1_UP_IRQHandler
;;;272    TIM1_TRG_COM_IRQHandler
;;;273    TIM1_CC_IRQHandler
;;;274    TIM2_IRQHandler
;;;275    TIM3_IRQHandler
;;;276    TIM4_IRQHandler
;;;277    I2C1_EV_IRQHandler
;;;278    I2C1_ER_IRQHandler
;;;279    I2C2_EV_IRQHandler
;;;280    I2C2_ER_IRQHandler
;;;281    SPI1_IRQHandler
;;;282    SPI2_IRQHandler
;;;283    USART1_IRQHandler
;;;284    USART2_IRQHandler
;;;285    USART3_IRQHandler
;;;286    EXTI15_10_IRQHandler
;;;287    RTC_Alarm_IRQHandler
;;;288    USBWakeUp_IRQHandler
;;;289    
;;;290                    B       .
        0x0800011a:    e7fe        ..      B        ADC1_2_IRQHandler ; 0x800011a
    $d
        0x0800011c:    08000609    ....    DCD    134219273
        0x08000120:    080000ed    ....    DCD    134217965
    $t
    .text
    __aeabi_memcpy
    __aeabi_memcpy4
    __aeabi_memcpy8
        0x08000124:    ea400301    @...    ORR      r3,r0,r1
        0x08000128:    079b        ..      LSLS     r3,r3,#30
        0x0800012a:    d003        ..      BEQ      0x8000134 ; __aeabi_memcpy + 16
        0x0800012c:    e009        ..      B        0x8000142 ; __aeabi_memcpy + 30
        0x0800012e:    c908        ..      LDM      r1!,{r3}
        0x08000130:    1f12        ..      SUBS     r2,r2,#4
        0x08000132:    c008        ..      STM      r0!,{r3}
        0x08000134:    2a04        .*      CMP      r2,#4
        0x08000136:    d2fa        ..      BCS      0x800012e ; __aeabi_memcpy + 10
        0x08000138:    e003        ..      B        0x8000142 ; __aeabi_memcpy + 30
        0x0800013a:    f8113b01    ...;    LDRB     r3,[r1],#1
        0x0800013e:    f8003b01    ...;    STRB     r3,[r0],#1
        0x08000142:    1e52        R.      SUBS     r2,r2,#1
        0x08000144:    d2f9        ..      BCS      0x800013a ; __aeabi_memcpy + 22
        0x08000146:    4770        pG      BX       lr
    .text
    __aeabi_memset
    __aeabi_memset4
    __aeabi_memset8
        0x08000148:    b2d2        ..      UXTB     r2,r2
        0x0800014a:    e001        ..      B        0x8000150 ; __aeabi_memset + 8
        0x0800014c:    f8002b01    ...+    STRB     r2,[r0],#1
        0x08000150:    1e49        I.      SUBS     r1,r1,#1
        0x08000152:    d2fb        ..      BCS      0x800014c ; __aeabi_memset + 4
        0x08000154:    4770        pG      BX       lr
    __aeabi_memclr
    __aeabi_memclr4
    __aeabi_memclr8
        0x08000156:    2200        ."      MOVS     r2,#0
        0x08000158:    e7f6        ..      B        __aeabi_memset ; 0x8000148
    _memset$wrapper
        0x0800015a:    b510        ..      PUSH     {r4,lr}
        0x0800015c:    4613        .F      MOV      r3,r2
        0x0800015e:    460a        .F      MOV      r2,r1
        0x08000160:    4604        .F      MOV      r4,r0
        0x08000162:    4619        .F      MOV      r1,r3
        0x08000164:    f7fffff0    ....    BL       __aeabi_memset ; 0x8000148
        0x08000168:    4620         F      MOV      r0,r4
        0x0800016a:    bd10        ..      POP      {r4,pc}
    .text
    __scatterload
    __scatterload_rt2
        0x0800016c:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000188] = 0x8000a3c
        0x0800016e:    4d07        .M      LDR      r5,[pc,#28] ; [0x800018c] = 0x8000a5c
        0x08000170:    e006        ..      B        0x8000180 ; __scatterload + 20
        0x08000172:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000174:    f0400301    @...    ORR      r3,r0,#1
        0x08000178:    e8940007    ....    LDM      r4,{r0-r2}
        0x0800017c:    4798        .G      BLX      r3
        0x0800017e:    3410        .4      ADDS     r4,r4,#0x10
        0x08000180:    42ac        .B      CMP      r4,r5
        0x08000182:    d3f6        ..      BCC      0x8000172 ; __scatterload + 6
        0x08000184:    f7ffffb6    ....    BL       __main_after_scatterload ; 0x80000f4
    $d
        0x08000188:    08000a3c    <...    DCD    134220348
        0x0800018c:    08000a5c    \...    DCD    134220380
    $t
    i.DMA1_Channel4_IRQHandler
    DMA1_Channel4_IRQHandler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1258     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
        0x08000190:    4808        .H      LDR      r0,[pc,#32] ; [0x80001b4] = 0x40020000
        0x08000192:    6801        .h      LDR      r1,[r0,#0]
        0x08000194:    f3c13140    ..@1    UBFX     r1,r1,#13,#1
        0x08000198:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c
;;;195    {
        0x0800019a:    d003        ..      BEQ      0x80001a4 ; DMA1_Channel4_IRQHandler + 20
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1489     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
        0x0800019c:    1481        ..      ASRS     r1,r0,#18
        0x0800019e:    6041        A`      STR      r1,[r0,#4]
;;; .\../Src/stm32f1xx_it.c
;;;200        Transfer_Complete_Callback();
        0x080001a0:    f000baae    ....    B.W      Transfer_Complete_Callback ; 0x8000700
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1412     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
        0x080001a4:    6800        .h      LDR      r0,[r0,#0]
        0x080001a6:    f3c030c0    ...0    UBFX     r0,r0,#15,#1
;;; .\../Src/stm32f1xx_it.c
;;;203      else if(LL_DMA_IsActiveFlag_TE4(DMA1))
        0x080001aa:    2800        .(      CMP      r0,#0
        0x080001ac:    d001        ..      BEQ      0x80001b2 ; DMA1_Channel4_IRQHandler + 34
;;;204      {
;;;205        Transfer_Error_Callback();
        0x080001ae:    f000bac7    ....    B.W      Transfer_Error_Callback ; 0x8000740
;;;206      }
;;;207    
;;;208      /* USER CODE END DMA1_Channel4_IRQn 0 */
;;;209      
;;;210      /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */
;;;211    
;;;212      /* USER CODE END DMA1_Channel4_IRQn 1 */
;;;213    }
        0x080001b2:    4770        pG      BX       lr
    $d
        0x080001b4:    40020000    ...@    DCD    1073872896
    $t
    i.DMA1_Channel7_IRQHandler
    DMA1_Channel7_IRQHandler
;;;214    
;;;215    /**
;;;216      * @brief This function handles DMA1 channel7 global interrupt.
;;;217      */
;;;218    void DMA1_Channel7_IRQHandler(void)
;;;219    {
;;;220      /* USER CODE BEGIN DMA1_Channel7_IRQn 0 */
;;;221    
;;;222      /* USER CODE END DMA1_Channel7_IRQn 0 */
;;;223      
;;;224      /* USER CODE BEGIN DMA1_Channel7_IRQn 1 */
;;;225    
;;;226      /* USER CODE END DMA1_Channel7_IRQn 1 */
;;;227    }
        0x080001b8:    4770        pG      BX       lr
    i.Error_Handler
    Error_Handler
;;; .\../Src/main.c
;;;1114   	while (1) {
        0x080001ba:    e7fe        ..      B        Error_Handler ; 0x80001ba
    i.G01parse
    G01parse
;;; .\..\Src\gcode.c
;;;43     void G01parse(char *line){
        0x080001bc:    b510        ..      PUSH     {r4,lr}
;;;44     	G_pipeline *gref = G_parse(line);
        0x080001be:    f000f815    ....    BL       G_parse ; 0x80001ec
;;;45     	gref->code = 1;
        0x080001c2:    2101        .!      MOVS     r1,#1
        0x080001c4:    7641        Av      STRB     r1,[r0,#0x19]
;;;46     }
        0x080001c6:    bd10        ..      POP      {r4,pc}
    i.G03parse
    G03parse
;;;47     
;;;48     int xc,zc,r;
;;;49     void G03parse(char *line){
        0x080001c8:    b510        ..      PUSH     {r4,lr}
;;;50     	G_pipeline *gref = G_parse(line);
        0x080001ca:    f000f80f    ....    BL       G_parse ; 0x80001ec
        0x080001ce:    4604        .F      MOV      r4,r0
;;;51     	gref->code = 3;
        0x080001d0:    2003        .       MOVS     r0,#3
        0x080001d2:    7660        `v      STRB     r0,[r4,#0x19]
;;;52     	int ii = gref->I >> 10,kk = gref->K >> 10; //back from 2210 to steps
        0x080001d4:    68e0        .h      LDR      r0,[r4,#0xc]
        0x080001d6:    1281        ..      ASRS     r1,r0,#10
        0x080001d8:    6920         i      LDR      r0,[r4,#0x10]
        0x080001da:    1280        ..      ASRS     r0,r0,#10
;;;53     	gref->R = SquareRoot(ii*ii + kk*kk);
        0x080001dc:    4349        IC      MULS     r1,r1,r1
        0x080001de:    fb001000    ....    MLA      r0,r0,r0,r1
        0x080001e2:    f000f997    ....    BL       SquareRoot ; 0x8000514
        0x080001e6:    6160        `a      STR      r0,[r4,#0x14]
;;;54     //	xc = gref->X + gref->I;
;;;55     //	zc = gref->Z + gref->K;
;;;56     }
        0x080001e8:    bd10        ..      POP      {r4,pc}
        0x080001ea:    0000        ..      MOVS     r0,r0
    i.G_parse
    G_parse
;;; .\..\Src\gcode.c (5)
        0x080001ec:    b530        0.      PUSH     {r4,r5,lr}
        0x080001ee:    b089        ..      SUB      sp,sp,#0x24
        0x080001f0:    4605        .F      MOV      r5,r0
;;;6        uint8_t char_counter = 0;  
        0x080001f2:    2000        .       MOVS     r0,#0
        0x080001f4:    9008        ..      STR      r0,[sp,#0x20]
;;;7      	G_pipeline init_gp={0,0,0,0,0};
        0x080001f6:    211c        .!      MOVS     r1,#0x1c
        0x080001f8:    a801        ..      ADD      r0,sp,#4
        0x080001fa:    f7ffffac    ....    BL       __aeabi_memclr ; 0x8000156
;;;8      	cb_init_by_top(&gp_cb,&init_gp);
        0x080001fe:    a801        ..      ADD      r0,sp,#4
;;; ../Inc/nuts_bolts.h
;;;56         if(cb->count == 0){
        0x08000200:    4c2a        *L      LDR      r4,[pc,#168] ; [0x80002ac] = 0x20000054
        0x08000202:    68e1        .h      LDR      r1,[r4,#0xc]
        0x08000204:    b311        ..      CBZ      r1,0x800024c ; G_parse + 96
;;;57             return;
;;;58         }
;;;59         memcpy(item, cb->top, cb->sz);
        0x08000206:    6922        "i      LDR      r2,[r4,#0x10]
        0x08000208:    69a1        .i      LDR      r1,[r4,#0x18]
        0x0800020a:    f7ffff8b    ....    BL       __aeabi_memcpy ; 0x8000124
;;;60     }
        0x0800020e:    e02f        /.      B        0x8000270 ; G_parse + 132
;;; .\..\Src\gcode.c
;;;17         letter = line[char_counter++];
        0x08000210:    1c48        H.      ADDS     r0,r1,#1
        0x08000212:    9008        ..      STR      r0,[sp,#0x20]
        0x08000214:    5c69        i\      LDRB     r1,[r5,r1]
;;;18     		switch(letter){
        0x08000216:    294b        K)      CMP      r1,#0x4b
        0x08000218:    d01f        ..      BEQ      0x800025a ; G_parse + 110
        0x0800021a:    dc04        ..      BGT      0x8000226 ; G_parse + 58
        0x0800021c:    2946        F)      CMP      r1,#0x46
        0x0800021e:    d022        ".      BEQ      0x8000266 ; G_parse + 122
        0x08000220:    2949        I)      CMP      r1,#0x49
        0x08000222:    d125        %.      BNE      0x8000270 ; G_parse + 132
        0x08000224:    e013        ..      B        0x800024e ; G_parse + 98
        0x08000226:    2958        X)      CMP      r1,#0x58
        0x08000228:    d002        ..      BEQ      0x8000230 ; G_parse + 68
        0x0800022a:    295a        Z)      CMP      r1,#0x5a
        0x0800022c:    d120         .      BNE      0x8000270 ; G_parse + 132
        0x0800022e:    e008        ..      B        0x8000242 ; G_parse + 86
;;;19     			case 'X':
;;;20     				init_gp.X = str_f_to_steps2210(line, &char_counter);
        0x08000230:    a908        ..      ADD      r1,sp,#0x20
        0x08000232:    4628        (F      MOV      r0,r5
        0x08000234:    f000fb9c    ....    BL       str_f_to_steps2210 ; 0x8000970
        0x08000238:    9001        ..      STR      r0,[sp,#4]
;;;21     				init_gp.X >>= 2; //Fusion360 generate X in diameter mode, so divide by 2
        0x0800023a:    9801        ..      LDR      r0,[sp,#4]
        0x0800023c:    1080        ..      ASRS     r0,r0,#2
        0x0800023e:    9001        ..      STR      r0,[sp,#4]
;;;22     				break;
        0x08000240:    e016        ..      B        0x8000270 ; G_parse + 132
;;;23     			case 'Z':
;;;24     				init_gp.Z = str_f_to_steps2210(line, &char_counter);
        0x08000242:    a908        ..      ADD      r1,sp,#0x20
        0x08000244:    4628        (F      MOV      r0,r5
        0x08000246:    f000fb93    ....    BL       str_f_to_steps2210 ; 0x8000970
        0x0800024a:    9002        ..      STR      r0,[sp,#8]
;;;25     				break;
        0x0800024c:    e010        ..      B        0x8000270 ; G_parse + 132
;;;26     			case 'I':
;;;27     				init_gp.I = str_f_to_steps2210(line, &char_counter);
        0x0800024e:    a908        ..      ADD      r1,sp,#0x20
        0x08000250:    4628        (F      MOV      r0,r5
        0x08000252:    f000fb8d    ....    BL       str_f_to_steps2210 ; 0x8000970
        0x08000256:    9004        ..      STR      r0,[sp,#0x10]
;;;28     				break;
        0x08000258:    e00a        ..      B        0x8000270 ; G_parse + 132
;;;29     			case 'K':
;;;30     				init_gp.K = str_f_to_steps2210(line, &char_counter);
        0x0800025a:    a908        ..      ADD      r1,sp,#0x20
        0x0800025c:    4628        (F      MOV      r0,r5
        0x0800025e:    f000fb87    ....    BL       str_f_to_steps2210 ; 0x8000970
        0x08000262:    9005        ..      STR      r0,[sp,#0x14]
;;;31     				break;
        0x08000264:    e004        ..      B        0x8000270 ; G_parse + 132
;;;32     			case 'F':
;;;33     				init_gp.feed = str_f_to_steps2210(line, &char_counter);
        0x08000266:    a908        ..      ADD      r1,sp,#0x20
        0x08000268:    4628        (F      MOV      r0,r5
        0x0800026a:    f000fb81    ....    BL       str_f_to_steps2210 ; 0x8000970
        0x0800026e:    9003        ..      STR      r0,[sp,#0xc]
        0x08000270:    f89d1020    .. .    LDRB     r1,[sp,#0x20]
        0x08000274:    5c68        h\      LDRB     r0,[r5,r1]
        0x08000276:    2800        .(      CMP      r0,#0
        0x08000278:    d1ca        ..      BNE      0x8000210 ; G_parse + 36
;;;34     				break;
;;;35     		}
;;;36     	}
;;;37     
;;;38     	cb_push_back(&gp_cb, &init_gp);
        0x0800027a:    a901        ..      ADD      r1,sp,#4
;;; ../Inc/nuts_bolts.h
;;;43         if(cb->count == cb->capacity){
        0x0800027c:    e9d42002    ...     LDRD     r2,r0,[r4,#8]
        0x08000280:    4290        .B      CMP      r0,r2
        0x08000282:    d100        ..      BNE      0x8000286 ; G_parse + 154
;;;44             while(1){}
        0x08000284:    e7fe        ..      B        0x8000284 ; G_parse + 152
;;;45                 // handle error
;;;46         }
;;;47         memcpy(cb->head, item, cb->sz);
        0x08000286:    e9d42004    ...     LDRD     r2,r0,[r4,#0x10]
        0x0800028a:    f7ffff4b    ..K.    BL       __aeabi_memcpy ; 0x8000124
;;;48     		cb->top = cb->head;
        0x0800028e:    6960        `i      LDR      r0,[r4,#0x14]
        0x08000290:    61a0        .a      STR      r0,[r4,#0x18]
;;;49         cb->head = (uint8_t *)cb->head + cb->sz;
        0x08000292:    6921        !i      LDR      r1,[r4,#0x10]
        0x08000294:    4401        .D      ADD      r1,r1,r0
        0x08000296:    6161        aa      STR      r1,[r4,#0x14]
;;;50         if(cb->head == cb->buffer_end)
        0x08000298:    6862        bh      LDR      r2,[r4,#4]
        0x0800029a:    4291        .B      CMP      r1,r2
        0x0800029c:    d101        ..      BNE      0x80002a2 ; G_parse + 182
;;;51             cb->head = cb->buffer;
        0x0800029e:    6821        !h      LDR      r1,[r4,#0]
        0x080002a0:    6161        aa      STR      r1,[r4,#0x14]
;;;52         cb->count++;
        0x080002a2:    68e1        .h      LDR      r1,[r4,#0xc]
        0x080002a4:    1c49        I.      ADDS     r1,r1,#1
        0x080002a6:    60e1        .`      STR      r1,[r4,#0xc]
;;; .\..\Src\gcode.c
;;;40     }
        0x080002a8:    b009        ..      ADD      sp,sp,#0x24
        0x080002aa:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080002ac:    20000054    T..     DCD    536870996
    $t
    i.I2C2_ER_IRQHandler
    I2C2_ER_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;368      while(1){
        0x080002b0:    e7fe        ..      B        I2C2_ER_IRQHandler ; 0x80002b0
        0x080002b2:    0000        ..      MOVS     r0,r0
    i.I2C2_EV_IRQHandler
    I2C2_EV_IRQHandler
;;; .\../Src/stm32f1xx_it.c (337)
        0x080002b4:    b508        ..      PUSH     {r3,lr}
        0x080002b6:    480d        .H      LDR      r0,[pc,#52] ; [0x80002ec] = 0x40005800
        0x080002b8:    6941        Ai      LDR      r1,[r0,#0x14]
        0x080002ba:    f3c10100    ....    UBFX     r1,r1,#0,#1
        0x080002be:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c (337)
        0x080002c0:    d006        ..      BEQ      0x80002d0 ; I2C2_EV_IRQHandler + 28
        0x080002c2:    6901        .i      LDR      r1,[r0,#0x10]
        0x080002c4:    f02101ff    !...    BIC      r1,r1,#0xff
        0x080002c8:    f0410178    A.x.    ORR      r1,r1,#0x78
        0x080002cc:    6101        .a      STR      r1,[r0,#0x10]
        0x080002ce:    bd08        ..      POP      {r3,pc}
        0x080002d0:    6941        Ai      LDR      r1,[r0,#0x14]
        0x080002d2:    f3c10140    ..@.    UBFX     r1,r1,#1,#1
;;;338      /* USER CODE BEGIN I2C2_EV_IRQn 0 */
;;;339      /* Check SB flag value in ISR register */
;;;340      if(LL_I2C_IsActiveFlag_SB(I2C2))
;;;341      {
;;;342        /* Send Slave address with a 7-Bit SLAVE_OWN_ADDRESS for a write request */
;;;343        LL_I2C_TransmitData8(I2C2, SSD1306_I2C_ADDR);
;;;344      }
;;;345      /* Check ADDR flag value in ISR register */
;;;346      else if(LL_I2C_IsActiveFlag_ADDR(I2C2))
        0x080002d6:    2900        .)      CMP      r1,#0
        0x080002d8:    d0f9        ..      BEQ      0x80002ce ; I2C2_EV_IRQHandler + 26
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;401      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
        0x080002da:    6841        Ah      LDR      r1,[r0,#4]
        0x080002dc:    f4416100    A..a    ORR      r1,r1,#0x800
        0x080002e0:    6041        A`      STR      r1,[r0,#4]
;;;402    }
;;;403    
;;;404    /**
;;;405      * @brief  Disable DMA transmission requests.
;;;406      * @rmtoll CR2          DMAEN         LL_I2C_DisableDMAReq_TX
;;;407      * @param  I2Cx I2C Instance.
;;;408      * @retval None
;;;409      */
;;;410    __STATIC_INLINE void LL_I2C_DisableDMAReq_TX(I2C_TypeDef *I2Cx)
;;;411    {
;;;412      CLEAR_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
;;;413    }
;;;414    
;;;415    /**
;;;416      * @brief  Check if DMA transmission requests are enabled or disabled.
;;;417      * @rmtoll CR2          DMAEN         LL_I2C_IsEnabledDMAReq_TX
;;;418      * @param  I2Cx I2C Instance.
;;;419      * @retval State of bit (1 or 0).
;;;420      */
;;;421    __STATIC_INLINE uint32_t LL_I2C_IsEnabledDMAReq_TX(I2C_TypeDef *I2Cx)
;;;422    {
;;;423      return (READ_BIT(I2Cx->CR2, I2C_CR2_DMAEN) == (I2C_CR2_DMAEN));
;;;424    }
;;;425    
;;;426    /**
;;;427      * @brief  Enable DMA reception requests.
;;;428      * @rmtoll CR2          DMAEN         LL_I2C_EnableDMAReq_RX
;;;429      * @param  I2Cx I2C Instance.
;;;430      * @retval None
;;;431      */
;;;432    __STATIC_INLINE void LL_I2C_EnableDMAReq_RX(I2C_TypeDef *I2Cx)
;;;433    {
;;;434      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
;;;435    }
;;;436    
;;;437    /**
;;;438      * @brief  Disable DMA reception requests.
;;;439      * @rmtoll CR2          DMAEN         LL_I2C_DisableDMAReq_RX
;;;440      * @param  I2Cx I2C Instance.
;;;441      * @retval None
;;;442      */
;;;443    __STATIC_INLINE void LL_I2C_DisableDMAReq_RX(I2C_TypeDef *I2Cx)
;;;444    {
;;;445      CLEAR_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
;;;446    }
;;;447    
;;;448    /**
;;;449      * @brief  Check if DMA reception requests are enabled or disabled.
;;;450      * @rmtoll CR2          DMAEN         LL_I2C_IsEnabledDMAReq_RX
;;;451      * @param  I2Cx I2C Instance.
;;;452      * @retval State of bit (1 or 0).
;;;453      */
;;;454    __STATIC_INLINE uint32_t LL_I2C_IsEnabledDMAReq_RX(I2C_TypeDef *I2Cx)
;;;455    {
;;;456      return (READ_BIT(I2Cx->CR2, I2C_CR2_DMAEN) == (I2C_CR2_DMAEN));
;;;457    }
;;;458    
;;;459    /**
;;;460      * @brief  Get the data register address used for DMA transfer.
;;;461      * @rmtoll DR           DR            LL_I2C_DMA_GetRegAddr
;;;462      * @param  I2Cx I2C Instance.
;;;463      * @retval Address of data register
;;;464      */
;;;465    __STATIC_INLINE uint32_t LL_I2C_DMA_GetRegAddr(I2C_TypeDef *I2Cx)
;;;466    {
;;;467      return (uint32_t) & (I2Cx->DR);
;;;468    }
;;;469    
;;;470    /**
;;;471      * @brief  Enable Clock stretching.
;;;472      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;473      * @rmtoll CR1          NOSTRETCH     LL_I2C_EnableClockStretching
;;;474      * @param  I2Cx I2C Instance.
;;;475      * @retval None
;;;476      */
;;;477    __STATIC_INLINE void LL_I2C_EnableClockStretching(I2C_TypeDef *I2Cx)
;;;478    {
;;;479      CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
;;;480    }
;;;481    
;;;482    /**
;;;483      * @brief  Disable Clock stretching.
;;;484      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;485      * @rmtoll CR1          NOSTRETCH     LL_I2C_DisableClockStretching
;;;486      * @param  I2Cx I2C Instance.
;;;487      * @retval None
;;;488      */
;;;489    __STATIC_INLINE void LL_I2C_DisableClockStretching(I2C_TypeDef *I2Cx)
;;;490    {
;;;491      SET_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
;;;492    }
;;;493    
;;;494    /**
;;;495      * @brief  Check if Clock stretching is enabled or disabled.
;;;496      * @rmtoll CR1          NOSTRETCH     LL_I2C_IsEnabledClockStretching
;;;497      * @param  I2Cx I2C Instance.
;;;498      * @retval State of bit (1 or 0).
;;;499      */
;;;500    __STATIC_INLINE uint32_t LL_I2C_IsEnabledClockStretching(I2C_TypeDef *I2Cx)
;;;501    {
;;;502      return (READ_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH) != (I2C_CR1_NOSTRETCH));
;;;503    }
;;;504    
;;;505    /**
;;;506      * @brief  Enable General Call.
;;;507      * @note   When enabled the Address 0x00 is ACKed.
;;;508      * @rmtoll CR1          ENGC          LL_I2C_EnableGeneralCall
;;;509      * @param  I2Cx I2C Instance.
;;;510      * @retval None
;;;511      */
;;;512    __STATIC_INLINE void LL_I2C_EnableGeneralCall(I2C_TypeDef *I2Cx)
;;;513    {
;;;514      SET_BIT(I2Cx->CR1, I2C_CR1_ENGC);
;;;515    }
;;;516    
;;;517    /**
;;;518      * @brief  Disable General Call.
;;;519      * @note   When disabled the Address 0x00 is NACKed.
;;;520      * @rmtoll CR1          ENGC          LL_I2C_DisableGeneralCall
;;;521      * @param  I2Cx I2C Instance.
;;;522      * @retval None
;;;523      */
;;;524    __STATIC_INLINE void LL_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx)
;;;525    {
;;;526      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENGC);
;;;527    }
;;;528    
;;;529    /**
;;;530      * @brief  Check if General Call is enabled or disabled.
;;;531      * @rmtoll CR1          ENGC          LL_I2C_IsEnabledGeneralCall
;;;532      * @param  I2Cx I2C Instance.
;;;533      * @retval State of bit (1 or 0).
;;;534      */
;;;535    __STATIC_INLINE uint32_t LL_I2C_IsEnabledGeneralCall(I2C_TypeDef *I2Cx)
;;;536    {
;;;537      return (READ_BIT(I2Cx->CR1, I2C_CR1_ENGC) == (I2C_CR1_ENGC));
;;;538    }
;;;539    
;;;540    /**
;;;541      * @brief  Set the Own Address1.
;;;542      * @rmtoll OAR1         ADD0          LL_I2C_SetOwnAddress1\n
;;;543      *         OAR1         ADD1_7        LL_I2C_SetOwnAddress1\n
;;;544      *         OAR1         ADD8_9        LL_I2C_SetOwnAddress1\n
;;;545      *         OAR1         ADDMODE       LL_I2C_SetOwnAddress1
;;;546      * @param  I2Cx I2C Instance.
;;;547      * @param  OwnAddress1 This parameter must be a value between Min_Data=0 and Max_Data=0x3FF.
;;;548      * @param  OwnAddrSize This parameter can be one of the following values:
;;;549      *         @arg @ref LL_I2C_OWNADDRESS1_7BIT
;;;550      *         @arg @ref LL_I2C_OWNADDRESS1_10BIT
;;;551      * @retval None
;;;552      */
;;;553    __STATIC_INLINE void LL_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx, uint32_t OwnAddress1, uint32_t OwnAddrSize)
;;;554    {
;;;555      MODIFY_REG(I2Cx->OAR1, I2C_OAR1_ADD0 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD8_9 | I2C_OAR1_ADDMODE, OwnAddress1 | OwnAddrSize);
;;;556    }
;;;557    
;;;558    /**
;;;559      * @brief  Set the 7bits Own Address2.
;;;560      * @note   This action has no effect if own address2 is enabled.
;;;561      * @rmtoll OAR2         ADD2          LL_I2C_SetOwnAddress2
;;;562      * @param  I2Cx I2C Instance.
;;;563      * @param  OwnAddress2 This parameter must be a value between Min_Data=0 and Max_Data=0x7F.
;;;564      * @retval None
;;;565      */
;;;566    __STATIC_INLINE void LL_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2)
;;;567    {
;;;568      MODIFY_REG(I2Cx->OAR2, I2C_OAR2_ADD2, OwnAddress2);
;;;569    }
;;;570    
;;;571    /**
;;;572      * @brief  Enable acknowledge on Own Address2 match address.
;;;573      * @rmtoll OAR2         ENDUAL        LL_I2C_EnableOwnAddress2
;;;574      * @param  I2Cx I2C Instance.
;;;575      * @retval None
;;;576      */
;;;577    __STATIC_INLINE void LL_I2C_EnableOwnAddress2(I2C_TypeDef *I2Cx)
;;;578    {
;;;579      SET_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
;;;580    }
;;;581    
;;;582    /**
;;;583      * @brief  Disable  acknowledge on Own Address2 match address.
;;;584      * @rmtoll OAR2         ENDUAL        LL_I2C_DisableOwnAddress2
;;;585      * @param  I2Cx I2C Instance.
;;;586      * @retval None
;;;587      */
;;;588    __STATIC_INLINE void LL_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx)
;;;589    {
;;;590      CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
;;;591    }
;;;592    
;;;593    /**
;;;594      * @brief  Check if Own Address1 acknowledge is enabled or disabled.
;;;595      * @rmtoll OAR2         ENDUAL        LL_I2C_IsEnabledOwnAddress2
;;;596      * @param  I2Cx I2C Instance.
;;;597      * @retval State of bit (1 or 0).
;;;598      */
;;;599    __STATIC_INLINE uint32_t LL_I2C_IsEnabledOwnAddress2(I2C_TypeDef *I2Cx)
;;;600    {
;;;601      return (READ_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL) == (I2C_OAR2_ENDUAL));
;;;602    }
;;;603    
;;;604    /**
;;;605      * @brief  Configure the Peripheral clock frequency.
;;;606      * @rmtoll CR2          FREQ          LL_I2C_SetPeriphClock
;;;607      * @param  I2Cx I2C Instance.
;;;608      * @param  PeriphClock Peripheral Clock (in Hz)
;;;609      * @retval None
;;;610      */
;;;611    __STATIC_INLINE void LL_I2C_SetPeriphClock(I2C_TypeDef *I2Cx, uint32_t PeriphClock)
;;;612    {
;;;613      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock));
;;;614    }
;;;615    
;;;616    /**
;;;617      * @brief  Get the Peripheral clock frequency.
;;;618      * @rmtoll CR2          FREQ          LL_I2C_GetPeriphClock
;;;619      * @param  I2Cx I2C Instance.
;;;620      * @retval Value of Peripheral Clock (in Hz)
;;;621      */
;;;622    __STATIC_INLINE uint32_t LL_I2C_GetPeriphClock(I2C_TypeDef *I2Cx)
;;;623    {
;;;624      return (uint32_t)(__LL_I2C_FREQ_MHZ_TO_HZ(READ_BIT(I2Cx->CR2, I2C_CR2_FREQ)));
;;;625    }
;;;626    
;;;627    /**
;;;628      * @brief  Configure the Duty cycle (Fast mode only).
;;;629      * @rmtoll CCR          DUTY          LL_I2C_SetDutyCycle
;;;630      * @param  I2Cx I2C Instance.
;;;631      * @param  DutyCycle This parameter can be one of the following values:
;;;632      *         @arg @ref LL_I2C_DUTYCYCLE_2
;;;633      *         @arg @ref LL_I2C_DUTYCYCLE_16_9
;;;634      * @retval None
;;;635      */
;;;636    __STATIC_INLINE void LL_I2C_SetDutyCycle(I2C_TypeDef *I2Cx, uint32_t DutyCycle)
;;;637    {
;;;638      MODIFY_REG(I2Cx->CCR, I2C_CCR_DUTY, DutyCycle);
;;;639    }
;;;640    
;;;641    /**
;;;642      * @brief  Get the Duty cycle (Fast mode only).
;;;643      * @rmtoll CCR          DUTY          LL_I2C_GetDutyCycle
;;;644      * @param  I2Cx I2C Instance.
;;;645      * @retval Returned value can be one of the following values:
;;;646      *         @arg @ref LL_I2C_DUTYCYCLE_2
;;;647      *         @arg @ref LL_I2C_DUTYCYCLE_16_9
;;;648      */
;;;649    __STATIC_INLINE uint32_t LL_I2C_GetDutyCycle(I2C_TypeDef *I2Cx)
;;;650    {
;;;651      return (uint32_t)(READ_BIT(I2Cx->CCR, I2C_CCR_DUTY));
;;;652    }
;;;653    
;;;654    /**
;;;655      * @brief  Configure the I2C master clock speed mode.
;;;656      * @rmtoll CCR          FS            LL_I2C_SetClockSpeedMode
;;;657      * @param  I2Cx I2C Instance.
;;;658      * @param  ClockSpeedMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_I2C_CLOCK_SPEED_STANDARD_MODE
;;;660      *         @arg @ref LL_I2C_CLOCK_SPEED_FAST_MODE
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_I2C_SetClockSpeedMode(I2C_TypeDef *I2Cx, uint32_t ClockSpeedMode)
;;;664    {
;;;665      MODIFY_REG(I2Cx->CCR, I2C_CCR_FS, ClockSpeedMode);
;;;666    }
;;;667    
;;;668    /**
;;;669      * @brief  Get the the I2C master speed mode.
;;;670      * @rmtoll CCR          FS            LL_I2C_GetClockSpeedMode
;;;671      * @param  I2Cx I2C Instance.
;;;672      * @retval Returned value can be one of the following values:
;;;673      *         @arg @ref LL_I2C_CLOCK_SPEED_STANDARD_MODE
;;;674      *         @arg @ref LL_I2C_CLOCK_SPEED_FAST_MODE
;;;675      */
;;;676    __STATIC_INLINE uint32_t LL_I2C_GetClockSpeedMode(I2C_TypeDef *I2Cx)
;;;677    {
;;;678      return (uint32_t)(READ_BIT(I2Cx->CCR, I2C_CCR_FS));
;;;679    }
;;;680    
;;;681    /**
;;;682      * @brief  Configure the SCL, SDA rising time.
;;;683      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;684      * @rmtoll TRISE        TRISE         LL_I2C_SetRiseTime
;;;685      * @param  I2Cx I2C Instance.
;;;686      * @param  RiseTime This parameter must be a value between Min_Data=0x02 and Max_Data=0x3F.
;;;687      * @retval None
;;;688      */
;;;689    __STATIC_INLINE void LL_I2C_SetRiseTime(I2C_TypeDef *I2Cx, uint32_t RiseTime)
;;;690    {
;;;691      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, RiseTime);
;;;692    }
;;;693    
;;;694    /**
;;;695      * @brief  Get the SCL, SDA rising time.
;;;696      * @rmtoll TRISE        TRISE         LL_I2C_GetRiseTime
;;;697      * @param  I2Cx I2C Instance.
;;;698      * @retval Value between Min_Data=0x02 and Max_Data=0x3F
;;;699      */
;;;700    __STATIC_INLINE uint32_t LL_I2C_GetRiseTime(I2C_TypeDef *I2Cx)
;;;701    {
;;;702      return (uint32_t)(READ_BIT(I2Cx->TRISE, I2C_TRISE_TRISE));
;;;703    }
;;;704    
;;;705    /**
;;;706      * @brief  Configure the SCL high and low period.
;;;707      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;708      * @rmtoll CCR          CCR           LL_I2C_SetClockPeriod
;;;709      * @param  I2Cx I2C Instance.
;;;710      * @param  ClockPeriod This parameter must be a value between Min_Data=0x004 and Max_Data=0xFFF, except in FAST DUTY mode where Min_Data=0x001.
;;;711      * @retval None
;;;712      */
;;;713    __STATIC_INLINE void LL_I2C_SetClockPeriod(I2C_TypeDef *I2Cx, uint32_t ClockPeriod)
;;;714    {
;;;715      MODIFY_REG(I2Cx->CCR, I2C_CCR_CCR, ClockPeriod);
;;;716    }
;;;717    
;;;718    /**
;;;719      * @brief  Get the SCL high and low period.
;;;720      * @rmtoll CCR          CCR           LL_I2C_GetClockPeriod
;;;721      * @param  I2Cx I2C Instance.
;;;722      * @retval Value between Min_Data=0x004 and Max_Data=0xFFF, except in FAST DUTY mode where Min_Data=0x001.
;;;723      */
;;;724    __STATIC_INLINE uint32_t LL_I2C_GetClockPeriod(I2C_TypeDef *I2Cx)
;;;725    {
;;;726      return (uint32_t)(READ_BIT(I2Cx->CCR, I2C_CCR_CCR));
;;;727    }
;;;728    
;;;729    /**
;;;730      * @brief  Configure the SCL speed.
;;;731      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;732      * @rmtoll CR2          FREQ          LL_I2C_ConfigSpeed\n
;;;733      *         TRISE        TRISE         LL_I2C_ConfigSpeed\n
;;;734      *         CCR          FS            LL_I2C_ConfigSpeed\n
;;;735      *         CCR          DUTY          LL_I2C_ConfigSpeed\n
;;;736      *         CCR          CCR           LL_I2C_ConfigSpeed
;;;737      * @param  I2Cx I2C Instance.
;;;738      * @param  PeriphClock Peripheral Clock (in Hz)
;;;739      * @param  ClockSpeed This parameter must be a value lower than 400kHz (in Hz).
;;;740      * @param  DutyCycle This parameter can be one of the following values:
;;;741      *         @arg @ref LL_I2C_DUTYCYCLE_2
;;;742      *         @arg @ref LL_I2C_DUTYCYCLE_16_9
;;;743      * @retval None
;;;744      */
;;;745    __STATIC_INLINE void LL_I2C_ConfigSpeed(I2C_TypeDef *I2Cx, uint32_t PeriphClock, uint32_t ClockSpeed,
;;;746                                            uint32_t DutyCycle)
;;;747    {
;;;748      register uint32_t freqrange = 0x0U;
;;;749      register uint32_t clockconfig = 0x0U;
;;;750    
;;;751      /* Compute frequency range */
;;;752      freqrange = __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock);
;;;753    
;;;754      /* Configure I2Cx: Frequency range register */
;;;755      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, freqrange);
;;;756    
;;;757      /* Configure I2Cx: Rise Time register */
;;;758      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, __LL_I2C_RISE_TIME(freqrange, ClockSpeed));
;;;759    
;;;760      /* Configure Speed mode, Duty Cycle and Clock control register value */
;;;761      if (ClockSpeed > LL_I2C_MAX_SPEED_STANDARD)
;;;762      {
;;;763        /* Set Speed mode at fast and duty cycle for Clock Speed request in fast clock range */
;;;764        clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
;;;765                      __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
;;;766                      DutyCycle;
;;;767      }
;;;768      else
;;;769      {
;;;770        /* Set Speed mode at standard for Clock Speed request in standard clock range */
;;;771        clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
;;;772                      __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
;;;773      }
;;;774    
;;;775      /* Configure I2Cx: Clock control register */
;;;776      MODIFY_REG(I2Cx->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), clockconfig);
;;;777    }
;;;778    
;;;779    /**
;;;780      * @brief  Configure peripheral mode.
;;;781      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;782      *         SMBus feature is supported by the I2Cx Instance.
;;;783      * @rmtoll CR1          SMBUS         LL_I2C_SetMode\n
;;;784      *         CR1          SMBTYPE       LL_I2C_SetMode\n
;;;785      *         CR1          ENARP         LL_I2C_SetMode
;;;786      * @param  I2Cx I2C Instance.
;;;787      * @param  PeripheralMode This parameter can be one of the following values:
;;;788      *         @arg @ref LL_I2C_MODE_I2C
;;;789      *         @arg @ref LL_I2C_MODE_SMBUS_HOST
;;;790      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
;;;791      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
;;;792      * @retval None
;;;793      */
;;;794    __STATIC_INLINE void LL_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode)
;;;795    {
;;;796      MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
;;;797    }
;;;798    
;;;799    /**
;;;800      * @brief  Get peripheral mode.
;;;801      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;802      *         SMBus feature is supported by the I2Cx Instance.
;;;803      * @rmtoll CR1          SMBUS         LL_I2C_GetMode\n
;;;804      *         CR1          SMBTYPE       LL_I2C_GetMode\n
;;;805      *         CR1          ENARP         LL_I2C_GetMode
;;;806      * @param  I2Cx I2C Instance.
;;;807      * @retval Returned value can be one of the following values:
;;;808      *         @arg @ref LL_I2C_MODE_I2C
;;;809      *         @arg @ref LL_I2C_MODE_SMBUS_HOST
;;;810      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
;;;811      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
;;;812      */
;;;813    __STATIC_INLINE uint32_t LL_I2C_GetMode(I2C_TypeDef *I2Cx)
;;;814    {
;;;815      return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP));
;;;816    }
;;;817    
;;;818    /**
;;;819      * @brief  Enable SMBus alert (Host or Device mode)
;;;820      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;821      *         SMBus feature is supported by the I2Cx Instance.
;;;822      * @note   SMBus Device mode:
;;;823      *         - SMBus Alert pin is drived low and
;;;824      *           Alert Response Address Header acknowledge is enabled.
;;;825      *         SMBus Host mode:
;;;826      *         - SMBus Alert pin management is supported.
;;;827      * @rmtoll CR1          ALERT         LL_I2C_EnableSMBusAlert
;;;828      * @param  I2Cx I2C Instance.
;;;829      * @retval None
;;;830      */
;;;831    __STATIC_INLINE void LL_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx)
;;;832    {
;;;833      SET_BIT(I2Cx->CR1, I2C_CR1_ALERT);
;;;834    }
;;;835    
;;;836    /**
;;;837      * @brief  Disable SMBus alert (Host or Device mode)
;;;838      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;839      *         SMBus feature is supported by the I2Cx Instance.
;;;840      * @note   SMBus Device mode:
;;;841      *         - SMBus Alert pin is not drived (can be used as a standard GPIO) and
;;;842      *           Alert Response Address Header acknowledge is disabled.
;;;843      *         SMBus Host mode:
;;;844      *         - SMBus Alert pin management is not supported.
;;;845      * @rmtoll CR1          ALERT         LL_I2C_DisableSMBusAlert
;;;846      * @param  I2Cx I2C Instance.
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx)
;;;850    {
;;;851      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ALERT);
;;;852    }
;;;853    
;;;854    /**
;;;855      * @brief  Check if SMBus alert (Host or Device mode) is enabled or disabled.
;;;856      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;857      *         SMBus feature is supported by the I2Cx Instance.
;;;858      * @rmtoll CR1          ALERT         LL_I2C_IsEnabledSMBusAlert
;;;859      * @param  I2Cx I2C Instance.
;;;860      * @retval State of bit (1 or 0).
;;;861      */
;;;862    __STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx)
;;;863    {
;;;864      return (READ_BIT(I2Cx->CR1, I2C_CR1_ALERT) == (I2C_CR1_ALERT));
;;;865    }
;;;866    
;;;867    /**
;;;868      * @brief  Enable SMBus Packet Error Calculation (PEC).
;;;869      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;870      *         SMBus feature is supported by the I2Cx Instance.
;;;871      * @rmtoll CR1          ENPEC         LL_I2C_EnableSMBusPEC
;;;872      * @param  I2Cx I2C Instance.
;;;873      * @retval None
;;;874      */
;;;875    __STATIC_INLINE void LL_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx)
;;;876    {
;;;877      SET_BIT(I2Cx->CR1, I2C_CR1_ENPEC);
;;;878    }
;;;879    
;;;880    /**
;;;881      * @brief  Disable SMBus Packet Error Calculation (PEC).
;;;882      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;883      *         SMBus feature is supported by the I2Cx Instance.
;;;884      * @rmtoll CR1          ENPEC         LL_I2C_DisableSMBusPEC
;;;885      * @param  I2Cx I2C Instance.
;;;886      * @retval None
;;;887      */
;;;888    __STATIC_INLINE void LL_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx)
;;;889    {
;;;890      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENPEC);
;;;891    }
;;;892    
;;;893    /**
;;;894      * @brief  Check if SMBus Packet Error Calculation (PEC) is enabled or disabled.
;;;895      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;896      *         SMBus feature is supported by the I2Cx Instance.
;;;897      * @rmtoll CR1          ENPEC         LL_I2C_IsEnabledSMBusPEC
;;;898      * @param  I2Cx I2C Instance.
;;;899      * @retval State of bit (1 or 0).
;;;900      */
;;;901    __STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx)
;;;902    {
;;;903      return (READ_BIT(I2Cx->CR1, I2C_CR1_ENPEC) == (I2C_CR1_ENPEC));
;;;904    }
;;;905    
;;;906    /**
;;;907      * @}
;;;908      */
;;;909    
;;;910    /** @defgroup I2C_LL_EF_IT_Management IT_Management
;;;911      * @{
;;;912      */
;;;913    
;;;914    /**
;;;915      * @brief  Enable TXE interrupt.
;;;916      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_TX\n
;;;917      *         CR2          ITBUFEN       LL_I2C_EnableIT_TX
;;;918      * @param  I2Cx I2C Instance.
;;;919      * @retval None
;;;920      */
;;;921    __STATIC_INLINE void LL_I2C_EnableIT_TX(I2C_TypeDef *I2Cx)
;;;922    {
;;;923      SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;924    }
;;;925    
;;;926    /**
;;;927      * @brief  Disable TXE interrupt.
;;;928      * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_TX\n
;;;929      *         CR2          ITBUFEN       LL_I2C_DisableIT_TX
;;;930      * @param  I2Cx I2C Instance.
;;;931      * @retval None
;;;932      */
;;;933    __STATIC_INLINE void LL_I2C_DisableIT_TX(I2C_TypeDef *I2Cx)
;;;934    {
;;;935      CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;936    }
;;;937    
;;;938    /**
;;;939      * @brief  Check if the TXE Interrupt is enabled or disabled.
;;;940      * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_TX\n
;;;941      *         CR2          ITBUFEN       LL_I2C_IsEnabledIT_TX
;;;942      * @param  I2Cx I2C Instance.
;;;943      * @retval State of bit (1 or 0).
;;;944      */
;;;945    __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx)
;;;946    {
;;;947      return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN) == (I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN));
;;;948    }
;;;949    
;;;950    /**
;;;951      * @brief  Enable RXNE interrupt.
;;;952      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_RX\n
;;;953      *         CR2          ITBUFEN       LL_I2C_EnableIT_RX
;;;954      * @param  I2Cx I2C Instance.
;;;955      * @retval None
;;;956      */
;;;957    __STATIC_INLINE void LL_I2C_EnableIT_RX(I2C_TypeDef *I2Cx)
;;;958    {
;;;959      SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;960    }
;;;961    
;;;962    /**
;;;963      * @brief  Disable RXNE interrupt.
;;;964      * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_RX\n
;;;965      *         CR2          ITBUFEN       LL_I2C_DisableIT_RX
;;;966      * @param  I2Cx I2C Instance.
;;;967      * @retval None
;;;968      */
;;;969    __STATIC_INLINE void LL_I2C_DisableIT_RX(I2C_TypeDef *I2Cx)
;;;970    {
;;;971      CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;972    }
;;;973    
;;;974    /**
;;;975      * @brief  Check if the RXNE Interrupt is enabled or disabled.
;;;976      * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_RX\n
;;;977      *         CR2          ITBUFEN       LL_I2C_IsEnabledIT_RX
;;;978      * @param  I2Cx I2C Instance.
;;;979      * @retval State of bit (1 or 0).
;;;980      */
;;;981    __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx)
;;;982    {
;;;983      return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN) == (I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN));
;;;984    }
;;;985    
;;;986    /**
;;;987      * @brief  Enable Events interrupts.
;;;988      * @note   Any of these events will generate interrupt :
;;;989      *         Start Bit (SB)
;;;990      *         Address sent, Address matched (ADDR)
;;;991      *         10-bit header sent (ADD10)
;;;992      *         Stop detection  (STOPF)
;;;993      *         Byte transfer finished (BTF)
;;;994      *
;;;995      * @note   Any of these events will generate interrupt if Buffer interrupts are enabled too(using unitary function @ref LL_I2C_EnableIT_BUF()) :
;;;996      *         Receive buffer not empty (RXNE)
;;;997      *         Transmit buffer empty (TXE)
;;;998      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_EVT
;;;999      * @param  I2Cx I2C Instance.
;;;1000     * @retval None
;;;1001     */
;;;1002   __STATIC_INLINE void LL_I2C_EnableIT_EVT(I2C_TypeDef *I2Cx)
;;;1003   {
;;;1004     SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
;;;1005   }
;;;1006   
;;;1007   /**
;;;1008     * @brief  Disable Events interrupts.
;;;1009     * @note   Any of these events will generate interrupt :
;;;1010     *         Start Bit (SB)
;;;1011     *         Address sent, Address matched (ADDR)
;;;1012     *         10-bit header sent (ADD10)
;;;1013     *         Stop detection  (STOPF)
;;;1014     *         Byte transfer finished (BTF)
;;;1015     *         Receive buffer not empty (RXNE)
;;;1016     *         Transmit buffer empty (TXE)
;;;1017     * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_EVT
;;;1018     * @param  I2Cx I2C Instance.
;;;1019     * @retval None
;;;1020     */
;;;1021   __STATIC_INLINE void LL_I2C_DisableIT_EVT(I2C_TypeDef *I2Cx)
;;;1022   {
;;;1023     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
;;;1024   }
;;;1025   
;;;1026   /**
;;;1027     * @brief  Check if Events interrupts are enabled or disabled.
;;;1028     * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_EVT
;;;1029     * @param  I2Cx I2C Instance.
;;;1030     * @retval State of bit (1 or 0).
;;;1031     */
;;;1032   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_EVT(I2C_TypeDef *I2Cx)
;;;1033   {
;;;1034     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN) == (I2C_CR2_ITEVTEN));
;;;1035   }
;;;1036   
;;;1037   /**
;;;1038     * @brief  Enable Buffer interrupts.
;;;1039     * @note   Any of these Buffer events will generate interrupt if Events interrupts are enabled too(using unitary function @ref LL_I2C_EnableIT_EVT()) :
;;;1040     *         Receive buffer not empty (RXNE)
;;;1041     *         Transmit buffer empty (TXE)
;;;1042     * @rmtoll CR2          ITBUFEN       LL_I2C_EnableIT_BUF
;;;1043     * @param  I2Cx I2C Instance.
;;;1044     * @retval None
;;;1045     */
;;;1046   __STATIC_INLINE void LL_I2C_EnableIT_BUF(I2C_TypeDef *I2Cx)
;;;1047   {
;;;1048     SET_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN);
;;;1049   }
;;;1050   
;;;1051   /**
;;;1052     * @brief  Disable Buffer interrupts.
;;;1053     * @note   Any of these Buffer events will generate interrupt :
;;;1054     *         Receive buffer not empty (RXNE)
;;;1055     *         Transmit buffer empty (TXE)
;;;1056     * @rmtoll CR2          ITBUFEN       LL_I2C_DisableIT_BUF
;;;1057     * @param  I2Cx I2C Instance.
;;;1058     * @retval None
;;;1059     */
;;;1060   __STATIC_INLINE void LL_I2C_DisableIT_BUF(I2C_TypeDef *I2Cx)
;;;1061   {
;;;1062     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN);
;;;1063   }
;;;1064   
;;;1065   /**
;;;1066     * @brief  Check if Buffer interrupts are enabled or disabled.
;;;1067     * @rmtoll CR2          ITBUFEN       LL_I2C_IsEnabledIT_BUF
;;;1068     * @param  I2Cx I2C Instance.
;;;1069     * @retval State of bit (1 or 0).
;;;1070     */
;;;1071   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_BUF(I2C_TypeDef *I2Cx)
;;;1072   {
;;;1073     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN) == (I2C_CR2_ITBUFEN));
;;;1074   }
;;;1075   
;;;1076   /**
;;;1077     * @brief  Enable Error interrupts.
;;;1078     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1079     *         SMBus feature is supported by the I2Cx Instance.
;;;1080     * @note   Any of these errors will generate interrupt :
;;;1081     *         Bus Error detection (BERR)
;;;1082     *         Arbitration Loss (ARLO)
;;;1083     *         Acknowledge Failure(AF)
;;;1084     *         Overrun/Underrun (OVR)
;;;1085     *         SMBus Timeout detection (TIMEOUT)
;;;1086     *         SMBus PEC error detection (PECERR)
;;;1087     *         SMBus Alert pin event detection (SMBALERT)
;;;1088     * @rmtoll CR2          ITERREN       LL_I2C_EnableIT_ERR
;;;1089     * @param  I2Cx I2C Instance.
;;;1090     * @retval None
;;;1091     */
;;;1092   __STATIC_INLINE void LL_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx)
;;;1093   {
;;;1094     SET_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
;;;1095   }
;;;1096   
;;;1097   /**
;;;1098     * @brief  Disable Error interrupts.
;;;1099     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1100     *         SMBus feature is supported by the I2Cx Instance.
;;;1101     * @note   Any of these errors will generate interrupt :
;;;1102     *         Bus Error detection (BERR)
;;;1103     *         Arbitration Loss (ARLO)
;;;1104     *         Acknowledge Failure(AF)
;;;1105     *         Overrun/Underrun (OVR)
;;;1106     *         SMBus Timeout detection (TIMEOUT)
;;;1107     *         SMBus PEC error detection (PECERR)
;;;1108     *         SMBus Alert pin event detection (SMBALERT)
;;;1109     * @rmtoll CR2          ITERREN       LL_I2C_DisableIT_ERR
;;;1110     * @param  I2Cx I2C Instance.
;;;1111     * @retval None
;;;1112     */
;;;1113   __STATIC_INLINE void LL_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx)
;;;1114   {
;;;1115     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
;;;1116   }
;;;1117   
;;;1118   /**
;;;1119     * @brief  Check if Error interrupts are enabled or disabled.
;;;1120     * @rmtoll CR2          ITERREN       LL_I2C_IsEnabledIT_ERR
;;;1121     * @param  I2Cx I2C Instance.
;;;1122     * @retval State of bit (1 or 0).
;;;1123     */
;;;1124   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx)
;;;1125   {
;;;1126     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITERREN) == (I2C_CR2_ITERREN));
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @}
;;;1131     */
;;;1132   
;;;1133   /** @defgroup I2C_LL_EF_FLAG_management FLAG_management
;;;1134     * @{
;;;1135     */
;;;1136   
;;;1137   /**
;;;1138     * @brief  Indicate the status of Transmit data register empty flag.
;;;1139     * @note   RESET: When next data is written in Transmit data register.
;;;1140     *         SET: When Transmit data register is empty.
;;;1141     * @rmtoll SR1          TXE           LL_I2C_IsActiveFlag_TXE
;;;1142     * @param  I2Cx I2C Instance.
;;;1143     * @retval State of bit (1 or 0).
;;;1144     */
;;;1145   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx)
;;;1146   {
;;;1147     return (READ_BIT(I2Cx->SR1, I2C_SR1_TXE) == (I2C_SR1_TXE));
;;;1148   }
;;;1149   
;;;1150   /**
;;;1151     * @brief  Indicate the status of Byte Transfer Finished flag.
;;;1152     *         RESET: When Data byte transfer not done.
;;;1153     *         SET: When Data byte transfer succeeded.
;;;1154     * @rmtoll SR1          BTF           LL_I2C_IsActiveFlag_BTF
;;;1155     * @param  I2Cx I2C Instance.
;;;1156     * @retval State of bit (1 or 0).
;;;1157     */
;;;1158   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BTF(I2C_TypeDef *I2Cx)
;;;1159   {
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
;;;1161   }
;;;1162   
;;;1163   /**
;;;1164     * @brief  Indicate the status of Receive data register not empty flag.
;;;1165     * @note   RESET: When Receive data register is read.
;;;1166     *         SET: When the received data is copied in Receive data register.
;;;1167     * @rmtoll SR1          RXNE          LL_I2C_IsActiveFlag_RXNE
;;;1168     * @param  I2Cx I2C Instance.
;;;1169     * @retval State of bit (1 or 0).
;;;1170     */
;;;1171   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx)
;;;1172   {
;;;1173     return (READ_BIT(I2Cx->SR1, I2C_SR1_RXNE) == (I2C_SR1_RXNE));
;;;1174   }
;;;1175   
;;;1176   /**
;;;1177     * @brief  Indicate the status of Start Bit (master mode).
;;;1178     * @note   RESET: When No Start condition.
;;;1179     *         SET: When Start condition is generated.
;;;1180     * @rmtoll SR1          SB            LL_I2C_IsActiveFlag_SB
;;;1181     * @param  I2Cx I2C Instance.
;;;1182     * @retval State of bit (1 or 0).
;;;1183     */
;;;1184   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_SB(I2C_TypeDef *I2Cx)
;;;1185   {
;;;1186     return (READ_BIT(I2Cx->SR1, I2C_SR1_SB) == (I2C_SR1_SB));
;;;1187   }
;;;1188   
;;;1189   /**
;;;1190     * @brief  Indicate the status of Address sent (master mode) or Address matched flag (slave mode).
;;;1191     * @note   RESET: Clear default value.
;;;1192     *         SET: When the address is fully sent (master mode) or when the received slave address matched with one of the enabled slave address (slave mode).
;;;1193     * @rmtoll SR1          ADDR          LL_I2C_IsActiveFlag_ADDR
;;;1194     * @param  I2Cx I2C Instance.
;;;1195     * @retval State of bit (1 or 0).
;;;1196     */
;;;1197   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx)
;;;1198   {
;;;1199     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADDR) == (I2C_SR1_ADDR));
;;;1200   }
;;;1201   
;;;1202   /**
;;;1203     * @brief  Indicate the status of 10-bit header sent (master mode).
;;;1204     * @note   RESET: When no ADD10 event occured.
;;;1205     *         SET: When the master has sent the first address byte (header).
;;;1206     * @rmtoll SR1          ADD10         LL_I2C_IsActiveFlag_ADD10
;;;1207     * @param  I2Cx I2C Instance.
;;;1208     * @retval State of bit (1 or 0).
;;;1209     */
;;;1210   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADD10(I2C_TypeDef *I2Cx)
;;;1211   {
;;;1212     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADD10) == (I2C_SR1_ADD10));
;;;1213   }
;;;1214   
;;;1215   /**
;;;1216     * @brief  Indicate the status of Acknowledge failure flag.
;;;1217     * @note   RESET: No acknowledge failure.
;;;1218     *         SET: When an acknowledge failure is received after a byte transmission.
;;;1219     * @rmtoll SR1          AF            LL_I2C_IsActiveFlag_AF
;;;1220     * @param  I2Cx I2C Instance.
;;;1221     * @retval State of bit (1 or 0).
;;;1222     */
;;;1223   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_AF(I2C_TypeDef *I2Cx)
;;;1224   {
;;;1225     return (READ_BIT(I2Cx->SR1, I2C_SR1_AF) == (I2C_SR1_AF));
;;;1226   }
;;;1227   
;;;1228   /**
;;;1229     * @brief  Indicate the status of Stop detection flag (slave mode).
;;;1230     * @note   RESET: Clear default value.
;;;1231     *         SET: When a Stop condition is detected.
;;;1232     * @rmtoll SR1          STOPF         LL_I2C_IsActiveFlag_STOP
;;;1233     * @param  I2Cx I2C Instance.
;;;1234     * @retval State of bit (1 or 0).
;;;1235     */
;;;1236   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx)
;;;1237   {
;;;1238     return (READ_BIT(I2Cx->SR1, I2C_SR1_STOPF) == (I2C_SR1_STOPF));
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Indicate the status of Bus error flag.
;;;1243     * @note   RESET: Clear default value.
;;;1244     *         SET: When a misplaced Start or Stop condition is detected.
;;;1245     * @rmtoll SR1          BERR          LL_I2C_IsActiveFlag_BERR
;;;1246     * @param  I2Cx I2C Instance.
;;;1247     * @retval State of bit (1 or 0).
;;;1248     */
;;;1249   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx)
;;;1250   {
;;;1251     return (READ_BIT(I2Cx->SR1, I2C_SR1_BERR) == (I2C_SR1_BERR));
;;;1252   }
;;;1253   
;;;1254   /**
;;;1255     * @brief  Indicate the status of Arbitration lost flag.
;;;1256     * @note   RESET: Clear default value.
;;;1257     *         SET: When arbitration lost.
;;;1258     * @rmtoll SR1          ARLO          LL_I2C_IsActiveFlag_ARLO
;;;1259     * @param  I2Cx I2C Instance.
;;;1260     * @retval State of bit (1 or 0).
;;;1261     */
;;;1262   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx)
;;;1263   {
;;;1264     return (READ_BIT(I2Cx->SR1, I2C_SR1_ARLO) == (I2C_SR1_ARLO));
;;;1265   }
;;;1266   
;;;1267   /**
;;;1268     * @brief  Indicate the status of Overrun/Underrun flag.
;;;1269     * @note   RESET: Clear default value.
;;;1270     *         SET: When an overrun/underrun error occurs (Clock Stretching Disabled).
;;;1271     * @rmtoll SR1          OVR           LL_I2C_IsActiveFlag_OVR
;;;1272     * @param  I2Cx I2C Instance.
;;;1273     * @retval State of bit (1 or 0).
;;;1274     */
;;;1275   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx)
;;;1276   {
;;;1277     return (READ_BIT(I2Cx->SR1, I2C_SR1_OVR) == (I2C_SR1_OVR));
;;;1278   }
;;;1279   
;;;1280   /**
;;;1281     * @brief  Indicate the status of SMBus PEC error flag in reception.
;;;1282     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1283     *         SMBus feature is supported by the I2Cx Instance.
;;;1284     * @rmtoll SR1          PECERR        LL_I2C_IsActiveSMBusFlag_PECERR
;;;1285     * @param  I2Cx I2C Instance.
;;;1286     * @retval State of bit (1 or 0).
;;;1287     */
;;;1288   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
;;;1289   {
;;;1290     return (READ_BIT(I2Cx->SR1, I2C_SR1_PECERR) == (I2C_SR1_PECERR));
;;;1291   }
;;;1292   
;;;1293   /**
;;;1294     * @brief  Indicate the status of SMBus Timeout detection flag.
;;;1295     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1296     *         SMBus feature is supported by the I2Cx Instance.
;;;1297     * @rmtoll SR1          TIMEOUT       LL_I2C_IsActiveSMBusFlag_TIMEOUT
;;;1298     * @param  I2Cx I2C Instance.
;;;1299     * @retval State of bit (1 or 0).
;;;1300     */
;;;1301   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
;;;1302   {
;;;1303     return (READ_BIT(I2Cx->SR1, I2C_SR1_TIMEOUT) == (I2C_SR1_TIMEOUT));
;;;1304   }
;;;1305   
;;;1306   /**
;;;1307     * @brief  Indicate the status of SMBus alert flag.
;;;1308     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1309     *         SMBus feature is supported by the I2Cx Instance.
;;;1310     * @rmtoll SR1          SMBALERT      LL_I2C_IsActiveSMBusFlag_ALERT
;;;1311     * @param  I2Cx I2C Instance.
;;;1312     * @retval State of bit (1 or 0).
;;;1313     */
;;;1314   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
;;;1315   {
;;;1316     return (READ_BIT(I2Cx->SR1, I2C_SR1_SMBALERT) == (I2C_SR1_SMBALERT));
;;;1317   }
;;;1318   
;;;1319   /**
;;;1320     * @brief  Indicate the status of Bus Busy flag.
;;;1321     * @note   RESET: Clear default value.
;;;1322     *         SET: When a Start condition is detected.
;;;1323     * @rmtoll SR2          BUSY          LL_I2C_IsActiveFlag_BUSY
;;;1324     * @param  I2Cx I2C Instance.
;;;1325     * @retval State of bit (1 or 0).
;;;1326     */
;;;1327   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx)
;;;1328   {
;;;1329     return (READ_BIT(I2Cx->SR2, I2C_SR2_BUSY) == (I2C_SR2_BUSY));
;;;1330   }
;;;1331   
;;;1332   /**
;;;1333     * @brief  Indicate the status of Dual flag.
;;;1334     * @note   RESET: Received address matched with OAR1.
;;;1335     *         SET: Received address matched with OAR2.
;;;1336     * @rmtoll SR2          DUALF         LL_I2C_IsActiveFlag_DUAL
;;;1337     * @param  I2Cx I2C Instance.
;;;1338     * @retval State of bit (1 or 0).
;;;1339     */
;;;1340   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_DUAL(I2C_TypeDef *I2Cx)
;;;1341   {
;;;1342     return (READ_BIT(I2Cx->SR2, I2C_SR2_DUALF) == (I2C_SR2_DUALF));
;;;1343   }
;;;1344   
;;;1345   /**
;;;1346     * @brief  Indicate the status of SMBus Host address reception (Slave mode).
;;;1347     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1348     *         SMBus feature is supported by the I2Cx Instance.
;;;1349     * @note   RESET: No SMBus Host address
;;;1350     *         SET: SMBus Host address received.
;;;1351     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1352     * @rmtoll SR2          SMBHOST       LL_I2C_IsActiveSMBusFlag_SMBHOST
;;;1353     * @param  I2Cx I2C Instance.
;;;1354     * @retval State of bit (1 or 0).
;;;1355     */
;;;1356   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_SMBHOST(I2C_TypeDef *I2Cx)
;;;1357   {
;;;1358     return (READ_BIT(I2Cx->SR2, I2C_SR2_SMBHOST) == (I2C_SR2_SMBHOST));
;;;1359   }
;;;1360   
;;;1361   /**
;;;1362     * @brief  Indicate the status of SMBus Device default address reception (Slave mode).
;;;1363     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1364     *         SMBus feature is supported by the I2Cx Instance.
;;;1365     * @note   RESET: No SMBus Device default address
;;;1366     *         SET: SMBus Device default address received.
;;;1367     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1368     * @rmtoll SR2          SMBDEFAULT    LL_I2C_IsActiveSMBusFlag_SMBDEFAULT
;;;1369     * @param  I2Cx I2C Instance.
;;;1370     * @retval State of bit (1 or 0).
;;;1371     */
;;;1372   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_SMBDEFAULT(I2C_TypeDef *I2Cx)
;;;1373   {
;;;1374     return (READ_BIT(I2Cx->SR2, I2C_SR2_SMBDEFAULT) == (I2C_SR2_SMBDEFAULT));
;;;1375   }
;;;1376   
;;;1377   /**
;;;1378     * @brief  Indicate the status of General call address reception (Slave mode).
;;;1379     * @note   RESET: No Generall call address
;;;1380     *         SET: General call address received.
;;;1381     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1382     * @rmtoll SR2          GENCALL       LL_I2C_IsActiveFlag_GENCALL
;;;1383     * @param  I2Cx I2C Instance.
;;;1384     * @retval State of bit (1 or 0).
;;;1385     */
;;;1386   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_GENCALL(I2C_TypeDef *I2Cx)
;;;1387   {
;;;1388     return (READ_BIT(I2Cx->SR2, I2C_SR2_GENCALL) == (I2C_SR2_GENCALL));
;;;1389   }
;;;1390   
;;;1391   /**
;;;1392     * @brief  Indicate the status of Master/Slave flag.
;;;1393     * @note   RESET: Slave Mode.
;;;1394     *         SET: Master Mode.
;;;1395     * @rmtoll SR2          MSL           LL_I2C_IsActiveFlag_MSL
;;;1396     * @param  I2Cx I2C Instance.
;;;1397     * @retval State of bit (1 or 0).
;;;1398     */
;;;1399   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_MSL(I2C_TypeDef *I2Cx)
;;;1400   {
;;;1401     return (READ_BIT(I2Cx->SR2, I2C_SR2_MSL) == (I2C_SR2_MSL));
;;;1402   }
;;;1403   
;;;1404   /**
;;;1405     * @brief  Clear Address Matched flag.
;;;1406     * @note   Clearing this flag is done by a read access to the I2Cx_SR1
;;;1407     *         register followed by a read access to the I2Cx_SR2 register.
;;;1408     * @rmtoll SR1          ADDR          LL_I2C_ClearFlag_ADDR
;;;1409     * @param  I2Cx I2C Instance.
;;;1410     * @retval None
;;;1411     */
;;;1412   __STATIC_INLINE void LL_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx)
;;;1413   {
;;;1414     __IO uint32_t tmpreg;
;;;1415     tmpreg = I2Cx->SR1;
        0x080002e2:    6941        Ai      LDR      r1,[r0,#0x14]
        0x080002e4:    9100        ..      STR      r1,[sp,#0]
;;;1416     (void) tmpreg;
;;;1417     tmpreg = I2Cx->SR2;
        0x080002e6:    6980        .i      LDR      r0,[r0,#0x18]
        0x080002e8:    9000        ..      STR      r0,[sp,#0]
;;; .\../Src/stm32f1xx_it.c
;;;360    }
        0x080002ea:    bd08        ..      POP      {r3,pc}
    $d
        0x080002ec:    40005800    .X.@    DCD    1073764352
    $t
    i.LL_APB2_GRP1_EnableClock
    LL_APB2_GRP1_EnableClock
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;780    {
        0x080002f0:    b508        ..      PUSH     {r3,lr}
;;;781      __IO uint32_t tmpreg;
;;;782      SET_BIT(RCC->APB2ENR, Periphs);
        0x080002f2:    4904        .I      LDR      r1,[pc,#16] ; [0x8000304] = 0x40021000
        0x080002f4:    698a        .i      LDR      r2,[r1,#0x18]
        0x080002f6:    4302        .C      ORRS     r2,r2,r0
        0x080002f8:    618a        .a      STR      r2,[r1,#0x18]
;;;783      /* Delay after an RCC peripheral clock enabling */
;;;784      tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
        0x080002fa:    6989        .i      LDR      r1,[r1,#0x18]
        0x080002fc:    4001        .@      ANDS     r1,r1,r0
        0x080002fe:    9100        ..      STR      r1,[sp,#0]
;;;785      (void)tmpreg;
;;;786    }
        0x08000300:    bd08        ..      POP      {r3,pc}
    $d
        0x08000302:    0000        ..      DCW    0
        0x08000304:    40021000    ...@    DCD    1073876992
    $t
    i.LL_GPIO_Init
    LL_GPIO_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;172    {
        0x08000308:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0800030c:    680a        .h      LDR      r2,[r1,#0]
        0x0800030e:    f3c2250f    ...%    UBFX     r5,r2,#8,#16
        0x08000312:    fa95f2a5    ....    RBIT     r2,r5
        0x08000316:    fab2f282    ....    CLZ      r2,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c (172)
        0x0800031a:    e06b        k.      B        0x80003f4 ; LL_GPIO_Init + 236
;;;173      uint32_t pinmask;
;;;174      uint32_t pinpos;
;;;175      uint32_t currentpin;
;;;176    
;;;177      /* Check the parameters */
;;;178      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;179      assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));
;;;180    
;;;181      /* ------------------------- Configure the port pins ---------------- */
;;;182      /* Initialize  pinpos on first pin set */
;;;183    
;;;184      pinmask = ((GPIO_InitStruct->Pin) << GPIO_PIN_MASK_POS) >> GPIO_PIN_NB;
;;;185      pinpos = POSITION_VAL(pinmask);
;;;186    
;;;187      /* Configure the port pins */
;;;188      while ((pinmask  >> pinpos) != 0U)
;;;189      {
;;;190        /* skip if bit is not set */
;;;191        if ((pinmask & (1U << pinpos)) != 0U)
        0x0800031c:    2301        .#      MOVS     r3,#1
        0x0800031e:    4093        .@      LSLS     r3,r3,r2
        0x08000320:    422b        +B      TST      r3,r5
        0x08000322:    d066        f.      BEQ      0x80003f2 ; LL_GPIO_Init + 234
;;;192        {
;;;193          /* Get current io position */
;;;194          if (pinpos < GPIO_PIN_MASK_POS)
        0x08000324:    2a08        .*      CMP      r2,#8
        0x08000326:    d203        ..      BCS      0x8000330 ; LL_GPIO_Init + 40
;;;195          {
;;;196            currentpin = (0x00000101U << pinpos);
        0x08000328:    f2401301    @...    MOV      r3,#0x101
        0x0800032c:    4093        .@      LSLS     r3,r3,r2
        0x0800032e:    e006        ..      B        0x800033e ; LL_GPIO_Init + 54
;;;197          }
;;;198          else
;;;199          {
;;;200            currentpin = ((0x00010001U << (pinpos - GPIO_PIN_MASK_POS)) | 0x04000000U);
        0x08000330:    f1a20308    ....    SUB      r3,r2,#8
        0x08000334:    f04f1401    O...    MOV      r4,#0x10001
        0x08000338:    409c        .@      LSLS     r4,r4,r3
        0x0800033a:    f0446380    D..c    ORR      r3,r4,#0x4000000
;;;201          }
;;;202    
;;;203          /* Check Pin Mode and Pin Pull parameters */
;;;204          assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
;;;205          assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));
;;;206    
;;;207          /* Pin Mode configuration */
;;;208          LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
        0x0800033e:    684e        Nh      LDR      r6,[r1,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;360      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000340:    eb006413    ...d    ADD      r4,r0,r3,LSR #24
;;;361      MODIFY_REG(*pReg, ((GPIO_CRL_CNF0 | GPIO_CRL_MODE0) << (POSITION_VAL(Pin) * 4U)), (Mode << (POSITION_VAL(Pin) * 4U)));
        0x08000344:    fa93fca3    ....    RBIT     r12,r3
        0x08000348:    fabcfc8c    ....    CLZ      r12,r12
        0x0800034c:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000350:    f04f0c0f    O...    MOV      r12,#0xf
        0x08000354:    6827        'h      LDR      r7,[r4,#0]
        0x08000356:    fa0cfc08    ....    LSL      r12,r12,r8
        0x0800035a:    ea27070c    '...    BIC      r7,r7,r12
        0x0800035e:    fa93fca3    ....    RBIT     r12,r3
        0x08000362:    fabcfc8c    ....    CLZ      r12,r12
        0x08000366:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x0800036a:    fa06f60c    ....    LSL      r6,r6,r12
        0x0800036e:    4337        7C      ORRS     r7,r7,r6
        0x08000370:    6027        '`      STR      r7,[r4,#0]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;211          LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
        0x08000372:    690e        .i      LDR      r6,[r1,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;583      MODIFY_REG(GPIOx->ODR, (Pin >> GPIO_PIN_MASK_POS), Pull << (POSITION_VAL(Pin >> GPIO_PIN_MASK_POS)));
        0x08000374:    68c7        .h      LDR      r7,[r0,#0xc]
        0x08000376:    ea4f2c13    O..,    LSR      r12,r3,#8
        0x0800037a:    fa9cfcac    ....    RBIT     r12,r12
        0x0800037e:    fabcfc8c    ....    CLZ      r12,r12
        0x08000382:    ea272713    '..'    BIC      r7,r7,r3,LSR #8
        0x08000386:    fa06f60c    ....    LSL      r6,r6,r12
        0x0800038a:    4337        7C      ORRS     r7,r7,r6
        0x0800038c:    60c7        .`      STR      r7,[r0,#0xc]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;213          if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
        0x0800038e:    684e        Nh      LDR      r6,[r1,#4]
        0x08000390:    2e01        ..      CMP      r6,#1
        0x08000392:    d001        ..      BEQ      0x8000398 ; LL_GPIO_Init + 144
        0x08000394:    2e09        ..      CMP      r6,#9
        0x08000396:    d12c        ,.      BNE      0x80003f2 ; LL_GPIO_Init + 234
;;;214          {
;;;215            /* Check speed and Output mode parameters */
;;;216            assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
;;;217            assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
;;;218    
;;;219            /* Speed mode configuration */
;;;220            LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
        0x08000398:    688f        .h      LDR      r7,[r1,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;439      MODIFY_REG(*pReg, (GPIO_CRL_MODE0 << (POSITION_VAL(Pin) * 4U)),
        0x0800039a:    fa93fca3    ....    RBIT     r12,r3
        0x0800039e:    fabcfc8c    ....    CLZ      r12,r12
        0x080003a2:    ea4f088c    O...    LSL      r8,r12,#2
        0x080003a6:    f04f0c03    O...    MOV      r12,#3
        0x080003aa:    6826        &h      LDR      r6,[r4,#0]
        0x080003ac:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080003b0:    ea26060c    &...    BIC      r6,r6,r12
        0x080003b4:    fa93fca3    ....    RBIT     r12,r3
        0x080003b8:    fabcfc8c    ....    CLZ      r12,r12
        0x080003bc:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x080003c0:    fa07f70c    ....    LSL      r7,r7,r12
        0x080003c4:    433e        >C      ORRS     r6,r6,r7
        0x080003c6:    6026        &`      STR      r6,[r4,#0]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;223            LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
        0x080003c8:    68cf        .h      LDR      r7,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;513      MODIFY_REG(*pReg, (GPIO_CRL_CNF0_0 << (POSITION_VAL(Pin) * 4U)),
        0x080003ca:    fa93fca3    ....    RBIT     r12,r3
        0x080003ce:    fabcfc8c    ....    CLZ      r12,r12
        0x080003d2:    ea4f088c    O...    LSL      r8,r12,#2
        0x080003d6:    f04f0c04    O...    MOV      r12,#4
        0x080003da:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080003de:    fa93f3a3    ....    RBIT     r3,r3
        0x080003e2:    fab3f383    ....    CLZ      r3,r3
        0x080003e6:    009b        ..      LSLS     r3,r3,#2
        0x080003e8:    ea26060c    &...    BIC      r6,r6,r12
        0x080003ec:    409f        .@      LSLS     r7,r7,r3
        0x080003ee:    433e        >C      ORRS     r6,r6,r7
        0x080003f0:    6026        &`      STR      r6,[r4,#0]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;226        pinpos++;
        0x080003f2:    1c52        R.      ADDS     r2,r2,#1
        0x080003f4:    fa35f302    5...    LSRS     r3,r5,r2
        0x080003f8:    d190        ..      BNE      0x800031c ; LL_GPIO_Init + 20
;;;227      }
;;;228      return (SUCCESS);
        0x080003fa:    2001        .       MOVS     r0,#1
;;;229    }
        0x080003fc:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_Init1msTick
    LL_Init1msTick
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;187      LL_InitTick(HCLKFrequency, 1000U);
        0x08000400:    f44f717a    O.zq    MOV      r1,#0x3e8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_utils.h
;;;237      SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
        0x08000404:    fbb0f1f1    ....    UDIV     r1,r0,r1
        0x08000408:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x0800040c:    1e49        I.      SUBS     r1,r1,#1
        0x0800040e:    6141        Aa      STR      r1,[r0,#0x14]
;;;238      SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
        0x08000410:    2100        .!      MOVS     r1,#0
        0x08000412:    6181        .a      STR      r1,[r0,#0x18]
;;;239      SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
        0x08000414:    2105        .!      MOVS     r1,#5
        0x08000416:    6101        .a      STR      r1,[r0,#0x10]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;188    }
        0x08000418:    4770        pG      BX       lr
        0x0800041a:    0000        ..      MOVS     r0,r0
    i.LL_SetSystemCoreClock
    LL_SetSystemCoreClock
;;;189    
;;;190    /**
;;;191      * @brief  This function provides accurate delay (in milliseconds) based
;;;192      *         on SysTick counter flag
;;;193      * @note   When a RTOS is used, it is recommended to avoid using blocking delay
;;;194      *         and use rather osDelay service.
;;;195      * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which
;;;196      *         will configure Systick to 1ms
;;;197      * @param  Delay specifies the delay time length, in milliseconds.
;;;198      * @retval None
;;;199      */
;;;200    void LL_mDelay(uint32_t Delay)
;;;201    {
;;;202      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
;;;203      /* Add this code to indicate that local variable is not used */
;;;204      ((void)tmp);
;;;205    
;;;206      /* Add a period to guaranty minimum wait */
;;;207      if (Delay < LL_MAX_DELAY)
;;;208      {
;;;209        Delay++;
;;;210      }
;;;211    
;;;212      while (Delay)
;;;213      {
;;;214        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
;;;215        {
;;;216          Delay--;
;;;217        }
;;;218      }
;;;219    }
;;;220    
;;;221    /**
;;;222      * @}
;;;223      */
;;;224    
;;;225    /** @addtogroup UTILS_EF_SYSTEM
;;;226      *  @brief    System Configuration functions
;;;227      *
;;;228      @verbatim
;;;229     ===============================================================================
;;;230               ##### System Configuration functions #####
;;;231     ===============================================================================
;;;232        [..]
;;;233             System, AHB and APB buses clocks configuration
;;;234    
;;;235             (+) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is RCC_MAX_FREQUENCY Hz.
;;;236      @endverbatim
;;;237      @internal
;;;238                 Depending on the SYSCLK frequency, the flash latency should be adapted accordingly:
;;;239                 (++) +-----------------------------------------------+
;;;240                 (++) | Latency       | SYSCLK clock frequency (MHz)  |
;;;241                 (++) |---------------|-------------------------------|
;;;242                 (++) |0WS(1CPU cycle)|       0 < SYSCLK <= 24        |
;;;243                 (++) |---------------|-------------------------------|
;;;244                 (++) |1WS(2CPU cycle)|      24 < SYSCLK <= 48        |
;;;245                 (++) |---------------|-------------------------------|
;;;246                 (++) |2WS(3CPU cycle)|      48 < SYSCLK <= 72        |
;;;247                 (++) +-----------------------------------------------+
;;;248      @endinternal
;;;249      * @{
;;;250      */
;;;251    
;;;252    /**
;;;253      * @brief  This function sets directly SystemCoreClock CMSIS variable.
;;;254      * @note   Variable can be calculated also through SystemCoreClockUpdate function.
;;;255      * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)
;;;256      * @retval None
;;;257      */
;;;258    void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
;;;259    {
;;;260      /* HCLK clock frequency */
;;;261      SystemCoreClock = HCLKFrequency;
        0x0800041c:    4901        .I      LDR      r1,[pc,#4] ; [0x8000424] = 0x20000000
        0x0800041e:    6008        .`      STR      r0,[r1,#0]
;;;262    }
        0x08000420:    4770        pG      BX       lr
    $d
        0x08000422:    0000        ..      DCW    0
        0x08000424:    20000000    ...     DCD    536870912
    $t
    i.MX_GPIO_Init
    MX_GPIO_Init
;;; .\../Src/main.c
;;;1027   {
        0x08000428:    e92d4ff0    -..O    PUSH     {r4-r11,lr}
        0x0800042c:    b085        ..      SUB      sp,sp,#0x14
;;;1028     LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x0800042e:    2114        .!      MOVS     r1,#0x14
        0x08000430:    4668        hF      MOV      r0,sp
        0x08000432:    f7fffe90    ....    BL       __aeabi_memclr ; 0x8000156
;;;1029   
;;;1030     /* GPIO Ports Clock Enable */
;;;1031     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOC);
        0x08000436:    2010        .       MOVS     r0,#0x10
        0x08000438:    f7ffff5a    ..Z.    BL       LL_APB2_GRP1_EnableClock ; 0x80002f0
;;;1032     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOD);
        0x0800043c:    2020                MOVS     r0,#0x20
        0x0800043e:    f7ffff57    ..W.    BL       LL_APB2_GRP1_EnableClock ; 0x80002f0
;;;1033     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08000442:    2004        .       MOVS     r0,#4
        0x08000444:    f7ffff54    ..T.    BL       LL_APB2_GRP1_EnableClock ; 0x80002f0
;;;1034     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x08000448:    2008        .       MOVS     r0,#8
        0x0800044a:    f7ffff51    ..Q.    BL       LL_APB2_GRP1_EnableClock ; 0x80002f0
;;;1035   
;;;1036     /**/
;;;1037     LL_GPIO_ResetOutputPin(GPIOC, LED_Pin|MOTOR_X_DIR_Pin);
        0x0800044e:    4828        (H      LDR      r0,[pc,#160] ; [0x80004f0] = 0x4a000a0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x08000450:    4f28        (O      LDR      r7,[pc,#160] ; [0x80004f4] = 0x40011000
        0x08000452:    f44f4120    O. A    MOV      r1,#0xa000
        0x08000456:    6179        ya      STR      r1,[r7,#0x14]
;;; .\../Src/main.c
;;;1040     LL_GPIO_ResetOutputPin(GPIOA, MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin);
        0x08000458:    f2482a82    H..*    MOV      r10,#0x8282
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x0800045c:    f8df8098    ....    LDR      r8,[pc,#152] ; [0x80004f8] = 0x40010800
        0x08000460:    2182        .!      MOVS     r1,#0x82
        0x08000462:    f8c81014    ....    STR      r1,[r8,#0x14]
;;; .\../Src/main.c
;;;1043     LL_GPIO_ResetOutputPin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
        0x08000466:    f2402b02    @..+    MOV      r11,#0x202
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x0800046a:    f8df9090    ....    LDR      r9,[pc,#144] ; [0x80004fc] = 0x40010c00
        0x0800046e:    2502        .%      MOVS     r5,#2
        0x08000470:    f8c95014    ...P    STR      r5,[r9,#0x14]
;;; .\../Src/main.c
;;;1046     GPIO_InitStruct.Pin = LED_Pin|MOTOR_X_DIR_Pin;
        0x08000474:    9000        ..      STR      r0,[sp,#0]
;;;1047     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000476:    2601        .&      MOVS     r6,#1
        0x08000478:    9601        ..      STR      r6,[sp,#4]
;;;1048     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x0800047a:    9502        ..      STR      r5,[sp,#8]
;;;1049     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x0800047c:    2400        .$      MOVS     r4,#0
        0x0800047e:    9403        ..      STR      r4,[sp,#0xc]
;;;1050     LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x08000480:    4669        iF      MOV      r1,sp
        0x08000482:    4638        8F      MOV      r0,r7
        0x08000484:    f7ffff40    ..@.    BL       LL_GPIO_Init ; 0x8000308
;;;1051   
;;;1052     /**/
;;;1053     GPIO_InitStruct.Pin = LL_GPIO_PIN_14;
        0x08000488:    481d        .H      LDR      r0,[pc,#116] ; [0x8000500] = 0x4400040
        0x0800048a:    9000        ..      STR      r0,[sp,#0]
;;;1054     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x0800048c:    9401        ..      STR      r4,[sp,#4]
;;;1055     LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x0800048e:    4669        iF      MOV      r1,sp
        0x08000490:    4638        8F      MOV      r0,r7
        0x08000492:    f7ffff39    ..9.    BL       LL_GPIO_Init ; 0x8000308
;;;1056   
;;;1057     /**/
;;;1058     GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_10 
        0x08000496:    481b        .H      LDR      r0,[pc,#108] ; [0x8000504] = 0x49c31bd
        0x08000498:    9000        ..      STR      r0,[sp,#0]
;;;1059                             |LL_GPIO_PIN_11|LL_GPIO_PIN_12|LL_GPIO_PIN_15;
;;;1060     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x0800049a:    9401        ..      STR      r4,[sp,#4]
;;;1061     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x0800049c:    4669        iF      MOV      r1,sp
        0x0800049e:    4640        @F      MOV      r0,r8
        0x080004a0:    f7ffff32    ..2.    BL       LL_GPIO_Init ; 0x8000308
;;;1062   
;;;1063     /**/
;;;1064     GPIO_InitStruct.Pin = MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin;
        0x080004a4:    f8cda000    ....    STR      r10,[sp,#0]
;;;1065     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x080004a8:    9601        ..      STR      r6,[sp,#4]
;;;1066     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x080004aa:    9502        ..      STR      r5,[sp,#8]
;;;1067     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080004ac:    9403        ..      STR      r4,[sp,#0xc]
;;;1068     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x080004ae:    4669        iF      MOV      r1,sp
        0x080004b0:    4640        @F      MOV      r0,r8
        0x080004b2:    f7ffff29    ..).    BL       LL_GPIO_Init ; 0x8000308
;;;1069   
;;;1070     /**/
;;;1071     GPIO_InitStruct.Pin = MOTOR_Z_ENABLE_Pin;
        0x080004b6:    f8cdb000    ....    STR      r11,[sp,#0]
;;;1072     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x080004ba:    9601        ..      STR      r6,[sp,#4]
;;;1073     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x080004bc:    9502        ..      STR      r5,[sp,#8]
;;;1074     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080004be:    9403        ..      STR      r4,[sp,#0xc]
;;;1075     LL_GPIO_Init(MOTOR_Z_ENABLE_GPIO_Port, &GPIO_InitStruct);
        0x080004c0:    4669        iF      MOV      r1,sp
        0x080004c2:    4648        HF      MOV      r0,r9
        0x080004c4:    f7ffff20    .. .    BL       LL_GPIO_Init ; 0x8000308
;;;1076   
;;;1077     /**/
;;;1078     GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14 
        0x080004c8:    480f        .H      LDR      r0,[pc,#60] ; [0x8000508] = 0x4f23cfe
        0x080004ca:    9000        ..      STR      r0,[sp,#0]
;;;1079                             |LL_GPIO_PIN_15|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5 
;;;1080                             |LL_GPIO_PIN_9;
;;;1081     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x080004cc:    9401        ..      STR      r4,[sp,#4]
;;;1082     LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x080004ce:    4669        iF      MOV      r1,sp
        0x080004d0:    4648        HF      MOV      r0,r9
        0x080004d2:    f7ffff19    ....    BL       LL_GPIO_Init ; 0x8000308
;;;1083   
;;;1084     /**/
;;;1085     GPIO_InitStruct.Pin = BUTTON_1_Pin|BUTTON_2_Pin;
        0x080004d6:    480d        .H      LDR      r0,[pc,#52] ; [0x800050c] = 0x4030003
        0x080004d8:    9000        ..      STR      r0,[sp,#0]
;;;1086     GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x080004da:    2008        .       MOVS     r0,#8
        0x080004dc:    9001        ..      STR      r0,[sp,#4]
;;;1087     GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x080004de:    9604        ..      STR      r6,[sp,#0x10]
;;;1088     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x080004e0:    4669        iF      MOV      r1,sp
        0x080004e2:    4640        @F      MOV      r0,r8
        0x080004e4:    f7ffff10    ....    BL       LL_GPIO_Init ; 0x8000308
;;;1089   
;;;1090   }
        0x080004e8:    b005        ..      ADD      sp,sp,#0x14
        0x080004ea:    e8bd8ff0    ....    POP      {r4-r11,pc}
    $d
        0x080004ee:    0000        ..      DCW    0
        0x080004f0:    04a000a0    ....    DCD    77594784
        0x080004f4:    40011000    ...@    DCD    1073811456
        0x080004f8:    40010800    ...@    DCD    1073809408
        0x080004fc:    40010c00    ...@    DCD    1073810432
        0x08000500:    04400040    @.@.    DCD    71303232
        0x08000504:    049c31bd    .1..    DCD    77345213
        0x08000508:    04f23cfe    .<..    DCD    82984190
        0x0800050c:    04030003    ....    DCD    67305475
    $t
    i.PendSV_Handler
    PendSV_Handler
;;; .\../Src/stm32f1xx_it.c
;;;146    }
        0x08000510:    4770        pG      BX       lr
    i.SVC_Handler
    SVC_Handler
;;; .\../Src/stm32f1xx_it.c (133)
        0x08000512:    4770        pG      BX       lr
    i.SquareRoot
    SquareRoot
;;; .\..\Src\nuts_bolts.c
;;;286    uint32_t SquareRoot(uint32_t a_nInput){
        0x08000514:    4602        .F      MOV      r2,r0
;;;287    	uint32_t op  = a_nInput;
;;;288    	uint32_t res = 0;
        0x08000516:    2000        .       MOVS     r0,#0
;;;289    	uint32_t one = 1uL << 30; // The second-to-top bit is set: use 1u << 14 for uint16_t type; use 1uL<<30 for uint32_t type
        0x08000518:    f04f4180    O..A    MOV      r1,#0x40000000
;;;290    
;;;291      // "one" starts at the highest power of four <= than the argument.
;;;292      one >>= __clz(op) & ~0x3;
        0x0800051c:    fab2f382    ....    CLZ      r3,r2
        0x08000520:    f0230303    #...    BIC      r3,r3,#3
        0x08000524:    40d9        .@      LSRS     r1,r1,r3
        0x08000526:    e007        ..      B        0x8000538 ; SquareRoot + 36
;;;293    //    while (one > op) {
;;;294    //		one >>= 2;
;;;295    //	}
;;;296    
;;;297    	while (one != 0){
;;;298    		if (op >= res + one){
        0x08000528:    1843        C.      ADDS     r3,r0,r1
        0x0800052a:    4293        .B      CMP      r3,r2
        0x0800052c:    d802        ..      BHI      0x8000534 ; SquareRoot + 32
;;;299    			op = op - (res + one);
        0x0800052e:    1ad2        ..      SUBS     r2,r2,r3
;;;300    			res = res +  2 * one;
        0x08000530:    eb000041    ..A.    ADD      r0,r0,r1,LSL #1
;;;301    		}
;;;302    		res >>= 1;
        0x08000534:    0840        @.      LSRS     r0,r0,#1
;;;303    		one >>= 2;
        0x08000536:    0889        ..      LSRS     r1,r1,#2
        0x08000538:    2900        .)      CMP      r1,#0
        0x0800053a:    d1f5        ..      BNE      0x8000528 ; SquareRoot + 20
;;;304    	}
;;;305    	return res;
;;;306    }
        0x0800053c:    4770        pG      BX       lr
        0x0800053e:    0000        ..      MOVS     r0,r0
    i.SysTick_Handler
    SysTick_Handler
;;; .\../Src/stm32f1xx_it.c
;;;177    	for(int a = 0; a<BT_TOTAL;a++){
        0x08000540:    2000        .       MOVS     r0,#0
        0x08000542:    4b05        .K      LDR      r3,[pc,#20] ; [0x8000558] = 0x20000034
        0x08000544:    eb031240    ..@.    ADD      r2,r3,r0,LSL #5
        0x08000548:    6911        .i      LDR      r1,[r2,#0x10]
        0x0800054a:    b109        ..      CBZ      r1,0x8000550 ; SysTick_Handler + 16
        0x0800054c:    1c49        I.      ADDS     r1,r1,#1
        0x0800054e:    6111        .a      STR      r1,[r2,#0x10]
;;; .\../Src/stm32f1xx_it.c (177)
        0x08000550:    1c40        @.      ADDS     r0,r0,#1
        0x08000552:    2801        .(      CMP      r0,#1
        0x08000554:    dbf6        ..      BLT      0x8000544 ; SysTick_Handler + 4
;;;178    		if( bt[a].buttons_mstick > 0 )
;;;179    			bt[a].buttons_mstick++;
;;;180    	}
;;;181      /* USER CODE END SysTick_IRQn 1 */
;;;182    }
        0x08000556:    4770        pG      BX       lr
    $d
        0x08000558:    20000034    4..     DCD    536870964
    $t
    i.SystemClock_Config
    SystemClock_Config
;;; .\../Src/main.c
;;;553    {
        0x0800055c:    b510        ..      PUSH     {r4,lr}
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;488      MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
        0x0800055e:    4827        'H      LDR      r0,[pc,#156] ; [0x80005fc] = 0x40022000
        0x08000560:    6801        .h      LDR      r1,[r0,#0]
        0x08000562:    f0210107    !...    BIC      r1,r1,#7
        0x08000566:    f0410102    A...    ORR      r1,r1,#2
        0x0800056a:    6001        .`      STR      r1,[r0,#0]
;;;489    }
;;;490    
;;;491    /**
;;;492      * @brief  Get FLASH Latency
;;;493      * @rmtoll FLASH_ACR    LATENCY       LL_FLASH_GetLatency
;;;494      * @retval Returned value can be one of the following values:
;;;495      *         @arg @ref LL_FLASH_LATENCY_0
;;;496      *         @arg @ref LL_FLASH_LATENCY_1
;;;497      *         @arg @ref LL_FLASH_LATENCY_2
;;;498      */
;;;499    __STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
;;;500    {
;;;501      return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
        0x0800056c:    6800        .h      LDR      r0,[r0,#0]
        0x0800056e:    f0000007    ....    AND      r0,r0,#7
;;; .\../Src/main.c
;;;556       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
        0x08000572:    2802        .(      CMP      r0,#2
;;; .\../Src/main.c (553)
        0x08000574:    d001        ..      BEQ      0x800057a ; SystemClock_Config + 30
;;;554      LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
;;;555    
;;;556       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
;;;557      {
;;;558        Error_Handler();  
        0x08000576:    f7fffe20    .. .    BL       Error_Handler ; 0x80001ba
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;792      SET_BIT(RCC->CR, RCC_CR_HSEON);
        0x0800057a:    4821        !H      LDR      r0,[pc,#132] ; [0x8000600] = 0x40021000
        0x0800057c:    6801        .h      LDR      r1,[r0,#0]
        0x0800057e:    f4413180    A..1    ORR      r1,r1,#0x10000
        0x08000582:    6001        .`      STR      r1,[r0,#0]
;;;793    }
;;;794    
;;;795    /**
;;;796      * @brief  Disable HSE crystal oscillator (HSE ON)
;;;797      * @rmtoll CR           HSEON         LL_RCC_HSE_Disable
;;;798      * @retval None
;;;799      */
;;;800    __STATIC_INLINE void LL_RCC_HSE_Disable(void)
;;;801    {
;;;802      CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
;;;803    }
;;;804    
;;;805    /**
;;;806      * @brief  Check if HSE oscillator Ready
;;;807      * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
;;;808      * @retval State of bit (1 or 0).
;;;809      */
;;;810    __STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
;;;811    {
;;;812      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
        0x08000584:    6801        .h      LDR      r1,[r0,#0]
        0x08000586:    f3c14140    ..@A    UBFX     r1,r1,#17,#1
;;; .\../Src/main.c
;;;563      while(LL_RCC_HSE_IsReady() != 1)
        0x0800058a:    2900        .)      CMP      r1,#0
        0x0800058c:    d0fa        ..      BEQ      0x8000584 ; SystemClock_Config + 40
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1495     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
        0x0800058e:    6841        Ah      LDR      r1,[r0,#4]
        0x08000590:    f421117c    !.|.    BIC      r1,r1,#0x3f0000
        0x08000594:    f44111e8    A...    ORR      r1,r1,#0x1d0000
        0x08000598:    6041        A`      STR      r1,[r0,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h (1405)
        0x0800059a:    6801        .h      LDR      r1,[r0,#0]
        0x0800059c:    f0417180    A..q    ORR      r1,r1,#0x1000000
        0x080005a0:    6001        .`      STR      r1,[r0,#0]
;;;1406   }
;;;1407   
;;;1408   /**
;;;1409     * @brief  Disable PLL
;;;1410     * @note Cannot be disabled if the PLL clock is used as the system clock
;;;1411     * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
;;;1412     * @retval None
;;;1413     */
;;;1414   __STATIC_INLINE void LL_RCC_PLL_Disable(void)
;;;1415   {
;;;1416     CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
;;;1417   }
;;;1418   
;;;1419   /**
;;;1420     * @brief  Check if PLL Ready
;;;1421     * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
;;;1422     * @retval State of bit (1 or 0).
;;;1423     */
;;;1424   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
;;;1425   {
;;;1426     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
        0x080005a2:    6801        .h      LDR      r1,[r0,#0]
        0x080005a4:    f3c16140    ..@a    UBFX     r1,r1,#25,#1
;;; .\../Src/main.c
;;;571      while(LL_RCC_PLL_IsReady() != 1)
        0x080005a8:    2900        .)      CMP      r1,#0
        0x080005aa:    d0fa        ..      BEQ      0x80005a2 ; SystemClock_Config + 70
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1065     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
        0x080005ac:    6841        Ah      LDR      r1,[r0,#4]
        0x080005ae:    f02101f0    !...    BIC      r1,r1,#0xf0
        0x080005b2:    6041        A`      STR      r1,[r0,#4]
;;;1066   }
;;;1067   
;;;1068   /**
;;;1069     * @brief  Set APB1 prescaler
;;;1070     * @rmtoll CFGR         PPRE1         LL_RCC_SetAPB1Prescaler
;;;1071     * @param  Prescaler This parameter can be one of the following values:
;;;1072     *         @arg @ref LL_RCC_APB1_DIV_1
;;;1073     *         @arg @ref LL_RCC_APB1_DIV_2
;;;1074     *         @arg @ref LL_RCC_APB1_DIV_4
;;;1075     *         @arg @ref LL_RCC_APB1_DIV_8
;;;1076     *         @arg @ref LL_RCC_APB1_DIV_16
;;;1077     * @retval None
;;;1078     */
;;;1079   __STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
;;;1080   {
;;;1081     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
        0x080005b4:    6841        Ah      LDR      r1,[r0,#4]
        0x080005b6:    f42161e0    !..a    BIC      r1,r1,#0x700
        0x080005ba:    f4416180    A..a    ORR      r1,r1,#0x400
        0x080005be:    6041        A`      STR      r1,[r0,#4]
;;;1082   }
;;;1083   
;;;1084   /**
;;;1085     * @brief  Set APB2 prescaler
;;;1086     * @rmtoll CFGR         PPRE2         LL_RCC_SetAPB2Prescaler
;;;1087     * @param  Prescaler This parameter can be one of the following values:
;;;1088     *         @arg @ref LL_RCC_APB2_DIV_1
;;;1089     *         @arg @ref LL_RCC_APB2_DIV_2
;;;1090     *         @arg @ref LL_RCC_APB2_DIV_4
;;;1091     *         @arg @ref LL_RCC_APB2_DIV_8
;;;1092     *         @arg @ref LL_RCC_APB2_DIV_16
;;;1093     * @retval None
;;;1094     */
;;;1095   __STATIC_INLINE void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
;;;1096   {
;;;1097     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
        0x080005c0:    6841        Ah      LDR      r1,[r0,#4]
        0x080005c2:    f4215160    !.`Q    BIC      r1,r1,#0x3800
        0x080005c6:    6041        A`      STR      r1,[r0,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h (1032)
        0x080005c8:    6841        Ah      LDR      r1,[r0,#4]
        0x080005ca:    f0210103    !...    BIC      r1,r1,#3
        0x080005ce:    f0410102    A...    ORR      r1,r1,#2
        0x080005d2:    6041        A`      STR      r1,[r0,#4]
;;;1033   }
;;;1034   
;;;1035   /**
;;;1036     * @brief  Get the system clock source
;;;1037     * @rmtoll CFGR         SWS           LL_RCC_GetSysClkSource
;;;1038     * @retval Returned value can be one of the following values:
;;;1039     *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI
;;;1040     *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
;;;1041     *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL
;;;1042     */
;;;1043   __STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
;;;1044   {
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x080005d4:    6841        Ah      LDR      r1,[r0,#4]
        0x080005d6:    f001010c    ....    AND      r1,r1,#0xc
;;; .\../Src/main.c
;;;581      while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
        0x080005da:    2908        .)      CMP      r1,#8
        0x080005dc:    d1fa        ..      BNE      0x80005d4 ; SystemClock_Config + 120
;;;582      {
;;;583      
;;;584      }
;;;585      LL_Init1msTick(72000000);
        0x080005de:    4c09        .L      LDR      r4,[pc,#36] ; [0x8000604] = 0x44aa200
        0x080005e0:    4620         F      MOV      r0,r4
        0x080005e2:    f7ffff0d    ....    BL       LL_Init1msTick ; 0x8000400
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;264        SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x080005e6:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x080005ea:    690a        .i      LDR      r2,[r1,#0x10]
        0x080005ec:    f0420204    B...    ORR      r2,r2,#4
        0x080005f0:    610a        .a      STR      r2,[r1,#0x10]
;;; .\../Src/main.c
;;;587      LL_SetSystemCoreClock(72000000);
        0x080005f2:    4620         F      MOV      r0,r4
        0x080005f4:    e8bd4010    ...@    POP      {r4,lr}
        0x080005f8:    f7ffbf10    ....    B.W      LL_SetSystemCoreClock ; 0x800041c
    $d
        0x080005fc:    40022000    . .@    DCD    1073881088
        0x08000600:    40021000    ...@    DCD    1073876992
        0x08000604:    044aa200    ..J.    DCD    72000000
    $t
    i.SystemInit
    SystemInit
;;; .\../Src/system_stm32f1xx.c
;;;179      RCC->CR |= 0x00000001U;
        0x08000608:    480d        .H      LDR      r0,[pc,#52] ; [0x8000640] = 0x40021000
        0x0800060a:    6801        .h      LDR      r1,[r0,#0]
        0x0800060c:    f0410101    A...    ORR      r1,r1,#1
        0x08000610:    6001        .`      STR      r1,[r0,#0]
;;;180    
;;;181      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;182    #if !defined(STM32F105xC) && !defined(STM32F107xC)
;;;183      RCC->CFGR &= 0xF8FF0000U;
        0x08000612:    6841        Ah      LDR      r1,[r0,#4]
        0x08000614:    4a0b        .J      LDR      r2,[pc,#44] ; [0x8000644] = 0xf8ff0000
        0x08000616:    4011        .@      ANDS     r1,r1,r2
        0x08000618:    6041        A`      STR      r1,[r0,#4]
;;;184    #else
;;;185      RCC->CFGR &= 0xF0FF0000U;
;;;186    #endif /* STM32F105xC */   
;;;187      
;;;188      /* Reset HSEON, CSSON and PLLON bits */
;;;189      RCC->CR &= 0xFEF6FFFFU;
        0x0800061a:    6801        .h      LDR      r1,[r0,#0]
        0x0800061c:    4a0a        .J      LDR      r2,[pc,#40] ; [0x8000648] = 0xfef6ffff
        0x0800061e:    4011        .@      ANDS     r1,r1,r2
        0x08000620:    6001        .`      STR      r1,[r0,#0]
;;;190    
;;;191      /* Reset HSEBYP bit */
;;;192      RCC->CR &= 0xFFFBFFFFU;
        0x08000622:    6801        .h      LDR      r1,[r0,#0]
        0x08000624:    f4212180    !..!    BIC      r1,r1,#0x40000
        0x08000628:    6001        .`      STR      r1,[r0,#0]
;;;193    
;;;194      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;195      RCC->CFGR &= 0xFF80FFFFU;
        0x0800062a:    6841        Ah      LDR      r1,[r0,#4]
        0x0800062c:    f42101fe    !...    BIC      r1,r1,#0x7f0000
        0x08000630:    6041        A`      STR      r1,[r0,#4]
;;;196    
;;;197    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;198      /* Reset PLL2ON and PLL3ON bits */
;;;199      RCC->CR &= 0xEBFFFFFFU;
;;;200    
;;;201      /* Disable all interrupts and clear pending bits  */
;;;202      RCC->CIR = 0x00FF0000U;
;;;203    
;;;204      /* Reset CFGR2 register */
;;;205      RCC->CFGR2 = 0x00000000U;
;;;206    #elif defined(STM32F100xB) || defined(STM32F100xE)
;;;207      /* Disable all interrupts and clear pending bits  */
;;;208      RCC->CIR = 0x009F0000U;
;;;209    
;;;210      /* Reset CFGR2 register */
;;;211      RCC->CFGR2 = 0x00000000U;      
;;;212    #else
;;;213      /* Disable all interrupts and clear pending bits  */
;;;214      RCC->CIR = 0x009F0000U;
        0x08000632:    f44f011f    O...    MOV      r1,#0x9f0000
        0x08000636:    6081        .`      STR      r1,[r0,#8]
;;;215    #endif /* STM32F105xC */
;;;216        
;;;217    #if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
;;;218      #ifdef DATA_IN_ExtSRAM
;;;219        SystemInit_ExtMemCtl(); 
;;;220      #endif /* DATA_IN_ExtSRAM */
;;;221    #endif 
;;;222    
;;;223    #ifdef VECT_TAB_SRAM
;;;224      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;225    #else
;;;226      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
        0x08000638:    4904        .I      LDR      r1,[pc,#16] ; [0x800064c] = 0xe000ed08
        0x0800063a:    03c0        ..      LSLS     r0,r0,#15
        0x0800063c:    6008        .`      STR      r0,[r1,#0]
;;;227    #endif 
;;;228    }
        0x0800063e:    4770        pG      BX       lr
    $d
        0x08000640:    40021000    ...@    DCD    1073876992
        0x08000644:    f8ff0000    ....    DCD    4177461248
        0x08000648:    fef6ffff    ....    DCD    4277600255
        0x0800064c:    e000ed08    ....    DCD    3758157064
    $t
    i.TIM1_UP_IRQHandler
    TIM1_UP_IRQHandler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
        0x08000650:    4804        .H      LDR      r0,[pc,#16] ; [0x8000664] = 0x40012c00
        0x08000652:    6901        .i      LDR      r1,[r0,#0x10]
        0x08000654:    f3c10100    ....    UBFX     r1,r1,#0,#1
        0x08000658:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c
;;;233    {
        0x0800065a:    d002        ..      BEQ      0x8000662 ; TIM1_UP_IRQHandler + 18
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x0800065c:    f06f0101    o...    MVN      r1,#1
        0x08000660:    6101        .a      STR      r1,[r0,#0x10]
;;; .\../Src/stm32f1xx_it.c
;;;245    }
        0x08000662:    4770        pG      BX       lr
    $d
        0x08000664:    40012c00    .,.@    DCD    1073818624
    $t
    i.TIM2_IRQHandler
    TIM2_IRQHandler
;;;246    
;;;247    /**
;;;248      * @brief This function handles TIM2 global interrupt.
;;;249      */
;;;250    void TIM2_IRQHandler(void)
;;;251    {
        0x08000668:    b510        ..      PUSH     {r4,lr}
        0x0800066a:    4808        .H      LDR      r0,[pc,#32] ; [0x800068c] = 0x40000408
        0x0800066c:    6800        .h      LDR      r0,[r0,#0]
        0x0800066e:    4c08        .L      LDR      r4,[pc,#32] ; [0x8000690] = 0x200000c0
        0x08000670:    2816        .(      CMP      r0,#0x16
;;; .\../Src/stm32f1xx_it.c (251)
        0x08000672:    d107        ..      BNE      0x8000684 ; TIM2_IRQHandler + 28
;;;252      /* USER CODE BEGIN TIM2_IRQn 0 */
;;;253    // prescaler=((((speed=72000000)/((period=20000)/(1/hz=1)))+0,5)-1)
;;;254    	if(TIM3->SMCR == 0x16) { // TIM3 connected to TIM2 as SLAVE
;;;255    		state.function(&state);
        0x08000674:    6821        !h      LDR      r1,[r4,#0]
        0x08000676:    4620         F      MOV      r0,r4
        0x08000678:    4788        .G      BLX      r1
;;;256    //		state.syncbase->ARR = state.z_period;
;;;257    		state.syncbase->EGR |= TIM_EGR_UG;
        0x0800067a:    6960        `i      LDR      r0,[r4,#0x14]
        0x0800067c:    6941        Ai      LDR      r1,[r0,#0x14]
        0x0800067e:    f0410101    A...    ORR      r1,r1,#1
        0x08000682:    6141        Aa      STR      r1,[r0,#0x14]
;;;258    	}
;;;259    
;;;260      /* USER CODE END TIM2_IRQn 0 */
;;;261      /* USER CODE BEGIN TIM2_IRQn 1 */
;;;262      /* Check whether update interrupt is pending */
;;;263    	state.syncbase->SR = 0;
        0x08000684:    6961        ai      LDR      r1,[r4,#0x14]
        0x08000686:    2000        .       MOVS     r0,#0
        0x08000688:    6108        .a      STR      r0,[r1,#0x10]
;;;264    
;;;265    //  if(LL_TIM_IsActiveFlag_UPDATE(TIM2) == 1)
;;;266    //  {
;;;267        /* Clear the update interrupt flag*/
;;;268    //    LL_TIM_ClearFlag_UPDATE(TIM2);
;;;269    //  }
;;;270      /* USER CODE END TIM2_IRQn 1 */
;;;271    }
        0x0800068a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800068c:    40000408    ...@    DCD    1073742856
        0x08000690:    200000c0    ...     DCD    536871104
    $t
    i.TIM3_IRQHandler
    TIM3_IRQHandler
;;;272    
;;;273    /**
;;;274      * @brief This function handles TIM3 global interrupt.
;;;275      */
;;;276    void TIM3_IRQHandler(void)
;;;277    {
        0x08000694:    b570        p.      PUSH     {r4-r6,lr}
        0x08000696:    4810        .H      LDR      r0,[pc,#64] ; [0x80006d8] = 0x40000408
        0x08000698:    6800        .h      LDR      r0,[r0,#0]
        0x0800069a:    2400        .$      MOVS     r4,#0
        0x0800069c:    2816        .(      CMP      r0,#0x16
;;; .\../Src/stm32f1xx_it.c (277)
        0x0800069e:    d117        ..      BNE      0x80006d0 ; TIM3_IRQHandler + 60
;;; ../Inc/fsm.h
;;;99     	TIM3->CCER = 0;	//	LL_TIM_CC_DisableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x080006a0:    480d        .H      LDR      r0,[pc,#52] ; [0x80006d8] = 0x40000408
        0x080006a2:    3018        .0      ADDS     r0,r0,#0x18
        0x080006a4:    6004        .`      STR      r4,[r0,#0]
;;;100    	int e2 = s->err;
        0x080006a6:    4b0d        .K      LDR      r3,[pc,#52] ; [0x80006dc] = 0x200000c0
        0x080006a8:    6b98        .k      LDR      r0,[r3,#0x38]
;;;101    	if (e2 > -s->dx)	{ // step X axis
        0x080006aa:    6b1a        .k      LDR      r2,[r3,#0x30]
;;; ../Inc/fsm.h (100)
        0x080006ac:    4619        .F      MOV      r1,r3
;;;101    	if (e2 > -s->dx)	{ // step X axis
        0x080006ae:    4255        UB      RSBS     r5,r2,#0
;;;102    		s->err -= s->dz; 
;;;103    		t3ccer[TIM_CCER_CC1E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x080006b0:    2601        .&      MOVS     r6,#1
;;; ../Inc/fsm.h (102)
        0x080006b2:    6b49        Ik      LDR      r1,[r1,#0x34]
;;; ../Inc/fsm.h (101)
        0x080006b4:    4285        .B      CMP      r5,r0
        0x080006b6:    da03        ..      BGE      0x80006c0 ; TIM3_IRQHandler + 44
;;;102    		s->err -= s->dz; 
        0x080006b8:    1a45        E.      SUBS     r5,r0,r1
        0x080006ba:    639d        .c      STR      r5,[r3,#0x38]
;;;103    		t3ccer[TIM_CCER_CC1E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x080006bc:    4d08        .M      LDR      r5,[pc,#32] ; [0x80006e0] = 0x42008400
        0x080006be:    602e        .`      STR      r6,[r5,#0]
;;;104    	}
;;;105    	if (e2 < s->dz)	{ // step Z axis
        0x080006c0:    4281        .B      CMP      r1,r0
        0x080006c2:    dd05        ..      BLE      0x80006d0 ; TIM3_IRQHandler + 60
;;;106    		s->err += s->dx;
        0x080006c4:    6b98        .k      LDR      r0,[r3,#0x38]
        0x080006c6:    4410        .D      ADD      r0,r0,r2
        0x080006c8:    6398        .c      STR      r0,[r3,#0x38]
;;;107    		t3ccer[TIM_CCER_CC3E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3); 
        0x080006ca:    4805        .H      LDR      r0,[pc,#20] ; [0x80006e0] = 0x42008400
        0x080006cc:    3020         0      ADDS     r0,r0,#0x20
        0x080006ce:    6006        .`      STR      r6,[r0,#0]
;;; .\../Src/stm32f1xx_it.c
;;;282    	TIM3->SR = 0;
        0x080006d0:    4801        .H      LDR      r0,[pc,#4] ; [0x80006d8] = 0x40000408
        0x080006d2:    3008        .0      ADDS     r0,r0,#8
        0x080006d4:    6004        .`      STR      r4,[r0,#0]
;;;283    	
;;;284      /* USER CODE END TIM3_IRQn 0 */
;;;285      /* USER CODE BEGIN TIM3_IRQn 1 */
;;;286    
;;;287      /* USER CODE END TIM3_IRQn 1 */
;;;288    }
        0x080006d6:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080006d8:    40000408    ...@    DCD    1073742856
        0x080006dc:    200000c0    ...     DCD    536871104
        0x080006e0:    42008400    ...B    DCD    1107330048
    $t
    i.TIM4_IRQHandler
    TIM4_IRQHandler
;;;289    
;;;290    /**
;;;291      * @brief This function handles TIM4 global interrupt.
;;;292      */
;;;293    void TIM4_IRQHandler(void)
;;;294    {
        0x080006e4:    b510        ..      PUSH     {r4,lr}
        0x080006e6:    4c05        .L      LDR      r4,[pc,#20] ; [0x80006fc] = 0x200000c0
        0x080006e8:    7c20         |      LDRB     r0,[r4,#0x10]
        0x080006ea:    2801        .(      CMP      r0,#1
;;; .\../Src/stm32f1xx_it.c (294)
        0x080006ec:    d102        ..      BNE      0x80006f4 ; TIM4_IRQHandler + 16
;;;295      /* USER CODE BEGIN TIM4_IRQn 0 */
;;;296    //	_Bool dir = t4cr1[TIM_CR1_DIR_Pos];
;;;297    //	if(t4sr[TIM_SR_CC3IF_Pos]){
;;;298    //		do_fsm_wait_tacho(&state);
;;;299    //	}
;;;300    //	if(TIM3->SMCR == 0x36) { // TIM3 connected to TIM4 as SLAVE
;;;301    	if (state.sync == true) {
;;;302    //		state.spindle_dir = t4cr1[TIM_CR1_DIR_Pos];
;;;303    //		state.f_encoder = encoder;
;;;304    //		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
;;;305    		state.function(&state);
        0x080006ee:    6821        !h      LDR      r1,[r4,#0]
        0x080006f0:    4620         F      MOV      r0,r4
        0x080006f2:    4788        .G      BLX      r1
;;;306    //		state.syncbase->ARR = state.z_period;
;;;307    //		TIM4->ARR = state.z_period;
;;;308    //		state.syncbase->EGR |= TIM_EGR_UG;
;;;309    		
;;;310    	}
;;;311    //	TIM4->SR &= ~TIM_SR_UIF; //   . 
;;;312    
;;;313      /* USER CODE END TIM4_IRQn 0 */
;;;314      /* USER CODE BEGIN TIM4_IRQn 1 */
;;;315      /* Check whether update interrupt is pending */
;;;316    //	if(LL_TIM_IsActiveFlag_CC2OVR(TIM4) == 1){
;;;317    //		TIM4->SR = 0;
;;;318    //	}
;;;319    	state.syncbase->SR = 0;
        0x080006f4:    6961        ai      LDR      r1,[r4,#0x14]
        0x080006f6:    2000        .       MOVS     r0,#0
        0x080006f8:    6108        .a      STR      r0,[r1,#0x10]
;;;320    /*
;;;321    	if(LL_TIM_IsActiveFlag_CC2(TIM4) == 1)
;;;322        LL_TIM_ClearFlag_CC2(TIM4);
;;;323    	if(LL_TIM_IsActiveFlag_CC3(TIM4) == 1)
;;;324        LL_TIM_ClearFlag_CC3(TIM4);
;;;325    	if(LL_TIM_IsActiveFlag_UPDATE(TIM4) == 1)
;;;326      {
;;;327        LL_TIM_ClearFlag_UPDATE(TIM4); //Clear the update interrupt flag
;;;328      }
;;;329    */
;;;330      /* USER CODE END TIM4_IRQn 1 */
;;;331    }
        0x080006fa:    bd10        ..      POP      {r4,pc}
    $d
        0x080006fc:    200000c0    ...     DCD    536871104
    $t
    i.Transfer_Complete_Callback
    Transfer_Complete_Callback
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
        0x08000700:    480b        .H      LDR      r0,[pc,#44] ; [0x8000730] = 0x40005800
        0x08000702:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08000704:    f3c10180    ....    UBFX     r1,r1,#2,#1
;;; .\..\Src\i2c_interface.c
;;;331    	while(!LL_I2C_IsActiveFlag_BTF(I2C2))
        0x08000708:    2900        .)      CMP      r1,#0
        0x0800070a:    d0fa        ..      BEQ      0x8000702 ; Transfer_Complete_Callback + 2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1596     SET_BIT(I2Cx->CR1, I2C_CR1_STOP);
        0x0800070c:    6801        .h      LDR      r1,[r0,#0]
        0x0800070e:    f4417100    A..q    ORR      r1,r1,#0x200
        0x08000712:    6001        .`      STR      r1,[r0,#0]
;;; .\..\Src\i2c_interface.c
;;;335      LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x08000714:    4a07        .J      LDR      r2,[pc,#28] ; [0x8000734] = 0x40020000
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;491      CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x08000716:    4808        .H      LDR      r0,[pc,#32] ; [0x8000738] = 0x8000a0c
        0x08000718:    1d01        ..      ADDS     r1,r0,#4
        0x0800071a:    78c0        .x      LDRB     r0,[r0,#3]
        0x0800071c:    5810        .X      LDR      r0,[r2,r0]
        0x0800071e:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x08000722:    f0200001     ...    BIC      r0,r0,#1
        0x08000726:    5050        PP      STR      r0,[r2,r1]
;;; .\..\Src\i2c_interface.c
;;;337      ubTransferComplete = 1;
        0x08000728:    4904        .I      LDR      r1,[pc,#16] ; [0x800073c] = 0x20000004
        0x0800072a:    2001        .       MOVS     r0,#1
        0x0800072c:    7008        .p      STRB     r0,[r1,#0]
;;;338    }
        0x0800072e:    4770        pG      BX       lr
    $d
        0x08000730:    40005800    .X.@    DCD    1073764352
        0x08000734:    40020000    ...@    DCD    1073872896
        0x08000738:    08000a0c    ....    DCD    134220300
        0x0800073c:    20000004    ...     DCD    536870916
    $t
    i.Transfer_Error_Callback
    Transfer_Error_Callback
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08000740:    4902        .I      LDR      r1,[pc,#8] ; [0x800074c] = 0xe000e180
        0x08000742:    f44f4080    O..@    MOV      r0,#0x4000
        0x08000746:    6008        .`      STR      r0,[r1,#0]
;;; .\..\Src\i2c_interface.c
;;;351      while(1){};
        0x08000748:    e7fe        ..      B        0x8000748 ; Transfer_Error_Callback + 8
    $d
        0x0800074a:    0000        ..      DCW    0
        0x0800074c:    e000e180    ....    DCD    3758154112
    $t
    i.USART2_IRQHandler
    USART2_IRQHandler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1859     return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
        0x08000750:    4806        .H      LDR      r0,[pc,#24] ; [0x800076c] = 0x40004400
        0x08000752:    6801        .h      LDR      r1,[r0,#0]
        0x08000754:    f3c11140    ..@.    UBFX     r1,r1,#5,#1
        0x08000758:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c
;;;382    {
        0x0800075a:    d006        ..      BEQ      0x800076a ; USART2_IRQHandler + 26
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2294     return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
        0x0800075c:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800075e:    f3c01040    ..@.    UBFX     r0,r0,#5,#1
;;; .\../Src/stm32f1xx_it.c
;;;384      if(LL_USART_IsActiveFlag_RXNE(USART2) && LL_USART_IsEnabledIT_RXNE(USART2))
        0x08000762:    2800        .(      CMP      r0,#0
        0x08000764:    d001        ..      BEQ      0x800076a ; USART2_IRQHandler + 26
;;;385      {
;;;386        /* RXNE flag will be cleared by reading of DR register (done in call) */
;;;387        /* Call function in charge of handling Character reception */
;;;388        USART_CharReception_Callback();
        0x08000766:    f000b803    ....    B.W      USART_CharReception_Callback ; 0x8000770
;;;389      }
;;;390      /* USER CODE END USART2_IRQn 0 */
;;;391      /* USER CODE BEGIN USART2_IRQn 1 */
;;;392    
;;;393      /* USER CODE END USART2_IRQn 1 */
;;;394    }
        0x0800076a:    4770        pG      BX       lr
    $d
        0x0800076c:    40004400    .D.@    DCD    1073759232
    $t
    i.USART_CharReception_Callback
    USART_CharReception_Callback
;;; .\../Src/main.c
;;;227    {
        0x08000770:    b510        ..      PUSH     {r4,lr}
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2470     return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
        0x08000772:    480b        .H      LDR      r0,[pc,#44] ; [0x80007a0] = 0x40004400
        0x08000774:    6840        @h      LDR      r0,[r0,#4]
        0x08000776:    b2c0        ..      UXTB     r0,r0
;;; .\../Src/main.c
;;;233    		ubUART2ReceptionComplete = 1;
        0x08000778:    490a        .I      LDR      r1,[pc,#40] ; [0x80007a4] = 0x20000008
;;; .\../Src/main.c (231)
        0x0800077a:    280a        .(      CMP      r0,#0xa
        0x0800077c:    6a0b        .j      LDR      r3,[r1,#0x20]
;;; .\../Src/main.c (227)
        0x0800077e:    d006        ..      BEQ      0x800078e ; USART_CharReception_Callback + 30
;;;228    	uint8_t *ptemp;
;;;229      /* Read Received character. RXNE flag is cleared by reading of DR register */
;;;230    	uint8_t symbol = LL_USART_ReceiveData8(USART2);
;;;231    	if(symbol == '\n' || symbol == '\r'){
        0x08000780:    280d        .(      CMP      r0,#0xd
        0x08000782:    d004        ..      BEQ      0x800078e ; USART_CharReception_Callback + 30
;;;232        /* Set Buffer swap indication */
;;;233    		ubUART2ReceptionComplete = 1;
;;;234    
;;;235        /* Swap buffers for next bytes to be received */
;;;236        ptemp = pBufferReadyForUser;
;;;237        pBufferReadyForUser = pBufferReadyForReception;
;;;238        pBufferReadyForReception = ptemp;
;;;239        uwNbReceivedChars = 0;
;;;240    	} else {
;;;241    		pBufferReadyForReception[uwNbReceivedChars++] = symbol;
        0x08000784:    698a        .i      LDR      r2,[r1,#0x18]
        0x08000786:    1c54        T.      ADDS     r4,r2,#1
        0x08000788:    618c        .a      STR      r4,[r1,#0x18]
        0x0800078a:    5498        .T      STRB     r0,[r3,r2]
;;;242    	}
;;;243    }
        0x0800078c:    bd10        ..      POP      {r4,pc}
;;; .\../Src/main.c (233)
        0x0800078e:    2001        .       MOVS     r0,#1
        0x08000790:    7048        Hp      STRB     r0,[r1,#1]
;;;234    
;;;235        /* Swap buffers for next bytes to be received */
;;;236        ptemp = pBufferReadyForUser;
        0x08000792:    69c8        .i      LDR      r0,[r1,#0x1c]
;;;237        pBufferReadyForUser = pBufferReadyForReception;
        0x08000794:    61cb        .a      STR      r3,[r1,#0x1c]
;;;238        pBufferReadyForReception = ptemp;
        0x08000796:    6208        .b      STR      r0,[r1,#0x20]
;;;239        uwNbReceivedChars = 0;
        0x08000798:    2000        .       MOVS     r0,#0
        0x0800079a:    6188        .a      STR      r0,[r1,#0x18]
;;;240    	} else {
;;;241    		pBufferReadyForReception[uwNbReceivedChars++] = symbol;
;;;242    	}
;;;243    }
        0x0800079c:    bd10        ..      POP      {r4,pc}
    $d
        0x0800079e:    0000        ..      DCW    0
        0x080007a0:    40004400    .D.@    DCD    1073759232
        0x080007a4:    20000008    ...     DCD    536870920
    $t
    i.__scatterload_copy
    __scatterload_copy
        0x080007a8:    e002        ..      B        0x80007b0 ; __scatterload_copy + 8
        0x080007aa:    c808        ..      LDM      r0!,{r3}
        0x080007ac:    1f12        ..      SUBS     r2,r2,#4
        0x080007ae:    c108        ..      STM      r1!,{r3}
        0x080007b0:    2a00        .*      CMP      r2,#0
        0x080007b2:    d1fa        ..      BNE      0x80007aa ; __scatterload_copy + 2
        0x080007b4:    4770        pG      BX       lr
    i.__scatterload_null
    __scatterload_null
        0x080007b6:    4770        pG      BX       lr
    i.__scatterload_zeroinit
    __scatterload_zeroinit
        0x080007b8:    2000        .       MOVS     r0,#0
        0x080007ba:    e001        ..      B        0x80007c0 ; __scatterload_zeroinit + 8
        0x080007bc:    c101        ..      STM      r1!,{r0}
        0x080007be:    1f12        ..      SUBS     r2,r2,#4
        0x080007c0:    2a00        .*      CMP      r2,#0
        0x080007c2:    d1fb        ..      BNE      0x80007bc ; __scatterload_zeroinit + 4
        0x080007c4:    4770        pG      BX       lr
    i.do_fsm_menu_lps
    do_fsm_menu_lps
;;; .\..\Src\fsm.c
;;;200    }
        0x080007c6:    4770        pG      BX       lr
    i.main
    main
;;; .\../Src/main.c
;;;262    {
        0x080007c8:    b5f8        ..      PUSH     {r3-r7,lr}
;;;263      /* USER CODE BEGIN 1 */
;;;264    	memset(&z_axis,0,sizeof(z_axis));
        0x080007ca:    2130        0!      MOVS     r1,#0x30
        0x080007cc:    4836        6H      LDR      r0,[pc,#216] ; [0x80008a8] = 0x20000090
        0x080007ce:    f7fffcc2    ....    BL       __aeabi_memclr ; 0x8000156
;;;265    	state.function = do_fsm_menu_lps;
        0x080007d2:    4935        5I      LDR      r1,[pc,#212] ; [0x80008a8] = 0x20000090
        0x080007d4:    4835        5H      LDR      r0,[pc,#212] ; [0x80008ac] = 0x80007c7
        0x080007d6:    3130        01      ADDS     r1,r1,#0x30
        0x080007d8:    6008        .`      STR      r0,[r1,#0]
;;;266      /* USER CODE END 1 */
;;;267    
;;;268      /* MCU Configuration--------------------------------------------------------*/
;;;269    
;;;270      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;271      
;;;272    
;;;273      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_AFIO);
        0x080007da:    2001        .       MOVS     r0,#1
        0x080007dc:    f7fffd88    ....    BL       LL_APB2_GRP1_EnableClock ; 0x80002f0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;466      SET_BIT(RCC->APB1ENR, Periphs);
        0x080007e0:    4833        3H      LDR      r0,[pc,#204] ; [0x80008b0] = 0x40021000
        0x080007e2:    69c1        .i      LDR      r1,[r0,#0x1c]
        0x080007e4:    f0415180    A..Q    ORR      r1,r1,#0x10000000
        0x080007e8:    61c1        .a      STR      r1,[r0,#0x1c]
;;;467      /* Delay after an RCC peripheral clock enabling */
;;;468      tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
        0x080007ea:    69c0        .i      LDR      r0,[r0,#0x1c]
        0x080007ec:    f0005080    ...P    AND      r0,r0,#0x10000000
        0x080007f0:    9000        ..      STR      r0,[sp,#0]
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1427     reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
        0x080007f2:    4930        0I      LDR      r1,[pc,#192] ; [0x80008b4] = 0xe000ed0c
        0x080007f4:    6808        .h      LDR      r0,[r1,#0]
;;;1428     reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
        0x080007f6:    f64f02ff    O...    MOV      r2,#0xf8ff
        0x080007fa:    4010        .@      ANDS     r0,r0,r2
;;;1429     reg_value  =  (reg_value                                   |
        0x080007fc:    4a2e        .J      LDR      r2,[pc,#184] ; [0x80008b8] = 0x5fa0000
        0x080007fe:    f4407040    @.@p    ORR      r0,r0,#0x300
        0x08000802:    4310        .C      ORRS     r0,r0,r2
;;;1430                   ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
;;;1431                   (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
;;;1432     SCB->AIRCR =  reg_value;
        0x08000804:    6008        .`      STR      r0,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;1597     CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
        0x08000806:    482d        -H      LDR      r0,[pc,#180] ; [0x80008bc] = 0x40010000
        0x08000808:    6841        Ah      LDR      r1,[r0,#4]
        0x0800080a:    f02161e0    !..a    BIC      r1,r1,#0x7000000
        0x0800080e:    6041        A`      STR      r1,[r0,#4]
;;;1598     SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);
        0x08000810:    6841        Ah      LDR      r1,[r0,#4]
        0x08000812:    f0417100    A..q    ORR      r1,r1,#0x2000000
        0x08000816:    6041        A`      STR      r1,[r0,#4]
;;; .\../Src/main.c
;;;288      SystemClock_Config();
        0x08000818:    f7fffea0    ....    BL       SystemClock_Config ; 0x800055c
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;291      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
        0x0800081c:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x08000820:    6901        .i      LDR      r1,[r0,#0x10]
        0x08000822:    f0410102    A...    ORR      r1,r1,#2
        0x08000826:    6101        .a      STR      r1,[r0,#0x10]
;;; .\../Src/main.c
;;;295      MX_GPIO_Init();
        0x08000828:    f7fffdfe    ....    BL       MX_GPIO_Init ; 0x8000428
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;880      WRITE_REG(GPIOx->ODR, READ_REG(GPIOx->ODR) ^ ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x0800082c:    4e24        $N      LDR      r6,[pc,#144] ; [0x80008c0] = 0x40010c00
        0x0800082e:    68f0        .h      LDR      r0,[r6,#0xc]
        0x08000830:    f0800002    ....    EOR      r0,r0,#2
        0x08000834:    60f0        .`      STR      r0,[r6,#0xc]
;;; .\../Src/main.c
;;;312    	for (int a = 0; a<6680;a++){
        0x08000836:    2400        .$      MOVS     r4,#0
        0x08000838:    4d22        "M      LDR      r5,[pc,#136] ; [0x80008c4] = 0x20000008
        0x0800083a:    f6412718    A..'    MOV      r7,#0x1a18
        0x0800083e:    6928        (i      LDR      r0,[r5,#0x10]
        0x08000840:    4420         D      ADD      r0,r0,r4
        0x08000842:    6128        (a      STR      r0,[r5,#0x10]
        0x08000844:    68e9        .h      LDR      r1,[r5,#0xc]
        0x08000846:    fb001010    ....    MLS      r0,r0,r0,r1
        0x0800084a:    f7fffe63    ..c.    BL       SquareRoot ; 0x8000514
        0x0800084e:    6168        ha      STR      r0,[r5,#0x14]
        0x08000850:    1c64        d.      ADDS     r4,r4,#1
        0x08000852:    42bc        .B      CMP      r4,r7
        0x08000854:    dbf3        ..      BLT      0x800083e ; main + 118
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;880      WRITE_REG(GPIOx->ODR, READ_REG(GPIOx->ODR) ^ ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08000856:    68f0        .h      LDR      r0,[r6,#0xc]
        0x08000858:    f0800002    ....    EOR      r0,r0,#2
        0x0800085c:    60f0        .`      STR      r0,[r6,#0xc]
;;; .\../Src/main.c
;;;321    	z_axis.Q824set = Thread_Info[Menu_Step].Q824;
        0x0800085e:    481a        .H      LDR      r0,[pc,#104] ; [0x80008c8] = 0x8000a1c
        0x08000860:    7829        )x      LDRB     r1,[r5,#0]
        0x08000862:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x08000866:    4910        .I      LDR      r1,[pc,#64] ; [0x80008a8] = 0x20000090
        0x08000868:    6800        .h      LDR      r0,[r0,#0]
        0x0800086a:    60c8        .`      STR      r0,[r1,#0xc]
;;;322    
;;;323    	char *end;
;;;324    
;;;325    	int size = 10;
        0x0800086c:    240a        .$      MOVS     r4,#0xa
;;;326    	cb_init(&gp_cb, size, sizeof(G_pipeline));
        0x0800086e:    251c        .%      MOVS     r5,#0x1c
;;; ../Inc/nuts_bolts.h
;;;24         cb->buffer = malloc(capacity * sz);
        0x08000870:    f44f708c    O..p    MOV      r0,#0x118
        0x08000874:    f000f846    ..F.    BL       malloc ; 0x8000904
        0x08000878:    4914        .I      LDR      r1,[pc,#80] ; [0x80008cc] = 0x20000054
        0x0800087a:    6008        .`      STR      r0,[r1,#0]
;;;25         if(cb->buffer == NULL){
;;;26             // handle error
;;;27             }
;;;28         cb->buffer_end = (char *)cb->buffer + capacity * sz;
        0x0800087c:    fb040205    ....    MLA      r2,r4,r5,r0
        0x08000880:    604a        J`      STR      r2,[r1,#4]
;;;29         cb->capacity = capacity;
        0x08000882:    608c        .`      STR      r4,[r1,#8]
;;;30         cb->count = 0;
        0x08000884:    2200        ."      MOVS     r2,#0
        0x08000886:    60ca        .`      STR      r2,[r1,#0xc]
;;;31         cb->sz = sz;
        0x08000888:    610d        .a      STR      r5,[r1,#0x10]
;;;32         cb->head = cb->buffer;
        0x0800088a:    6148        Ha      STR      r0,[r1,#0x14]
;;;33         cb->tail = cb->buffer;
        0x0800088c:    61c8        .a      STR      r0,[r1,#0x1c]
;;;34     		cb->top  = cb->buffer;
        0x0800088e:    6188        .a      STR      r0,[r1,#0x18]
;;; .\../Src/main.c
;;;363    	G01parse("X0. Z-2.5 F1.");
        0x08000890:    a00f        ..      ADR      r0,{pc}+0x40 ; 0x80008d0
        0x08000892:    f7fffc93    ....    BL       G01parse ; 0x80001bc
;;;364    	G01parse("X10.");
        0x08000896:    a012        ..      ADR      r0,{pc}+0x4a ; 0x80008e0
        0x08000898:    f7fffc90    ....    BL       G01parse ; 0x80001bc
;;;365    //	G03parse("X14. Z-4.5 K-2.");
;;;366    	G03parse("X12. Z-4.5 I-1.99 K-2.245");
        0x0800089c:    a012        ..      ADR      r0,{pc}+0x4c ; 0x80008e8
        0x0800089e:    f7fffc93    ....    BL       G03parse ; 0x80001c8
;;;367    	
;;;368    	return 0;
        0x080008a2:    2000        .       MOVS     r0,#0
;;;369    
;;;370    
;;;371      /* Enable DMA TX Interrupt */
;;;372      LL_USART_EnableDMAReq_TX(USART2);
;;;373      /* Enable DMA Channel Tx */
;;;374      LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_7);
;;;375    
;;;376    /* Enable RXNE and Error interrupts */
;;;377      LL_USART_EnableIT_RXNE(USART2);
;;;378      LL_USART_EnableIT_ERROR(USART2);
;;;379    
;;;380    
;;;381    
;;;382    // Timers post init:
;;;383    	LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;384    //  LL_TIM_CC_EnableChannel(TIM2, LL_TIM_CHANNEL_CH1); // if we need output on leg
;;;385      LL_TIM_ClearFlag_UPDATE(TIM2);
;;;386    	LL_TIM_EnableIT_UPDATE(TIM2);
;;;387    
;;;388    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;389    
;;;390    
;;;391    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;392    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1);
;;;393    //	TIM3->SR = 0;
;;;394    //	TIM2->SR = 0;
;;;395    	TIM3->ARR = 0;
;;;396    	LL_TIM_GenerateEvent_UPDATE(TIM3);
;;;397    	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
;;;398    	TIM3->SR = 0;
;;;399    	LL_TIM_EnableIT_UPDATE(TIM3);
;;;400    
;;;401    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;402    
;;;403    
;;;404    
;;;405    	if(LL_GPIO_IsInputPinSet(BUTTON_1_GPIO_Port, BUTTON_1_Pin)){
;;;406    		demo = true;
;;;407    	}
;;;408    //	MOTOR_Z_Disable();
;;;409    //	MOTOR_X_Disable();
;;;410    //  
;;;411    #ifndef _SIMU
;;;412    	Activate_I2C_Master();
;;;413    	init_screen(I2C2);
;;;414    //	update_screen();
;;;415    //	i2c_device_init(I2C2);
;;;416    	LL_mDelay(250);
;;;417    #endif
;;;418    	init_buttons();
;;;419    	
;;;420    
;;;421      /* USER CODE END 2 */
;;;422    
;;;423      /* Infinite loop */
;;;424      /* USER CODE BEGIN WHILE */
;;;425    
;;;426    
;;;427    ///// from STM examples:
;;;428    //  /**************************/
;;;429    //  /* Start pulse generation */
;;;430    //  /**************************/
;;;431    //  /* Enable channel 1 */
;;;432    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;433    //  
;;;434    //  /* Enable TIM3 outputs */
;;;435    //  LL_TIM_EnableAllOutputs(TIM3);
;;;436    //  
;;;437    //  /* Enable auto-reload register preload */
;;;438    //  LL_TIM_EnableARRPreload(TIM3);
;;;439    
;;;440    //  /* Force update generation */
;;;441    //  LL_TIM_GenerateEvent_UPDATE(TIM3);  
;;;442    
;;;443    
;;;444    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;445    
;;;446    
;;;447    
;;;448    
;;;449    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;450    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;451    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;452    
;;;453    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;454    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;455    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;456    
;;;457    
;;;458    //	MOTOR_X_BlockPulse(); // LL_TIM_OC_SetCompareCH3(TIM3, 0);
;;;459    //	MOTOR_Z_BlockPulse(); // LL_TIM_OC_SetCompareCH3(TIM3, 0);
;;;460    
;;;461    //LL_TIM_EnableCounter(TIM3);
;;;462    
;;;463    
;;;464    //TIM3->SR = 0;
;;;465    //TIM3->EGR |= TIM_EGR_UG;
;;;466    //		LL_TIM_GenerateEvent_UPDATE(TIM3); /* Force update generation */
;;;467    
;;;468    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1);
;;;469    	//GPIOB->BSRR
;;;470    //	LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_0);
;;;471    //	LL_mDelay(50);
;;;472    //	LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_0);
;;;473    //	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;474    	
;;;475    //	LL_TIM_EnableAllOutputs(TIM3);
;;;476    //MOTOR_X_AllowPulse();
;;;477    //MOTOR_Z_AllowPulse();
;;;478    //		LL_mDelay(50);
;;;479    //	LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;480      LL_TIM_EnableIT_CC3(TIM4);													// enable interrupts for TACHO events from encoder
;;;481      LL_TIM_EnableCounter(TIM4); 												//Enable timer 4
;;;482    //	enable_encoder_ticks(); 														// enable interrup for encoder ticks
;;;483    	TIM4->SR = 0; 																			// reset interrup flags
;;;484    
;;;485    //	LL_TIM_EnableIT_UPDATE(TIM1);
;;;486    //	LL_TIM_EnableIT_UPDATE(TIM2);
;;;487    //	LL_TIM_EnableCounter(TIM2);
;;;488    	
;;;489    //	do_fsm_move_start(&state);
;;;490    
;;;491    	
;;;492      /* Enable counter */
;;;493    //  LL_TIM_EnableCounter(TIM2);
;;;494      /* Force update generation */
;;;495    //  LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;496    
;;;497    // init buttons
;;;498    //	LL_mDelay(5);
;;;499    	do_fsm_menu(&state);
;;;500    //	LL_mDelay(5);
;;;501    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;502    	LED_GPIO_Port->BSRR = LED_Pin; // led off
;;;503    	while (1) {
;;;504        /* USER CODE END WHILE */
;;;505    
;;;506        /* USER CODE BEGIN 3 */
;;;507    #ifndef _SIMU		
;;;508    //		reqest_sample_i2c_dma(); // init reqest to joystick by DMA, when process_button complete i2c done its job
;;;509    #endif		
;;;510    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;511    		process_G_pipeline();
;;;512    		process_button();
;;;513    //		process_joystick();
;;;514    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;515    
;;;516    
;;;517    //		uint8_t level = Thread_Info[Menu_Step].level;
;;;518    
;;;519    //		if(auto_mode == true) {
;;;520    //			if ( auto_mode_delay == 0 ) {
;;;521    //				buttons_flag_set = single_click_Msk; //
;;;522    //			}
;;;523    //		}
;;;524    
;;;525    		if(buttons_flag_set) {
;;;526    			do_fsm_menu(&state);
;;;527    			buttons_flag_set = 0; // reset button flags
;;;528    		}
;;;529    
;;;530    		if(z_axis.ramp_step != rs) {
;;;531    			rs = z_axis.ramp_step;
;;;532    			menu_changed = 1;
;;;533    		}
;;;534    
;;;535    		if(z_axis.current_pos != rs) {
;;;536    			rs = z_axis.current_pos;
;;;537    //			menu_changed = 1;
;;;538    		}
;;;539    
;;;540    // update display info
;;;541    		if(menu_changed == 1){ // haltodo && hi2c2.hdmatx->State == HAL_DMA_STATE_READY) {
;;;542    			menu_changed = update_screen();
;;;543    		}
;;;544    	}
;;;545      /* USER CODE END 3 */
;;;546    }
        0x080008a4:    bdf8        ..      POP      {r3-r7,pc}
    $d
        0x080008a6:    0000        ..      DCW    0
        0x080008a8:    20000090    ...     DCD    536871056
        0x080008ac:    080007c7    ....    DCD    134219719
        0x080008b0:    40021000    ...@    DCD    1073876992
        0x080008b4:    e000ed0c    ....    DCD    3758157068
        0x080008b8:    05fa0000    ....    DCD    100270080
        0x080008bc:    40010000    ...@    DCD    1073807360
        0x080008c0:    40010c00    ...@    DCD    1073810432
        0x080008c4:    20000008    ...     DCD    536870920
        0x080008c8:    08000a1c    ....    DCD    134220316
        0x080008cc:    20000054    T..     DCD    536870996
        0x080008d0:    202e3058    X0.     DCD    539897944
        0x080008d4:    2e322d5a    Z-2.    DCD    775040346
        0x080008d8:    31462035    5 F1    DCD    826679349
        0x080008dc:    0000002e    ....    DCD    46
        0x080008e0:    2e303158    X10.    DCD    774910296
        0x080008e4:    00000000    ....    DCD    0
        0x080008e8:    2e323158    X12.    DCD    775041368
        0x080008ec:    342d5a20     Z-4    DCD    875387424
        0x080008f0:    4920352e    .5 I    DCD    1226847534
        0x080008f4:    392e312d    -1.9    DCD    959328557
        0x080008f8:    2d4b2039    9 K-    DCD    759898169
        0x080008fc:    34322e32    2.24    DCD    875703858
        0x08000900:    00000035    5...    DCD    53
    $t
    i.malloc
    malloc
        0x08000904:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000906:    300b        .0      ADDS     r0,r0,#0xb
        0x08000908:    4d15        .M      LDR      r5,[pc,#84] ; [0x8000960] = 0x20000030
        0x0800090a:    f0200107     ...    BIC      r1,r0,#7
        0x0800090e:    2400        .$      MOVS     r4,#0
        0x08000910:    4a14        .J      LDR      r2,[pc,#80] ; [0x8000964] = 0x2000002c
        0x08000912:    e00f        ..      B        0x8000934 ; malloc + 48
        0x08000914:    6803        .h      LDR      r3,[r0,#0]
        0x08000916:    428b        .B      CMP      r3,r1
        0x08000918:    d30b        ..      BCC      0x8000932 ; malloc + 46
        0x0800091a:    428b        .B      CMP      r3,r1
        0x0800091c:    d905        ..      BLS      0x800092a ; malloc + 38
        0x0800091e:    1a5e        ^.      SUBS     r6,r3,r1
        0x08000920:    1843        C.      ADDS     r3,r0,r1
        0x08000922:    6847        Gh      LDR      r7,[r0,#4]
        0x08000924:    e9c36700    ...g    STRD     r6,r7,[r3,#0]
        0x08000928:    e000        ..      B        0x800092c ; malloc + 40
        0x0800092a:    6843        Ch      LDR      r3,[r0,#4]
        0x0800092c:    6013        .`      STR      r3,[r2,#0]
        0x0800092e:    c002        ..      STM      r0!,{r1}
        0x08000930:    e004        ..      B        0x800093c ; malloc + 56
        0x08000932:    1d02        ..      ADDS     r2,r0,#4
        0x08000934:    6810        .h      LDR      r0,[r2,#0]
        0x08000936:    2800        .(      CMP      r0,#0
        0x08000938:    d1ec        ..      BNE      0x8000914 ; malloc + 16
        0x0800093a:    4620         F      MOV      r0,r4
        0x0800093c:    2800        .(      CMP      r0,#0
        0x0800093e:    d102        ..      BNE      0x8000946 ; malloc + 66
        0x08000940:    6828        (h      LDR      r0,[r5,#0]
        0x08000942:    b108        ..      CBZ      r0,0x8000948 ; malloc + 68
        0x08000944:    2000        .       MOVS     r0,#0
        0x08000946:    bdf0        ..      POP      {r4-r7,pc}
        0x08000948:    4a06        .J      LDR      r2,[pc,#24] ; [0x8000964] = 0x2000002c
        0x0800094a:    4807        .H      LDR      r0,[pc,#28] ; [0x8000968] = 0x2000010c
        0x0800094c:    6010        .`      STR      r0,[r2,#0]
        0x0800094e:    4a07        .J      LDR      r2,[pc,#28] ; [0x800096c] = 0x20000308
        0x08000950:    1a12        ..      SUBS     r2,r2,r0
        0x08000952:    f0220207    "...    BIC      r2,r2,#7
        0x08000956:    e9c02400    ...$    STRD     r2,r4,[r0,#0]
        0x0800095a:    2001        .       MOVS     r0,#1
        0x0800095c:    6028        (`      STR      r0,[r5,#0]
        0x0800095e:    e7d7        ..      B        0x8000910 ; malloc + 12
    $d
        0x08000960:    20000030    0..     DCD    536870960
        0x08000964:    2000002c    ,..     DCD    536870956
        0x08000968:    2000010c    ...     DCD    536871180
        0x0800096c:    20000308    ...     DCD    536871688
    $t
    i.str_f_to_steps2210
    str_f_to_steps2210
;;; .\..\Src\nuts_bolts.c
;;;215    int str_f_to_steps2210(char *line, uint8_t *char_counter){
        0x08000970:    e92d41f0    -..A    PUSH     {r4-r8,lr}
;;;216      char *str = line + *char_counter;
        0x08000974:    780a        .x      LDRB     r2,[r1,#0]
        0x08000976:    1815        ..      ADDS     r5,r2,r0
;;;217    
;;;218    	// minimum processed value is 0.001mm
;;;219        #define steps_per_unit_Z_2210   400<<10
;;;220    
;;;221    	uint8_t ten = 0;
        0x08000978:    2400        .$      MOVS     r4,#0
;;;222    	fixedpt t2210 = 0;
        0x0800097a:    2700        .'      MOVS     r7,#0
;;;223    	uint32_t number = 0;
        0x0800097c:    2200        ."      MOVS     r2,#0
;;;224    	bool negative = false;
        0x0800097e:    4694        .F      MOV      r12,r2
;;;225    	bool fract = false;
        0x08000980:    2600        .&      MOVS     r6,#0
        0x08000982:    e024        $.      B        0x80009ce ; str_f_to_steps2210 + 94
;;;226    	char c;
;;;227    	while ((c = *str) != 0) {
;;;228    		if (c >= '0' && c <= '9')   {
        0x08000984:    f1a30830    ..0.    SUB      r8,r3,#0x30
        0x08000988:    f1b80f09    ....    CMP      r8,#9
        0x0800098c:    d810        ..      BHI      0x80009b0 ; str_f_to_steps2210 + 64
;;;229    				if(fract==false){
        0x0800098e:    b14e        N.      CBZ      r6,0x80009a4 ; str_f_to_steps2210 + 52
;;;230    						number = number * 10 + (c - '0');
;;;231    				} else{
;;;232    						if(ten<3){
        0x08000990:    2c03        .,      CMP      r4,#3
        0x08000992:    d204        ..      BCS      0x800099e ; str_f_to_steps2210 + 46
;;;233    								number = number * 10 + (c - '0');
        0x08000994:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x08000998:    eb030242    ..B.    ADD      r2,r3,r2,LSL #1
        0x0800099c:    3a30        0:      SUBS     r2,r2,#0x30
;;;234    						}
;;;235    						ten++;
        0x0800099e:    1c64        d.      ADDS     r4,r4,#1
        0x080009a0:    b2e4        ..      UXTB     r4,r4
        0x080009a2:    e013        ..      B        0x80009cc ; str_f_to_steps2210 + 92
        0x080009a4:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x080009a8:    eb030242    ..B.    ADD      r2,r3,r2,LSL #1
        0x080009ac:    3a30        0:      SUBS     r2,r2,#0x30
        0x080009ae:    e00d        ..      B        0x80009cc ; str_f_to_steps2210 + 92
;;;236    				}
;;;237    		}	else if (c == '-')  {
        0x080009b0:    2b2d        -+      CMP      r3,#0x2d
        0x080009b2:    d002        ..      BEQ      0x80009ba ; str_f_to_steps2210 + 74
        0x080009b4:    2b2e        .+      CMP      r3,#0x2e
        0x080009b6:    d003        ..      BEQ      0x80009c0 ; str_f_to_steps2210 + 80
        0x080009b8:    e00c        ..      B        0x80009d4 ; str_f_to_steps2210 + 100
;;;238    				negative = true;
        0x080009ba:    f04f0c01    O...    MOV      r12,#1
        0x080009be:    e005        ..      B        0x80009cc ; str_f_to_steps2210 + 92
;;;239    		}	else if (c == '.') {
;;;240    				t2210 = number * steps_per_unit_Z_2210; //steps_per_unit_Z_2210 already in 2210 format
        0x080009c0:    f44f23c8    O..#    MOV      r3,#0x64000
        0x080009c4:    fb02f703    ....    MUL      r7,r2,r3
;;;241    				number = 0;
        0x080009c8:    2200        ."      MOVS     r2,#0
;;;242    				fract = true;
        0x080009ca:    2601        .&      MOVS     r6,#1
;;;243    		} else break;   
;;;244    		str++;
        0x080009cc:    1c6d        m.      ADDS     r5,r5,#1
        0x080009ce:    782b        +x      LDRB     r3,[r5,#0]
        0x080009d0:    2b00        .+      CMP      r3,#0
        0x080009d2:    d1d7        ..      BNE      0x8000984 ; str_f_to_steps2210 + 20
;;;245    	}
;;;246    //    if (endptr != 0) *endptr = (char *)str;
;;;247    	*char_counter = str - line - 1; // Set char_counter to next statement
        0x080009d4:    1a28        (.      SUBS     r0,r5,r0
        0x080009d6:    1e40        @.      SUBS     r0,r0,#1
        0x080009d8:    7008        .p      STRB     r0,[r1,#0]
;;;248    
;;;249    	switch(ten){
        0x080009da:    2c01        .,      CMP      r4,#1
        0x080009dc:    d002        ..      BEQ      0x80009e4 ; str_f_to_steps2210 + 116
        0x080009de:    2c02        .,      CMP      r4,#2
        0x080009e0:    d106        ..      BNE      0x80009f0 ; str_f_to_steps2210 + 128
        0x080009e2:    e002        ..      B        0x80009ea ; str_f_to_steps2210 + 122
;;;250    			case 1:{ // if only one fract didgit in g-code
;;;251    					number *= 100;
        0x080009e4:    2064        d       MOVS     r0,#0x64
        0x080009e6:    4342        BC      MULS     r2,r0,r2
;;;252    					break;
        0x080009e8:    e002        ..      B        0x80009f0 ; str_f_to_steps2210 + 128
;;;253    			}
;;;254    			case 2:{// if only two fract didgits in g-code
;;;255    					number *= 10;
        0x080009ea:    eb020082    ....    ADD      r0,r2,r2,LSL #2
        0x080009ee:    0042        B.      LSLS     r2,r0,#1
;;;256    					break;
;;;257    			}
;;;258    	}
;;;259    
;;;260    //  t2210 += ((number * 419430) >> 10); // quick divide for 400 steps/mm, 400/1000 = 4/10, number<<10*4/10 = number<<12/10. 
;;;261    	t2210 += ((number << 10) * 400 / 1000);
        0x080009f0:    f44f20c8    O..     MOV      r0,#0x64000
        0x080009f4:    4342        BC      MULS     r2,r0,r2
        0x080009f6:    f44f707a    O.zp    MOV      r0,#0x3e8
        0x080009fa:    fbb2f0f0    ....    UDIV     r0,r2,r0
        0x080009fe:    4438        8D      ADD      r0,r0,r7
;;;262    	
;;;263    //  t2210 += (( number * steps_per_unit_Z_fract_2210 ) / 10 );
;;;264    	if (negative) return -t2210;
        0x08000a00:    f1bc0f00    ....    CMP      r12,#0
        0x08000a04:    d000        ..      BEQ      0x8000a08 ; str_f_to_steps2210 + 152
        0x08000a06:    4240        @B      RSBS     r0,r0,#0
;;;265    	else return t2210;
;;;266    }
        0x08000a08:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d.realdata
    .constdata
    CHANNEL_OFFSET_TAB
        0x08000a0c:    44301c08    ..0D    DCD    1144003592
        0x08000a10:    00806c58    Xl..    DCD    8416344
    .constdata
    CHANNEL_OFFSET_TAB
        0x08000a14:    44301c08    ..0D    DCD    1144003592
        0x08000a18:    00806c58    Xl..    DCD    8416344
    Thread_Info
        0x08000a1c:    06000000    ....    DCD    100663296
        0x08000a20:    352e3100    .1.5    DCD    892219648
        0x08000a24:    6d000030    0..m    DCD    1828716592
        0x08000a28:    0000006d    m...    DCD    109
        0x08000a2c:    392e0000    ...9    DCD    959315968
        0x08000a30:    00000035    5...    DCD    53
        0x08000a34:    3733302e    .037    DCD    926101550
        0x08000a38:    00000000    ....    DCD    0
    Region$$Table$$Base
        0x08000a3c:    08000a5c    \...    DCD    134220380
        0x08000a40:    20000000    ...     DCD    536870912
        0x08000a44:    00000034    4...    DCD    52
        0x08000a48:    080007a8    ....    DCD    134219688
        0x08000a4c:    08000a90    ....    DCD    134220432
        0x08000a50:    20000034    4..     DCD    536870964
        0x08000a54:    00000994    ....    DCD    2452
        0x08000a58:    080007b8    ....    DCD    134219704
    Region$$Table$$Limit

** Section #2 'RW_IRAM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 52 bytes (alignment 4)
    Address: 0x20000000


** Section #3 'RW_IRAM1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 2452 bytes (alignment 8)
    Address: 0x20000034


** Section #4 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #5 '.debug_frame' (SHT_PROGBITS)
    Size   : 1572 bytes


** Section #6 '.debug_info' (SHT_PROGBITS)
    Size   : 124260 bytes


** Section #7 '.debug_line' (SHT_PROGBITS)
    Size   : 10844 bytes


** Section #8 '.debug_loc' (SHT_PROGBITS)
    Size   : 1792 bytes


** Section #9 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 460636 bytes


** Section #10 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 2318 bytes


** Section #11 '.symtab' (SHT_SYMTAB)
    Size   : 4960 bytes (alignment 4)
    String table #12 '.strtab'
    Last local symbol no. 184


** Section #12 '.strtab' (SHT_STRTAB)
    Size   : 4928 bytes


** Section #13 '.note' (SHT_NOTE)
    Size   : 28 bytes (alignment 4)


** Section #14 '.comment' (SHT_PROGBITS)
    Size   : 27884 bytes


** Section #15 '.shstrtab' (SHT_STRTAB)
    Size   : 156 bytes


