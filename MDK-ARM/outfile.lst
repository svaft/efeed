
========================================================================

** ELF Header Information

    File Name: C:\STM32\project\efeed\MDK-ARM\efeed\efeed.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x080000ed
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_SOFT (0x05000202)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Soft float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 1
    Section header entries: 16

    Program header offset: 839644 (0x000ccfdc)
    Section header offset: 839676 (0x000ccffc)

    Section header string table index: 15

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 16048 bytes (13444 bytes in file)
    Virtual address: 0x08000000 (Alignment 8)


========================================================================

** Section #1 'ER_IROM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 13032 bytes (alignment 8)
    Address: 0x08000000

    $d.realdata
    RESET
    __Vectors
        0x08000000:    20000bc8    ...     DCD    536873928
        0x08000004:    08000101    ....    DCD    134217985
        0x08000008:    08000109    ....    DCD    134217993
        0x0800000c:    0800010b    ....    DCD    134217995
        0x08000010:    0800010d    ....    DCD    134217997
        0x08000014:    0800010f    ....    DCD    134217999
        0x08000018:    08000111    ....    DCD    134218001
        0x0800001c:    00000000    ....    DCD    0
        0x08000020:    00000000    ....    DCD    0
        0x08000024:    00000000    ....    DCD    0
        0x08000028:    00000000    ....    DCD    0
        0x0800002c:    08001d35    5...    DCD    134225205
        0x08000030:    08000115    ....    DCD    134218005
        0x08000034:    00000000    ....    DCD    0
        0x08000038:    08001c35    5...    DCD    134224949
        0x0800003c:    08001d39    9...    DCD    134225209
        0x08000040:    0800011b    ....    DCD    134218011
        0x08000044:    0800011b    ....    DCD    134218011
        0x08000048:    0800011b    ....    DCD    134218011
        0x0800004c:    0800011b    ....    DCD    134218011
        0x08000050:    0800011b    ....    DCD    134218011
        0x08000054:    0800011b    ....    DCD    134218011
        0x08000058:    0800011b    ....    DCD    134218011
        0x0800005c:    0800011b    ....    DCD    134218011
        0x08000060:    0800011b    ....    DCD    134218011
        0x08000064:    0800011b    ....    DCD    134218011
        0x08000068:    0800011b    ....    DCD    134218011
        0x0800006c:    0800011b    ....    DCD    134218011
        0x08000070:    0800011b    ....    DCD    134218011
        0x08000074:    0800011b    ....    DCD    134218011
        0x08000078:    080006e5    ....    DCD    134219493
        0x0800007c:    0800011b    ....    DCD    134218011
        0x08000080:    0800011b    ....    DCD    134218011
        0x08000084:    0800071d    ....    DCD    134219549
        0x08000088:    0800011b    ....    DCD    134218011
        0x0800008c:    0800011b    ....    DCD    134218011
        0x08000090:    0800011b    ....    DCD    134218011
        0x08000094:    0800011b    ....    DCD    134218011
        0x08000098:    0800011b    ....    DCD    134218011
        0x0800009c:    0800011b    ....    DCD    134218011
        0x080000a0:    0800011b    ....    DCD    134218011
        0x080000a4:    08001ed9    ....    DCD    134225625
        0x080000a8:    0800011b    ....    DCD    134218011
        0x080000ac:    0800011b    ....    DCD    134218011
        0x080000b0:    08001ef9    ....    DCD    134225657
        0x080000b4:    08001f41    A...    DCD    134225729
        0x080000b8:    08001f45    E...    DCD    134225733
        0x080000bc:    0800011b    ....    DCD    134218011
        0x080000c0:    0800011b    ....    DCD    134218011
        0x080000c4:    080007d1    ....    DCD    134219729
        0x080000c8:    080007cd    ....    DCD    134219725
        0x080000cc:    0800011b    ....    DCD    134218011
        0x080000d0:    0800011b    ....    DCD    134218011
        0x080000d4:    0800011b    ....    DCD    134218011
        0x080000d8:    08001ff9    ....    DCD    134225913
        0x080000dc:    0800011b    ....    DCD    134218011
        0x080000e0:    0800011b    ....    DCD    134218011
        0x080000e4:    0800011b    ....    DCD    134218011
        0x080000e8:    0800011b    ....    DCD    134218011
    $t
    .ARM.Collect$$$$00000000
    .ARM.Collect$$$$00000001
    __Vectors_End
    __main
    _main_stk
        0x080000ec:    f8dfd00c    ....    LDR      sp,__lit__00000000 ; [0x80000fc] = 0x20000bc8
    .ARM.Collect$$$$00000004
    _main_scatterload
        0x080000f0:    f000faba    ....    BL       __scatterload ; 0x8000668
    .ARM.Collect$$$$00000008
    .ARM.Collect$$$$0000000A
    .ARM.Collect$$$$0000000B
    __main_after_scatterload
    _main_clock
    _main_cpp_init
    _main_init
        0x080000f4:    4800        .H      LDR      r0,[pc,#0] ; [0x80000f8] = 0x80029a9
        0x080000f6:    4700        .G      BX       r0
    $d
        0x080000f8:    080029a9    .)..    DCD    134228393
    .ARM.Collect$$$$00002712
    __lit__00000000
    .ARM.Collect$$$$0000000D
    .ARM.Collect$$$$0000000F
    __rt_final_cpp
    __rt_final_exit
        0x080000fc:    20000bc8    ...     DCD    536873928
    $t
    .text
    Reset_Handler
;;;150                     LDR     R0, =SystemInit
        0x08000100:    4806        .H      LDR      r0,[pc,#24] ; [0x800011c] = 0x8001e81
;;;151                     BLX     R0
        0x08000102:    4780        .G      BLX      r0
;;;152                     LDR     R0, =__main
        0x08000104:    4806        .H      LDR      r0,[pc,#24] ; [0x8000120] = 0x80000ed
;;;153                     BX      R0
        0x08000106:    4700        .G      BX       r0
    NMI_Handler
;;;154                     ENDP
;;;155    
;;;156    ; Dummy Exception Handlers (infinite loops which can be modified)
;;;157    
;;;158    NMI_Handler     PROC
;;;159                    EXPORT  NMI_Handler                [WEAK]
;;;160                    B       .
        0x08000108:    e7fe        ..      B        NMI_Handler ; 0x8000108
    HardFault_Handler
;;;161                    ENDP
;;;162    HardFault_Handler\
;;;163                    PROC
;;;164                    EXPORT  HardFault_Handler          [WEAK]
;;;165                    B       .
        0x0800010a:    e7fe        ..      B        HardFault_Handler ; 0x800010a
    MemManage_Handler
;;;166                    ENDP
;;;167    MemManage_Handler\
;;;168                    PROC
;;;169                    EXPORT  MemManage_Handler          [WEAK]
;;;170                    B       .
        0x0800010c:    e7fe        ..      B        MemManage_Handler ; 0x800010c
    BusFault_Handler
;;;171                    ENDP
;;;172    BusFault_Handler\
;;;173                    PROC
;;;174                    EXPORT  BusFault_Handler           [WEAK]
;;;175                    B       .
        0x0800010e:    e7fe        ..      B        BusFault_Handler ; 0x800010e
    UsageFault_Handler
;;;176                    ENDP
;;;177    UsageFault_Handler\
;;;178                    PROC
;;;179                    EXPORT  UsageFault_Handler         [WEAK]
;;;180                    B       .
        0x08000110:    e7fe        ..      B        UsageFault_Handler ; 0x8000110
;;;181                    ENDP
;;;182    SVC_Handler     PROC
;;;183                    EXPORT  SVC_Handler                [WEAK]
;;;184                    B       .
        0x08000112:    e7fe        ..      B        0x8000112 ; UsageFault_Handler + 2
    DebugMon_Handler
;;;185                    ENDP
;;;186    DebugMon_Handler\
;;;187                    PROC
;;;188                    EXPORT  DebugMon_Handler           [WEAK]
;;;189                    B       .
        0x08000114:    e7fe        ..      B        DebugMon_Handler ; 0x8000114
;;;190                    ENDP
;;;191    PendSV_Handler  PROC
;;;192                    EXPORT  PendSV_Handler             [WEAK]
;;;193                    B       .
        0x08000116:    e7fe        ..      B        0x8000116 ; DebugMon_Handler + 2
;;;194                    ENDP
;;;195    SysTick_Handler PROC
;;;196                    EXPORT  SysTick_Handler            [WEAK]
;;;197                    B       .
        0x08000118:    e7fe        ..      B        0x8000118 ; DebugMon_Handler + 4
    ADC1_2_IRQHandler
    CAN1_RX1_IRQHandler
    CAN1_SCE_IRQHandler
    DMA1_Channel1_IRQHandler
    DMA1_Channel2_IRQHandler
    DMA1_Channel3_IRQHandler
    DMA1_Channel5_IRQHandler
    DMA1_Channel6_IRQHandler
    EXTI0_IRQHandler
    EXTI15_10_IRQHandler
    EXTI1_IRQHandler
    EXTI2_IRQHandler
    EXTI3_IRQHandler
    EXTI4_IRQHandler
    EXTI9_5_IRQHandler
    FLASH_IRQHandler
    I2C1_ER_IRQHandler
    I2C1_EV_IRQHandler
    PVD_IRQHandler
    RCC_IRQHandler
    RTC_Alarm_IRQHandler
    RTC_IRQHandler
    SPI1_IRQHandler
    SPI2_IRQHandler
    TAMPER_IRQHandler
    TIM1_BRK_IRQHandler
    TIM1_CC_IRQHandler
    TIM1_TRG_COM_IRQHandler
    USART1_IRQHandler
    USART3_IRQHandler
    USBWakeUp_IRQHandler
    USB_HP_CAN1_TX_IRQHandler
    USB_LP_CAN1_RX0_IRQHandler
    WWDG_IRQHandler
;;;198                    ENDP
;;;199    
;;;200    Default_Handler PROC
;;;201    
;;;202                    EXPORT  WWDG_IRQHandler            [WEAK]
;;;203                    EXPORT  PVD_IRQHandler             [WEAK]
;;;204                    EXPORT  TAMPER_IRQHandler          [WEAK]
;;;205                    EXPORT  RTC_IRQHandler             [WEAK]
;;;206                    EXPORT  FLASH_IRQHandler           [WEAK]
;;;207                    EXPORT  RCC_IRQHandler             [WEAK]
;;;208                    EXPORT  EXTI0_IRQHandler           [WEAK]
;;;209                    EXPORT  EXTI1_IRQHandler           [WEAK]
;;;210                    EXPORT  EXTI2_IRQHandler           [WEAK]
;;;211                    EXPORT  EXTI3_IRQHandler           [WEAK]
;;;212                    EXPORT  EXTI4_IRQHandler           [WEAK]
;;;213                    EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
;;;214                    EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
;;;215                    EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
;;;216                    EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
;;;217                    EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
;;;218                    EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
;;;219                    EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
;;;220                    EXPORT  ADC1_2_IRQHandler          [WEAK]
;;;221                    EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
;;;222                    EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
;;;223                    EXPORT  CAN1_RX1_IRQHandler        [WEAK]
;;;224                    EXPORT  CAN1_SCE_IRQHandler        [WEAK]
;;;225                    EXPORT  EXTI9_5_IRQHandler         [WEAK]
;;;226                    EXPORT  TIM1_BRK_IRQHandler        [WEAK]
;;;227                    EXPORT  TIM1_UP_IRQHandler         [WEAK]
;;;228                    EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
;;;229                    EXPORT  TIM1_CC_IRQHandler         [WEAK]
;;;230                    EXPORT  TIM2_IRQHandler            [WEAK]
;;;231                    EXPORT  TIM3_IRQHandler            [WEAK]
;;;232                    EXPORT  TIM4_IRQHandler            [WEAK]
;;;233                    EXPORT  I2C1_EV_IRQHandler         [WEAK]
;;;234                    EXPORT  I2C1_ER_IRQHandler         [WEAK]
;;;235                    EXPORT  I2C2_EV_IRQHandler         [WEAK]
;;;236                    EXPORT  I2C2_ER_IRQHandler         [WEAK]
;;;237                    EXPORT  SPI1_IRQHandler            [WEAK]
;;;238                    EXPORT  SPI2_IRQHandler            [WEAK]
;;;239                    EXPORT  USART1_IRQHandler          [WEAK]
;;;240                    EXPORT  USART2_IRQHandler          [WEAK]
;;;241                    EXPORT  USART3_IRQHandler          [WEAK]
;;;242                    EXPORT  EXTI15_10_IRQHandler       [WEAK]
;;;243                    EXPORT  RTC_Alarm_IRQHandler        [WEAK]
;;;244                    EXPORT  USBWakeUp_IRQHandler       [WEAK]
;;;245    
;;;246    WWDG_IRQHandler
;;;247    PVD_IRQHandler
;;;248    TAMPER_IRQHandler
;;;249    RTC_IRQHandler
;;;250    FLASH_IRQHandler
;;;251    RCC_IRQHandler
;;;252    EXTI0_IRQHandler
;;;253    EXTI1_IRQHandler
;;;254    EXTI2_IRQHandler
;;;255    EXTI3_IRQHandler
;;;256    EXTI4_IRQHandler
;;;257    DMA1_Channel1_IRQHandler
;;;258    DMA1_Channel2_IRQHandler
;;;259    DMA1_Channel3_IRQHandler
;;;260    DMA1_Channel4_IRQHandler
;;;261    DMA1_Channel5_IRQHandler
;;;262    DMA1_Channel6_IRQHandler
;;;263    DMA1_Channel7_IRQHandler
;;;264    ADC1_2_IRQHandler
;;;265    USB_HP_CAN1_TX_IRQHandler
;;;266    USB_LP_CAN1_RX0_IRQHandler
;;;267    CAN1_RX1_IRQHandler
;;;268    CAN1_SCE_IRQHandler
;;;269    EXTI9_5_IRQHandler
;;;270    TIM1_BRK_IRQHandler
;;;271    TIM1_UP_IRQHandler
;;;272    TIM1_TRG_COM_IRQHandler
;;;273    TIM1_CC_IRQHandler
;;;274    TIM2_IRQHandler
;;;275    TIM3_IRQHandler
;;;276    TIM4_IRQHandler
;;;277    I2C1_EV_IRQHandler
;;;278    I2C1_ER_IRQHandler
;;;279    I2C2_EV_IRQHandler
;;;280    I2C2_ER_IRQHandler
;;;281    SPI1_IRQHandler
;;;282    SPI2_IRQHandler
;;;283    USART1_IRQHandler
;;;284    USART2_IRQHandler
;;;285    USART3_IRQHandler
;;;286    EXTI15_10_IRQHandler
;;;287    RTC_Alarm_IRQHandler
;;;288    USBWakeUp_IRQHandler
;;;289    
;;;290                    B       .
        0x0800011a:    e7fe        ..      B        ADC1_2_IRQHandler ; 0x800011a
    $d
        0x0800011c:    08001e81    ....    DCD    134225537
        0x08000120:    080000ed    ....    DCD    134217965
    $t
    .text
    __aeabi_uldivmod
        0x08000124:    e92d5ff0    -.._    PUSH     {r4-r12,lr}
        0x08000128:    4605        .F      MOV      r5,r0
        0x0800012a:    2000        .       MOVS     r0,#0
        0x0800012c:    4692        .F      MOV      r10,r2
        0x0800012e:    469b        .F      MOV      r11,r3
        0x08000130:    4688        .F      MOV      r8,r1
        0x08000132:    4606        .F      MOV      r6,r0
        0x08000134:    4681        .F      MOV      r9,r0
        0x08000136:    2440        @$      MOVS     r4,#0x40
        0x08000138:    e01b        ..      B        0x8000172 ; __aeabi_uldivmod + 78
        0x0800013a:    4628        (F      MOV      r0,r5
        0x0800013c:    4641        AF      MOV      r1,r8
        0x0800013e:    4647        GF      MOV      r7,r8
        0x08000140:    4622        "F      MOV      r2,r4
        0x08000142:    f000fa12    ....    BL       __aeabi_llsr ; 0x800056a
        0x08000146:    4653        SF      MOV      r3,r10
        0x08000148:    465a        ZF      MOV      r2,r11
        0x0800014a:    1ac0        ..      SUBS     r0,r0,r3
        0x0800014c:    4191        .A      SBCS     r1,r1,r2
        0x0800014e:    d310        ..      BCC      0x8000172 ; __aeabi_uldivmod + 78
        0x08000150:    4611        .F      MOV      r1,r2
        0x08000152:    4618        .F      MOV      r0,r3
        0x08000154:    4622        "F      MOV      r2,r4
        0x08000156:    f000f9f9    ....    BL       __aeabi_llsl ; 0x800054c
        0x0800015a:    1a2d        -.      SUBS     r5,r5,r0
        0x0800015c:    eb670801    g...    SBC      r8,r7,r1
        0x08000160:    464f        OF      MOV      r7,r9
        0x08000162:    4622        "F      MOV      r2,r4
        0x08000164:    2001        .       MOVS     r0,#1
        0x08000166:    2100        .!      MOVS     r1,#0
        0x08000168:    f000f9f0    ....    BL       __aeabi_llsl ; 0x800054c
        0x0800016c:    eb170900    ....    ADDS     r9,r7,r0
        0x08000170:    414e        NA      ADCS     r6,r6,r1
        0x08000172:    1e20         .      SUBS     r0,r4,#0
        0x08000174:    f1a40401    ....    SUB      r4,r4,#1
        0x08000178:    dcdf        ..      BGT      0x800013a ; __aeabi_uldivmod + 22
        0x0800017a:    4648        HF      MOV      r0,r9
        0x0800017c:    4631        1F      MOV      r1,r6
        0x0800017e:    462a        *F      MOV      r2,r5
        0x08000180:    4643        CF      MOV      r3,r8
        0x08000182:    e8bd9ff0    ....    POP      {r4-r12,pc}
    .text
    __aeabi_memset
    __aeabi_memset4
    __aeabi_memset8
        0x08000186:    b2d2        ..      UXTB     r2,r2
        0x08000188:    e001        ..      B        0x800018e ; __aeabi_memset + 8
        0x0800018a:    f8002b01    ...+    STRB     r2,[r0],#1
        0x0800018e:    1e49        I.      SUBS     r1,r1,#1
        0x08000190:    d2fb        ..      BCS      0x800018a ; __aeabi_memset + 4
        0x08000192:    4770        pG      BX       lr
    __aeabi_memclr
    __aeabi_memclr4
    __aeabi_memclr8
        0x08000194:    2200        ."      MOVS     r2,#0
        0x08000196:    e7f6        ..      B        __aeabi_memset ; 0x8000186
    _memset$wrapper
        0x08000198:    b510        ..      PUSH     {r4,lr}
        0x0800019a:    4613        .F      MOV      r3,r2
        0x0800019c:    460a        .F      MOV      r2,r1
        0x0800019e:    4604        .F      MOV      r4,r0
        0x080001a0:    4619        .F      MOV      r1,r3
        0x080001a2:    f7fffff0    ....    BL       __aeabi_memset ; 0x8000186
        0x080001a6:    4620         F      MOV      r0,r4
        0x080001a8:    bd10        ..      POP      {r4,pc}
    .text
    __aeabi_dadd
        0x080001aa:    e92d4ffe    -..O    PUSH     {r1-r11,lr}
        0x080001ae:    4680        .F      MOV      r8,r0
        0x080001b0:    ea810003    ....    EOR      r0,r1,r3
        0x080001b4:    0fc0        ..      LSRS     r0,r0,#31
        0x080001b6:    460c        .F      MOV      r4,r1
        0x080001b8:    9000        ..      STR      r0,[sp,#0]
        0x080001ba:    f0214100    !..A    BIC      r1,r1,#0x80000000
        0x080001be:    f0234500    #..E    BIC      r5,r3,#0x80000000
        0x080001c2:    ebb80002    ....    SUBS     r0,r8,r2
        0x080001c6:    41a9        .A      SBCS     r1,r1,r5
        0x080001c8:    d205        ..      BCS      0x80001d6 ; __aeabi_dadd + 44
        0x080001ca:    4640        @F      MOV      r0,r8
        0x080001cc:    4621        !F      MOV      r1,r4
        0x080001ce:    4690        .F      MOV      r8,r2
        0x080001d0:    461c        .F      MOV      r4,r3
        0x080001d2:    460b        .F      MOV      r3,r1
        0x080001d4:    4602        .F      MOV      r2,r0
        0x080001d6:    f0234000    #..@    BIC      r0,r3,#0x80000000
        0x080001da:    4310        .C      ORRS     r0,r0,r2
        0x080001dc:    d047        G.      BEQ      0x800026e ; __aeabi_dadd + 196
        0x080001de:    0d27        '.      LSRS     r7,r4,#20
        0x080001e0:    f3c7000a    ....    UBFX     r0,r7,#0,#11
        0x080001e4:    f3c3510a    ...Q    UBFX     r1,r3,#20,#11
        0x080001e8:    9002        ..      STR      r0,[sp,#8]
        0x080001ea:    1a40        @.      SUBS     r0,r0,r1
        0x080001ec:    9001        ..      STR      r0,[sp,#4]
        0x080001ee:    2840        @(      CMP      r0,#0x40
        0x080001f0:    da6b        k.      BGE      0x80002ca ; __aeabi_dadd + 288
        0x080001f2:    f3c30013    ....    UBFX     r0,r3,#0,#20
        0x080001f6:    f4401b80    @...    ORR      r11,r0,#0x100000
        0x080001fa:    9800        ..      LDR      r0,[sp,#0]
        0x080001fc:    4692        .F      MOV      r10,r2
        0x080001fe:    b120         .      CBZ      r0,0x800020a ; __aeabi_dadd + 96
        0x08000200:    2300        .#      MOVS     r3,#0
        0x08000202:    ebd20a03    ....    RSBS     r10,r2,r3
        0x08000206:    eb630b0b    c...    SBC      r11,r3,r11
        0x0800020a:    9801        ..      LDR      r0,[sp,#4]
        0x0800020c:    4659        YF      MOV      r1,r11
        0x0800020e:    f1c00240    ..@.    RSB      r2,r0,#0x40
        0x08000212:    4650        PF      MOV      r0,r10
        0x08000214:    f000f99a    ....    BL       __aeabi_llsl ; 0x800054c
        0x08000218:    4606        .F      MOV      r6,r0
        0x0800021a:    460d        .F      MOV      r5,r1
        0x0800021c:    4650        PF      MOV      r0,r10
        0x0800021e:    4659        YF      MOV      r1,r11
        0x08000220:    9a01        ..      LDR      r2,[sp,#4]
        0x08000222:    f000f9b2    ....    BL       __aeabi_lasr ; 0x800058a
        0x08000226:    eb100008    ....    ADDS     r0,r0,r8
        0x0800022a:    4161        aA      ADCS     r1,r1,r4
        0x0800022c:    2400        .$      MOVS     r4,#0
        0x0800022e:    ea875211    ...R    EOR      r2,r7,r1,LSR #20
        0x08000232:    ea8473e7    ...s    EOR      r3,r4,r7,ASR #31
        0x08000236:    431a        .C      ORRS     r2,r2,r3
        0x08000238:    d040        @.      BEQ      0x80002bc ; __aeabi_dadd + 274
        0x0800023a:    9a00        ..      LDR      r2,[sp,#0]
        0x0800023c:    b362        b.      CBZ      r2,0x8000298 ; __aeabi_dadd + 238
        0x0800023e:    9a01        ..      LDR      r2,[sp,#4]
        0x08000240:    2a01        .*      CMP      r2,#1
        0x08000242:    ea4f5207    O..R    LSL      r2,r7,#20
        0x08000246:    dc15        ..      BGT      0x8000274 ; __aeabi_dadd + 202
        0x08000248:    1b00        ..      SUBS     r0,r0,r4
        0x0800024a:    eb610102    a...    SBC      r1,r1,r2
        0x0800024e:    f04f4200    O..B    MOV      r2,#0x80000000
        0x08000252:    ea025207    ...R    AND      r2,r2,r7,LSL #20
        0x08000256:    e9cd4200    ...B    STRD     r4,r2,[sp,#0]
        0x0800025a:    1c00        ..      ADDS     r0,r0,#0
        0x0800025c:    f5411180    A...    ADC      r1,r1,#0x100000
        0x08000260:    4632        2F      MOV      r2,r6
        0x08000262:    462b        +F      MOV      r3,r5
        0x08000264:    f000f9b2    ....    BL       _double_epilogue ; 0x80005cc
        0x08000268:    b003        ..      ADD      sp,sp,#0xc
        0x0800026a:    e8bd8ff0    ....    POP      {r4-r11,pc}
        0x0800026e:    4640        @F      MOV      r0,r8
        0x08000270:    4621        !F      MOV      r1,r4
        0x08000272:    e7f9        ..      B        0x8000268 ; __aeabi_dadd + 190
        0x08000274:    1b00        ..      SUBS     r0,r0,r4
        0x08000276:    eb610102    a...    SBC      r1,r1,r2
        0x0800027a:    1c00        ..      ADDS     r0,r0,#0
        0x0800027c:    f5411380    A...    ADC      r3,r1,#0x100000
        0x08000280:    1800        ..      ADDS     r0,r0,r0
        0x08000282:    415b        [A      ADCS     r3,r3,r3
        0x08000284:    1820         .      ADDS     r0,r4,r0
        0x08000286:    f5a21700    ....    SUB      r7,r2,#0x200000
        0x0800028a:    eb470103    G...    ADC      r1,r7,r3
        0x0800028e:    ea4070d5    @..p    ORR      r0,r0,r5,LSR #31
        0x08000292:    19b6        ..      ADDS     r6,r6,r6
        0x08000294:    416d        mA      ADCS     r5,r5,r5
        0x08000296:    e011        ..      B        0x80002bc ; __aeabi_dadd + 274
        0x08000298:    086d        m.      LSRS     r5,r5,#1
        0x0800029a:    ea4f0636    O.6.    RRX      r6,r6
        0x0800029e:    ea4575c0    E..u    ORR      r5,r5,r0,LSL #31
        0x080002a2:    ea4f5207    O..R    LSL      r2,r7,#20
        0x080002a6:    1b00        ..      SUBS     r0,r0,r4
        0x080002a8:    eb610102    a...    SBC      r1,r1,r2
        0x080002ac:    1c00        ..      ADDS     r0,r0,#0
        0x080002ae:    f5411180    A...    ADC      r1,r1,#0x100000
        0x080002b2:    0849        I.      LSRS     r1,r1,#1
        0x080002b4:    ea4f0030    O.0.    RRX      r0,r0
        0x080002b8:    1900        ..      ADDS     r0,r0,r4
        0x080002ba:    4151        QA      ADCS     r1,r1,r2
        0x080002bc:    4632        2F      MOV      r2,r6
        0x080002be:    462b        +F      MOV      r3,r5
        0x080002c0:    b003        ..      ADD      sp,sp,#0xc
        0x080002c2:    e8bd4ff0    ...O    POP      {r4-r11,lr}
        0x080002c6:    f000b972    ..r.    B.W      __I$use$fp ; 0x80005ae
        0x080002ca:    9800        ..      LDR      r0,[sp,#0]
        0x080002cc:    2201        ."      MOVS     r2,#1
        0x080002ce:    0040        @.      LSLS     r0,r0,#1
        0x080002d0:    2300        .#      MOVS     r3,#0
        0x080002d2:    ebd00202    ....    RSBS     r2,r0,r2
        0x080002d6:    eb6373e0    c..s    SBC      r3,r3,r0,ASR #31
        0x080002da:    9800        ..      LDR      r0,[sp,#0]
        0x080002dc:    4621        !F      MOV      r1,r4
        0x080002de:    ea4f74e0    O..t    ASR      r4,r0,#31
        0x080002e2:    ebb80000    ....    SUBS     r0,r8,r0
        0x080002e6:    eb610104    a...    SBC      r1,r1,r4
        0x080002ea:    e7e9        ..      B        0x80002c0 ; __aeabi_dadd + 278
    __aeabi_dsub
        0x080002ec:    f0834300    ...C    EOR      r3,r3,#0x80000000
        0x080002f0:    e75b        [.      B        __aeabi_dadd ; 0x80001aa
    __aeabi_drsub
        0x080002f2:    f0814100    ...A    EOR      r1,r1,#0x80000000
        0x080002f6:    e758        X.      B        __aeabi_dadd ; 0x80001aa
    .text
    __aeabi_dmul
        0x080002f8:    e92d4ffe    -..O    PUSH     {r1-r11,lr}
        0x080002fc:    ea810403    ....    EOR      r4,r1,r3
        0x08000300:    f0044400    ...D    AND      r4,r4,#0x80000000
        0x08000304:    f0214100    !..A    BIC      r1,r1,#0x80000000
        0x08000308:    9400        ..      STR      r4,[sp,#0]
        0x0800030a:    f04f0b00    O...    MOV      r11,#0
        0x0800030e:    f0234300    #..C    BIC      r3,r3,#0x80000000
        0x08000312:    ea500401    P...    ORRS     r4,r0,r1
        0x08000316:    d05e        ^.      BEQ      0x80003d6 ; __aeabi_dmul + 222
        0x08000318:    ea520403    R...    ORRS     r4,r2,r3
        0x0800031c:    d05b        [.      BEQ      0x80003d6 ; __aeabi_dmul + 222
        0x0800031e:    f3c3540a    ...T    UBFX     r4,r3,#20,#11
        0x08000322:    f3c1550a    ...U    UBFX     r5,r1,#20,#11
        0x08000326:    442c        ,D      ADD      r4,r4,r5
        0x08000328:    f2a434f3    ...4    SUB      r4,r4,#0x3f3
        0x0800032c:    9401        ..      STR      r4,[sp,#4]
        0x0800032e:    fba05402    ...T    UMULL    r5,r4,r0,r2
        0x08000332:    f3c10113    ....    UBFX     r1,r1,#0,#20
        0x08000336:    f4411180    A...    ORR      r1,r1,#0x100000
        0x0800033a:    f3c30313    ....    UBFX     r3,r3,#0,#20
        0x0800033e:    f4431380    C...    ORR      r3,r3,#0x100000
        0x08000342:    fb014402    ...D    MLA      r4,r1,r2,r4
        0x08000346:    fb004e03    ...N    MLA      lr,r0,r3,r4
        0x0800034a:    0a84        ..      LSRS     r4,r0,#10
        0x0800034c:    0a97        ..      LSRS     r7,r2,#10
        0x0800034e:    ea445481    D..T    ORR      r4,r4,r1,LSL #22
        0x08000352:    ea475783    G..W    ORR      r7,r7,r3,LSL #22
        0x08000356:    fba46807    ...h    UMULL    r6,r8,r4,r7
        0x0800035a:    9502        ..      STR      r5,[sp,#8]
        0x0800035c:    0a8d        ..      LSRS     r5,r1,#10
        0x0800035e:    fb058507    ....    MLA      r5,r5,r7,r8
        0x08000362:    ea4f2c93    O..,    LSR      r12,r3,#10
        0x08000366:    fb04540c    ...T    MLA      r4,r4,r12,r5
        0x0800036a:    0527        '.      LSLS     r7,r4,#20
        0x0800036c:    9d02        ..      LDR      r5,[sp,#8]
        0x0800036e:    ea4f5806    O..X    LSL      r8,r6,#20
        0x08000372:    ea473716    G..7    ORR      r7,r7,r6,LSR #12
        0x08000376:    ebb50508    ....    SUBS     r5,r5,r8
        0x0800037a:    eb6e0c07    n...    SBC      r12,lr,r7
        0x0800037e:    0e87        ..      LSRS     r7,r0,#26
        0x08000380:    0e92        ..      LSRS     r2,r2,#26
        0x08000382:    ea471781    G...    ORR      r7,r7,r1,LSL #6
        0x08000386:    ea421283    B...    ORR      r2,r2,r3,LSL #6
        0x0800038a:    fba70102    ....    UMULL    r0,r1,r7,r2
        0x0800038e:    ebb6010b    ....    SUBS     r1,r6,r11
        0x08000392:    eb640400    d...    SBC      r4,r4,r0
        0x08000396:    0d2b        +.      LSRS     r3,r5,#20
        0x08000398:    ea43330c    C..3    ORR      r3,r3,r12,LSL #12
        0x0800039c:    185e        ^.      ADDS     r6,r3,r1
        0x0800039e:    eb44501c    D..P    ADC      r0,r4,r12,LSR #20
        0x080003a2:    46da        .F      MOV      r10,r11
        0x080003a4:    4651        QF      MOV      r1,r10
        0x080003a6:    fbe70102    ....    UMLAL    r0,r1,r7,r2
        0x080003aa:    f3c50413    ....    UBFX     r4,r5,#0,#20
        0x080003ae:    ea4f330b    O..3    LSL      r3,r11,#12
        0x080003b2:    ea435314    C..S    ORR      r3,r3,r4,LSR #20
        0x080003b6:    ea4f3204    O..2    LSL      r2,r4,#12
        0x080003ba:    9c01        ..      LDR      r4,[sp,#4]
        0x080003bc:    ea430306    C...    ORR      r3,r3,r6
        0x080003c0:    f1a4040c    ....    SUB      r4,r4,#0xc
        0x080003c4:    9402        ..      STR      r4,[sp,#8]
        0x080003c6:    9c00        ..      LDR      r4,[sp,#0]
        0x080003c8:    e9cdb400    ....    STRD     r11,r4,[sp,#0]
        0x080003cc:    f000f8fe    ....    BL       _double_epilogue ; 0x80005cc
        0x080003d0:    b003        ..      ADD      sp,sp,#0xc
        0x080003d2:    e8bd8ff0    ....    POP      {r4-r11,pc}
        0x080003d6:    2000        .       MOVS     r0,#0
        0x080003d8:    4601        .F      MOV      r1,r0
        0x080003da:    e7f9        ..      B        0x80003d0 ; __aeabi_dmul + 216
    .text
    __aeabi_ddiv
        0x080003dc:    e92d4df0    -..M    PUSH     {r4-r8,r10,r11,lr}
        0x080003e0:    ea810403    ....    EOR      r4,r1,r3
        0x080003e4:    f0044b00    ...K    AND      r11,r4,#0x80000000
        0x080003e8:    f0214500    !..E    BIC      r5,r1,#0x80000000
        0x080003ec:    4614        .F      MOV      r4,r2
        0x080003ee:    f04f0a00    O...    MOV      r10,#0
        0x080003f2:    f0234100    #..A    BIC      r1,r3,#0x80000000
        0x080003f6:    ea500205    P...    ORRS     r2,r0,r5
        0x080003fa:    d020         .      BEQ      0x800043e ; __aeabi_ddiv + 98
        0x080003fc:    ea540201    T...    ORRS     r2,r4,r1
        0x08000400:    d01d        ..      BEQ      0x800043e ; __aeabi_ddiv + 98
        0x08000402:    f3c5570a    ...W    UBFX     r7,r5,#20,#11
        0x08000406:    4602        .F      MOV      r2,r0
        0x08000408:    f3c50313    ....    UBFX     r3,r5,#0,#20
        0x0800040c:    f3c10013    ....    UBFX     r0,r1,#0,#20
        0x08000410:    f3c1560a    ...V    UBFX     r6,r1,#20,#11
        0x08000414:    f4401580    @...    ORR      r5,r0,#0x100000
        0x08000418:    f4431380    C...    ORR      r3,r3,#0x100000
        0x0800041c:    eba70806    ....    SUB      r8,r7,r6
        0x08000420:    1b10        ..      SUBS     r0,r2,r4
        0x08000422:    46d6        .F      MOV      lr,r10
        0x08000424:    f20838fd    ...8    ADD      r8,r8,#0x3fd
        0x08000428:    eb730005    s...    SBCS     r0,r3,r5
        0x0800042c:    d302        ..      BCC      0x8000434 ; __aeabi_ddiv + 88
        0x0800042e:    f1080801    ....    ADD      r8,r8,#1
        0x08000432:    e001        ..      B        0x8000438 ; __aeabi_ddiv + 92
        0x08000434:    1892        ..      ADDS     r2,r2,r2
        0x08000436:    415b        [A      ADCS     r3,r3,r3
        0x08000438:    f1b80f00    ....    CMP      r8,#0
        0x0800043c:    da03        ..      BGE      0x8000446 ; __aeabi_ddiv + 106
        0x0800043e:    2000        .       MOVS     r0,#0
        0x08000440:    4601        .F      MOV      r1,r0
        0x08000442:    e8bd8df0    ....    POP      {r4-r8,r10,r11,pc}
        0x08000446:    2000        .       MOVS     r0,#0
        0x08000448:    f44f1180    O...    MOV      r1,#0x100000
        0x0800044c:    4606        .F      MOV      r6,r0
        0x0800044e:    4684        .F      MOV      r12,r0
        0x08000450:    e00e        ..      B        0x8000470 ; __aeabi_ddiv + 148
        0x08000452:    1b17        ..      SUBS     r7,r2,r4
        0x08000454:    eb730705    s...    SBCS     r7,r3,r5
        0x08000458:    d305        ..      BCC      0x8000466 ; __aeabi_ddiv + 138
        0x0800045a:    1b12        ..      SUBS     r2,r2,r4
        0x0800045c:    eb630305    c...    SBC      r3,r3,r5
        0x08000460:    4306        .C      ORRS     r6,r6,r0
        0x08000462:    ea4c0c01    L...    ORR      r12,r12,r1
        0x08000466:    0849        I.      LSRS     r1,r1,#1
        0x08000468:    ea4f0030    O.0.    RRX      r0,r0
        0x0800046c:    1892        ..      ADDS     r2,r2,r2
        0x0800046e:    415b        [A      ADCS     r3,r3,r3
        0x08000470:    ea500701    P...    ORRS     r7,r0,r1
        0x08000474:    d1ed        ..      BNE      0x8000452 ; __aeabi_ddiv + 118
        0x08000476:    ea520003    R...    ORRS     r0,r2,r3
        0x0800047a:    d012        ..      BEQ      0x80004a2 ; __aeabi_ddiv + 198
        0x0800047c:    ea820004    ....    EOR      r0,r2,r4
        0x08000480:    ea830105    ....    EOR      r1,r3,r5
        0x08000484:    4308        .C      ORRS     r0,r0,r1
        0x08000486:    d005        ..      BEQ      0x8000494 ; __aeabi_ddiv + 184
        0x08000488:    1b10        ..      SUBS     r0,r2,r4
        0x0800048a:    41ab        .A      SBCS     r3,r3,r5
        0x0800048c:    d206        ..      BCS      0x800049c ; __aeabi_ddiv + 192
        0x0800048e:    2201        ."      MOVS     r2,#1
        0x08000490:    2300        .#      MOVS     r3,#0
        0x08000492:    e006        ..      B        0x80004a2 ; __aeabi_ddiv + 198
        0x08000494:    2200        ."      MOVS     r2,#0
        0x08000496:    f04f4300    O..C    MOV      r3,#0x80000000
        0x0800049a:    e002        ..      B        0x80004a2 ; __aeabi_ddiv + 198
        0x0800049c:    f06f0201    o...    MVN      r2,#1
        0x080004a0:    1053        S.      ASRS     r3,r2,#1
        0x080004a2:    eb1a0006    ....    ADDS     r0,r10,r6
        0x080004a6:    eb4c5108    L..Q    ADC      r1,r12,r8,LSL #20
        0x080004aa:    eb10000a    ....    ADDS     r0,r0,r10
        0x080004ae:    eb41010b    A...    ADC      r1,r1,r11
        0x080004b2:    e8bd4df0    ...M    POP      {r4-r8,r10,r11,lr}
        0x080004b6:    f000b87a    ..z.    B.W      __I$use$fp ; 0x80005ae
    .text
    __aeabi_i2d
        0x080004ba:    b50e        ..      PUSH     {r1-r3,lr}
        0x080004bc:    0fc1        ..      LSRS     r1,r0,#31
        0x080004be:    ea8070e0    ...p    EOR      r0,r0,r0,ASR #31
        0x080004c2:    4408        .D      ADD      r0,r0,r1
        0x080004c4:    07ca        ..      LSLS     r2,r1,#31
        0x080004c6:    2100        .!      MOVS     r1,#0
        0x080004c8:    f2404333    @.3C    MOV      r3,#0x433
        0x080004cc:    e88d000e    ....    STM      sp,{r1-r3}
        0x080004d0:    460a        .F      MOV      r2,r1
        0x080004d2:    460b        .F      MOV      r3,r1
        0x080004d4:    f000f87a    ..z.    BL       _double_epilogue ; 0x80005cc
        0x080004d8:    b003        ..      ADD      sp,sp,#0xc
        0x080004da:    bd00        ..      POP      {pc}
    .text
    __aeabi_d2iz
        0x080004dc:    b570        p.      PUSH     {r4-r6,lr}
        0x080004de:    f3c1520a    ...R    UBFX     r2,r1,#20,#11
        0x080004e2:    f0014500    ...E    AND      r5,r1,#0x80000000
        0x080004e6:    2400        .$      MOVS     r4,#0
        0x080004e8:    f3c10113    ....    UBFX     r1,r1,#0,#20
        0x080004ec:    f24033ff    @..3    MOV      r3,#0x3ff
        0x080004f0:    f4411180    A...    ORR      r1,r1,#0x100000
        0x080004f4:    429a        .B      CMP      r2,r3
        0x080004f6:    da01        ..      BGE      0x80004fc ; __aeabi_d2iz + 32
        0x080004f8:    2000        .       MOVS     r0,#0
        0x080004fa:    bd70        p.      POP      {r4-r6,pc}
        0x080004fc:    f2404333    @.3C    MOV      r3,#0x433
        0x08000500:    429a        .B      CMP      r2,r3
        0x08000502:    f2a24233    ..3B    SUB      r2,r2,#0x433
        0x08000506:    dc03        ..      BGT      0x8000510 ; __aeabi_d2iz + 52
        0x08000508:    4252        RB      RSBS     r2,r2,#0
        0x0800050a:    f000f82e    ....    BL       __aeabi_llsr ; 0x800056a
        0x0800050e:    e000        ..      B        0x8000512 ; __aeabi_d2iz + 54
        0x08000510:    4090        .@      LSLS     r0,r0,r2
        0x08000512:    432c        ,C      ORRS     r4,r4,r5
        0x08000514:    d0f1        ..      BEQ      0x80004fa ; __aeabi_d2iz + 30
        0x08000516:    4240        @B      RSBS     r0,r0,#0
        0x08000518:    bd70        p.      POP      {r4-r6,pc}
        0x0800051a:    0000        ..      MOVS     r0,r0
    .text
    __aeabi_cdcmpeq
    __aeabi_cdcmple
        0x0800051c:    b530        0.      PUSH     {r4,r5,lr}
        0x0800051e:    1e04        ..      SUBS     r4,r0,#0
        0x08000520:    f1710400    q...    SBCS     r4,r1,#0
        0x08000524:    db04        ..      BLT      0x8000530 ; __aeabi_cdcmpeq + 20
        0x08000526:    f04f4400    O..D    MOV      r4,#0x80000000
        0x0800052a:    4240        @B      RSBS     r0,r0,#0
        0x0800052c:    eb640101    d...    SBC      r1,r4,r1
        0x08000530:    1e14        ..      SUBS     r4,r2,#0
        0x08000532:    f1730400    s...    SBCS     r4,r3,#0
        0x08000536:    db05        ..      BLT      0x8000544 ; __aeabi_cdcmpeq + 40
        0x08000538:    461c        .F      MOV      r4,r3
        0x0800053a:    f04f4300    O..C    MOV      r3,#0x80000000
        0x0800053e:    4252        RB      RSBS     r2,r2,#0
        0x08000540:    eb630304    c...    SBC      r3,r3,r4
        0x08000544:    428b        .B      CMP      r3,r1
        0x08000546:    bf08        ..      IT       EQ
        0x08000548:    4282        .B      CMPEQ    r2,r0
        0x0800054a:    bd30        0.      POP      {r4,r5,pc}
    .text
    __aeabi_llsl
    _ll_shift_l
        0x0800054c:    2a20         *      CMP      r2,#0x20
        0x0800054e:    db04        ..      BLT      0x800055a ; __aeabi_llsl + 14
        0x08000550:    3a20         :      SUBS     r2,r2,#0x20
        0x08000552:    fa00f102    ....    LSL      r1,r0,r2
        0x08000556:    2000        .       MOVS     r0,#0
        0x08000558:    4770        pG      BX       lr
        0x0800055a:    4091        .@      LSLS     r1,r1,r2
        0x0800055c:    f1c20320    .. .    RSB      r3,r2,#0x20
        0x08000560:    fa20f303     ...    LSR      r3,r0,r3
        0x08000564:    4319        .C      ORRS     r1,r1,r3
        0x08000566:    4090        .@      LSLS     r0,r0,r2
        0x08000568:    4770        pG      BX       lr
    .text
    __aeabi_llsr
    _ll_ushift_r
        0x0800056a:    2a20         *      CMP      r2,#0x20
        0x0800056c:    db04        ..      BLT      0x8000578 ; __aeabi_llsr + 14
        0x0800056e:    3a20         :      SUBS     r2,r2,#0x20
        0x08000570:    fa21f002    !...    LSR      r0,r1,r2
        0x08000574:    2100        .!      MOVS     r1,#0
        0x08000576:    4770        pG      BX       lr
        0x08000578:    fa21f302    !...    LSR      r3,r1,r2
        0x0800057c:    40d0        .@      LSRS     r0,r0,r2
        0x0800057e:    f1c20220    .. .    RSB      r2,r2,#0x20
        0x08000582:    4091        .@      LSLS     r1,r1,r2
        0x08000584:    4308        .C      ORRS     r0,r0,r1
        0x08000586:    4619        .F      MOV      r1,r3
        0x08000588:    4770        pG      BX       lr
    .text
    __aeabi_lasr
    _ll_sshift_r
        0x0800058a:    2a20         *      CMP      r2,#0x20
        0x0800058c:    db06        ..      BLT      0x800059c ; __aeabi_lasr + 18
        0x0800058e:    17cb        ..      ASRS     r3,r1,#31
        0x08000590:    3a20         :      SUBS     r2,r2,#0x20
        0x08000592:    fa41f002    A...    ASR      r0,r1,r2
        0x08000596:    ea4373e0    C..s    ORR      r3,r3,r0,ASR #31
        0x0800059a:    e006        ..      B        0x80005aa ; __aeabi_lasr + 32
        0x0800059c:    fa41f302    A...    ASR      r3,r1,r2
        0x080005a0:    40d0        .@      LSRS     r0,r0,r2
        0x080005a2:    f1c20220    .. .    RSB      r2,r2,#0x20
        0x080005a6:    4091        .@      LSLS     r1,r1,r2
        0x080005a8:    4308        .C      ORRS     r0,r0,r1
        0x080005aa:    4619        .F      MOV      r1,r3
        0x080005ac:    4770        pG      BX       lr
    .text
    .text
    __I$use$fp
    _double_round
        0x080005ae:    b510        ..      PUSH     {r4,lr}
        0x080005b0:    1e14        ..      SUBS     r4,r2,#0
        0x080005b2:    f1730400    s...    SBCS     r4,r3,#0
        0x080005b6:    da08        ..      BGE      0x80005ca ; __I$use$fp + 28
        0x080005b8:    1c40        @.      ADDS     r0,r0,#1
        0x080005ba:    f1410100    A...    ADC      r1,r1,#0
        0x080005be:    1892        ..      ADDS     r2,r2,r2
        0x080005c0:    415b        [A      ADCS     r3,r3,r3
        0x080005c2:    431a        .C      ORRS     r2,r2,r3
        0x080005c4:    d101        ..      BNE      0x80005ca ; __I$use$fp + 28
        0x080005c6:    f0200001     ...    BIC      r0,r0,#1
        0x080005ca:    bd10        ..      POP      {r4,pc}
    _double_epilogue
        0x080005cc:    e92d4df0    -..M    PUSH     {r4-r8,r10,r11,lr}
        0x080005d0:    4692        .F      MOV      r10,r2
        0x080005d2:    469b        .F      MOV      r11,r3
        0x080005d4:    b111        ..      CBZ      r1,0x80005dc ; _double_epilogue + 16
        0x080005d6:    fab1f281    ....    CLZ      r2,r1
        0x080005da:    e002        ..      B        0x80005e2 ; _double_epilogue + 22
        0x080005dc:    fab0f280    ....    CLZ      r2,r0
        0x080005e0:    3220         2      ADDS     r2,r2,#0x20
        0x080005e2:    4690        .F      MOV      r8,r2
        0x080005e4:    f7ffffb2    ....    BL       __aeabi_llsl ; 0x800054c
        0x080005e8:    4604        .F      MOV      r4,r0
        0x080005ea:    460f        .F      MOV      r7,r1
        0x080005ec:    ea40000a    @...    ORR      r0,r0,r10
        0x080005f0:    ea41010b    A...    ORR      r1,r1,r11
        0x080005f4:    4653        SF      MOV      r3,r10
        0x080005f6:    465a        ZF      MOV      r2,r11
        0x080005f8:    4308        .C      ORRS     r0,r0,r1
        0x080005fa:    d013        ..      BEQ      0x8000624 ; _double_epilogue + 88
        0x080005fc:    4611        .F      MOV      r1,r2
        0x080005fe:    ea530001    S...    ORRS     r0,r3,r1
        0x08000602:    d019        ..      BEQ      0x8000638 ; _double_epilogue + 108
        0x08000604:    f1c80240    ..@.    RSB      r2,r8,#0x40
        0x08000608:    4650        PF      MOV      r0,r10
        0x0800060a:    f7ffffae    ....    BL       __aeabi_llsr ; 0x800056a
        0x0800060e:    4605        .F      MOV      r5,r0
        0x08000610:    460e        .F      MOV      r6,r1
        0x08000612:    4650        PF      MOV      r0,r10
        0x08000614:    4659        YF      MOV      r1,r11
        0x08000616:    4642        BF      MOV      r2,r8
        0x08000618:    f7ffff98    ....    BL       __aeabi_llsl ; 0x800054c
        0x0800061c:    4308        .C      ORRS     r0,r0,r1
        0x0800061e:    d005        ..      BEQ      0x800062c ; _double_epilogue + 96
        0x08000620:    2001        .       MOVS     r0,#1
        0x08000622:    e004        ..      B        0x800062e ; _double_epilogue + 98
        0x08000624:    4620         F      MOV      r0,r4
        0x08000626:    4639        9F      MOV      r1,r7
        0x08000628:    e8bd8df0    ....    POP      {r4-r8,r10,r11,pc}
        0x0800062c:    2000        .       MOVS     r0,#0
        0x0800062e:    4305        .C      ORRS     r5,r5,r0
        0x08000630:    ea4676e0    F..v    ORR      r6,r6,r0,ASR #31
        0x08000634:    432c        ,C      ORRS     r4,r4,r5
        0x08000636:    4337        7C      ORRS     r7,r7,r6
        0x08000638:    980a        ..      LDR      r0,[sp,#0x28]
        0x0800063a:    0563        c.      LSLS     r3,r4,#21
        0x0800063c:    0ae4        ..      LSRS     r4,r4,#11
        0x0800063e:    eba00008    ....    SUB      r0,r0,r8
        0x08000642:    2200        ."      MOVS     r2,#0
        0x08000644:    0afd        ..      LSRS     r5,r7,#11
        0x08000646:    ea445447    D.GT    ORR      r4,r4,r7,LSL #21
        0x0800064a:    300a        .0      ADDS     r0,r0,#0xa
        0x0800064c:    d502        ..      BPL      0x8000654 ; _double_epilogue + 136
        0x0800064e:    2000        .       MOVS     r0,#0
        0x08000650:    4601        .F      MOV      r1,r0
        0x08000652:    e7e9        ..      B        0x8000628 ; _double_epilogue + 92
        0x08000654:    0501        ..      LSLS     r1,r0,#20
        0x08000656:    1910        ..      ADDS     r0,r2,r4
        0x08000658:    4169        iA      ADCS     r1,r1,r5
        0x0800065a:    e9dd4508    ...E    LDRD     r4,r5,[sp,#0x20]
        0x0800065e:    1900        ..      ADDS     r0,r0,r4
        0x08000660:    4169        iA      ADCS     r1,r1,r5
        0x08000662:    e8bd4df0    ...M    POP      {r4-r8,r10,r11,lr}
        0x08000666:    e7a2        ..      B        __I$use$fp ; 0x80005ae
    .text
    __scatterload
    __scatterload_rt2
        0x08000668:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000684] = 0x80032c8
        0x0800066a:    4d07        .M      LDR      r5,[pc,#28] ; [0x8000688] = 0x80032e8
        0x0800066c:    e006        ..      B        0x800067c ; __scatterload + 20
        0x0800066e:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000670:    f0400301    @...    ORR      r3,r0,#1
        0x08000674:    e8940007    ....    LDM      r4,{r0-r2}
        0x08000678:    4798        .G      BLX      r3
        0x0800067a:    3410        .4      ADDS     r4,r4,#0x10
        0x0800067c:    42ac        .B      CMP      r4,r5
        0x0800067e:    d3f6        ..      BCC      0x800066e ; __scatterload + 6
        0x08000680:    f7fffd38    ..8.    BL       __main_after_scatterload ; 0x80000f4
    $d
        0x08000684:    080032c8    .2..    DCD    134230728
        0x08000688:    080032e8    .2..    DCD    134230760
    $t
    .text
    __decompress
    __decompress1
        0x0800068c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800068e:    188c        ..      ADDS     r4,r1,r2
        0x08000690:    f8105b01    ...[    LDRB     r5,[r0],#1
        0x08000694:    f0150307    ....    ANDS     r3,r5,#7
        0x08000698:    d101        ..      BNE      0x800069e ; __decompress + 18
        0x0800069a:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x0800069e:    112a        *.      ASRS     r2,r5,#4
        0x080006a0:    d106        ..      BNE      0x80006b0 ; __decompress + 36
        0x080006a2:    f8102b01    ...+    LDRB     r2,[r0],#1
        0x080006a6:    e003        ..      B        0x80006b0 ; __decompress + 36
        0x080006a8:    f8106b01    ...k    LDRB     r6,[r0],#1
        0x080006ac:    f8016b01    ...k    STRB     r6,[r1],#1
        0x080006b0:    1e5b        [.      SUBS     r3,r3,#1
        0x080006b2:    d1f9        ..      BNE      0x80006a8 ; __decompress + 28
        0x080006b4:    072b        +.      LSLS     r3,r5,#28
        0x080006b6:    d405        ..      BMI      0x80006c4 ; __decompress + 56
        0x080006b8:    2300        .#      MOVS     r3,#0
        0x080006ba:    1e52        R.      SUBS     r2,r2,#1
        0x080006bc:    d40d        ..      BMI      0x80006da ; __decompress + 78
        0x080006be:    f8013b01    ...;    STRB     r3,[r1],#1
        0x080006c2:    e7fa        ..      B        0x80006ba ; __decompress + 46
        0x080006c4:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x080006c8:    1acb        ..      SUBS     r3,r1,r3
        0x080006ca:    1c92        ..      ADDS     r2,r2,#2
        0x080006cc:    e003        ..      B        0x80006d6 ; __decompress + 74
        0x080006ce:    f8135b01    ...[    LDRB     r5,[r3],#1
        0x080006d2:    f8015b01    ...[    STRB     r5,[r1],#1
        0x080006d6:    1e52        R.      SUBS     r2,r2,#1
        0x080006d8:    d5f9        ..      BPL      0x80006ce ; __decompress + 66
        0x080006da:    42a1        .B      CMP      r1,r4
        0x080006dc:    d3d8        ..      BCC      0x8000690 ; __decompress + 4
        0x080006de:    2000        .       MOVS     r0,#0
        0x080006e0:    bd70        p.      POP      {r4-r6,pc}
        0x080006e2:    0000        ..      MOVS     r0,r0
    i.DMA1_Channel4_IRQHandler
    DMA1_Channel4_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;195    {
        0x080006e4:    b510        ..      PUSH     {r4,lr}
;;;196      /* USER CODE BEGIN DMA1_Channel4_IRQn 0 */
;;;197      if(LL_DMA_IsActiveFlag_TC4(DMA1))
        0x080006e6:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1258     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
        0x080006e8:    480b        .H      LDR      r0,[pc,#44] ; [0x8000718] = 0x40020000
        0x080006ea:    6800        .h      LDR      r0,[r0,#0]
        0x080006ec:    f3c03040    ..@0    UBFX     r0,r0,#13,#1
        0x080006f0:    b140        @.      CBZ      r0,0x8000704 ; DMA1_Channel4_IRQHandler + 32
;;; .\../Src/stm32f1xx_it.c
;;;199        LL_DMA_ClearFlag_GI4(DMA1);
        0x080006f2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1489     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
        0x080006f4:    f44f5080    O..P    MOV      r0,#0x1000
        0x080006f8:    4907        .I      LDR      r1,[pc,#28] ; [0x8000718] = 0x40020000
        0x080006fa:    6048        H`      STR      r0,[r1,#4]
;;;1490   }
        0x080006fc:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;200        Transfer_Complete_Callback();
        0x080006fe:    f001fc45    ..E.    BL       Transfer_Complete_Callback ; 0x8001f8c
        0x08000702:    e007        ..      B        0x8000714 ; DMA1_Channel4_IRQHandler + 48
;;;201    //    DMA1_Transfer_Complete_Callback();
;;;202      }
;;;203      else if(LL_DMA_IsActiveFlag_TE4(DMA1))
        0x08000704:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1412     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
        0x08000706:    4804        .H      LDR      r0,[pc,#16] ; [0x8000718] = 0x40020000
        0x08000708:    6800        .h      LDR      r0,[r0,#0]
        0x0800070a:    f3c030c0    ...0    UBFX     r0,r0,#15,#1
        0x0800070e:    b108        ..      CBZ      r0,0x8000714 ; DMA1_Channel4_IRQHandler + 48
;;; .\../Src/stm32f1xx_it.c
;;;205        Transfer_Error_Callback();
        0x08000710:    f001fc66    ..f.    BL       Transfer_Error_Callback ; 0x8001fe0
;;;206      }
;;;207    
;;;208      /* USER CODE END DMA1_Channel4_IRQn 0 */
;;;209      
;;;210      /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */
;;;211    
;;;212      /* USER CODE END DMA1_Channel4_IRQn 1 */
;;;213    }
        0x08000714:    bd10        ..      POP      {r4,pc}
    $d
        0x08000716:    0000        ..      DCW    0
        0x08000718:    40020000    ...@    DCD    1073872896
    $t
    i.DMA1_Channel7_IRQHandler
    DMA1_Channel7_IRQHandler
;;;214    
;;;215    /**
;;;216      * @brief This function handles DMA1 channel7 global interrupt.
;;;217      */
;;;218    void DMA1_Channel7_IRQHandler(void)
;;;219    {
;;;220      /* USER CODE BEGIN DMA1_Channel7_IRQn 0 */
;;;221    
;;;222      /* USER CODE END DMA1_Channel7_IRQn 0 */
;;;223      
;;;224      /* USER CODE BEGIN DMA1_Channel7_IRQn 1 */
;;;225    
;;;226      /* USER CODE END DMA1_Channel7_IRQn 1 */
;;;227    }
        0x0800071c:    4770        pG      BX       lr
    i.Error_Handler
    Error_Handler
;;; .\../Src/main.c
;;;1040   	while (1) {
        0x0800071e:    bf00        ..      NOP      
        0x08000720:    e7fe        ..      B        0x8000720 ; Error_Handler + 2
        0x08000722:    0000        ..      MOVS     r0,r0
    i.G01
    G01
;;; .\..\Src\fsm.c
;;;490    void G01(int dx, int dz, int feed){
        0x08000724:    b570        p.      PUSH     {r4-r6,lr}
        0x08000726:    4605        .F      MOV      r5,r0
        0x08000728:    460c        .F      MOV      r4,r1
        0x0800072a:    4616        .F      MOV      r6,r2
;;;491    	dzdx_init(dx, dz, &state);
        0x0800072c:    4a21        !J      LDR      r2,[pc,#132] ; [0x80007b4] = 0x20000044
        0x0800072e:    4621        !F      MOV      r1,r4
        0x08000730:    4628        (F      MOV      r0,r5
        0x08000732:    f001ff6f    ..o.    BL       dzdx_init ; 0x8002614
;;;492    
;;;493    	if(dz<0) {
        0x08000736:    2c00        .,      CMP      r4,#0
        0x08000738:    da07        ..      BGE      0x800074a ; G01 + 38
;;;494    		feed_direction = feed_direction_left;
        0x0800073a:    2000        .       MOVS     r0,#0
        0x0800073c:    491e        .I      LDR      r1,[pc,#120] ; [0x80007b8] = 0x200000a1
        0x0800073e:    7008        .p      STRB     r0,[r1,#0]
;;;495    		MOTOR_Z_Reverse();
        0x08000740:    f2480080    H...    MOV      r0,#0x8080
        0x08000744:    491d        .I      LDR      r1,[pc,#116] ; [0x80007bc] = 0x40010814
        0x08000746:    6008        .`      STR      r0,[r1,#0]
        0x08000748:    e007        ..      B        0x800075a ; G01 + 54
;;;496    	} else {
;;;497    		feed_direction = feed_direction_right;
        0x0800074a:    2001        .       MOVS     r0,#1
        0x0800074c:    491a        .I      LDR      r1,[pc,#104] ; [0x80007b8] = 0x200000a1
        0x0800074e:    7008        .p      STRB     r0,[r1,#0]
;;;498    		MOTOR_Z_Forward();
        0x08000750:    f2480080    H...    MOV      r0,#0x8080
        0x08000754:    4919        .I      LDR      r1,[pc,#100] ; [0x80007bc] = 0x40010814
        0x08000756:    1f09        ..      SUBS     r1,r1,#4
        0x08000758:    6008        .`      STR      r0,[r1,#0]
;;;499    	}
;;;500    
;;;501    	if(dx<0) {
        0x0800075a:    2d00        .-      CMP      r5,#0
        0x0800075c:    da03        ..      BGE      0x8000766 ; G01 + 66
;;;502    		MOTOR_X_Reverse();
        0x0800075e:    4818        .H      LDR      r0,[pc,#96] ; [0x80007c0] = 0x4800080
        0x08000760:    4918        .I      LDR      r1,[pc,#96] ; [0x80007c4] = 0x40011000
        0x08000762:    6148        Ha      STR      r0,[r1,#0x14]
        0x08000764:    e002        ..      B        0x800076c ; G01 + 72
;;;503    	} else {
;;;504    		MOTOR_X_Forward();
        0x08000766:    4816        .H      LDR      r0,[pc,#88] ; [0x80007c0] = 0x4800080
        0x08000768:    4916        .I      LDR      r1,[pc,#88] ; [0x80007c4] = 0x40011000
        0x0800076a:    6108        .a      STR      r0,[r1,#0x10]
;;;505    	}
;;;506    
;;;507    	state.sync = false;
        0x0800076c:    2000        .       MOVS     r0,#0
        0x0800076e:    4911        .I      LDR      r1,[pc,#68] ; [0x80007b4] = 0x20000044
        0x08000770:    7408        .t      STRB     r0,[r1,#0x10]
;;;508    	if(state.sync){
        0x08000772:    4608        .F      MOV      r0,r1
        0x08000774:    7c00        .|      LDRB     r0,[r0,#0x10]
        0x08000776:    b110        ..      CBZ      r0,0x800077e ; G01 + 90
;;;509    		state.main_feed_direction = feed_direction;
        0x08000778:    480f        .H      LDR      r0,[pc,#60] ; [0x80007b8] = 0x200000a1
        0x0800077a:    7800        .x      LDRB     r0,[r0,#0]
        0x0800077c:    7448        Ht      STRB     r0,[r1,#0x11]
;;;510    	}
;;;511    
;;;512    	z_axis.current_pos = 0;
        0x0800077e:    2000        .       MOVS     r0,#0
        0x08000780:    4911        .I      LDR      r1,[pc,#68] ; [0x80007c8] = 0x200005e0
        0x08000782:    6008        .`      STR      r0,[r1,#0]
;;;513    	z_axis.end_pos = abs(dz);
        0x08000784:    1e20         .      SUBS     r0,r4,#0
        0x08000786:    db01        ..      BLT      0x800078c ; G01 + 104
        0x08000788:    4601        .F      MOV      r1,r0
        0x0800078a:    e000        ..      B        0x800078e ; G01 + 106
        0x0800078c:    4241        AB      RSBS     r1,r0,#0
        0x0800078e:    4a0e        .J      LDR      r2,[pc,#56] ; [0x80007c8] = 0x200005e0
        0x08000790:    6051        Q`      STR      r1,[r2,#4]
;;;514    	if(z_axis.end_pos > 0){
        0x08000792:    4610        .F      MOV      r0,r2
        0x08000794:    6840        @h      LDR      r0,[r0,#4]
        0x08000796:    b130        0.      CBZ      r0,0x80007a6 ; G01 + 130
;;;515    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
        0x08000798:    4610        .F      MOV      r0,r2
        0x0800079a:    6840        @h      LDR      r0,[r0,#4]
        0x0800079c:    f0200001     ...    BIC      r0,r0,#1
        0x080007a0:    4611        .F      MOV      r1,r2
        0x080007a2:    6048        H`      STR      r0,[r1,#4]
        0x080007a4:    e002        ..      B        0x80007ac ; G01 + 136
;;;516    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;517    
;;;518    	} else {
;;;519    		state.sync = true;
        0x080007a6:    2001        .       MOVS     r0,#1
        0x080007a8:    4902        .I      LDR      r1,[pc,#8] ; [0x80007b4] = 0x20000044
        0x080007aa:    7408        .t      STRB     r0,[r1,#0x10]
;;;520    	}
;;;521    	do_fsm_move_start(&state);
        0x080007ac:    4801        .H      LDR      r0,[pc,#4] ; [0x80007b4] = 0x20000044
        0x080007ae:    f001fe07    ....    BL       do_fsm_move_start ; 0x80023c0
;;;522    }
        0x080007b2:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080007b4:    20000044    D..     DCD    536870980
        0x080007b8:    200000a1    ...     DCD    536871073
        0x080007bc:    40010814    ...@    DCD    1073809428
        0x080007c0:    04800080    ....    DCD    75497600
        0x080007c4:    40011000    ...@    DCD    1073811456
        0x080007c8:    200005e0    ...     DCD    536872416
    $t
    i.I2C2_ER_IRQHandler
    I2C2_ER_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;370      while(1){
        0x080007cc:    bf00        ..      NOP      
        0x080007ce:    e7fe        ..      B        0x80007ce ; I2C2_ER_IRQHandler + 2
    i.I2C2_EV_IRQHandler
    I2C2_EV_IRQHandler
;;; .\../Src/stm32f1xx_it.c (339)
        0x080007d0:    b508        ..      PUSH     {r3,lr}
;;;340      /* USER CODE BEGIN I2C2_EV_IRQn 0 */
;;;341      /* Check SB flag value in ISR register */
;;;342      if(LL_I2C_IsActiveFlag_SB(I2C2))
        0x080007d2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1186     return (READ_BIT(I2Cx->SR1, I2C_SR1_SB) == (I2C_SR1_SB));
        0x080007d4:    4814        .H      LDR      r0,[pc,#80] ; [0x8000828] = 0x40005800
        0x080007d6:    6940        @i      LDR      r0,[r0,#0x14]
        0x080007d8:    f0000001    ....    AND      r0,r0,#1
        0x080007dc:    b148        H.      CBZ      r0,0x80007f2 ; I2C2_EV_IRQHandler + 34
;;; .\../Src/stm32f1xx_it.c
;;;345        LL_I2C_TransmitData8(I2C2, SSD1306_I2C_ADDR);
        0x080007de:    2078        x       MOVS     r0,#0x78
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1758     MODIFY_REG(I2Cx->DR, I2C_DR_DR, Data);
        0x080007e0:    4911        .I      LDR      r1,[pc,#68] ; [0x8000828] = 0x40005800
        0x080007e2:    6909        .i      LDR      r1,[r1,#0x10]
        0x080007e4:    f02101ff    !...    BIC      r1,r1,#0xff
        0x080007e8:    4301        .C      ORRS     r1,r1,r0
        0x080007ea:    4a0f        .J      LDR      r2,[pc,#60] ; [0x8000828] = 0x40005800
        0x080007ec:    6111        .a      STR      r1,[r2,#0x10]
;;;1759   }
        0x080007ee:    bf00        ..      NOP      
        0x080007f0:    e018        ..      B        0x8000824 ; I2C2_EV_IRQHandler + 84
;;; .\../Src/stm32f1xx_it.c
;;;348      else if(LL_I2C_IsActiveFlag_ADDR(I2C2))
        0x080007f2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1199     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADDR) == (I2C_SR1_ADDR));
        0x080007f4:    480c        .H      LDR      r0,[pc,#48] ; [0x8000828] = 0x40005800
        0x080007f6:    6940        @i      LDR      r0,[r0,#0x14]
        0x080007f8:    f3c00040    ..@.    UBFX     r0,r0,#1,#1
        0x080007fc:    b190        ..      CBZ      r0,0x8000824 ; I2C2_EV_IRQHandler + 84
;;; .\../Src/stm32f1xx_it.c
;;;351        LL_I2C_EnableDMAReq_TX(I2C2);
        0x080007fe:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;401      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
        0x08000800:    4809        .H      LDR      r0,[pc,#36] ; [0x8000828] = 0x40005800
        0x08000802:    6840        @h      LDR      r0,[r0,#4]
        0x08000804:    f4406000    @..`    ORR      r0,r0,#0x800
        0x08000808:    4907        .I      LDR      r1,[pc,#28] ; [0x8000828] = 0x40005800
        0x0800080a:    6048        H`      STR      r0,[r1,#4]
;;;402    }
        0x0800080c:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;354        LL_I2C_ClearFlag_ADDR(I2C2);
        0x0800080e:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1415     tmpreg = I2Cx->SR1;
        0x08000810:    4608        .F      MOV      r0,r1
        0x08000812:    6940        @i      LDR      r0,[r0,#0x14]
        0x08000814:    9000        ..      STR      r0,[sp,#0]
;;;1416     (void) tmpreg;
        0x08000816:    bf00        ..      NOP      
;;;1417     tmpreg = I2Cx->SR2;
        0x08000818:    4608        .F      MOV      r0,r1
        0x0800081a:    6980        .i      LDR      r0,[r0,#0x18]
        0x0800081c:    9000        ..      STR      r0,[sp,#0]
;;;1418     (void) tmpreg;
        0x0800081e:    bf00        ..      NOP      
;;;1419   }
        0x08000820:    bf00        ..      NOP      
        0x08000822:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;362    }
        0x08000824:    bd08        ..      POP      {r3,pc}
    $d
        0x08000826:    0000        ..      DCW    0
        0x08000828:    40005800    .X.@    DCD    1073764352
    $t
    i.LL_APB1_GRP1_EnableClock
    LL_APB1_GRP1_EnableClock
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;464    {
        0x0800082c:    b508        ..      PUSH     {r3,lr}
;;;465      __IO uint32_t tmpreg;
;;;466      SET_BIT(RCC->APB1ENR, Periphs);
        0x0800082e:    4905        .I      LDR      r1,[pc,#20] ; [0x8000844] = 0x40021000
        0x08000830:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x08000832:    4301        .C      ORRS     r1,r1,r0
        0x08000834:    4a03        .J      LDR      r2,[pc,#12] ; [0x8000844] = 0x40021000
        0x08000836:    61d1        .a      STR      r1,[r2,#0x1c]
;;;467      /* Delay after an RCC peripheral clock enabling */
;;;468      tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
        0x08000838:    4611        .F      MOV      r1,r2
        0x0800083a:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x0800083c:    4001        .@      ANDS     r1,r1,r0
        0x0800083e:    9100        ..      STR      r1,[sp,#0]
;;;469      (void)tmpreg;
        0x08000840:    bf00        ..      NOP      
;;;470    }
        0x08000842:    bd08        ..      POP      {r3,pc}
    $d
        0x08000844:    40021000    ...@    DCD    1073876992
    $t
    i.LL_APB2_GRP1_EnableClock
    LL_APB2_GRP1_EnableClock
;;;471    
;;;472    /**
;;;473      * @brief  Check if APB1 peripheral clock is enabled or not
;;;474      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_IsEnabledClock\n
;;;475      *         APB1ENR      CAN1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;476      *         APB1ENR      CAN2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;477      *         APB1ENR      CECEN         LL_APB1_GRP1_IsEnabledClock\n
;;;478      *         APB1ENR      DACEN         LL_APB1_GRP1_IsEnabledClock\n
;;;479      *         APB1ENR      I2C1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;480      *         APB1ENR      I2C2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;481      *         APB1ENR      PWREN         LL_APB1_GRP1_IsEnabledClock\n
;;;482      *         APB1ENR      SPI2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;483      *         APB1ENR      SPI3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;484      *         APB1ENR      TIM12EN       LL_APB1_GRP1_IsEnabledClock\n
;;;485      *         APB1ENR      TIM13EN       LL_APB1_GRP1_IsEnabledClock\n
;;;486      *         APB1ENR      TIM14EN       LL_APB1_GRP1_IsEnabledClock\n
;;;487      *         APB1ENR      TIM2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;488      *         APB1ENR      TIM3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;489      *         APB1ENR      TIM4EN        LL_APB1_GRP1_IsEnabledClock\n
;;;490      *         APB1ENR      TIM5EN        LL_APB1_GRP1_IsEnabledClock\n
;;;491      *         APB1ENR      TIM6EN        LL_APB1_GRP1_IsEnabledClock\n
;;;492      *         APB1ENR      TIM7EN        LL_APB1_GRP1_IsEnabledClock\n
;;;493      *         APB1ENR      UART4EN       LL_APB1_GRP1_IsEnabledClock\n
;;;494      *         APB1ENR      UART5EN       LL_APB1_GRP1_IsEnabledClock\n
;;;495      *         APB1ENR      USART2EN      LL_APB1_GRP1_IsEnabledClock\n
;;;496      *         APB1ENR      USART3EN      LL_APB1_GRP1_IsEnabledClock\n
;;;497      *         APB1ENR      USBEN         LL_APB1_GRP1_IsEnabledClock\n
;;;498      *         APB1ENR      WWDGEN        LL_APB1_GRP1_IsEnabledClock
;;;499      * @param  Periphs This parameter can be a combination of the following values:
;;;500      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;501      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;502      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;503      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;504      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;505      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;506      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;507      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;508      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;509      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;510      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;511      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;512      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;513      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;514      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;515      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;516      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;517      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;518      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;519      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;520      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;521      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;522      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;523      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;524      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;525      *
;;;526      *         (*) value not defined in all devices.
;;;527      * @retval State of Periphs (1 or 0).
;;;528    */
;;;529    __STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
;;;530    {
;;;531      return (READ_BIT(RCC->APB1ENR, Periphs) == Periphs);
;;;532    }
;;;533    
;;;534    /**
;;;535      * @brief  Disable APB1 peripherals clock.
;;;536      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_DisableClock\n
;;;537      *         APB1ENR      CAN1EN        LL_APB1_GRP1_DisableClock\n
;;;538      *         APB1ENR      CAN2EN        LL_APB1_GRP1_DisableClock\n
;;;539      *         APB1ENR      CECEN         LL_APB1_GRP1_DisableClock\n
;;;540      *         APB1ENR      DACEN         LL_APB1_GRP1_DisableClock\n
;;;541      *         APB1ENR      I2C1EN        LL_APB1_GRP1_DisableClock\n
;;;542      *         APB1ENR      I2C2EN        LL_APB1_GRP1_DisableClock\n
;;;543      *         APB1ENR      PWREN         LL_APB1_GRP1_DisableClock\n
;;;544      *         APB1ENR      SPI2EN        LL_APB1_GRP1_DisableClock\n
;;;545      *         APB1ENR      SPI3EN        LL_APB1_GRP1_DisableClock\n
;;;546      *         APB1ENR      TIM12EN       LL_APB1_GRP1_DisableClock\n
;;;547      *         APB1ENR      TIM13EN       LL_APB1_GRP1_DisableClock\n
;;;548      *         APB1ENR      TIM14EN       LL_APB1_GRP1_DisableClock\n
;;;549      *         APB1ENR      TIM2EN        LL_APB1_GRP1_DisableClock\n
;;;550      *         APB1ENR      TIM3EN        LL_APB1_GRP1_DisableClock\n
;;;551      *         APB1ENR      TIM4EN        LL_APB1_GRP1_DisableClock\n
;;;552      *         APB1ENR      TIM5EN        LL_APB1_GRP1_DisableClock\n
;;;553      *         APB1ENR      TIM6EN        LL_APB1_GRP1_DisableClock\n
;;;554      *         APB1ENR      TIM7EN        LL_APB1_GRP1_DisableClock\n
;;;555      *         APB1ENR      UART4EN       LL_APB1_GRP1_DisableClock\n
;;;556      *         APB1ENR      UART5EN       LL_APB1_GRP1_DisableClock\n
;;;557      *         APB1ENR      USART2EN      LL_APB1_GRP1_DisableClock\n
;;;558      *         APB1ENR      USART3EN      LL_APB1_GRP1_DisableClock\n
;;;559      *         APB1ENR      USBEN         LL_APB1_GRP1_DisableClock\n
;;;560      *         APB1ENR      WWDGEN        LL_APB1_GRP1_DisableClock
;;;561      * @param  Periphs This parameter can be a combination of the following values:
;;;562      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;563      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;564      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;565      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;566      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;567      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;568      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;569      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;570      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;571      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;572      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;573      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;574      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;575      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;576      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;577      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;578      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;579      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;580      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;581      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;582      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;583      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;584      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;585      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;586      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;587      *
;;;588      *         (*) value not defined in all devices.
;;;589      * @retval None
;;;590    */
;;;591    __STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
;;;592    {
;;;593      CLEAR_BIT(RCC->APB1ENR, Periphs);
;;;594    }
;;;595    
;;;596    /**
;;;597      * @brief  Force APB1 peripherals reset.
;;;598      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ForceReset\n
;;;599      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ForceReset\n
;;;600      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ForceReset\n
;;;601      *         APB1RSTR     CECRST        LL_APB1_GRP1_ForceReset\n
;;;602      *         APB1RSTR     DACRST        LL_APB1_GRP1_ForceReset\n
;;;603      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ForceReset\n
;;;604      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ForceReset\n
;;;605      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ForceReset\n
;;;606      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ForceReset\n
;;;607      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ForceReset\n
;;;608      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ForceReset\n
;;;609      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ForceReset\n
;;;610      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ForceReset\n
;;;611      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ForceReset\n
;;;612      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ForceReset\n
;;;613      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ForceReset\n
;;;614      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ForceReset\n
;;;615      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ForceReset\n
;;;616      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ForceReset\n
;;;617      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ForceReset\n
;;;618      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ForceReset\n
;;;619      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ForceReset\n
;;;620      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ForceReset\n
;;;621      *         APB1RSTR     USBRST        LL_APB1_GRP1_ForceReset\n
;;;622      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ForceReset
;;;623      * @param  Periphs This parameter can be a combination of the following values:
;;;624      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;625      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;626      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;627      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;628      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;629      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;630      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;631      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;632      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;633      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;634      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;635      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;636      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;637      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;638      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;639      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;640      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;641      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;642      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;643      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;644      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;645      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;646      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;647      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;648      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;649      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;650      *
;;;651      *         (*) value not defined in all devices.
;;;652      * @retval None
;;;653    */
;;;654    __STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
;;;655    {
;;;656      SET_BIT(RCC->APB1RSTR, Periphs);
;;;657    }
;;;658    
;;;659    /**
;;;660      * @brief  Release APB1 peripherals reset.
;;;661      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ReleaseReset\n
;;;662      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ReleaseReset\n
;;;663      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ReleaseReset\n
;;;664      *         APB1RSTR     CECRST        LL_APB1_GRP1_ReleaseReset\n
;;;665      *         APB1RSTR     DACRST        LL_APB1_GRP1_ReleaseReset\n
;;;666      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ReleaseReset\n
;;;667      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ReleaseReset\n
;;;668      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ReleaseReset\n
;;;669      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ReleaseReset\n
;;;670      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ReleaseReset\n
;;;671      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ReleaseReset\n
;;;672      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ReleaseReset\n
;;;673      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ReleaseReset\n
;;;674      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ReleaseReset\n
;;;675      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ReleaseReset\n
;;;676      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ReleaseReset\n
;;;677      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ReleaseReset\n
;;;678      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ReleaseReset\n
;;;679      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ReleaseReset\n
;;;680      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ReleaseReset\n
;;;681      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ReleaseReset\n
;;;682      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ReleaseReset\n
;;;683      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ReleaseReset\n
;;;684      *         APB1RSTR     USBRST        LL_APB1_GRP1_ReleaseReset\n
;;;685      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ReleaseReset
;;;686      * @param  Periphs This parameter can be a combination of the following values:
;;;687      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;688      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;689      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;690      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;691      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;692      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;693      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;694      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;695      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;696      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;697      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;698      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;699      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;700      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;701      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;702      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;703      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;704      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;705      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;706      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;707      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;708      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;709      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;710      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;711      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;712      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;713      *
;;;714      *         (*) value not defined in all devices.
;;;715      * @retval None
;;;716    */
;;;717    __STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
;;;718    {
;;;719      CLEAR_BIT(RCC->APB1RSTR, Periphs);
;;;720    }
;;;721    
;;;722    /**
;;;723      * @}
;;;724      */
;;;725    
;;;726    /** @defgroup BUS_LL_EF_APB2 APB2
;;;727      * @{
;;;728      */
;;;729    
;;;730    /**
;;;731      * @brief  Enable APB2 peripherals clock.
;;;732      * @rmtoll APB2ENR      ADC1EN        LL_APB2_GRP1_EnableClock\n
;;;733      *         APB2ENR      ADC2EN        LL_APB2_GRP1_EnableClock\n
;;;734      *         APB2ENR      ADC3EN        LL_APB2_GRP1_EnableClock\n
;;;735      *         APB2ENR      AFIOEN        LL_APB2_GRP1_EnableClock\n
;;;736      *         APB2ENR      IOPAEN        LL_APB2_GRP1_EnableClock\n
;;;737      *         APB2ENR      IOPBEN        LL_APB2_GRP1_EnableClock\n
;;;738      *         APB2ENR      IOPCEN        LL_APB2_GRP1_EnableClock\n
;;;739      *         APB2ENR      IOPDEN        LL_APB2_GRP1_EnableClock\n
;;;740      *         APB2ENR      IOPEEN        LL_APB2_GRP1_EnableClock\n
;;;741      *         APB2ENR      IOPFEN        LL_APB2_GRP1_EnableClock\n
;;;742      *         APB2ENR      IOPGEN        LL_APB2_GRP1_EnableClock\n
;;;743      *         APB2ENR      SPI1EN        LL_APB2_GRP1_EnableClock\n
;;;744      *         APB2ENR      TIM10EN       LL_APB2_GRP1_EnableClock\n
;;;745      *         APB2ENR      TIM11EN       LL_APB2_GRP1_EnableClock\n
;;;746      *         APB2ENR      TIM15EN       LL_APB2_GRP1_EnableClock\n
;;;747      *         APB2ENR      TIM16EN       LL_APB2_GRP1_EnableClock\n
;;;748      *         APB2ENR      TIM17EN       LL_APB2_GRP1_EnableClock\n
;;;749      *         APB2ENR      TIM1EN        LL_APB2_GRP1_EnableClock\n
;;;750      *         APB2ENR      TIM8EN        LL_APB2_GRP1_EnableClock\n
;;;751      *         APB2ENR      TIM9EN        LL_APB2_GRP1_EnableClock\n
;;;752      *         APB2ENR      USART1EN      LL_APB2_GRP1_EnableClock
;;;753      * @param  Periphs This parameter can be a combination of the following values:
;;;754      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC1
;;;755      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC2 (*)
;;;756      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC3 (*)
;;;757      *         @arg @ref LL_APB2_GRP1_PERIPH_AFIO
;;;758      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOA
;;;759      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOB
;;;760      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOC
;;;761      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOD
;;;762      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOE (*)
;;;763      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOF (*)
;;;764      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOG (*)
;;;765      *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
;;;766      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM10 (*)
;;;767      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM11 (*)
;;;768      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15 (*)
;;;769      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16 (*)
;;;770      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
;;;771      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
;;;772      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
;;;773      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM9 (*)
;;;774      *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
;;;775      *
;;;776      *         (*) value not defined in all devices.
;;;777      * @retval None
;;;778    */
;;;779    __STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
;;;780    {
        0x08000848:    b508        ..      PUSH     {r3,lr}
;;;781      __IO uint32_t tmpreg;
;;;782      SET_BIT(RCC->APB2ENR, Periphs);
        0x0800084a:    4905        .I      LDR      r1,[pc,#20] ; [0x8000860] = 0x40021000
        0x0800084c:    6989        .i      LDR      r1,[r1,#0x18]
        0x0800084e:    4301        .C      ORRS     r1,r1,r0
        0x08000850:    4a03        .J      LDR      r2,[pc,#12] ; [0x8000860] = 0x40021000
        0x08000852:    6191        .a      STR      r1,[r2,#0x18]
;;;783      /* Delay after an RCC peripheral clock enabling */
;;;784      tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
        0x08000854:    4611        .F      MOV      r1,r2
        0x08000856:    6989        .i      LDR      r1,[r1,#0x18]
        0x08000858:    4001        .@      ANDS     r1,r1,r0
        0x0800085a:    9100        ..      STR      r1,[sp,#0]
;;;785      (void)tmpreg;
        0x0800085c:    bf00        ..      NOP      
;;;786    }
        0x0800085e:    bd08        ..      POP      {r3,pc}
    $d
        0x08000860:    40021000    ...@    DCD    1073876992
    $t
    i.LL_DMA_SetChannelPriorityLevel
    LL_DMA_SetChannelPriorityLevel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;850    {
        0x08000864:    b530        0.      PUSH     {r4,r5,lr}
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
        0x08000866:    1e4b        K.      SUBS     r3,r1,#1
        0x08000868:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000880] = 0x80031e8
        0x0800086a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800086c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800086e:    f4235340    #.@S    BIC      r3,r3,#0x3000
        0x08000872:    4313        .C      ORRS     r3,r3,r2
        0x08000874:    1e4c        L.      SUBS     r4,r1,#1
        0x08000876:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000880] = 0x80031e8
        0x08000878:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800087a:    5103        .Q      STR      r3,[r0,r4]
;;;852                 Priority);
;;;853    }
        0x0800087c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800087e:    0000        ..      DCW    0
        0x08000880:    080031e8    .1..    DCD    134230504
    $t
    i.LL_DMA_SetDataTransferDirection
    LL_DMA_SetDataTransferDirection
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (570)
        0x08000884:    b530        0.      PUSH     {r4,r5,lr}
;;;571      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
        0x08000886:    1e4b        K.      SUBS     r3,r1,#1
        0x08000888:    4c05        .L      LDR      r4,[pc,#20] ; [0x80008a0] = 0x80031e8
        0x0800088a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800088c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800088e:    f2440410    D...    MOV      r4,#0x4010
        0x08000892:    43a3        .C      BICS     r3,r3,r4
        0x08000894:    4313        .C      ORRS     r3,r3,r2
        0x08000896:    1e4c        L.      SUBS     r4,r1,#1
        0x08000898:    4d01        .M      LDR      r5,[pc,#4] ; [0x80008a0] = 0x80031e8
        0x0800089a:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800089c:    5103        .Q      STR      r3,[r0,r4]
;;;572                 DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
;;;573    }
        0x0800089e:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008a0:    080031e8    .1..    DCD    134230504
    $t
    i.LL_DMA_SetMemoryIncMode
    LL_DMA_SetMemoryIncMode
;;;574    
;;;575    /**
;;;576      * @brief  Get Data transfer direction (read from peripheral or from memory).
;;;577      * @rmtoll CCR          DIR           LL_DMA_GetDataTransferDirection\n
;;;578      *         CCR          MEM2MEM       LL_DMA_GetDataTransferDirection
;;;579      * @param  DMAx DMAx Instance
;;;580      * @param  Channel This parameter can be one of the following values:
;;;581      *         @arg @ref LL_DMA_CHANNEL_1
;;;582      *         @arg @ref LL_DMA_CHANNEL_2
;;;583      *         @arg @ref LL_DMA_CHANNEL_3
;;;584      *         @arg @ref LL_DMA_CHANNEL_4
;;;585      *         @arg @ref LL_DMA_CHANNEL_5
;;;586      *         @arg @ref LL_DMA_CHANNEL_6
;;;587      *         @arg @ref LL_DMA_CHANNEL_7
;;;588      * @retval Returned value can be one of the following values:
;;;589      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;590      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;591      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;592      */
;;;593    __STATIC_INLINE uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
;;;594    {
;;;595      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;596                       DMA_CCR_DIR | DMA_CCR_MEM2MEM));
;;;597    }
;;;598    
;;;599    /**
;;;600      * @brief  Set DMA mode circular or normal.
;;;601      * @note The circular buffer mode cannot be used if the memory-to-memory
;;;602      * data transfer is configured on the selected Channel.
;;;603      * @rmtoll CCR          CIRC          LL_DMA_SetMode
;;;604      * @param  DMAx DMAx Instance
;;;605      * @param  Channel This parameter can be one of the following values:
;;;606      *         @arg @ref LL_DMA_CHANNEL_1
;;;607      *         @arg @ref LL_DMA_CHANNEL_2
;;;608      *         @arg @ref LL_DMA_CHANNEL_3
;;;609      *         @arg @ref LL_DMA_CHANNEL_4
;;;610      *         @arg @ref LL_DMA_CHANNEL_5
;;;611      *         @arg @ref LL_DMA_CHANNEL_6
;;;612      *         @arg @ref LL_DMA_CHANNEL_7
;;;613      * @param  Mode This parameter can be one of the following values:
;;;614      *         @arg @ref LL_DMA_MODE_NORMAL
;;;615      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;616      * @retval None
;;;617      */
;;;618    __STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
;;;619    {
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
;;;621                 Mode);
;;;622    }
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
        0x080008a4:    b530        0.      PUSH     {r4,r5,lr}
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
        0x080008a6:    1e4b        K.      SUBS     r3,r1,#1
        0x080008a8:    4c05        .L      LDR      r4,[pc,#20] ; [0x80008c0] = 0x80031e8
        0x080008aa:    5ce3        .\      LDRB     r3,[r4,r3]
        0x080008ac:    58c3        .X      LDR      r3,[r0,r3]
        0x080008ae:    f0230380    #...    BIC      r3,r3,#0x80
        0x080008b2:    4313        .C      ORRS     r3,r3,r2
        0x080008b4:    1e4c        L.      SUBS     r4,r1,#1
        0x080008b6:    4d02        .M      LDR      r5,[pc,#8] ; [0x80008c0] = 0x80031e8
        0x080008b8:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x080008ba:    5103        .Q      STR      r3,[r0,r4]
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
        0x080008bc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008be:    0000        ..      DCW    0
        0x080008c0:    080031e8    .1..    DCD    134230504
    $t
    i.LL_DMA_SetMemorySize
    LL_DMA_SetMemorySize
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
;;;759    
;;;760    /**
;;;761      * @brief  Get Peripheral size.
;;;762      * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
;;;763      * @param  DMAx DMAx Instance
;;;764      * @param  Channel This parameter can be one of the following values:
;;;765      *         @arg @ref LL_DMA_CHANNEL_1
;;;766      *         @arg @ref LL_DMA_CHANNEL_2
;;;767      *         @arg @ref LL_DMA_CHANNEL_3
;;;768      *         @arg @ref LL_DMA_CHANNEL_4
;;;769      *         @arg @ref LL_DMA_CHANNEL_5
;;;770      *         @arg @ref LL_DMA_CHANNEL_6
;;;771      *         @arg @ref LL_DMA_CHANNEL_7
;;;772      * @retval Returned value can be one of the following values:
;;;773      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;774      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;775      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;776      */
;;;777    __STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;778    {
;;;779      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;780                       DMA_CCR_PSIZE));
;;;781    }
;;;782    
;;;783    /**
;;;784      * @brief  Set Memory size.
;;;785      * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
;;;786      * @param  DMAx DMAx Instance
;;;787      * @param  Channel This parameter can be one of the following values:
;;;788      *         @arg @ref LL_DMA_CHANNEL_1
;;;789      *         @arg @ref LL_DMA_CHANNEL_2
;;;790      *         @arg @ref LL_DMA_CHANNEL_3
;;;791      *         @arg @ref LL_DMA_CHANNEL_4
;;;792      *         @arg @ref LL_DMA_CHANNEL_5
;;;793      *         @arg @ref LL_DMA_CHANNEL_6
;;;794      *         @arg @ref LL_DMA_CHANNEL_7
;;;795      * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
;;;796      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;797      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;798      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;799      * @retval None
;;;800      */
;;;801    __STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
;;;802    {
        0x080008c4:    b530        0.      PUSH     {r4,r5,lr}
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
        0x080008c6:    1e4b        K.      SUBS     r3,r1,#1
        0x080008c8:    4c05        .L      LDR      r4,[pc,#20] ; [0x80008e0] = 0x80031e8
        0x080008ca:    5ce3        .\      LDRB     r3,[r4,r3]
        0x080008cc:    58c3        .X      LDR      r3,[r0,r3]
        0x080008ce:    f4236340    #.@c    BIC      r3,r3,#0xc00
        0x080008d2:    4313        .C      ORRS     r3,r3,r2
        0x080008d4:    1e4c        L.      SUBS     r4,r1,#1
        0x080008d6:    4d02        .M      LDR      r5,[pc,#8] ; [0x80008e0] = 0x80031e8
        0x080008d8:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x080008da:    5103        .Q      STR      r3,[r0,r4]
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
        0x080008dc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008de:    0000        ..      DCW    0
        0x080008e0:    080031e8    .1..    DCD    134230504
    $t
    i.LL_DMA_SetMode
    LL_DMA_SetMode
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (619)
        0x080008e4:    b530        0.      PUSH     {r4,r5,lr}
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
        0x080008e6:    1e4b        K.      SUBS     r3,r1,#1
        0x080008e8:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000900] = 0x80031e8
        0x080008ea:    5ce3        .\      LDRB     r3,[r4,r3]
        0x080008ec:    58c3        .X      LDR      r3,[r0,r3]
        0x080008ee:    f0230320    #. .    BIC      r3,r3,#0x20
        0x080008f2:    4313        .C      ORRS     r3,r3,r2
        0x080008f4:    1e4c        L.      SUBS     r4,r1,#1
        0x080008f6:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000900] = 0x80031e8
        0x080008f8:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x080008fa:    5103        .Q      STR      r3,[r0,r4]
;;;621                 Mode);
;;;622    }
        0x080008fc:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080008fe:    0000        ..      DCW    0
        0x08000900:    080031e8    .1..    DCD    134230504
    $t
    i.LL_DMA_SetPeriphIncMode
    LL_DMA_SetPeriphIncMode
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
        0x08000904:    b530        0.      PUSH     {r4,r5,lr}
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
        0x08000906:    1e4b        K.      SUBS     r3,r1,#1
        0x08000908:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000920] = 0x80031e8
        0x0800090a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800090c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800090e:    f0230340    #.@.    BIC      r3,r3,#0x40
        0x08000912:    4313        .C      ORRS     r3,r3,r2
        0x08000914:    1e4c        L.      SUBS     r4,r1,#1
        0x08000916:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000920] = 0x80031e8
        0x08000918:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800091a:    5103        .Q      STR      r3,[r0,r4]
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
        0x0800091c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800091e:    0000        ..      DCW    0
        0x08000920:    080031e8    .1..    DCD    134230504
    $t
    i.LL_DMA_SetPeriphSize
    LL_DMA_SetPeriphSize
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
        0x08000924:    b530        0.      PUSH     {r4,r5,lr}
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
        0x08000926:    1e4b        K.      SUBS     r3,r1,#1
        0x08000928:    4c05        .L      LDR      r4,[pc,#20] ; [0x8000940] = 0x80031e8
        0x0800092a:    5ce3        .\      LDRB     r3,[r4,r3]
        0x0800092c:    58c3        .X      LDR      r3,[r0,r3]
        0x0800092e:    f4237340    #.@s    BIC      r3,r3,#0x300
        0x08000932:    4313        .C      ORRS     r3,r3,r2
        0x08000934:    1e4c        L.      SUBS     r4,r1,#1
        0x08000936:    4d02        .M      LDR      r5,[pc,#8] ; [0x8000940] = 0x80031e8
        0x08000938:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x0800093a:    5103        .Q      STR      r3,[r0,r4]
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
        0x0800093c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800093e:    0000        ..      DCW    0
        0x08000940:    080031e8    .1..    DCD    134230504
    $t
    i.LL_GPIO_Init
    LL_GPIO_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;172    {
        0x08000944:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08000948:    4602        .F      MOV      r2,r0
        0x0800094a:    460b        .F      MOV      r3,r1
;;;173      uint32_t pinmask;
;;;174      uint32_t pinpos;
;;;175      uint32_t currentpin;
;;;176    
;;;177      /* Check the parameters */
;;;178      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;179      assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));
;;;180    
;;;181      /* ------------------------- Configure the port pins ---------------- */
;;;182      /* Initialize  pinpos on first pin set */
;;;183    
;;;184      pinmask = ((GPIO_InitStruct->Pin) << GPIO_PIN_MASK_POS) >> GPIO_PIN_NB;
        0x0800094c:    6818        .h      LDR      r0,[r3,#0]
        0x0800094e:    f3c0250f    ...%    UBFX     r5,r0,#8,#16
;;;185      pinpos = POSITION_VAL(pinmask);
        0x08000952:    fa95f0a5    ....    RBIT     r0,r5
        0x08000956:    fab0f480    ....    CLZ      r4,r0
;;;186    
;;;187      /* Configure the port pins */
;;;188      while ((pinmask  >> pinpos) != 0U)
        0x0800095a:    e07c        |.      B        0x8000a56 ; LL_GPIO_Init + 274
;;;189      {
;;;190        /* skip if bit is not set */
;;;191        if ((pinmask & (1U << pinpos)) != 0U)
        0x0800095c:    2001        .       MOVS     r0,#1
        0x0800095e:    40a0        .@      LSLS     r0,r0,r4
        0x08000960:    4028        (@      ANDS     r0,r0,r5
        0x08000962:    2800        .(      CMP      r0,#0
        0x08000964:    d076        v.      BEQ      0x8000a54 ; LL_GPIO_Init + 272
;;;192        {
;;;193          /* Get current io position */
;;;194          if (pinpos < GPIO_PIN_MASK_POS)
        0x08000966:    2c08        .,      CMP      r4,#8
        0x08000968:    d204        ..      BCS      0x8000974 ; LL_GPIO_Init + 48
;;;195          {
;;;196            currentpin = (0x00000101U << pinpos);
        0x0800096a:    f2401001    @...    MOV      r0,#0x101
        0x0800096e:    fa00f104    ....    LSL      r1,r0,r4
        0x08000972:    e006        ..      B        0x8000982 ; LL_GPIO_Init + 62
;;;197          }
;;;198          else
;;;199          {
;;;200            currentpin = ((0x00010001U << (pinpos - GPIO_PIN_MASK_POS)) | 0x04000000U);
        0x08000974:    f1a40008    ....    SUB      r0,r4,#8
        0x08000978:    f04f1601    O...    MOV      r6,#0x10001
        0x0800097c:    4086        .@      LSLS     r6,r6,r0
        0x0800097e:    f0466180    F..a    ORR      r1,r6,#0x4000000
;;;201          }
;;;202    
;;;203          /* Check Pin Mode and Pin Pull parameters */
;;;204          assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
;;;205          assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));
;;;206    
;;;207          /* Pin Mode configuration */
;;;208          LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
        0x08000982:    6858        Xh      LDR      r0,[r3,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;360      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000984:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;361      MODIFY_REG(*pReg, ((GPIO_CRL_CNF0 | GPIO_CRL_MODE0) << (POSITION_VAL(Pin) * 4U)), (Mode << (POSITION_VAL(Pin) * 4U)));
        0x08000988:    fa91fca1    ....    RBIT     r12,r1
        0x0800098c:    fabcfc8c    ....    CLZ      r12,r12
        0x08000990:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000994:    f04f0c0f    O...    MOV      r12,#0xf
        0x08000998:    fa0cfc08    ....    LSL      r12,r12,r8
        0x0800099c:    6837        7h      LDR      r7,[r6,#0]
        0x0800099e:    ea27070c    '...    BIC      r7,r7,r12
        0x080009a2:    fa91fca1    ....    RBIT     r12,r1
        0x080009a6:    fabcfc8c    ....    CLZ      r12,r12
        0x080009aa:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x080009ae:    fa00fc0c    ....    LSL      r12,r0,r12
        0x080009b2:    ea47070c    G...    ORR      r7,r7,r12
        0x080009b6:    6037        7`      STR      r7,[r6,#0]
;;;362    }
        0x080009b8:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;211          LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
        0x080009ba:    6918        .i      LDR      r0,[r3,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;583      MODIFY_REG(GPIOx->ODR, (Pin >> GPIO_PIN_MASK_POS), Pull << (POSITION_VAL(Pin >> GPIO_PIN_MASK_POS)));
        0x080009bc:    68d6        .h      LDR      r6,[r2,#0xc]
        0x080009be:    ea262611    &..&    BIC      r6,r6,r1,LSR #8
        0x080009c2:    0a0f        ..      LSRS     r7,r1,#8
        0x080009c4:    fa97f7a7    ....    RBIT     r7,r7
        0x080009c8:    fab7f787    ....    CLZ      r7,r7
        0x080009cc:    fa00f707    ....    LSL      r7,r0,r7
        0x080009d0:    433e        >C      ORRS     r6,r6,r7
        0x080009d2:    60d6        .`      STR      r6,[r2,#0xc]
;;;584    }
        0x080009d4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;213          if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
        0x080009d6:    6858        Xh      LDR      r0,[r3,#4]
        0x080009d8:    2801        .(      CMP      r0,#1
        0x080009da:    d002        ..      BEQ      0x80009e2 ; LL_GPIO_Init + 158
        0x080009dc:    6858        Xh      LDR      r0,[r3,#4]
        0x080009de:    2809        .(      CMP      r0,#9
        0x080009e0:    d138        8.      BNE      0x8000a54 ; LL_GPIO_Init + 272
;;;214          {
;;;215            /* Check speed and Output mode parameters */
;;;216            assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
;;;217            assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
;;;218    
;;;219            /* Speed mode configuration */
;;;220            LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
        0x080009e2:    6898        .h      LDR      r0,[r3,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;438      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x080009e4:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;439      MODIFY_REG(*pReg, (GPIO_CRL_MODE0 << (POSITION_VAL(Pin) * 4U)),
        0x080009e8:    fa91fca1    ....    RBIT     r12,r1
        0x080009ec:    fabcfc8c    ....    CLZ      r12,r12
        0x080009f0:    ea4f088c    O...    LSL      r8,r12,#2
        0x080009f4:    f04f0c03    O...    MOV      r12,#3
        0x080009f8:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080009fc:    6837        7h      LDR      r7,[r6,#0]
        0x080009fe:    ea27070c    '...    BIC      r7,r7,r12
        0x08000a02:    fa91fca1    ....    RBIT     r12,r1
        0x08000a06:    fabcfc8c    ....    CLZ      r12,r12
        0x08000a0a:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x08000a0e:    fa00fc0c    ....    LSL      r12,r0,r12
        0x08000a12:    ea47070c    G...    ORR      r7,r7,r12
        0x08000a16:    6037        7`      STR      r7,[r6,#0]
;;;440                 (Speed << (POSITION_VAL(Pin) * 4U)));
;;;441    }
        0x08000a18:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;223            LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
        0x08000a1a:    68d8        .h      LDR      r0,[r3,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;512      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000a1c:    eb026611    ...f    ADD      r6,r2,r1,LSR #24
;;;513      MODIFY_REG(*pReg, (GPIO_CRL_CNF0_0 << (POSITION_VAL(Pin) * 4U)),
        0x08000a20:    fa91fca1    ....    RBIT     r12,r1
        0x08000a24:    fabcfc8c    ....    CLZ      r12,r12
        0x08000a28:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000a2c:    f04f0c04    O...    MOV      r12,#4
        0x08000a30:    fa0cfc08    ....    LSL      r12,r12,r8
        0x08000a34:    6837        7h      LDR      r7,[r6,#0]
        0x08000a36:    ea27070c    '...    BIC      r7,r7,r12
        0x08000a3a:    fa91fca1    ....    RBIT     r12,r1
        0x08000a3e:    fabcfc8c    ....    CLZ      r12,r12
        0x08000a42:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x08000a46:    fa00fc0c    ....    LSL      r12,r0,r12
        0x08000a4a:    ea47070c    G...    ORR      r7,r7,r12
        0x08000a4e:    6037        7`      STR      r7,[r6,#0]
;;;514                 (OutputType << (POSITION_VAL(Pin) * 4U)));
;;;515    }
        0x08000a50:    bf00        ..      NOP      
        0x08000a52:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;226        pinpos++;
        0x08000a54:    1c64        d.      ADDS     r4,r4,#1
        0x08000a56:    fa25f004    %...    LSR      r0,r5,r4
        0x08000a5a:    2800        .(      CMP      r0,#0
        0x08000a5c:    f47faf7e    ..~.    BNE      0x800095c ; LL_GPIO_Init + 24
;;;227      }
;;;228      return (SUCCESS);
        0x08000a60:    2001        .       MOVS     r0,#1
;;;229    }
        0x08000a62:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_GPIO_IsInputPinSet
    LL_GPIO_IsInputPinSet
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;740    {
        0x08000a66:    4602        .F      MOV      r2,r0
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08000a68:    6890        .h      LDR      r0,[r2,#8]
        0x08000a6a:    f3c1230f    ...#    UBFX     r3,r1,#8,#16
        0x08000a6e:    4018        .@      ANDS     r0,r0,r3
        0x08000a70:    f3c1230f    ...#    UBFX     r3,r1,#8,#16
        0x08000a74:    4298        .B      CMP      r0,r3
        0x08000a76:    d101        ..      BNE      0x8000a7c ; LL_GPIO_IsInputPinSet + 22
        0x08000a78:    2001        .       MOVS     r0,#1
        0x08000a7a:    4770        pG      BX       lr
        0x08000a7c:    2000        .       MOVS     r0,#0
        0x08000a7e:    e7fc        ..      B        0x8000a7a ; LL_GPIO_IsInputPinSet + 20
    i.LL_GPIO_ResetOutputPin
    LL_GPIO_ResetOutputPin
;;;742    }
;;;743    
;;;744    /**
;;;745      * @brief  Write output data register for the port.
;;;746      * @rmtoll ODR          ODy           LL_GPIO_WriteOutputPort
;;;747      * @param  GPIOx GPIO Port
;;;748      * @param  PortValue Level value for each pin of the port
;;;749      * @retval None
;;;750      */
;;;751    __STATIC_INLINE void LL_GPIO_WriteOutputPort(GPIO_TypeDef *GPIOx, uint32_t PortValue)
;;;752    {
;;;753      WRITE_REG(GPIOx->ODR, PortValue);
;;;754    }
;;;755    
;;;756    /**
;;;757      * @brief  Return full output data register value for a dedicated port.
;;;758      * @rmtoll ODR          ODy           LL_GPIO_ReadOutputPort
;;;759      * @param  GPIOx GPIO Port
;;;760      * @retval Output data register value of port
;;;761      */
;;;762    __STATIC_INLINE uint32_t LL_GPIO_ReadOutputPort(GPIO_TypeDef *GPIOx)
;;;763    {
;;;764      return (uint32_t)(READ_REG(GPIOx->ODR));
;;;765    }
;;;766    
;;;767    /**
;;;768      * @brief  Return if input data level for several pins of dedicated port is high or low.
;;;769      * @rmtoll ODR          ODy           LL_GPIO_IsOutputPinSet
;;;770      * @param  GPIOx GPIO Port
;;;771      * @param  PinMask This parameter can be a combination of the following values:
;;;772      *         @arg @ref LL_GPIO_PIN_0
;;;773      *         @arg @ref LL_GPIO_PIN_1
;;;774      *         @arg @ref LL_GPIO_PIN_2
;;;775      *         @arg @ref LL_GPIO_PIN_3
;;;776      *         @arg @ref LL_GPIO_PIN_4
;;;777      *         @arg @ref LL_GPIO_PIN_5
;;;778      *         @arg @ref LL_GPIO_PIN_6
;;;779      *         @arg @ref LL_GPIO_PIN_7
;;;780      *         @arg @ref LL_GPIO_PIN_8
;;;781      *         @arg @ref LL_GPIO_PIN_9
;;;782      *         @arg @ref LL_GPIO_PIN_10
;;;783      *         @arg @ref LL_GPIO_PIN_11
;;;784      *         @arg @ref LL_GPIO_PIN_12
;;;785      *         @arg @ref LL_GPIO_PIN_13
;;;786      *         @arg @ref LL_GPIO_PIN_14
;;;787      *         @arg @ref LL_GPIO_PIN_15
;;;788      *         @arg @ref LL_GPIO_PIN_ALL
;;;789      * @retval State of bit (1 or 0).
;;;790      */
;;;791    __STATIC_INLINE uint32_t LL_GPIO_IsOutputPinSet(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;792    {
;;;793      return (READ_BIT(GPIOx->ODR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
;;;794    }
;;;795    
;;;796    /**
;;;797      * @brief  Set several pins to high level on dedicated gpio port.
;;;798      * @rmtoll BSRR         BSy           LL_GPIO_SetOutputPin
;;;799      * @param  GPIOx GPIO Port
;;;800      * @param  PinMask This parameter can be a combination of the following values:
;;;801      *         @arg @ref LL_GPIO_PIN_0
;;;802      *         @arg @ref LL_GPIO_PIN_1
;;;803      *         @arg @ref LL_GPIO_PIN_2
;;;804      *         @arg @ref LL_GPIO_PIN_3
;;;805      *         @arg @ref LL_GPIO_PIN_4
;;;806      *         @arg @ref LL_GPIO_PIN_5
;;;807      *         @arg @ref LL_GPIO_PIN_6
;;;808      *         @arg @ref LL_GPIO_PIN_7
;;;809      *         @arg @ref LL_GPIO_PIN_8
;;;810      *         @arg @ref LL_GPIO_PIN_9
;;;811      *         @arg @ref LL_GPIO_PIN_10
;;;812      *         @arg @ref LL_GPIO_PIN_11
;;;813      *         @arg @ref LL_GPIO_PIN_12
;;;814      *         @arg @ref LL_GPIO_PIN_13
;;;815      *         @arg @ref LL_GPIO_PIN_14
;;;816      *         @arg @ref LL_GPIO_PIN_15
;;;817      *         @arg @ref LL_GPIO_PIN_ALL
;;;818      * @retval None
;;;819      */
;;;820    __STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;821    {
;;;822      WRITE_REG(GPIOx->BSRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
;;;823    }
;;;824    
;;;825    /**
;;;826      * @brief  Set several pins to low level on dedicated gpio port.
;;;827      * @rmtoll BRR          BRy           LL_GPIO_ResetOutputPin
;;;828      * @param  GPIOx GPIO Port
;;;829      * @param  PinMask This parameter can be a combination of the following values:
;;;830      *         @arg @ref LL_GPIO_PIN_0
;;;831      *         @arg @ref LL_GPIO_PIN_1
;;;832      *         @arg @ref LL_GPIO_PIN_2
;;;833      *         @arg @ref LL_GPIO_PIN_3
;;;834      *         @arg @ref LL_GPIO_PIN_4
;;;835      *         @arg @ref LL_GPIO_PIN_5
;;;836      *         @arg @ref LL_GPIO_PIN_6
;;;837      *         @arg @ref LL_GPIO_PIN_7
;;;838      *         @arg @ref LL_GPIO_PIN_8
;;;839      *         @arg @ref LL_GPIO_PIN_9
;;;840      *         @arg @ref LL_GPIO_PIN_10
;;;841      *         @arg @ref LL_GPIO_PIN_11
;;;842      *         @arg @ref LL_GPIO_PIN_12
;;;843      *         @arg @ref LL_GPIO_PIN_13
;;;844      *         @arg @ref LL_GPIO_PIN_14
;;;845      *         @arg @ref LL_GPIO_PIN_15
;;;846      *         @arg @ref LL_GPIO_PIN_ALL
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
;;;850    {
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x08000a80:    f3c1220f    ..."    UBFX     r2,r1,#8,#16
        0x08000a84:    6142        Ba      STR      r2,[r0,#0x14]
;;;852    }
        0x08000a86:    4770        pG      BX       lr
    i.LL_I2C_ConfigSpeed
    LL_I2C_ConfigSpeed
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;747    {
        0x08000a88:    b5f0        ..      PUSH     {r4-r7,lr}
;;;748      register uint32_t freqrange = 0x0U;
        0x08000a8a:    2400        .$      MOVS     r4,#0
;;;749      register uint32_t clockconfig = 0x0U;
        0x08000a8c:    2500        .%      MOVS     r5,#0
;;;750    
;;;751      /* Compute frequency range */
;;;752      freqrange = __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock);
        0x08000a8e:    4e2b        +N      LDR      r6,[pc,#172] ; [0x8000b3c] = 0xf4240
        0x08000a90:    fbb1f4f6    ....    UDIV     r4,r1,r6
;;;753    
;;;754      /* Configure I2Cx: Frequency range register */
;;;755      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, freqrange);
        0x08000a94:    6846        Fh      LDR      r6,[r0,#4]
        0x08000a96:    f026063f    &.?.    BIC      r6,r6,#0x3f
        0x08000a9a:    4326        &C      ORRS     r6,r6,r4
        0x08000a9c:    6046        F`      STR      r6,[r0,#4]
;;;756    
;;;757      /* Configure I2Cx: Rise Time register */
;;;758      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, __LL_I2C_RISE_TIME(freqrange, ClockSpeed));
        0x08000a9e:    4e28        (N      LDR      r6,[pc,#160] ; [0x8000b40] = 0x186a0
        0x08000aa0:    42b2        .B      CMP      r2,r6
        0x08000aa2:    d801        ..      BHI      0x8000aa8 ; LL_I2C_ConfigSpeed + 32
        0x08000aa4:    1c66        f.      ADDS     r6,r4,#1
        0x08000aa6:    e007        ..      B        0x8000ab8 ; LL_I2C_ConfigSpeed + 48
        0x08000aa8:    f44f7696    O..v    MOV      r6,#0x12c
        0x08000aac:    4366        fC      MULS     r6,r4,r6
        0x08000aae:    f44f777a    O.zw    MOV      r7,#0x3e8
        0x08000ab2:    fbb6f6f7    ....    UDIV     r6,r6,r7
        0x08000ab6:    1c76        v.      ADDS     r6,r6,#1
        0x08000ab8:    6a07        .j      LDR      r7,[r0,#0x20]
        0x08000aba:    f027073f    '.?.    BIC      r7,r7,#0x3f
        0x08000abe:    433e        >C      ORRS     r6,r6,r7
        0x08000ac0:    6206        .b      STR      r6,[r0,#0x20]
;;;759    
;;;760      /* Configure Speed mode, Duty Cycle and Clock control register value */
;;;761      if (ClockSpeed > LL_I2C_MAX_SPEED_STANDARD)
        0x08000ac2:    4e1f        .N      LDR      r6,[pc,#124] ; [0x8000b40] = 0x186a0
        0x08000ac4:    42b2        .B      CMP      r2,r6
        0x08000ac6:    d924        $.      BLS      0x8000b12 ; LL_I2C_ConfigSpeed + 138
;;;762      {
;;;763        /* Set Speed mode at fast and duty cycle for Clock Speed request in fast clock range */
;;;764        clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
        0x08000ac8:    b96b        k.      CBNZ     r3,0x8000ae6 ; LL_I2C_ConfigSpeed + 94
;;;765                      __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
        0x08000aca:    eb020642    ..B.    ADD      r6,r2,r2,LSL #1
        0x08000ace:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000ad2:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000ad6:    b90e        ..      CBNZ     r6,0x8000adc ; LL_I2C_ConfigSpeed + 84
        0x08000ad8:    2601        .&      MOVS     r6,#1
        0x08000ada:    e015        ..      B        0x8000b08 ; LL_I2C_ConfigSpeed + 128
        0x08000adc:    eb020642    ..B.    ADD      r6,r2,r2,LSL #1
        0x08000ae0:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000ae4:    e010        ..      B        0x8000b08 ; LL_I2C_ConfigSpeed + 128
        0x08000ae6:    eb0206c2    ....    ADD      r6,r2,r2,LSL #3
        0x08000aea:    eb061602    ....    ADD      r6,r6,r2,LSL #4
        0x08000aee:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000af2:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000af6:    b90e        ..      CBNZ     r6,0x8000afc ; LL_I2C_ConfigSpeed + 116
        0x08000af8:    2601        .&      MOVS     r6,#1
        0x08000afa:    e005        ..      B        0x8000b08 ; LL_I2C_ConfigSpeed + 128
        0x08000afc:    eb0206c2    ....    ADD      r6,r2,r2,LSL #3
        0x08000b00:    eb061602    ....    ADD      r6,r6,r2,LSL #4
        0x08000b04:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000b08:    f4464600    F..F    ORR      r6,r6,#0x8000
        0x08000b0c:    ea460503    F...    ORR      r5,r6,r3
        0x08000b10:    e00c        ..      B        0x8000b2c ; LL_I2C_ConfigSpeed + 164
;;;766                      DutyCycle;
;;;767      }
;;;768      else
;;;769      {
;;;770        /* Set Speed mode at standard for Clock Speed request in standard clock range */
;;;771        clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
        0x08000b12:    0056        V.      LSLS     r6,r2,#1
        0x08000b14:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000b18:    f3c6060b    ....    UBFX     r6,r6,#0,#12
        0x08000b1c:    2e04        ..      CMP      r6,#4
        0x08000b1e:    d201        ..      BCS      0x8000b24 ; LL_I2C_ConfigSpeed + 156
;;;772                      __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
        0x08000b20:    2604        .&      MOVS     r6,#4
        0x08000b22:    e002        ..      B        0x8000b2a ; LL_I2C_ConfigSpeed + 162
        0x08000b24:    0056        V.      LSLS     r6,r2,#1
        0x08000b26:    fbb1f6f6    ....    UDIV     r6,r1,r6
        0x08000b2a:    4635        5F      MOV      r5,r6
;;;773      }
;;;774    
;;;775      /* Configure I2Cx: Clock control register */
;;;776      MODIFY_REG(I2Cx->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), clockconfig);
        0x08000b2c:    69c6        .i      LDR      r6,[r0,#0x1c]
        0x08000b2e:    f64c77ff    L..w    MOV      r7,#0xcfff
        0x08000b32:    43be        .C      BICS     r6,r6,r7
        0x08000b34:    432e        .C      ORRS     r6,r6,r5
        0x08000b36:    61c6        .a      STR      r6,[r0,#0x1c]
;;;777    }
        0x08000b38:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000b3a:    0000        ..      DCW    0
        0x08000b3c:    000f4240    @B..    DCD    1000000
        0x08000b40:    000186a0    ....    DCD    100000
    $t
    i.LL_I2C_Init
    LL_I2C_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;147    {
        0x08000b44:    b57f        ..      PUSH     {r0-r6,lr}
        0x08000b46:    4604        .F      MOV      r4,r0
        0x08000b48:    460d        .F      MOV      r5,r1
;;;148      LL_RCC_ClocksTypeDef rcc_clocks;
;;;149    
;;;150      /* Check the I2C Instance I2Cx */
;;;151      assert_param(IS_I2C_ALL_INSTANCE(I2Cx));
;;;152    
;;;153      /* Check the I2C parameters from I2C_InitStruct */
;;;154      assert_param(IS_LL_I2C_PERIPHERAL_MODE(I2C_InitStruct->PeripheralMode));
;;;155      assert_param(IS_LL_I2C_CLOCK_SPEED(I2C_InitStruct->ClockSpeed));
;;;156      assert_param(IS_LL_I2C_DUTY_CYCLE(I2C_InitStruct->DutyCycle));
;;;157      assert_param(IS_LL_I2C_OWN_ADDRESS1(I2C_InitStruct->OwnAddress1));
;;;158      assert_param(IS_LL_I2C_TYPE_ACKNOWLEDGE(I2C_InitStruct->TypeAcknowledge));
;;;159      assert_param(IS_LL_I2C_OWN_ADDRSIZE(I2C_InitStruct->OwnAddrSize));
;;;160    
;;;161      /* Disable the selected I2Cx Peripheral */
;;;162      LL_I2C_Disable(I2Cx);
        0x08000b4a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;378      CLEAR_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000b4c:    6820         h      LDR      r0,[r4,#0]
        0x08000b4e:    f0200001     ...    BIC      r0,r0,#1
        0x08000b52:    6020         `      STR      r0,[r4,#0]
;;;379    }
        0x08000b54:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;165      LL_RCC_GetSystemClocksFreq(&rcc_clocks);
        0x08000b56:    4668        hF      MOV      r0,sp
        0x08000b58:    f000f836    ..6.    BL       LL_RCC_GetSystemClocksFreq ; 0x8000bc8
;;;166    
;;;167      /*---------------------------- I2Cx SCL Clock Speed Configuration ------------
;;;168       * Configure the SCL speed :
;;;169       * - ClockSpeed: I2C_CR2_FREQ[5:0], I2C_TRISE_TRISE[5:0], I2C_CCR_FS,
;;;170       *           and I2C_CCR_CCR[11:0] bits
;;;171       * - DutyCycle: I2C_CCR_DUTY[7:0] bits
;;;172       */
;;;173      LL_I2C_ConfigSpeed(I2Cx, rcc_clocks.PCLK1_Frequency, I2C_InitStruct->ClockSpeed, I2C_InitStruct->DutyCycle);
        0x08000b5c:    e9d52301    ...#    LDRD     r2,r3,[r5,#4]
        0x08000b60:    4620         F      MOV      r0,r4
        0x08000b62:    9902        ..      LDR      r1,[sp,#8]
        0x08000b64:    f7ffff90    ....    BL       LL_I2C_ConfigSpeed ; 0x8000a88
;;;174    
;;;175      /*---------------------------- I2Cx OAR1 Configuration -----------------------
;;;176       * Disable, Configure and Enable I2Cx device own address 1 with parameters :
;;;177       * - OwnAddress1:  I2C_OAR1_ADD[9:8], I2C_OAR1_ADD[7:1] and I2C_OAR1_ADD0 bits
;;;178       * - OwnAddrSize:  I2C_OAR1_ADDMODE bit
;;;179       */
;;;180      LL_I2C_SetOwnAddress1(I2Cx, I2C_InitStruct->OwnAddress1, I2C_InitStruct->OwnAddrSize);
        0x08000b68:    6969        ii      LDR      r1,[r5,#0x14]
        0x08000b6a:    68e8        .h      LDR      r0,[r5,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;555      MODIFY_REG(I2Cx->OAR1, I2C_OAR1_ADD0 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD8_9 | I2C_OAR1_ADDMODE, OwnAddress1 | OwnAddrSize);
        0x08000b6c:    68a2        .h      LDR      r2,[r4,#8]
        0x08000b6e:    f24833ff    H..3    MOV      r3,#0x83ff
        0x08000b72:    439a        .C      BICS     r2,r2,r3
        0x08000b74:    ea400301    @...    ORR      r3,r0,r1
        0x08000b78:    431a        .C      ORRS     r2,r2,r3
        0x08000b7a:    60a2        .`      STR      r2,[r4,#8]
;;;556    }
        0x08000b7c:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;186      LL_I2C_SetMode(I2Cx, I2C_InitStruct->PeripheralMode);
        0x08000b7e:    6828        (h      LDR      r0,[r5,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;796      MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
        0x08000b80:    6821        !h      LDR      r1,[r4,#0]
        0x08000b82:    f021011a    !...    BIC      r1,r1,#0x1a
        0x08000b86:    4301        .C      ORRS     r1,r1,r0
        0x08000b88:    6021        !`      STR      r1,[r4,#0]
;;;797    }
        0x08000b8a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;189      LL_I2C_Enable(I2Cx);
        0x08000b8c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;367      SET_BIT(I2Cx->CR1, I2C_CR1_PE);
        0x08000b8e:    6820         h      LDR      r0,[r4,#0]
        0x08000b90:    f0400001    @...    ORR      r0,r0,#1
        0x08000b94:    6020         `      STR      r0,[r4,#0]
;;;368    }
        0x08000b96:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;196      LL_I2C_AcknowledgeNextData(I2Cx, I2C_InitStruct->TypeAcknowledge);
        0x08000b98:    6928        (i      LDR      r0,[r5,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1572     MODIFY_REG(I2Cx->CR1, I2C_CR1_ACK, TypeAcknowledge);
        0x08000b9a:    6821        !h      LDR      r1,[r4,#0]
        0x08000b9c:    f4216180    !..a    BIC      r1,r1,#0x400
        0x08000ba0:    4301        .C      ORRS     r1,r1,r0
        0x08000ba2:    6021        !`      STR      r1,[r4,#0]
;;;1573   }
        0x08000ba4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_i2c.c
;;;198      return SUCCESS;
        0x08000ba6:    2001        .       MOVS     r0,#1
;;;199    }
        0x08000ba8:    b004        ..      ADD      sp,sp,#0x10
        0x08000baa:    bd70        p.      POP      {r4-r6,pc}
    i.LL_Init1msTick
    LL_Init1msTick
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;187      LL_InitTick(HCLKFrequency, 1000U);
        0x08000bac:    f44f717a    O.zq    MOV      r1,#0x3e8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_utils.h
;;;237      SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
        0x08000bb0:    fbb0f2f1    ....    UDIV     r2,r0,r1
        0x08000bb4:    1e52        R.      SUBS     r2,r2,#1
        0x08000bb6:    f04f23e0    O..#    MOV      r3,#0xe000e000
        0x08000bba:    615a        Za      STR      r2,[r3,#0x14]
;;;238      SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
        0x08000bbc:    2200        ."      MOVS     r2,#0
        0x08000bbe:    619a        .a      STR      r2,[r3,#0x18]
;;;239      SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
        0x08000bc0:    2205        ."      MOVS     r2,#5
        0x08000bc2:    611a        .a      STR      r2,[r3,#0x10]
;;;240                       SysTick_CTRL_ENABLE_Msk;                   /* Enable the Systick Timer */
;;;241    }
        0x08000bc4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;188    }
        0x08000bc6:    4770        pG      BX       lr
    i.LL_RCC_GetSystemClocksFreq
    LL_RCC_GetSystemClocksFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;206    {
        0x08000bc8:    b510        ..      PUSH     {r4,lr}
        0x08000bca:    4604        .F      MOV      r4,r0
;;;207      /* Get SYSCLK frequency */
;;;208      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
        0x08000bcc:    f001f868    ..h.    BL       RCC_GetSystemClockFreq ; 0x8001ca0
        0x08000bd0:    6020         `      STR      r0,[r4,#0]
;;;209    
;;;210      /* HCLK clock frequency */
;;;211      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
        0x08000bd2:    6820         h      LDR      r0,[r4,#0]
        0x08000bd4:    f001f830    ..0.    BL       RCC_GetHCLKClockFreq ; 0x8001c38
        0x08000bd8:    6060        ``      STR      r0,[r4,#4]
;;;212    
;;;213      /* PCLK1 clock frequency */
;;;214      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x08000bda:    6860        `h      LDR      r0,[r4,#4]
        0x08000bdc:    f001f83c    ..<.    BL       RCC_GetPCLK1ClockFreq ; 0x8001c58
        0x08000be0:    60a0        .`      STR      r0,[r4,#8]
;;;215    
;;;216      /* PCLK2 clock frequency */
;;;217      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x08000be2:    6860        `h      LDR      r0,[r4,#4]
        0x08000be4:    f001f84a    ..J.    BL       RCC_GetPCLK2ClockFreq ; 0x8001c7c
        0x08000be8:    60e0        .`      STR      r0,[r4,#0xc]
;;;218    }
        0x08000bea:    bd10        ..      POP      {r4,pc}
    i.LL_SetSystemCoreClock
    LL_SetSystemCoreClock
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;261      SystemCoreClock = HCLKFrequency;
        0x08000bec:    4901        .I      LDR      r1,[pc,#4] ; [0x8000bf4] = 0x20000000
        0x08000bee:    6008        .`      STR      r0,[r1,#0]
;;;262    }
        0x08000bf0:    4770        pG      BX       lr
    $d
        0x08000bf2:    0000        ..      DCW    0
        0x08000bf4:    20000000    ...     DCD    536870912
    $t
    i.LL_TIM_BDTR_Init
    LL_TIM_BDTR_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;715    {
        0x08000bf8:    b510        ..      PUSH     {r4,lr}
        0x08000bfa:    4603        .F      MOV      r3,r0
        0x08000bfc:    460a        .F      MOV      r2,r1
;;;716      uint32_t tmpbdtr = 0;
        0x08000bfe:    2100        .!      MOVS     r1,#0
;;;717    
;;;718      /* Check the parameters */
;;;719      assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
;;;720      assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
;;;721      assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
;;;722      assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
;;;723      assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
;;;724      assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
;;;725      assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
;;;726    
;;;727      /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;728      the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;729    
;;;730      /* Set the BDTR bits */
;;;731      MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
        0x08000c00:    7b14        .{      LDRB     r4,[r2,#0xc]
        0x08000c02:    4621        !F      MOV      r1,r4
;;;732      MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
        0x08000c04:    6890        .h      LDR      r0,[r2,#8]
        0x08000c06:    4301        .C      ORRS     r1,r1,r0
;;;733      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
        0x08000c08:    f4216080    !..`    BIC      r0,r1,#0x400
        0x08000c0c:    6854        Th      LDR      r4,[r2,#4]
        0x08000c0e:    ea400104    @...    ORR      r1,r0,r4
;;;734      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
        0x08000c12:    f4216000    !..`    BIC      r0,r1,#0x800
        0x08000c16:    6814        .h      LDR      r4,[r2,#0]
        0x08000c18:    ea400104    @...    ORR      r1,r0,r4
;;;735      MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
        0x08000c1c:    f4215080    !..P    BIC      r0,r1,#0x1000
        0x08000c20:    89d4        ..      LDRH     r4,[r2,#0xe]
        0x08000c22:    ea400104    @...    ORR      r1,r0,r4
;;;736      MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
        0x08000c26:    f4215000    !..P    BIC      r0,r1,#0x2000
        0x08000c2a:    6914        .i      LDR      r4,[r2,#0x10]
        0x08000c2c:    ea400104    @...    ORR      r1,r0,r4
;;;737      MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x08000c30:    f4214080    !..@    BIC      r0,r1,#0x4000
        0x08000c34:    6954        Ti      LDR      r4,[r2,#0x14]
        0x08000c36:    ea400104    @...    ORR      r1,r0,r4
;;;738      MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x08000c3a:    f4214000    !..@    BIC      r0,r1,#0x8000
        0x08000c3e:    6954        Ti      LDR      r4,[r2,#0x14]
        0x08000c40:    ea400104    @...    ORR      r1,r0,r4
;;;739    
;;;740      /* Set TIMx_BDTR */
;;;741      LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
        0x08000c44:    6459        Yd      STR      r1,[r3,#0x44]
;;;742    
;;;743      return SUCCESS;
        0x08000c46:    2001        .       MOVS     r0,#1
;;;744    }
        0x08000c48:    bd10        ..      POP      {r4,pc}
    i.LL_TIM_CC_DisableChannel
    LL_TIM_CC_DisableChannel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
        0x08000c4a:    6a02        .j      LDR      r2,[r0,#0x20]
        0x08000c4c:    438a        .C      BICS     r2,r2,r1
        0x08000c4e:    6202        .b      STR      r2,[r0,#0x20]
;;;1519   }
        0x08000c50:    4770        pG      BX       lr
    i.LL_TIM_CC_EnableChannel
    LL_TIM_CC_EnableChannel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1493)
        0x08000c52:    6a02        .j      LDR      r2,[r0,#0x20]
        0x08000c54:    430a        .C      ORRS     r2,r2,r1
        0x08000c56:    6202        .b      STR      r2,[r0,#0x20]
;;;1494   }
        0x08000c58:    4770        pG      BX       lr
    i.LL_TIM_DisableARRPreload
    LL_TIM_DisableARRPreload
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1209)
        0x08000c5a:    6801        .h      LDR      r1,[r0,#0]
        0x08000c5c:    f0210180    !...    BIC      r1,r1,#0x80
        0x08000c60:    6001        .`      STR      r1,[r0,#0]
;;;1210   }
        0x08000c62:    4770        pG      BX       lr
    i.LL_TIM_DisableMasterSlaveMode
    LL_TIM_DisableMasterSlaveMode
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000c64:    6881        .h      LDR      r1,[r0,#8]
        0x08000c66:    f0210180    !...    BIC      r1,r1,#0x80
        0x08000c6a:    6081        .`      STR      r1,[r0,#8]
        0x08000c6c:    4770        pG      BX       lr
    i.LL_TIM_EnableARRPreload
    LL_TIM_EnableARRPreload
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1198)
        0x08000c6e:    6801        .h      LDR      r1,[r0,#0]
        0x08000c70:    f0410180    A...    ORR      r1,r1,#0x80
        0x08000c74:    6001        .`      STR      r1,[r0,#0]
;;;1199   }
        0x08000c76:    4770        pG      BX       lr
    i.LL_TIM_EnableIT_UPDATE
    LL_TIM_EnableIT_UPDATE
;;;1200   
;;;1201   /**
;;;1202     * @brief  Disable auto-reload (ARR) preload.
;;;1203     * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
;;;1204     * @param  TIMx Timer instance
;;;1205     * @retval None
;;;1206     */
;;;1207   __STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
;;;1208   {
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2645   }
;;;2646   
;;;2647   /**
;;;2648     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2649     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2650     * a timer instance can operate as a slave timer.
;;;2651     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2652     * @param  TIMx Timer instance
;;;2653     * @retval State of bit (1 or 0).
;;;2654     */
;;;2655   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2656   {
;;;2657     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2658   }
;;;2659   
;;;2660   /**
;;;2661     * @brief  Configure the external trigger (ETR) input.
;;;2662     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2663     *       a timer instance provides an external trigger input.
;;;2664     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2665     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2666     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2667     * @param  TIMx Timer instance
;;;2668     * @param  ETRPolarity This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2670     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2671     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2673     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2674     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2675     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2676     * @param  ETRFilter This parameter can be one of the following values:
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2690     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2691     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2692     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2693     * @retval None
;;;2694     */
;;;2695   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2696                                         uint32_t ETRFilter)
;;;2697   {
;;;2698     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2699   }
;;;2700   
;;;2701   /**
;;;2702     * @}
;;;2703     */
;;;2704   
;;;2705   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2706     * @{
;;;2707     */
;;;2708   /**
;;;2709     * @brief  Enable the break function.
;;;2710     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2711     *       a timer instance provides a break input.
;;;2712     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2713     * @param  TIMx Timer instance
;;;2714     * @retval None
;;;2715     */
;;;2716   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2717   {
;;;2718     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2719   }
;;;2720   
;;;2721   /**
;;;2722     * @brief  Disable the break function.
;;;2723     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2724     * @param  TIMx Timer instance
;;;2725     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2726     *       a timer instance provides a break input.
;;;2727     * @retval None
;;;2728     */
;;;2729   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2730   {
;;;2731     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2732   }
;;;2733   
;;;2734   /**
;;;2735     * @brief  Configure the break input.
;;;2736     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2737     *       a timer instance provides a break input.
;;;2738     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2739     * @param  TIMx Timer instance
;;;2740     * @param  BreakPolarity This parameter can be one of the following values:
;;;2741     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2742     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2743     * @retval None
;;;2744     */
;;;2745   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2746   {
;;;2747     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2748   }
;;;2749   
;;;2750   /**
;;;2751     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2752     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2753     *       a timer instance provides a break input.
;;;2754     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2755     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2756     * @param  TIMx Timer instance
;;;2757     * @param  OffStateIdle This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2760     * @param  OffStateRun This parameter can be one of the following values:
;;;2761     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2762     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2763     * @retval None
;;;2764     */
;;;2765   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2766   {
;;;2767     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2768   }
;;;2769   
;;;2770   /**
;;;2771     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2772     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2773     *       a timer instance provides a break input.
;;;2774     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2775     * @param  TIMx Timer instance
;;;2776     * @retval None
;;;2777     */
;;;2778   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2779   {
;;;2780     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2781   }
;;;2782   
;;;2783   /**
;;;2784     * @brief  Disable automatic output (MOE can be set only by software).
;;;2785     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2786     *       a timer instance provides a break input.
;;;2787     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2788     * @param  TIMx Timer instance
;;;2789     * @retval None
;;;2790     */
;;;2791   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2792   {
;;;2793     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2794   }
;;;2795   
;;;2796   /**
;;;2797     * @brief  Indicate whether automatic output is enabled.
;;;2798     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2799     *       a timer instance provides a break input.
;;;2800     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2801     * @param  TIMx Timer instance
;;;2802     * @retval State of bit (1 or 0).
;;;2803     */
;;;2804   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2805   {
;;;2806     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2807   }
;;;2808   
;;;2809   /**
;;;2810     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2811     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2812     *       software and is reset in case of break or break2 event
;;;2813     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2814     *       a timer instance provides a break input.
;;;2815     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2816     * @param  TIMx Timer instance
;;;2817     * @retval None
;;;2818     */
;;;2819   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2820   {
;;;2821     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2822   }
;;;2823   
;;;2824   /**
;;;2825     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2826     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2827     *       software and is reset in case of break or break2 event.
;;;2828     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2829     *       a timer instance provides a break input.
;;;2830     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2831     * @param  TIMx Timer instance
;;;2832     * @retval None
;;;2833     */
;;;2834   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2835   {
;;;2836     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2837   }
;;;2838   
;;;2839   /**
;;;2840     * @brief  Indicates whether outputs are enabled.
;;;2841     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2842     *       a timer instance provides a break input.
;;;2843     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2844     * @param  TIMx Timer instance
;;;2845     * @retval State of bit (1 or 0).
;;;2846     */
;;;2847   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2848   {
;;;2849     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2850   }
;;;2851   
;;;2852   /**
;;;2853     * @}
;;;2854     */
;;;2855   
;;;2856   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2857     * @{
;;;2858     */
;;;2859   /**
;;;2860     * @brief  Configures the timer DMA burst feature.
;;;2861     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2862     *       not a timer instance supports the DMA burst mode.
;;;2863     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2864     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2865     * @param  TIMx Timer instance
;;;2866     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2882     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2883     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2884     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2885     * @param  DMABurstLength This parameter can be one of the following values:
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2901     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2902     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2903     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2904     * @retval None
;;;2905     */
;;;2906   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2907   {
;;;2908     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2909   }
;;;2910   
;;;2911   /**
;;;2912     * @}
;;;2913     */
;;;2914   
;;;2915   
;;;2916   /**
;;;2917     * @}
;;;2918     */
;;;2919   
;;;2920   
;;;2921   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2922     * @{
;;;2923     */
;;;2924   /**
;;;2925     * @brief  Clear the update interrupt flag (UIF).
;;;2926     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2927     * @param  TIMx Timer instance
;;;2928     * @retval None
;;;2929     */
;;;2930   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2931   {
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
        0x08000c78:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08000c7a:    f0410101    A...    ORR      r1,r1,#1
        0x08000c7e:    60c1        .`      STR      r1,[r0,#0xc]
        0x08000c80:    4770        pG      BX       lr
    i.LL_TIM_EnableMasterSlaveMode
    LL_TIM_EnableMasterSlaveMode
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2631)
        0x08000c82:    6881        .h      LDR      r1,[r0,#8]
        0x08000c84:    f0410180    A...    ORR      r1,r1,#0x80
        0x08000c88:    6081        .`      STR      r1,[r0,#8]
;;;2632   }
        0x08000c8a:    4770        pG      BX       lr
    i.LL_TIM_GenerateEvent_UPDATE
    LL_TIM_GenerateEvent_UPDATE
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2645   }
;;;2646   
;;;2647   /**
;;;2648     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2649     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2650     * a timer instance can operate as a slave timer.
;;;2651     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2652     * @param  TIMx Timer instance
;;;2653     * @retval State of bit (1 or 0).
;;;2654     */
;;;2655   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2656   {
;;;2657     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2658   }
;;;2659   
;;;2660   /**
;;;2661     * @brief  Configure the external trigger (ETR) input.
;;;2662     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2663     *       a timer instance provides an external trigger input.
;;;2664     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2665     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2666     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2667     * @param  TIMx Timer instance
;;;2668     * @param  ETRPolarity This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2670     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2671     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2673     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2674     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2675     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2676     * @param  ETRFilter This parameter can be one of the following values:
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2690     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2691     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2692     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2693     * @retval None
;;;2694     */
;;;2695   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2696                                         uint32_t ETRFilter)
;;;2697   {
;;;2698     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2699   }
;;;2700   
;;;2701   /**
;;;2702     * @}
;;;2703     */
;;;2704   
;;;2705   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2706     * @{
;;;2707     */
;;;2708   /**
;;;2709     * @brief  Enable the break function.
;;;2710     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2711     *       a timer instance provides a break input.
;;;2712     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2713     * @param  TIMx Timer instance
;;;2714     * @retval None
;;;2715     */
;;;2716   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2717   {
;;;2718     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2719   }
;;;2720   
;;;2721   /**
;;;2722     * @brief  Disable the break function.
;;;2723     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2724     * @param  TIMx Timer instance
;;;2725     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2726     *       a timer instance provides a break input.
;;;2727     * @retval None
;;;2728     */
;;;2729   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2730   {
;;;2731     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2732   }
;;;2733   
;;;2734   /**
;;;2735     * @brief  Configure the break input.
;;;2736     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2737     *       a timer instance provides a break input.
;;;2738     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2739     * @param  TIMx Timer instance
;;;2740     * @param  BreakPolarity This parameter can be one of the following values:
;;;2741     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2742     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2743     * @retval None
;;;2744     */
;;;2745   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2746   {
;;;2747     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2748   }
;;;2749   
;;;2750   /**
;;;2751     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2752     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2753     *       a timer instance provides a break input.
;;;2754     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2755     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2756     * @param  TIMx Timer instance
;;;2757     * @param  OffStateIdle This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2760     * @param  OffStateRun This parameter can be one of the following values:
;;;2761     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2762     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2763     * @retval None
;;;2764     */
;;;2765   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2766   {
;;;2767     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2768   }
;;;2769   
;;;2770   /**
;;;2771     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2772     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2773     *       a timer instance provides a break input.
;;;2774     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2775     * @param  TIMx Timer instance
;;;2776     * @retval None
;;;2777     */
;;;2778   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2779   {
;;;2780     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2781   }
;;;2782   
;;;2783   /**
;;;2784     * @brief  Disable automatic output (MOE can be set only by software).
;;;2785     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2786     *       a timer instance provides a break input.
;;;2787     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2788     * @param  TIMx Timer instance
;;;2789     * @retval None
;;;2790     */
;;;2791   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2792   {
;;;2793     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2794   }
;;;2795   
;;;2796   /**
;;;2797     * @brief  Indicate whether automatic output is enabled.
;;;2798     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2799     *       a timer instance provides a break input.
;;;2800     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2801     * @param  TIMx Timer instance
;;;2802     * @retval State of bit (1 or 0).
;;;2803     */
;;;2804   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2805   {
;;;2806     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2807   }
;;;2808   
;;;2809   /**
;;;2810     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2811     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2812     *       software and is reset in case of break or break2 event
;;;2813     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2814     *       a timer instance provides a break input.
;;;2815     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2816     * @param  TIMx Timer instance
;;;2817     * @retval None
;;;2818     */
;;;2819   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2820   {
;;;2821     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2822   }
;;;2823   
;;;2824   /**
;;;2825     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2826     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2827     *       software and is reset in case of break or break2 event.
;;;2828     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2829     *       a timer instance provides a break input.
;;;2830     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2831     * @param  TIMx Timer instance
;;;2832     * @retval None
;;;2833     */
;;;2834   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2835   {
;;;2836     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2837   }
;;;2838   
;;;2839   /**
;;;2840     * @brief  Indicates whether outputs are enabled.
;;;2841     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2842     *       a timer instance provides a break input.
;;;2843     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2844     * @param  TIMx Timer instance
;;;2845     * @retval State of bit (1 or 0).
;;;2846     */
;;;2847   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2848   {
;;;2849     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2850   }
;;;2851   
;;;2852   /**
;;;2853     * @}
;;;2854     */
;;;2855   
;;;2856   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2857     * @{
;;;2858     */
;;;2859   /**
;;;2860     * @brief  Configures the timer DMA burst feature.
;;;2861     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2862     *       not a timer instance supports the DMA burst mode.
;;;2863     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2864     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2865     * @param  TIMx Timer instance
;;;2866     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2882     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2883     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2884     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2885     * @param  DMABurstLength This parameter can be one of the following values:
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2901     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2902     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2903     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2904     * @retval None
;;;2905     */
;;;2906   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2907   {
;;;2908     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2909   }
;;;2910   
;;;2911   /**
;;;2912     * @}
;;;2913     */
;;;2914   
;;;2915   
;;;2916   /**
;;;2917     * @}
;;;2918     */
;;;2919   
;;;2920   
;;;2921   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2922     * @{
;;;2923     */
;;;2924   /**
;;;2925     * @brief  Clear the update interrupt flag (UIF).
;;;2926     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2927     * @param  TIMx Timer instance
;;;2928     * @retval None
;;;2929     */
;;;2930   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2931   {
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3204   }
;;;3205   
;;;3206   /**
;;;3207     * @brief  Disable update interrupt (UIE).
;;;3208     * @rmtoll DIER         UIE           LL_TIM_DisableIT_UPDATE
;;;3209     * @param  TIMx Timer instance
;;;3210     * @retval None
;;;3211     */
;;;3212   __STATIC_INLINE void LL_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3213   {
;;;3214     CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3215   }
;;;3216   
;;;3217   /**
;;;3218     * @brief  Indicates whether the update interrupt (UIE) is enabled.
;;;3219     * @rmtoll DIER         UIE           LL_TIM_IsEnabledIT_UPDATE
;;;3220     * @param  TIMx Timer instance
;;;3221     * @retval State of bit (1 or 0).
;;;3222     */
;;;3223   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
;;;3224   {
;;;3225     return (READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE));
;;;3226   }
;;;3227   
;;;3228   /**
;;;3229     * @brief  Enable capture/compare 1 interrupt (CC1IE).
;;;3230     * @rmtoll DIER         CC1IE         LL_TIM_EnableIT_CC1
;;;3231     * @param  TIMx Timer instance
;;;3232     * @retval None
;;;3233     */
;;;3234   __STATIC_INLINE void LL_TIM_EnableIT_CC1(TIM_TypeDef *TIMx)
;;;3235   {
;;;3236     SET_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3237   }
;;;3238   
;;;3239   /**
;;;3240     * @brief  Disable capture/compare 1  interrupt (CC1IE).
;;;3241     * @rmtoll DIER         CC1IE         LL_TIM_DisableIT_CC1
;;;3242     * @param  TIMx Timer instance
;;;3243     * @retval None
;;;3244     */
;;;3245   __STATIC_INLINE void LL_TIM_DisableIT_CC1(TIM_TypeDef *TIMx)
;;;3246   {
;;;3247     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3248   }
;;;3249   
;;;3250   /**
;;;3251     * @brief  Indicates whether the capture/compare 1 interrupt (CC1IE) is enabled.
;;;3252     * @rmtoll DIER         CC1IE         LL_TIM_IsEnabledIT_CC1
;;;3253     * @param  TIMx Timer instance
;;;3254     * @retval State of bit (1 or 0).
;;;3255     */
;;;3256   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx)
;;;3257   {
;;;3258     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1IE) == (TIM_DIER_CC1IE));
;;;3259   }
;;;3260   
;;;3261   /**
;;;3262     * @brief  Enable capture/compare 2 interrupt (CC2IE).
;;;3263     * @rmtoll DIER         CC2IE         LL_TIM_EnableIT_CC2
;;;3264     * @param  TIMx Timer instance
;;;3265     * @retval None
;;;3266     */
;;;3267   __STATIC_INLINE void LL_TIM_EnableIT_CC2(TIM_TypeDef *TIMx)
;;;3268   {
;;;3269     SET_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3270   }
;;;3271   
;;;3272   /**
;;;3273     * @brief  Disable capture/compare 2  interrupt (CC2IE).
;;;3274     * @rmtoll DIER         CC2IE         LL_TIM_DisableIT_CC2
;;;3275     * @param  TIMx Timer instance
;;;3276     * @retval None
;;;3277     */
;;;3278   __STATIC_INLINE void LL_TIM_DisableIT_CC2(TIM_TypeDef *TIMx)
;;;3279   {
;;;3280     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3281   }
;;;3282   
;;;3283   /**
;;;3284     * @brief  Indicates whether the capture/compare 2 interrupt (CC2IE) is enabled.
;;;3285     * @rmtoll DIER         CC2IE         LL_TIM_IsEnabledIT_CC2
;;;3286     * @param  TIMx Timer instance
;;;3287     * @retval State of bit (1 or 0).
;;;3288     */
;;;3289   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx)
;;;3290   {
;;;3291     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2IE) == (TIM_DIER_CC2IE));
;;;3292   }
;;;3293   
;;;3294   /**
;;;3295     * @brief  Enable capture/compare 3 interrupt (CC3IE).
;;;3296     * @rmtoll DIER         CC3IE         LL_TIM_EnableIT_CC3
;;;3297     * @param  TIMx Timer instance
;;;3298     * @retval None
;;;3299     */
;;;3300   __STATIC_INLINE void LL_TIM_EnableIT_CC3(TIM_TypeDef *TIMx)
;;;3301   {
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3303   }
;;;3304   
;;;3305   /**
;;;3306     * @brief  Disable capture/compare 3  interrupt (CC3IE).
;;;3307     * @rmtoll DIER         CC3IE         LL_TIM_DisableIT_CC3
;;;3308     * @param  TIMx Timer instance
;;;3309     * @retval None
;;;3310     */
;;;3311   __STATIC_INLINE void LL_TIM_DisableIT_CC3(TIM_TypeDef *TIMx)
;;;3312   {
;;;3313     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3314   }
;;;3315   
;;;3316   /**
;;;3317     * @brief  Indicates whether the capture/compare 3 interrupt (CC3IE) is enabled.
;;;3318     * @rmtoll DIER         CC3IE         LL_TIM_IsEnabledIT_CC3
;;;3319     * @param  TIMx Timer instance
;;;3320     * @retval State of bit (1 or 0).
;;;3321     */
;;;3322   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx)
;;;3323   {
;;;3324     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3IE) == (TIM_DIER_CC3IE));
;;;3325   }
;;;3326   
;;;3327   /**
;;;3328     * @brief  Enable capture/compare 4 interrupt (CC4IE).
;;;3329     * @rmtoll DIER         CC4IE         LL_TIM_EnableIT_CC4
;;;3330     * @param  TIMx Timer instance
;;;3331     * @retval None
;;;3332     */
;;;3333   __STATIC_INLINE void LL_TIM_EnableIT_CC4(TIM_TypeDef *TIMx)
;;;3334   {
;;;3335     SET_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3336   }
;;;3337   
;;;3338   /**
;;;3339     * @brief  Disable capture/compare 4  interrupt (CC4IE).
;;;3340     * @rmtoll DIER         CC4IE         LL_TIM_DisableIT_CC4
;;;3341     * @param  TIMx Timer instance
;;;3342     * @retval None
;;;3343     */
;;;3344   __STATIC_INLINE void LL_TIM_DisableIT_CC4(TIM_TypeDef *TIMx)
;;;3345   {
;;;3346     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3347   }
;;;3348   
;;;3349   /**
;;;3350     * @brief  Indicates whether the capture/compare 4 interrupt (CC4IE) is enabled.
;;;3351     * @rmtoll DIER         CC4IE         LL_TIM_IsEnabledIT_CC4
;;;3352     * @param  TIMx Timer instance
;;;3353     * @retval State of bit (1 or 0).
;;;3354     */
;;;3355   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx)
;;;3356   {
;;;3357     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4IE) == (TIM_DIER_CC4IE));
;;;3358   }
;;;3359   
;;;3360   /**
;;;3361     * @brief  Enable commutation interrupt (COMIE).
;;;3362     * @rmtoll DIER         COMIE         LL_TIM_EnableIT_COM
;;;3363     * @param  TIMx Timer instance
;;;3364     * @retval None
;;;3365     */
;;;3366   __STATIC_INLINE void LL_TIM_EnableIT_COM(TIM_TypeDef *TIMx)
;;;3367   {
;;;3368     SET_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3369   }
;;;3370   
;;;3371   /**
;;;3372     * @brief  Disable commutation interrupt (COMIE).
;;;3373     * @rmtoll DIER         COMIE         LL_TIM_DisableIT_COM
;;;3374     * @param  TIMx Timer instance
;;;3375     * @retval None
;;;3376     */
;;;3377   __STATIC_INLINE void LL_TIM_DisableIT_COM(TIM_TypeDef *TIMx)
;;;3378   {
;;;3379     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3380   }
;;;3381   
;;;3382   /**
;;;3383     * @brief  Indicates whether the commutation interrupt (COMIE) is enabled.
;;;3384     * @rmtoll DIER         COMIE         LL_TIM_IsEnabledIT_COM
;;;3385     * @param  TIMx Timer instance
;;;3386     * @retval State of bit (1 or 0).
;;;3387     */
;;;3388   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx)
;;;3389   {
;;;3390     return (READ_BIT(TIMx->DIER, TIM_DIER_COMIE) == (TIM_DIER_COMIE));
;;;3391   }
;;;3392   
;;;3393   /**
;;;3394     * @brief  Enable trigger interrupt (TIE).
;;;3395     * @rmtoll DIER         TIE           LL_TIM_EnableIT_TRIG
;;;3396     * @param  TIMx Timer instance
;;;3397     * @retval None
;;;3398     */
;;;3399   __STATIC_INLINE void LL_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx)
;;;3400   {
;;;3401     SET_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3402   }
;;;3403   
;;;3404   /**
;;;3405     * @brief  Disable trigger interrupt (TIE).
;;;3406     * @rmtoll DIER         TIE           LL_TIM_DisableIT_TRIG
;;;3407     * @param  TIMx Timer instance
;;;3408     * @retval None
;;;3409     */
;;;3410   __STATIC_INLINE void LL_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx)
;;;3411   {
;;;3412     CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3413   }
;;;3414   
;;;3415   /**
;;;3416     * @brief  Indicates whether the trigger interrupt (TIE) is enabled.
;;;3417     * @rmtoll DIER         TIE           LL_TIM_IsEnabledIT_TRIG
;;;3418     * @param  TIMx Timer instance
;;;3419     * @retval State of bit (1 or 0).
;;;3420     */
;;;3421   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx)
;;;3422   {
;;;3423     return (READ_BIT(TIMx->DIER, TIM_DIER_TIE) == (TIM_DIER_TIE));
;;;3424   }
;;;3425   
;;;3426   /**
;;;3427     * @brief  Enable break interrupt (BIE).
;;;3428     * @rmtoll DIER         BIE           LL_TIM_EnableIT_BRK
;;;3429     * @param  TIMx Timer instance
;;;3430     * @retval None
;;;3431     */
;;;3432   __STATIC_INLINE void LL_TIM_EnableIT_BRK(TIM_TypeDef *TIMx)
;;;3433   {
;;;3434     SET_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3435   }
;;;3436   
;;;3437   /**
;;;3438     * @brief  Disable break interrupt (BIE).
;;;3439     * @rmtoll DIER         BIE           LL_TIM_DisableIT_BRK
;;;3440     * @param  TIMx Timer instance
;;;3441     * @retval None
;;;3442     */
;;;3443   __STATIC_INLINE void LL_TIM_DisableIT_BRK(TIM_TypeDef *TIMx)
;;;3444   {
;;;3445     CLEAR_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3446   }
;;;3447   
;;;3448   /**
;;;3449     * @brief  Indicates whether the break interrupt (BIE) is enabled.
;;;3450     * @rmtoll DIER         BIE           LL_TIM_IsEnabledIT_BRK
;;;3451     * @param  TIMx Timer instance
;;;3452     * @retval State of bit (1 or 0).
;;;3453     */
;;;3454   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx)
;;;3455   {
;;;3456     return (READ_BIT(TIMx->DIER, TIM_DIER_BIE) == (TIM_DIER_BIE));
;;;3457   }
;;;3458   
;;;3459   /**
;;;3460     * @}
;;;3461     */
;;;3462   
;;;3463   /** @defgroup TIM_LL_EF_DMA_Management DMA-Management
;;;3464     * @{
;;;3465     */
;;;3466   /**
;;;3467     * @brief  Enable update DMA request (UDE).
;;;3468     * @rmtoll DIER         UDE           LL_TIM_EnableDMAReq_UPDATE
;;;3469     * @param  TIMx Timer instance
;;;3470     * @retval None
;;;3471     */
;;;3472   __STATIC_INLINE void LL_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3473   {
;;;3474     SET_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3475   }
;;;3476   
;;;3477   /**
;;;3478     * @brief  Disable update DMA request (UDE).
;;;3479     * @rmtoll DIER         UDE           LL_TIM_DisableDMAReq_UPDATE
;;;3480     * @param  TIMx Timer instance
;;;3481     * @retval None
;;;3482     */
;;;3483   __STATIC_INLINE void LL_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3484   {
;;;3485     CLEAR_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3486   }
;;;3487   
;;;3488   /**
;;;3489     * @brief  Indicates whether the update DMA request  (UDE) is enabled.
;;;3490     * @rmtoll DIER         UDE           LL_TIM_IsEnabledDMAReq_UPDATE
;;;3491     * @param  TIMx Timer instance
;;;3492     * @retval State of bit (1 or 0).
;;;3493     */
;;;3494   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3495   {
;;;3496     return (READ_BIT(TIMx->DIER, TIM_DIER_UDE) == (TIM_DIER_UDE));
;;;3497   }
;;;3498   
;;;3499   /**
;;;3500     * @brief  Enable capture/compare 1 DMA request (CC1DE).
;;;3501     * @rmtoll DIER         CC1DE         LL_TIM_EnableDMAReq_CC1
;;;3502     * @param  TIMx Timer instance
;;;3503     * @retval None
;;;3504     */
;;;3505   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3506   {
;;;3507     SET_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3508   }
;;;3509   
;;;3510   /**
;;;3511     * @brief  Disable capture/compare 1  DMA request (CC1DE).
;;;3512     * @rmtoll DIER         CC1DE         LL_TIM_DisableDMAReq_CC1
;;;3513     * @param  TIMx Timer instance
;;;3514     * @retval None
;;;3515     */
;;;3516   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3517   {
;;;3518     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3519   }
;;;3520   
;;;3521   /**
;;;3522     * @brief  Indicates whether the capture/compare 1 DMA request (CC1DE) is enabled.
;;;3523     * @rmtoll DIER         CC1DE         LL_TIM_IsEnabledDMAReq_CC1
;;;3524     * @param  TIMx Timer instance
;;;3525     * @retval State of bit (1 or 0).
;;;3526     */
;;;3527   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3528   {
;;;3529     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1DE) == (TIM_DIER_CC1DE));
;;;3530   }
;;;3531   
;;;3532   /**
;;;3533     * @brief  Enable capture/compare 2 DMA request (CC2DE).
;;;3534     * @rmtoll DIER         CC2DE         LL_TIM_EnableDMAReq_CC2
;;;3535     * @param  TIMx Timer instance
;;;3536     * @retval None
;;;3537     */
;;;3538   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3539   {
;;;3540     SET_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3541   }
;;;3542   
;;;3543   /**
;;;3544     * @brief  Disable capture/compare 2  DMA request (CC2DE).
;;;3545     * @rmtoll DIER         CC2DE         LL_TIM_DisableDMAReq_CC2
;;;3546     * @param  TIMx Timer instance
;;;3547     * @retval None
;;;3548     */
;;;3549   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3550   {
;;;3551     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3552   }
;;;3553   
;;;3554   /**
;;;3555     * @brief  Indicates whether the capture/compare 2 DMA request (CC2DE) is enabled.
;;;3556     * @rmtoll DIER         CC2DE         LL_TIM_IsEnabledDMAReq_CC2
;;;3557     * @param  TIMx Timer instance
;;;3558     * @retval State of bit (1 or 0).
;;;3559     */
;;;3560   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3561   {
;;;3562     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2DE) == (TIM_DIER_CC2DE));
;;;3563   }
;;;3564   
;;;3565   /**
;;;3566     * @brief  Enable capture/compare 3 DMA request (CC3DE).
;;;3567     * @rmtoll DIER         CC3DE         LL_TIM_EnableDMAReq_CC3
;;;3568     * @param  TIMx Timer instance
;;;3569     * @retval None
;;;3570     */
;;;3571   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3572   {
;;;3573     SET_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3574   }
;;;3575   
;;;3576   /**
;;;3577     * @brief  Disable capture/compare 3  DMA request (CC3DE).
;;;3578     * @rmtoll DIER         CC3DE         LL_TIM_DisableDMAReq_CC3
;;;3579     * @param  TIMx Timer instance
;;;3580     * @retval None
;;;3581     */
;;;3582   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3583   {
;;;3584     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3585   }
;;;3586   
;;;3587   /**
;;;3588     * @brief  Indicates whether the capture/compare 3 DMA request (CC3DE) is enabled.
;;;3589     * @rmtoll DIER         CC3DE         LL_TIM_IsEnabledDMAReq_CC3
;;;3590     * @param  TIMx Timer instance
;;;3591     * @retval State of bit (1 or 0).
;;;3592     */
;;;3593   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3594   {
;;;3595     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3DE) == (TIM_DIER_CC3DE));
;;;3596   }
;;;3597   
;;;3598   /**
;;;3599     * @brief  Enable capture/compare 4 DMA request (CC4DE).
;;;3600     * @rmtoll DIER         CC4DE         LL_TIM_EnableDMAReq_CC4
;;;3601     * @param  TIMx Timer instance
;;;3602     * @retval None
;;;3603     */
;;;3604   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3605   {
;;;3606     SET_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3607   }
;;;3608   
;;;3609   /**
;;;3610     * @brief  Disable capture/compare 4  DMA request (CC4DE).
;;;3611     * @rmtoll DIER         CC4DE         LL_TIM_DisableDMAReq_CC4
;;;3612     * @param  TIMx Timer instance
;;;3613     * @retval None
;;;3614     */
;;;3615   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3616   {
;;;3617     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3618   }
;;;3619   
;;;3620   /**
;;;3621     * @brief  Indicates whether the capture/compare 4 DMA request (CC4DE) is enabled.
;;;3622     * @rmtoll DIER         CC4DE         LL_TIM_IsEnabledDMAReq_CC4
;;;3623     * @param  TIMx Timer instance
;;;3624     * @retval State of bit (1 or 0).
;;;3625     */
;;;3626   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3627   {
;;;3628     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4DE) == (TIM_DIER_CC4DE));
;;;3629   }
;;;3630   
;;;3631   /**
;;;3632     * @brief  Enable commutation DMA request (COMDE).
;;;3633     * @rmtoll DIER         COMDE         LL_TIM_EnableDMAReq_COM
;;;3634     * @param  TIMx Timer instance
;;;3635     * @retval None
;;;3636     */
;;;3637   __STATIC_INLINE void LL_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3638   {
;;;3639     SET_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3640   }
;;;3641   
;;;3642   /**
;;;3643     * @brief  Disable commutation DMA request (COMDE).
;;;3644     * @rmtoll DIER         COMDE         LL_TIM_DisableDMAReq_COM
;;;3645     * @param  TIMx Timer instance
;;;3646     * @retval None
;;;3647     */
;;;3648   __STATIC_INLINE void LL_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3649   {
;;;3650     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3651   }
;;;3652   
;;;3653   /**
;;;3654     * @brief  Indicates whether the commutation DMA request (COMDE) is enabled.
;;;3655     * @rmtoll DIER         COMDE         LL_TIM_IsEnabledDMAReq_COM
;;;3656     * @param  TIMx Timer instance
;;;3657     * @retval State of bit (1 or 0).
;;;3658     */
;;;3659   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx)
;;;3660   {
;;;3661     return (READ_BIT(TIMx->DIER, TIM_DIER_COMDE) == (TIM_DIER_COMDE));
;;;3662   }
;;;3663   
;;;3664   /**
;;;3665     * @brief  Enable trigger interrupt (TDE).
;;;3666     * @rmtoll DIER         TDE           LL_TIM_EnableDMAReq_TRIG
;;;3667     * @param  TIMx Timer instance
;;;3668     * @retval None
;;;3669     */
;;;3670   __STATIC_INLINE void LL_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3671   {
;;;3672     SET_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3673   }
;;;3674   
;;;3675   /**
;;;3676     * @brief  Disable trigger interrupt (TDE).
;;;3677     * @rmtoll DIER         TDE           LL_TIM_DisableDMAReq_TRIG
;;;3678     * @param  TIMx Timer instance
;;;3679     * @retval None
;;;3680     */
;;;3681   __STATIC_INLINE void LL_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3682   {
;;;3683     CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3684   }
;;;3685   
;;;3686   /**
;;;3687     * @brief  Indicates whether the trigger interrupt (TDE) is enabled.
;;;3688     * @rmtoll DIER         TDE           LL_TIM_IsEnabledDMAReq_TRIG
;;;3689     * @param  TIMx Timer instance
;;;3690     * @retval State of bit (1 or 0).
;;;3691     */
;;;3692   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3693   {
;;;3694     return (READ_BIT(TIMx->DIER, TIM_DIER_TDE) == (TIM_DIER_TDE));
;;;3695   }
;;;3696   
;;;3697   /**
;;;3698     * @}
;;;3699     */
;;;3700   
;;;3701   /** @defgroup TIM_LL_EF_EVENT_Management EVENT-Management
;;;3702     * @{
;;;3703     */
;;;3704   /**
;;;3705     * @brief  Generate an update event.
;;;3706     * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
;;;3707     * @param  TIMx Timer instance
;;;3708     * @retval None
;;;3709     */
;;;3710   __STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
;;;3711   {
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08000c8c:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08000c8e:    f0410101    A...    ORR      r1,r1,#1
        0x08000c92:    6141        Aa      STR      r1,[r0,#0x14]
;;;3713   }
        0x08000c94:    4770        pG      BX       lr
        0x08000c96:    0000        ..      MOVS     r0,r0
    i.LL_TIM_IC_SetActiveInput
    LL_TIM_IC_SetActiveInput
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2164)
        0x08000c98:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000c9a:    4603        .F      MOV      r3,r0
        0x08000c9c:    4614        .F      MOV      r4,r2
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000c9e:    2901        .)      CMP      r1,#1
        0x08000ca0:    d101        ..      BNE      0x8000ca6 ; LL_TIM_IC_SetActiveInput + 14
        0x08000ca2:    2500        .%      MOVS     r5,#0
        0x08000ca4:    e016        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000ca6:    2904        .)      CMP      r1,#4
        0x08000ca8:    d101        ..      BNE      0x8000cae ; LL_TIM_IC_SetActiveInput + 22
        0x08000caa:    2501        .%      MOVS     r5,#1
        0x08000cac:    e012        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cae:    2910        .)      CMP      r1,#0x10
        0x08000cb0:    d101        ..      BNE      0x8000cb6 ; LL_TIM_IC_SetActiveInput + 30
        0x08000cb2:    2502        .%      MOVS     r5,#2
        0x08000cb4:    e00e        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cb6:    2940        @)      CMP      r1,#0x40
        0x08000cb8:    d101        ..      BNE      0x8000cbe ; LL_TIM_IC_SetActiveInput + 38
        0x08000cba:    2503        .%      MOVS     r5,#3
        0x08000cbc:    e00a        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cbe:    f5b17f80    ....    CMP      r1,#0x100
        0x08000cc2:    d101        ..      BNE      0x8000cc8 ; LL_TIM_IC_SetActiveInput + 48
        0x08000cc4:    2504        .%      MOVS     r5,#4
        0x08000cc6:    e005        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cc8:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000ccc:    d101        ..      BNE      0x8000cd2 ; LL_TIM_IC_SetActiveInput + 58
        0x08000cce:    2505        .%      MOVS     r5,#5
        0x08000cd0:    e000        ..      B        0x8000cd4 ; LL_TIM_IC_SetActiveInput + 60
        0x08000cd2:    2506        .%      MOVS     r5,#6
        0x08000cd4:    4628        (F      MOV      r0,r5
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000cd6:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000cfc] = 0x80031ef
        0x08000cd8:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000cda:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000cde:    1972        r.      ADDS     r2,r6,r5
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000ce0:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000d00] = 0x80031fd
        0x08000ce2:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000ce4:    2603        .&      MOVS     r6,#3
        0x08000ce6:    40be        .@      LSLS     r6,r6,r7
        0x08000ce8:    6815        .h      LDR      r5,[r2,#0]
        0x08000cea:    43b5        .C      BICS     r5,r5,r6
        0x08000cec:    0c26        &.      LSRS     r6,r4,#16
        0x08000cee:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000d00] = 0x80031fd
        0x08000cf0:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000cf2:    40be        .@      LSLS     r6,r6,r7
        0x08000cf4:    4335        5C      ORRS     r5,r5,r6
        0x08000cf6:    6015        .`      STR      r5,[r2,#0]
;;;2168   }
        0x08000cf8:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000cfa:    0000        ..      DCW    0
        0x08000cfc:    080031ef    .1..    DCD    134230511
        0x08000d00:    080031fd    .1..    DCD    134230525
    $t
    i.LL_TIM_IC_SetFilter
    LL_TIM_IC_SetFilter
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
        0x08000d04:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000d06:    4603        .F      MOV      r3,r0
        0x08000d08:    4614        .F      MOV      r4,r2
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000d0a:    2901        .)      CMP      r1,#1
        0x08000d0c:    d101        ..      BNE      0x8000d12 ; LL_TIM_IC_SetFilter + 14
        0x08000d0e:    2500        .%      MOVS     r5,#0
        0x08000d10:    e016        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d12:    2904        .)      CMP      r1,#4
        0x08000d14:    d101        ..      BNE      0x8000d1a ; LL_TIM_IC_SetFilter + 22
        0x08000d16:    2501        .%      MOVS     r5,#1
        0x08000d18:    e012        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d1a:    2910        .)      CMP      r1,#0x10
        0x08000d1c:    d101        ..      BNE      0x8000d22 ; LL_TIM_IC_SetFilter + 30
        0x08000d1e:    2502        .%      MOVS     r5,#2
        0x08000d20:    e00e        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d22:    2940        @)      CMP      r1,#0x40
        0x08000d24:    d101        ..      BNE      0x8000d2a ; LL_TIM_IC_SetFilter + 38
        0x08000d26:    2503        .%      MOVS     r5,#3
        0x08000d28:    e00a        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d2a:    f5b17f80    ....    CMP      r1,#0x100
        0x08000d2e:    d101        ..      BNE      0x8000d34 ; LL_TIM_IC_SetFilter + 48
        0x08000d30:    2504        .%      MOVS     r5,#4
        0x08000d32:    e005        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d34:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000d38:    d101        ..      BNE      0x8000d3e ; LL_TIM_IC_SetFilter + 58
        0x08000d3a:    2505        .%      MOVS     r5,#5
        0x08000d3c:    e000        ..      B        0x8000d40 ; LL_TIM_IC_SetFilter + 60
        0x08000d3e:    2506        .%      MOVS     r5,#6
        0x08000d40:    4628        (F      MOV      r0,r5
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000d42:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000d68] = 0x80031ef
        0x08000d44:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000d46:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000d4a:    1972        r.      ADDS     r2,r6,r5
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000d4c:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000d6c] = 0x80031fd
        0x08000d4e:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000d50:    26f0        .&      MOVS     r6,#0xf0
        0x08000d52:    40be        .@      LSLS     r6,r6,r7
        0x08000d54:    6815        .h      LDR      r5,[r2,#0]
        0x08000d56:    43b5        .C      BICS     r5,r5,r6
        0x08000d58:    0c26        &.      LSRS     r6,r4,#16
        0x08000d5a:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000d6c] = 0x80031fd
        0x08000d5c:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000d5e:    40be        .@      LSLS     r6,r6,r7
        0x08000d60:    4335        5C      ORRS     r5,r5,r6
        0x08000d62:    6015        .`      STR      r5,[r2,#0]
;;;2281   }
        0x08000d64:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000d66:    0000        ..      DCW    0
        0x08000d68:    080031ef    .1..    DCD    134230511
        0x08000d6c:    080031fd    .1..    DCD    134230525
    $t
    i.LL_TIM_IC_SetPolarity
    LL_TIM_IC_SetPolarity
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
        0x08000d70:    b570        p.      PUSH     {r4-r6,lr}
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000d72:    2901        .)      CMP      r1,#1
        0x08000d74:    d101        ..      BNE      0x8000d7a ; LL_TIM_IC_SetPolarity + 10
        0x08000d76:    2400        .$      MOVS     r4,#0
        0x08000d78:    e016        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d7a:    2904        .)      CMP      r1,#4
        0x08000d7c:    d101        ..      BNE      0x8000d82 ; LL_TIM_IC_SetPolarity + 18
        0x08000d7e:    2401        .$      MOVS     r4,#1
        0x08000d80:    e012        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d82:    2910        .)      CMP      r1,#0x10
        0x08000d84:    d101        ..      BNE      0x8000d8a ; LL_TIM_IC_SetPolarity + 26
        0x08000d86:    2402        .$      MOVS     r4,#2
        0x08000d88:    e00e        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d8a:    2940        @)      CMP      r1,#0x40
        0x08000d8c:    d101        ..      BNE      0x8000d92 ; LL_TIM_IC_SetPolarity + 34
        0x08000d8e:    2403        .$      MOVS     r4,#3
        0x08000d90:    e00a        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d92:    f5b17f80    ....    CMP      r1,#0x100
        0x08000d96:    d101        ..      BNE      0x8000d9c ; LL_TIM_IC_SetPolarity + 44
        0x08000d98:    2404        .$      MOVS     r4,#4
        0x08000d9a:    e005        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000d9c:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000da0:    d101        ..      BNE      0x8000da6 ; LL_TIM_IC_SetPolarity + 54
        0x08000da2:    2405        .$      MOVS     r4,#5
        0x08000da4:    e000        ..      B        0x8000da8 ; LL_TIM_IC_SetPolarity + 56
        0x08000da6:    2406        .$      MOVS     r4,#6
        0x08000da8:    4623        #F      MOV      r3,r4
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
        0x08000daa:    6a04        .j      LDR      r4,[r0,#0x20]
        0x08000dac:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000dc4] = 0x8003204
        0x08000dae:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000db0:    250a        .%      MOVS     r5,#0xa
        0x08000db2:    40b5        .@      LSLS     r5,r5,r6
        0x08000db4:    43ac        .C      BICS     r4,r4,r5
        0x08000db6:    4d03        .M      LDR      r5,[pc,#12] ; [0x8000dc4] = 0x8003204
        0x08000db8:    5ced        .\      LDRB     r5,[r5,r3]
        0x08000dba:    fa02f505    ....    LSL      r5,r2,r5
        0x08000dbe:    432c        ,C      ORRS     r4,r4,r5
        0x08000dc0:    6204        .b      STR      r4,[r0,#0x20]
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
        0x08000dc2:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000dc4:    08003204    .2..    DCD    134230532
    $t
    i.LL_TIM_IC_SetPrescaler
    LL_TIM_IC_SetPrescaler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2214)
        0x08000dc8:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000dca:    4603        .F      MOV      r3,r0
        0x08000dcc:    4614        .F      MOV      r4,r2
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000dce:    2901        .)      CMP      r1,#1
        0x08000dd0:    d101        ..      BNE      0x8000dd6 ; LL_TIM_IC_SetPrescaler + 14
        0x08000dd2:    2500        .%      MOVS     r5,#0
        0x08000dd4:    e016        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000dd6:    2904        .)      CMP      r1,#4
        0x08000dd8:    d101        ..      BNE      0x8000dde ; LL_TIM_IC_SetPrescaler + 22
        0x08000dda:    2501        .%      MOVS     r5,#1
        0x08000ddc:    e012        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000dde:    2910        .)      CMP      r1,#0x10
        0x08000de0:    d101        ..      BNE      0x8000de6 ; LL_TIM_IC_SetPrescaler + 30
        0x08000de2:    2502        .%      MOVS     r5,#2
        0x08000de4:    e00e        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000de6:    2940        @)      CMP      r1,#0x40
        0x08000de8:    d101        ..      BNE      0x8000dee ; LL_TIM_IC_SetPrescaler + 38
        0x08000dea:    2503        .%      MOVS     r5,#3
        0x08000dec:    e00a        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000dee:    f5b17f80    ....    CMP      r1,#0x100
        0x08000df2:    d101        ..      BNE      0x8000df8 ; LL_TIM_IC_SetPrescaler + 48
        0x08000df4:    2504        .%      MOVS     r5,#4
        0x08000df6:    e005        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000df8:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000dfc:    d101        ..      BNE      0x8000e02 ; LL_TIM_IC_SetPrescaler + 58
        0x08000dfe:    2505        .%      MOVS     r5,#5
        0x08000e00:    e000        ..      B        0x8000e04 ; LL_TIM_IC_SetPrescaler + 60
        0x08000e02:    2506        .%      MOVS     r5,#6
        0x08000e04:    4628        (F      MOV      r0,r5
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000e06:    4d09        .M      LDR      r5,[pc,#36] ; [0x8000e2c] = 0x80031ef
        0x08000e08:    5c2e        .\      LDRB     r6,[r5,r0]
        0x08000e0a:    f1030518    ....    ADD      r5,r3,#0x18
        0x08000e0e:    1972        r.      ADDS     r2,r6,r5
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x08000e10:    4e07        .N      LDR      r6,[pc,#28] ; [0x8000e30] = 0x80031fd
        0x08000e12:    5c37        7\      LDRB     r7,[r6,r0]
        0x08000e14:    260c        .&      MOVS     r6,#0xc
        0x08000e16:    40be        .@      LSLS     r6,r6,r7
        0x08000e18:    6815        .h      LDR      r5,[r2,#0]
        0x08000e1a:    43b5        .C      BICS     r5,r5,r6
        0x08000e1c:    0c26        &.      LSRS     r6,r4,#16
        0x08000e1e:    4f04        .O      LDR      r7,[pc,#16] ; [0x8000e30] = 0x80031fd
        0x08000e20:    5c3f        ?\      LDRB     r7,[r7,r0]
        0x08000e22:    40be        .@      LSLS     r6,r6,r7
        0x08000e24:    4335        5C      ORRS     r5,r5,r6
        0x08000e26:    6015        .`      STR      r5,[r2,#0]
;;;2218   }
        0x08000e28:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000e2a:    0000        ..      DCW    0
        0x08000e2c:    080031ef    .1..    DCD    134230511
        0x08000e30:    080031fd    .1..    DCD    134230525
    $t
    i.LL_TIM_Init
    LL_TIM_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;341    {
        0x08000e34:    b510        ..      PUSH     {r4,lr}
        0x08000e36:    4602        .F      MOV      r2,r0
;;;342      uint32_t tmpcr1 = 0U;
        0x08000e38:    2300        .#      MOVS     r3,#0
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_TIM_INSTANCE(TIMx));
;;;346      assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
;;;347      assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
;;;348    
;;;349      tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
        0x08000e3a:    6813        .h      LDR      r3,[r2,#0]
;;;350    
;;;351      if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
        0x08000e3c:    481b        .H      LDR      r0,[pc,#108] ; [0x8000eac] = 0x40012c00
        0x08000e3e:    4282        .B      CMP      r2,r0
        0x08000e40:    d008        ..      BEQ      0x8000e54 ; LL_TIM_Init + 32
        0x08000e42:    f1b24f80    ...O    CMP      r2,#0x40000000
        0x08000e46:    d005        ..      BEQ      0x8000e54 ; LL_TIM_Init + 32
        0x08000e48:    4819        .H      LDR      r0,[pc,#100] ; [0x8000eb0] = 0x40000400
        0x08000e4a:    4282        .B      CMP      r2,r0
        0x08000e4c:    d002        ..      BEQ      0x8000e54 ; LL_TIM_Init + 32
        0x08000e4e:    4819        .H      LDR      r0,[pc,#100] ; [0x8000eb4] = 0x40000800
        0x08000e50:    4282        .B      CMP      r2,r0
        0x08000e52:    d104        ..      BNE      0x8000e5e ; LL_TIM_Init + 42
;;;352      {
;;;353        /* Select the Counter Mode */
;;;354        MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
        0x08000e54:    f0230070    #.p.    BIC      r0,r3,#0x70
        0x08000e58:    684c        Lh      LDR      r4,[r1,#4]
        0x08000e5a:    ea400304    @...    ORR      r3,r0,r4
;;;355      }
;;;356    
;;;357      if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
        0x08000e5e:    4813        .H      LDR      r0,[pc,#76] ; [0x8000eac] = 0x40012c00
        0x08000e60:    4282        .B      CMP      r2,r0
        0x08000e62:    d008        ..      BEQ      0x8000e76 ; LL_TIM_Init + 66
        0x08000e64:    f1b24f80    ...O    CMP      r2,#0x40000000
        0x08000e68:    d005        ..      BEQ      0x8000e76 ; LL_TIM_Init + 66
        0x08000e6a:    4811        .H      LDR      r0,[pc,#68] ; [0x8000eb0] = 0x40000400
        0x08000e6c:    4282        .B      CMP      r2,r0
        0x08000e6e:    d002        ..      BEQ      0x8000e76 ; LL_TIM_Init + 66
        0x08000e70:    4810        .H      LDR      r0,[pc,#64] ; [0x8000eb4] = 0x40000800
        0x08000e72:    4282        .B      CMP      r2,r0
        0x08000e74:    d104        ..      BNE      0x8000e80 ; LL_TIM_Init + 76
;;;358      {
;;;359        /* Set the clock division */
;;;360        MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
        0x08000e76:    f4237040    #.@p    BIC      r0,r3,#0x300
        0x08000e7a:    68cc        .h      LDR      r4,[r1,#0xc]
        0x08000e7c:    ea400304    @...    ORR      r3,r0,r4
;;;361      }
;;;362    
;;;363      /* Write to TIMx CR1 */
;;;364      LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
        0x08000e80:    6013        .`      STR      r3,[r2,#0]
;;;365    
;;;366      /* Set the Autoreload value */
;;;367      LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
        0x08000e82:    6888        .h      LDR      r0,[r1,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
        0x08000e84:    62d0        .b      STR      r0,[r2,#0x2c]
;;;1333   }
        0x08000e86:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;370      LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
        0x08000e88:    8808        ..      LDRH     r0,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
        0x08000e8a:    6290        .b      STR      r0,[r2,#0x28]
;;;1308   }
        0x08000e8c:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;372      if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
        0x08000e8e:    4807        .H      LDR      r0,[pc,#28] ; [0x8000eac] = 0x40012c00
        0x08000e90:    4282        .B      CMP      r2,r0
        0x08000e92:    d103        ..      BNE      0x8000e9c ; LL_TIM_Init + 104
;;;373      {
;;;374        /* Set the Repetition Counter value */
;;;375        LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
        0x08000e94:    7c08        .|      LDRB     r0,[r1,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
        0x08000e96:    6310        .c      STR      r0,[r2,#0x30]
;;;1358   }
        0x08000e98:    bf00        ..      NOP      
        0x08000e9a:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;380      LL_TIM_GenerateEvent_UPDATE(TIMx);
        0x08000e9c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08000e9e:    6950        Pi      LDR      r0,[r2,#0x14]
        0x08000ea0:    f0400001    @...    ORR      r0,r0,#1
        0x08000ea4:    6150        Pa      STR      r0,[r2,#0x14]
;;;3713   }
        0x08000ea6:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;382      return SUCCESS;
        0x08000ea8:    2001        .       MOVS     r0,#1
;;;383    }
        0x08000eaa:    bd10        ..      POP      {r4,pc}
    $d
        0x08000eac:    40012c00    .,.@    DCD    1073818624
        0x08000eb0:    40000400    ...@    DCD    1073742848
        0x08000eb4:    40000800    ...@    DCD    1073743872
    $t
    i.LL_TIM_IsActiveFlag_UPDATE
    LL_TIM_IsActiveFlag_UPDATE
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2942   {
        0x08000eb8:    4601        .F      MOV      r1,r0
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
        0x08000eba:    6908        .i      LDR      r0,[r1,#0x10]
        0x08000ebc:    f0000001    ....    AND      r0,r0,#1
;;;2944   }
        0x08000ec0:    4770        pG      BX       lr
        0x08000ec2:    0000        ..      MOVS     r0,r0
    i.LL_TIM_OC_DisableFast
    LL_TIM_OC_DisableFast
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1805)
        0x08000ec4:    b570        p.      PUSH     {r4-r6,lr}
        0x08000ec6:    4602        .F      MOV      r2,r0
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000ec8:    2901        .)      CMP      r1,#1
        0x08000eca:    d101        ..      BNE      0x8000ed0 ; LL_TIM_OC_DisableFast + 12
        0x08000ecc:    2400        .$      MOVS     r4,#0
        0x08000ece:    e016        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ed0:    2904        .)      CMP      r1,#4
        0x08000ed2:    d101        ..      BNE      0x8000ed8 ; LL_TIM_OC_DisableFast + 20
        0x08000ed4:    2401        .$      MOVS     r4,#1
        0x08000ed6:    e012        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ed8:    2910        .)      CMP      r1,#0x10
        0x08000eda:    d101        ..      BNE      0x8000ee0 ; LL_TIM_OC_DisableFast + 28
        0x08000edc:    2402        .$      MOVS     r4,#2
        0x08000ede:    e00e        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ee0:    2940        @)      CMP      r1,#0x40
        0x08000ee2:    d101        ..      BNE      0x8000ee8 ; LL_TIM_OC_DisableFast + 36
        0x08000ee4:    2403        .$      MOVS     r4,#3
        0x08000ee6:    e00a        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ee8:    f5b17f80    ....    CMP      r1,#0x100
        0x08000eec:    d101        ..      BNE      0x8000ef2 ; LL_TIM_OC_DisableFast + 46
        0x08000eee:    2404        .$      MOVS     r4,#4
        0x08000ef0:    e005        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000ef2:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000ef6:    d101        ..      BNE      0x8000efc ; LL_TIM_OC_DisableFast + 56
        0x08000ef8:    2405        .$      MOVS     r4,#5
        0x08000efa:    e000        ..      B        0x8000efe ; LL_TIM_OC_DisableFast + 58
        0x08000efc:    2406        .$      MOVS     r4,#6
        0x08000efe:    4623        #F      MOV      r3,r4
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000f00:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000f1c] = 0x80031ef
        0x08000f02:    5ce5        .\      LDRB     r5,[r4,r3]
        0x08000f04:    f1020418    ....    ADD      r4,r2,#0x18
        0x08000f08:    1928        (.      ADDS     r0,r5,r4
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
        0x08000f0a:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000f20] = 0x80031f6
        0x08000f0c:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000f0e:    2504        .%      MOVS     r5,#4
        0x08000f10:    40b5        .@      LSLS     r5,r5,r6
        0x08000f12:    6804        .h      LDR      r4,[r0,#0]
        0x08000f14:    43ac        .C      BICS     r4,r4,r5
        0x08000f16:    6004        .`      STR      r4,[r0,#0]
;;;1809   
;;;1810   }
        0x08000f18:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000f1a:    0000        ..      DCW    0
        0x08000f1c:    080031ef    .1..    DCD    134230511
        0x08000f20:    080031f6    .1..    DCD    134230518
    $t
    i.LL_TIM_OC_EnablePreload
    LL_TIM_OC_EnablePreload
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
        0x08000f24:    b570        p.      PUSH     {r4-r6,lr}
        0x08000f26:    4602        .F      MOV      r2,r0
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000f28:    2901        .)      CMP      r1,#1
        0x08000f2a:    d101        ..      BNE      0x8000f30 ; LL_TIM_OC_EnablePreload + 12
        0x08000f2c:    2400        .$      MOVS     r4,#0
        0x08000f2e:    e016        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f30:    2904        .)      CMP      r1,#4
        0x08000f32:    d101        ..      BNE      0x8000f38 ; LL_TIM_OC_EnablePreload + 20
        0x08000f34:    2401        .$      MOVS     r4,#1
        0x08000f36:    e012        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f38:    2910        .)      CMP      r1,#0x10
        0x08000f3a:    d101        ..      BNE      0x8000f40 ; LL_TIM_OC_EnablePreload + 28
        0x08000f3c:    2402        .$      MOVS     r4,#2
        0x08000f3e:    e00e        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f40:    2940        @)      CMP      r1,#0x40
        0x08000f42:    d101        ..      BNE      0x8000f48 ; LL_TIM_OC_EnablePreload + 36
        0x08000f44:    2403        .$      MOVS     r4,#3
        0x08000f46:    e00a        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f48:    f5b17f80    ....    CMP      r1,#0x100
        0x08000f4c:    d101        ..      BNE      0x8000f52 ; LL_TIM_OC_EnablePreload + 46
        0x08000f4e:    2404        .$      MOVS     r4,#4
        0x08000f50:    e005        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f52:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000f56:    d101        ..      BNE      0x8000f5c ; LL_TIM_OC_EnablePreload + 56
        0x08000f58:    2405        .$      MOVS     r4,#5
        0x08000f5a:    e000        ..      B        0x8000f5e ; LL_TIM_OC_EnablePreload + 58
        0x08000f5c:    2406        .$      MOVS     r4,#6
        0x08000f5e:    4623        #F      MOV      r3,r4
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000f60:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000f7c] = 0x80031ef
        0x08000f62:    5ce5        .\      LDRB     r5,[r4,r3]
        0x08000f64:    f1020418    ....    ADD      r4,r2,#0x18
        0x08000f68:    1928        (.      ADDS     r0,r5,r4
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
        0x08000f6a:    4d05        .M      LDR      r5,[pc,#20] ; [0x8000f80] = 0x80031f6
        0x08000f6c:    5cee        .\      LDRB     r6,[r5,r3]
        0x08000f6e:    2508        .%      MOVS     r5,#8
        0x08000f70:    40b5        .@      LSLS     r5,r5,r6
        0x08000f72:    6804        .h      LDR      r4,[r0,#0]
        0x08000f74:    432c        ,C      ORRS     r4,r4,r5
        0x08000f76:    6004        .`      STR      r4,[r0,#0]
;;;1853   }
        0x08000f78:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000f7a:    0000        ..      DCW    0
        0x08000f7c:    080031ef    .1..    DCD    134230511
        0x08000f80:    080031f6    .1..    DCD    134230518
    $t
    i.LL_TIM_OC_Init
    LL_TIM_OC_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;418    {
        0x08000f84:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08000f88:    4606        .F      MOV      r6,r0
        0x08000f8a:    460c        .F      MOV      r4,r1
        0x08000f8c:    4615        .F      MOV      r5,r2
;;;419      ErrorStatus result = ERROR;
        0x08000f8e:    2700        .'      MOVS     r7,#0
;;;420    
;;;421      switch (Channel)
        0x08000f90:    2c01        .,      CMP      r4,#1
        0x08000f92:    d008        ..      BEQ      0x8000fa6 ; LL_TIM_OC_Init + 34
        0x08000f94:    2c10        .,      CMP      r4,#0x10
        0x08000f96:    d00c        ..      BEQ      0x8000fb2 ; LL_TIM_OC_Init + 46
        0x08000f98:    f5b47f80    ....    CMP      r4,#0x100
        0x08000f9c:    d00f        ..      BEQ      0x8000fbe ; LL_TIM_OC_Init + 58
        0x08000f9e:    f5b45f80    ..._    CMP      r4,#0x1000
        0x08000fa2:    d118        ..      BNE      0x8000fd6 ; LL_TIM_OC_Init + 82
        0x08000fa4:    e011        ..      B        0x8000fca ; LL_TIM_OC_Init + 70
;;;422      {
;;;423        case LL_TIM_CHANNEL_CH1:
;;;424          result = OC1Config(TIMx, TIM_OC_InitStruct);
        0x08000fa6:    4629        )F      MOV      r1,r5
        0x08000fa8:    4630        0F      MOV      r0,r6
        0x08000faa:    f000fd53    ..S.    BL       OC1Config ; 0x8001a54
        0x08000fae:    4607        .F      MOV      r7,r0
;;;425          break;
        0x08000fb0:    e012        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;426        case LL_TIM_CHANNEL_CH2:
;;;427          result = OC2Config(TIMx, TIM_OC_InitStruct);
        0x08000fb2:    4629        )F      MOV      r1,r5
        0x08000fb4:    4630        0F      MOV      r0,r6
        0x08000fb6:    f000fd8b    ....    BL       OC2Config ; 0x8001ad0
        0x08000fba:    4607        .F      MOV      r7,r0
;;;428          break;
        0x08000fbc:    e00c        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;429        case LL_TIM_CHANNEL_CH3:
;;;430          result = OC3Config(TIMx, TIM_OC_InitStruct);
        0x08000fbe:    4629        )F      MOV      r1,r5
        0x08000fc0:    4630        0F      MOV      r0,r6
        0x08000fc2:    f000fdc9    ....    BL       OC3Config ; 0x8001b58
        0x08000fc6:    4607        .F      MOV      r7,r0
;;;431          break;
        0x08000fc8:    e006        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;432        case LL_TIM_CHANNEL_CH4:
;;;433          result = OC4Config(TIMx, TIM_OC_InitStruct);
        0x08000fca:    4629        )F      MOV      r1,r5
        0x08000fcc:    4630        0F      MOV      r0,r6
        0x08000fce:    f000fe01    ....    BL       OC4Config ; 0x8001bd4
        0x08000fd2:    4607        .F      MOV      r7,r0
;;;434          break;
        0x08000fd4:    e000        ..      B        0x8000fd8 ; LL_TIM_OC_Init + 84
;;;435        default:
;;;436          break;
        0x08000fd6:    bf00        ..      NOP      
        0x08000fd8:    bf00        ..      NOP      
;;;437      }
;;;438    
;;;439      return result;
        0x08000fda:    4638        8F      MOV      r0,r7
;;;440    }
        0x08000fdc:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_TIM_OC_SetCompareCH2
    LL_TIM_OC_SetCompareCH2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
        0x08000fe0:    6381        .c      STR      r1,[r0,#0x38]
;;;2012   }
        0x08000fe2:    4770        pG      BX       lr
    i.LL_TIM_SetClockSource
    LL_TIM_SetClockSource
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
        0x08000fe4:    6882        .h      LDR      r2,[r0,#8]
        0x08000fe6:    f2440307    D...    MOV      r3,#0x4007
        0x08000fea:    439a        .C      BICS     r2,r2,r3
        0x08000fec:    430a        .C      ORRS     r2,r2,r1
        0x08000fee:    6082        .`      STR      r2,[r0,#8]
;;;2533   }
        0x08000ff0:    4770        pG      BX       lr
    i.LL_TIM_SetTriggerOutput
    LL_TIM_SetTriggerOutput
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
        0x08000ff2:    6842        Bh      LDR      r2,[r0,#4]
        0x08000ff4:    f0220270    ".p.    BIC      r2,r2,#0x70
        0x08000ff8:    430a        .C      ORRS     r2,r2,r1
        0x08000ffa:    6042        B`      STR      r2,[r0,#4]
;;;2579   }
        0x08000ffc:    4770        pG      BX       lr
        0x08000ffe:    0000        ..      MOVS     r0,r0
    i.LL_USART_Init
    LL_USART_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;212    {
        0x08001000:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x08001004:    4604        .F      MOV      r4,r0
        0x08001006:    460d        .F      MOV      r5,r1
;;;213      ErrorStatus status = ERROR;
        0x08001008:    2700        .'      MOVS     r7,#0
;;;214      uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;
        0x0800100a:    2600        .&      MOVS     r6,#0
;;;215      LL_RCC_ClocksTypeDef rcc_clocks;
;;;216    
;;;217      /* Check the parameters */
;;;218      assert_param(IS_UART_INSTANCE(USARTx));
;;;219      assert_param(IS_LL_USART_BAUDRATE(USART_InitStruct->BaudRate));
;;;220      assert_param(IS_LL_USART_DATAWIDTH(USART_InitStruct->DataWidth));
;;;221      assert_param(IS_LL_USART_STOPBITS(USART_InitStruct->StopBits));
;;;222      assert_param(IS_LL_USART_PARITY(USART_InitStruct->Parity));
;;;223      assert_param(IS_LL_USART_DIRECTION(USART_InitStruct->TransferDirection));
;;;224      assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
;;;225    #if defined(USART_CR1_OVER8)
;;;226      assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));
;;;227    #endif /* USART_OverSampling_Feature */
;;;228    
;;;229      /* USART needs to be in disabled state, in order to be able to configure some bits in
;;;230         CRx registers */
;;;231      if (LL_USART_IsEnabled(USARTx) == 0U)
        0x0800100c:    4620         F      MOV      r0,r4
        0x0800100e:    f000f83f    ..?.    BL       LL_USART_IsEnabled ; 0x8001090
        0x08001012:    2800        .(      CMP      r0,#0
        0x08001014:    d132        2.      BNE      0x800107c ; LL_USART_Init + 124
;;;232      {
;;;233        /*---------------------------- USART CR1 Configuration -----------------------
;;;234         * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:
;;;235         * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
;;;236         * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
;;;237         * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
;;;238         * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
;;;239         */
;;;240    #if defined(USART_CR1_OVER8)
;;;241        MODIFY_REG(USARTx->CR1,
;;;242                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;243                    USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;244                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;245                    USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));
;;;246    #else
;;;247        MODIFY_REG(USARTx->CR1,
        0x08001016:    68e9        .h      LDR      r1,[r5,#0xc]
        0x08001018:    6868        hh      LDR      r0,[r5,#4]
        0x0800101a:    4308        .C      ORRS     r0,r0,r1
        0x0800101c:    6929        )i      LDR      r1,[r5,#0x10]
        0x0800101e:    4308        .C      ORRS     r0,r0,r1
        0x08001020:    68e1        .h      LDR      r1,[r4,#0xc]
        0x08001022:    f241620c    A..b    MOV      r2,#0x160c
        0x08001026:    4391        .C      BICS     r1,r1,r2
        0x08001028:    4308        .C      ORRS     r0,r0,r1
        0x0800102a:    60e0        .`      STR      r0,[r4,#0xc]
;;;248                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;249                    USART_CR1_TE | USART_CR1_RE),
;;;250                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;251                    USART_InitStruct->TransferDirection));
;;;252    #endif /* USART_OverSampling_Feature */
;;;253    
;;;254        /*---------------------------- USART CR2 Configuration -----------------------
;;;255         * Configure USARTx CR2 (Stop bits) with parameters:
;;;256         * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.
;;;257         * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().
;;;258         */
;;;259        LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
        0x0800102c:    68a8        .h      LDR      r0,[r5,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;828      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
        0x0800102e:    6921        !i      LDR      r1,[r4,#0x10]
        0x08001030:    f4215140    !.@Q    BIC      r1,r1,#0x3000
        0x08001034:    4301        .C      ORRS     r1,r1,r0
        0x08001036:    6121        !a      STR      r1,[r4,#0x10]
;;;829    }
        0x08001038:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;265        LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
        0x0800103a:    6968        hi      LDR      r0,[r5,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;972      MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
        0x0800103c:    6961        ai      LDR      r1,[r4,#0x14]
        0x0800103e:    f4217140    !.@q    BIC      r1,r1,#0x300
        0x08001042:    4301        .C      ORRS     r1,r1,r0
        0x08001044:    6161        aa      STR      r1,[r4,#0x14]
;;;973    }
        0x08001046:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;270        LL_RCC_GetSystemClocksFreq(&rcc_clocks);
        0x08001048:    4668        hF      MOV      r0,sp
        0x0800104a:    f7fffdbd    ....    BL       LL_RCC_GetSystemClocksFreq ; 0x8000bc8
;;;271        if (USARTx == USART1)
        0x0800104e:    480d        .H      LDR      r0,[pc,#52] ; [0x8001084] = 0x40013800
        0x08001050:    4284        .B      CMP      r4,r0
        0x08001052:    d101        ..      BNE      0x8001058 ; LL_USART_Init + 88
;;;272        {
;;;273          periphclk = rcc_clocks.PCLK2_Frequency;
        0x08001054:    9e03        ..      LDR      r6,[sp,#0xc]
        0x08001056:    e008        ..      B        0x800106a ; LL_USART_Init + 106
;;;274        }
;;;275        else if (USARTx == USART2)
        0x08001058:    480b        .H      LDR      r0,[pc,#44] ; [0x8001088] = 0x40004400
        0x0800105a:    4284        .B      CMP      r4,r0
        0x0800105c:    d101        ..      BNE      0x8001062 ; LL_USART_Init + 98
;;;276        {
;;;277          periphclk = rcc_clocks.PCLK1_Frequency;
        0x0800105e:    9e02        ..      LDR      r6,[sp,#8]
        0x08001060:    e003        ..      B        0x800106a ; LL_USART_Init + 106
;;;278        }
;;;279    #if defined(USART3)
;;;280        else if (USARTx == USART3)
        0x08001062:    480a        .H      LDR      r0,[pc,#40] ; [0x800108c] = 0x40004800
        0x08001064:    4284        .B      CMP      r4,r0
        0x08001066:    d100        ..      BNE      0x800106a ; LL_USART_Init + 106
;;;281        {
;;;282          periphclk = rcc_clocks.PCLK1_Frequency;
        0x08001068:    9e02        ..      LDR      r6,[sp,#8]
;;;283        }
;;;284    #endif /* USART3 */
;;;285    #if defined(UART4)
;;;286        else if (USARTx == UART4)
;;;287        {
;;;288          periphclk = rcc_clocks.PCLK1_Frequency;
;;;289        }
;;;290    #endif /* UART4 */
;;;291    #if defined(UART5)
;;;292        else if (USARTx == UART5)
;;;293        {
;;;294          periphclk = rcc_clocks.PCLK1_Frequency;
;;;295        }
;;;296    #endif /* UART5 */
;;;297        else
;;;298        {
;;;299          /* Nothing to do, as error code is already assigned to ERROR value */
;;;300        }
;;;301    
;;;302        /* Configure the USART Baud Rate :
;;;303           - valid baud rate value (different from 0) is required
;;;304           - Peripheral clock as returned by RCC service, should be valid (different from 0).
;;;305        */
;;;306        if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
        0x0800106a:    b13e        >.      CBZ      r6,0x800107c ; LL_USART_Init + 124
;;;307            && (USART_InitStruct->BaudRate != 0U))
        0x0800106c:    6828        (h      LDR      r0,[r5,#0]
        0x0800106e:    b128        (.      CBZ      r0,0x800107c ; LL_USART_Init + 124
;;;308        {
;;;309          status = SUCCESS;
        0x08001070:    2701        .'      MOVS     r7,#1
;;;310    #if defined(USART_CR1_OVER8)
;;;311          LL_USART_SetBaudRate(USARTx,
;;;312                               periphclk,
;;;313                               USART_InitStruct->OverSampling,
;;;314                               USART_InitStruct->BaudRate);
;;;315    #else
;;;316          LL_USART_SetBaudRate(USARTx,
        0x08001072:    4631        1F      MOV      r1,r6
        0x08001074:    4620         F      MOV      r0,r4
        0x08001076:    682a        *h      LDR      r2,[r5,#0]
        0x08001078:    f000f80f    ....    BL       LL_USART_SetBaudRate ; 0x800109a
;;;317                               periphclk,
;;;318                               USART_InitStruct->BaudRate);
;;;319    #endif /* USART_OverSampling_Feature */
;;;320        }
;;;321      }
;;;322      /* Endif (=> USART not in Disabled state => return ERROR) */
;;;323    
;;;324      return (status);
        0x0800107c:    4638        8F      MOV      r0,r7
;;;325    }
        0x0800107e:    b004        ..      ADD      sp,sp,#0x10
        0x08001080:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x08001084:    40013800    .8.@    DCD    1073821696
        0x08001088:    40004400    .D.@    DCD    1073759232
        0x0800108c:    40004800    .H.@    DCD    1073760256
    $t
    i.LL_USART_IsEnabled
    LL_USART_IsEnabled
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;455    {
        0x08001090:    4601        .F      MOV      r1,r0
;;;456      return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
        0x08001092:    68c8        .h      LDR      r0,[r1,#0xc]
        0x08001094:    f3c03040    ..@0    UBFX     r0,r0,#13,#1
;;;457    }
        0x08001098:    4770        pG      BX       lr
    i.LL_USART_SetBaudRate
    LL_USART_SetBaudRate
;;;458    
;;;459    /**
;;;460      * @brief  Receiver Enable (Receiver is enabled and begins searching for a start bit)
;;;461      * @rmtoll CR1          RE            LL_USART_EnableDirectionRx
;;;462      * @param  USARTx USART Instance
;;;463      * @retval None
;;;464      */
;;;465    __STATIC_INLINE void LL_USART_EnableDirectionRx(USART_TypeDef *USARTx)
;;;466    {
;;;467      SET_BIT(USARTx->CR1, USART_CR1_RE);
;;;468    }
;;;469    
;;;470    /**
;;;471      * @brief  Receiver Disable
;;;472      * @rmtoll CR1          RE            LL_USART_DisableDirectionRx
;;;473      * @param  USARTx USART Instance
;;;474      * @retval None
;;;475      */
;;;476    __STATIC_INLINE void LL_USART_DisableDirectionRx(USART_TypeDef *USARTx)
;;;477    {
;;;478      CLEAR_BIT(USARTx->CR1, USART_CR1_RE);
;;;479    }
;;;480    
;;;481    /**
;;;482      * @brief  Transmitter Enable
;;;483      * @rmtoll CR1          TE            LL_USART_EnableDirectionTx
;;;484      * @param  USARTx USART Instance
;;;485      * @retval None
;;;486      */
;;;487    __STATIC_INLINE void LL_USART_EnableDirectionTx(USART_TypeDef *USARTx)
;;;488    {
;;;489      SET_BIT(USARTx->CR1, USART_CR1_TE);
;;;490    }
;;;491    
;;;492    /**
;;;493      * @brief  Transmitter Disable
;;;494      * @rmtoll CR1          TE            LL_USART_DisableDirectionTx
;;;495      * @param  USARTx USART Instance
;;;496      * @retval None
;;;497      */
;;;498    __STATIC_INLINE void LL_USART_DisableDirectionTx(USART_TypeDef *USARTx)
;;;499    {
;;;500      CLEAR_BIT(USARTx->CR1, USART_CR1_TE);
;;;501    }
;;;502    
;;;503    /**
;;;504      * @brief  Configure simultaneously enabled/disabled states
;;;505      *         of Transmitter and Receiver
;;;506      * @rmtoll CR1          RE            LL_USART_SetTransferDirection\n
;;;507      *         CR1          TE            LL_USART_SetTransferDirection
;;;508      * @param  USARTx USART Instance
;;;509      * @param  TransferDirection This parameter can be one of the following values:
;;;510      *         @arg @ref LL_USART_DIRECTION_NONE
;;;511      *         @arg @ref LL_USART_DIRECTION_RX
;;;512      *         @arg @ref LL_USART_DIRECTION_TX
;;;513      *         @arg @ref LL_USART_DIRECTION_TX_RX
;;;514      * @retval None
;;;515      */
;;;516    __STATIC_INLINE void LL_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection)
;;;517    {
;;;518      MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
;;;519    }
;;;520    
;;;521    /**
;;;522      * @brief  Return enabled/disabled states of Transmitter and Receiver
;;;523      * @rmtoll CR1          RE            LL_USART_GetTransferDirection\n
;;;524      *         CR1          TE            LL_USART_GetTransferDirection
;;;525      * @param  USARTx USART Instance
;;;526      * @retval Returned value can be one of the following values:
;;;527      *         @arg @ref LL_USART_DIRECTION_NONE
;;;528      *         @arg @ref LL_USART_DIRECTION_RX
;;;529      *         @arg @ref LL_USART_DIRECTION_TX
;;;530      *         @arg @ref LL_USART_DIRECTION_TX_RX
;;;531      */
;;;532    __STATIC_INLINE uint32_t LL_USART_GetTransferDirection(USART_TypeDef *USARTx)
;;;533    {
;;;534      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_RE | USART_CR1_TE));
;;;535    }
;;;536    
;;;537    /**
;;;538      * @brief  Configure Parity (enabled/disabled and parity mode if enabled).
;;;539      * @note   This function selects if hardware parity control (generation and detection) is enabled or disabled.
;;;540      *         When the parity control is enabled (Odd or Even), computed parity bit is inserted at the MSB position
;;;541      *         (9th or 8th bit depending on data width) and parity is checked on the received data.
;;;542      * @rmtoll CR1          PS            LL_USART_SetParity\n
;;;543      *         CR1          PCE           LL_USART_SetParity
;;;544      * @param  USARTx USART Instance
;;;545      * @param  Parity This parameter can be one of the following values:
;;;546      *         @arg @ref LL_USART_PARITY_NONE
;;;547      *         @arg @ref LL_USART_PARITY_EVEN
;;;548      *         @arg @ref LL_USART_PARITY_ODD
;;;549      * @retval None
;;;550      */
;;;551    __STATIC_INLINE void LL_USART_SetParity(USART_TypeDef *USARTx, uint32_t Parity)
;;;552    {
;;;553      MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
;;;554    }
;;;555    
;;;556    /**
;;;557      * @brief  Return Parity configuration (enabled/disabled and parity mode if enabled)
;;;558      * @rmtoll CR1          PS            LL_USART_GetParity\n
;;;559      *         CR1          PCE           LL_USART_GetParity
;;;560      * @param  USARTx USART Instance
;;;561      * @retval Returned value can be one of the following values:
;;;562      *         @arg @ref LL_USART_PARITY_NONE
;;;563      *         @arg @ref LL_USART_PARITY_EVEN
;;;564      *         @arg @ref LL_USART_PARITY_ODD
;;;565      */
;;;566    __STATIC_INLINE uint32_t LL_USART_GetParity(USART_TypeDef *USARTx)
;;;567    {
;;;568      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
;;;569    }
;;;570    
;;;571    /**
;;;572      * @brief  Set Receiver Wake Up method from Mute mode.
;;;573      * @rmtoll CR1          WAKE          LL_USART_SetWakeUpMethod
;;;574      * @param  USARTx USART Instance
;;;575      * @param  Method This parameter can be one of the following values:
;;;576      *         @arg @ref LL_USART_WAKEUP_IDLELINE
;;;577      *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
;;;578      * @retval None
;;;579      */
;;;580    __STATIC_INLINE void LL_USART_SetWakeUpMethod(USART_TypeDef *USARTx, uint32_t Method)
;;;581    {
;;;582      MODIFY_REG(USARTx->CR1, USART_CR1_WAKE, Method);
;;;583    }
;;;584    
;;;585    /**
;;;586      * @brief  Return Receiver Wake Up method from Mute mode
;;;587      * @rmtoll CR1          WAKE          LL_USART_GetWakeUpMethod
;;;588      * @param  USARTx USART Instance
;;;589      * @retval Returned value can be one of the following values:
;;;590      *         @arg @ref LL_USART_WAKEUP_IDLELINE
;;;591      *         @arg @ref LL_USART_WAKEUP_ADDRESSMARK
;;;592      */
;;;593    __STATIC_INLINE uint32_t LL_USART_GetWakeUpMethod(USART_TypeDef *USARTx)
;;;594    {
;;;595      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_WAKE));
;;;596    }
;;;597    
;;;598    /**
;;;599      * @brief  Set Word length (i.e. nb of data bits, excluding start and stop bits)
;;;600      * @rmtoll CR1          M             LL_USART_SetDataWidth
;;;601      * @param  USARTx USART Instance
;;;602      * @param  DataWidth This parameter can be one of the following values:
;;;603      *         @arg @ref LL_USART_DATAWIDTH_8B
;;;604      *         @arg @ref LL_USART_DATAWIDTH_9B
;;;605      * @retval None
;;;606      */
;;;607    __STATIC_INLINE void LL_USART_SetDataWidth(USART_TypeDef *USARTx, uint32_t DataWidth)
;;;608    {
;;;609      MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
;;;610    }
;;;611    
;;;612    /**
;;;613      * @brief  Return Word length (i.e. nb of data bits, excluding start and stop bits)
;;;614      * @rmtoll CR1          M             LL_USART_GetDataWidth
;;;615      * @param  USARTx USART Instance
;;;616      * @retval Returned value can be one of the following values:
;;;617      *         @arg @ref LL_USART_DATAWIDTH_8B
;;;618      *         @arg @ref LL_USART_DATAWIDTH_9B
;;;619      */
;;;620    __STATIC_INLINE uint32_t LL_USART_GetDataWidth(USART_TypeDef *USARTx)
;;;621    {
;;;622      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
;;;623    }
;;;624    
;;;625    #if defined(USART_CR1_OVER8)
;;;626    /**
;;;627      * @brief  Set Oversampling to 8-bit or 16-bit mode
;;;628      * @rmtoll CR1          OVER8         LL_USART_SetOverSampling
;;;629      * @param  USARTx USART Instance
;;;630      * @param  OverSampling This parameter can be one of the following values:
;;;631      *         @arg @ref LL_USART_OVERSAMPLING_16
;;;632      *         @arg @ref LL_USART_OVERSAMPLING_8
;;;633      * @retval None
;;;634      */
;;;635    __STATIC_INLINE void LL_USART_SetOverSampling(USART_TypeDef *USARTx, uint32_t OverSampling)
;;;636    {
;;;637      MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
;;;638    }
;;;639    
;;;640    /**
;;;641      * @brief  Return Oversampling mode
;;;642      * @rmtoll CR1          OVER8         LL_USART_GetOverSampling
;;;643      * @param  USARTx USART Instance
;;;644      * @retval Returned value can be one of the following values:
;;;645      *         @arg @ref LL_USART_OVERSAMPLING_16
;;;646      *         @arg @ref LL_USART_OVERSAMPLING_8
;;;647      */
;;;648    __STATIC_INLINE uint32_t LL_USART_GetOverSampling(USART_TypeDef *USARTx)
;;;649    {
;;;650      return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_OVER8));
;;;651    }
;;;652    
;;;653    #endif /* USART_OverSampling_Feature */
;;;654    /**
;;;655      * @brief  Configure if Clock pulse of the last data bit is output to the SCLK pin or not
;;;656      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;657      *         Synchronous mode is supported by the USARTx instance.
;;;658      * @rmtoll CR2          LBCL          LL_USART_SetLastClkPulseOutput
;;;659      * @param  USARTx USART Instance
;;;660      * @param  LastBitClockPulse This parameter can be one of the following values:
;;;661      *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
;;;662      *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
;;;663      * @retval None
;;;664      */
;;;665    __STATIC_INLINE void LL_USART_SetLastClkPulseOutput(USART_TypeDef *USARTx, uint32_t LastBitClockPulse)
;;;666    {
;;;667      MODIFY_REG(USARTx->CR2, USART_CR2_LBCL, LastBitClockPulse);
;;;668    }
;;;669    
;;;670    /**
;;;671      * @brief  Retrieve Clock pulse of the last data bit output configuration
;;;672      *         (Last bit Clock pulse output to the SCLK pin or not)
;;;673      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;674      *         Synchronous mode is supported by the USARTx instance.
;;;675      * @rmtoll CR2          LBCL          LL_USART_GetLastClkPulseOutput
;;;676      * @param  USARTx USART Instance
;;;677      * @retval Returned value can be one of the following values:
;;;678      *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
;;;679      *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
;;;680      */
;;;681    __STATIC_INLINE uint32_t LL_USART_GetLastClkPulseOutput(USART_TypeDef *USARTx)
;;;682    {
;;;683      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_LBCL));
;;;684    }
;;;685    
;;;686    /**
;;;687      * @brief  Select the phase of the clock output on the SCLK pin in synchronous mode
;;;688      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;689      *         Synchronous mode is supported by the USARTx instance.
;;;690      * @rmtoll CR2          CPHA          LL_USART_SetClockPhase
;;;691      * @param  USARTx USART Instance
;;;692      * @param  ClockPhase This parameter can be one of the following values:
;;;693      *         @arg @ref LL_USART_PHASE_1EDGE
;;;694      *         @arg @ref LL_USART_PHASE_2EDGE
;;;695      * @retval None
;;;696      */
;;;697    __STATIC_INLINE void LL_USART_SetClockPhase(USART_TypeDef *USARTx, uint32_t ClockPhase)
;;;698    {
;;;699      MODIFY_REG(USARTx->CR2, USART_CR2_CPHA, ClockPhase);
;;;700    }
;;;701    
;;;702    /**
;;;703      * @brief  Return phase of the clock output on the SCLK pin in synchronous mode
;;;704      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;705      *         Synchronous mode is supported by the USARTx instance.
;;;706      * @rmtoll CR2          CPHA          LL_USART_GetClockPhase
;;;707      * @param  USARTx USART Instance
;;;708      * @retval Returned value can be one of the following values:
;;;709      *         @arg @ref LL_USART_PHASE_1EDGE
;;;710      *         @arg @ref LL_USART_PHASE_2EDGE
;;;711      */
;;;712    __STATIC_INLINE uint32_t LL_USART_GetClockPhase(USART_TypeDef *USARTx)
;;;713    {
;;;714      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPHA));
;;;715    }
;;;716    
;;;717    /**
;;;718      * @brief  Select the polarity of the clock output on the SCLK pin in synchronous mode
;;;719      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;720      *         Synchronous mode is supported by the USARTx instance.
;;;721      * @rmtoll CR2          CPOL          LL_USART_SetClockPolarity
;;;722      * @param  USARTx USART Instance
;;;723      * @param  ClockPolarity This parameter can be one of the following values:
;;;724      *         @arg @ref LL_USART_POLARITY_LOW
;;;725      *         @arg @ref LL_USART_POLARITY_HIGH
;;;726      * @retval None
;;;727      */
;;;728    __STATIC_INLINE void LL_USART_SetClockPolarity(USART_TypeDef *USARTx, uint32_t ClockPolarity)
;;;729    {
;;;730      MODIFY_REG(USARTx->CR2, USART_CR2_CPOL, ClockPolarity);
;;;731    }
;;;732    
;;;733    /**
;;;734      * @brief  Return polarity of the clock output on the SCLK pin in synchronous mode
;;;735      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;736      *         Synchronous mode is supported by the USARTx instance.
;;;737      * @rmtoll CR2          CPOL          LL_USART_GetClockPolarity
;;;738      * @param  USARTx USART Instance
;;;739      * @retval Returned value can be one of the following values:
;;;740      *         @arg @ref LL_USART_POLARITY_LOW
;;;741      *         @arg @ref LL_USART_POLARITY_HIGH
;;;742      */
;;;743    __STATIC_INLINE uint32_t LL_USART_GetClockPolarity(USART_TypeDef *USARTx)
;;;744    {
;;;745      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_CPOL));
;;;746    }
;;;747    
;;;748    /**
;;;749      * @brief  Configure Clock signal format (Phase Polarity and choice about output of last bit clock pulse)
;;;750      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;751      *         Synchronous mode is supported by the USARTx instance.
;;;752      * @note   Call of this function is equivalent to following function call sequence :
;;;753      *         - Clock Phase configuration using @ref LL_USART_SetClockPhase() function
;;;754      *         - Clock Polarity configuration using @ref LL_USART_SetClockPolarity() function
;;;755      *         - Output of Last bit Clock pulse configuration using @ref LL_USART_SetLastClkPulseOutput() function
;;;756      * @rmtoll CR2          CPHA          LL_USART_ConfigClock\n
;;;757      *         CR2          CPOL          LL_USART_ConfigClock\n
;;;758      *         CR2          LBCL          LL_USART_ConfigClock
;;;759      * @param  USARTx USART Instance
;;;760      * @param  Phase This parameter can be one of the following values:
;;;761      *         @arg @ref LL_USART_PHASE_1EDGE
;;;762      *         @arg @ref LL_USART_PHASE_2EDGE
;;;763      * @param  Polarity This parameter can be one of the following values:
;;;764      *         @arg @ref LL_USART_POLARITY_LOW
;;;765      *         @arg @ref LL_USART_POLARITY_HIGH
;;;766      * @param  LBCPOutput This parameter can be one of the following values:
;;;767      *         @arg @ref LL_USART_LASTCLKPULSE_NO_OUTPUT
;;;768      *         @arg @ref LL_USART_LASTCLKPULSE_OUTPUT
;;;769      * @retval None
;;;770      */
;;;771    __STATIC_INLINE void LL_USART_ConfigClock(USART_TypeDef *USARTx, uint32_t Phase, uint32_t Polarity, uint32_t LBCPOutput)
;;;772    {
;;;773      MODIFY_REG(USARTx->CR2, USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL, Phase | Polarity | LBCPOutput);
;;;774    }
;;;775    
;;;776    /**
;;;777      * @brief  Enable Clock output on SCLK pin
;;;778      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;779      *         Synchronous mode is supported by the USARTx instance.
;;;780      * @rmtoll CR2          CLKEN         LL_USART_EnableSCLKOutput
;;;781      * @param  USARTx USART Instance
;;;782      * @retval None
;;;783      */
;;;784    __STATIC_INLINE void LL_USART_EnableSCLKOutput(USART_TypeDef *USARTx)
;;;785    {
;;;786      SET_BIT(USARTx->CR2, USART_CR2_CLKEN);
;;;787    }
;;;788    
;;;789    /**
;;;790      * @brief  Disable Clock output on SCLK pin
;;;791      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;792      *         Synchronous mode is supported by the USARTx instance.
;;;793      * @rmtoll CR2          CLKEN         LL_USART_DisableSCLKOutput
;;;794      * @param  USARTx USART Instance
;;;795      * @retval None
;;;796      */
;;;797    __STATIC_INLINE void LL_USART_DisableSCLKOutput(USART_TypeDef *USARTx)
;;;798    {
;;;799      CLEAR_BIT(USARTx->CR2, USART_CR2_CLKEN);
;;;800    }
;;;801    
;;;802    /**
;;;803      * @brief  Indicate if Clock output on SCLK pin is enabled
;;;804      * @note   Macro @ref IS_USART_INSTANCE(USARTx) can be used to check whether or not
;;;805      *         Synchronous mode is supported by the USARTx instance.
;;;806      * @rmtoll CR2          CLKEN         LL_USART_IsEnabledSCLKOutput
;;;807      * @param  USARTx USART Instance
;;;808      * @retval State of bit (1 or 0).
;;;809      */
;;;810    __STATIC_INLINE uint32_t LL_USART_IsEnabledSCLKOutput(USART_TypeDef *USARTx)
;;;811    {
;;;812      return (READ_BIT(USARTx->CR2, USART_CR2_CLKEN) == (USART_CR2_CLKEN));
;;;813    }
;;;814    
;;;815    /**
;;;816      * @brief  Set the length of the stop bits
;;;817      * @rmtoll CR2          STOP          LL_USART_SetStopBitsLength
;;;818      * @param  USARTx USART Instance
;;;819      * @param  StopBits This parameter can be one of the following values:
;;;820      *         @arg @ref LL_USART_STOPBITS_0_5
;;;821      *         @arg @ref LL_USART_STOPBITS_1
;;;822      *         @arg @ref LL_USART_STOPBITS_1_5
;;;823      *         @arg @ref LL_USART_STOPBITS_2
;;;824      * @retval None
;;;825      */
;;;826    __STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
;;;827    {
;;;828      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
;;;829    }
;;;830    
;;;831    /**
;;;832      * @brief  Retrieve the length of the stop bits
;;;833      * @rmtoll CR2          STOP          LL_USART_GetStopBitsLength
;;;834      * @param  USARTx USART Instance
;;;835      * @retval Returned value can be one of the following values:
;;;836      *         @arg @ref LL_USART_STOPBITS_0_5
;;;837      *         @arg @ref LL_USART_STOPBITS_1
;;;838      *         @arg @ref LL_USART_STOPBITS_1_5
;;;839      *         @arg @ref LL_USART_STOPBITS_2
;;;840      */
;;;841    __STATIC_INLINE uint32_t LL_USART_GetStopBitsLength(USART_TypeDef *USARTx)
;;;842    {
;;;843      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
;;;844    }
;;;845    
;;;846    /**
;;;847      * @brief  Configure Character frame format (Datawidth, Parity control, Stop Bits)
;;;848      * @note   Call of this function is equivalent to following function call sequence :
;;;849      *         - Data Width configuration using @ref LL_USART_SetDataWidth() function
;;;850      *         - Parity Control and mode configuration using @ref LL_USART_SetParity() function
;;;851      *         - Stop bits configuration using @ref LL_USART_SetStopBitsLength() function
;;;852      * @rmtoll CR1          PS            LL_USART_ConfigCharacter\n
;;;853      *         CR1          PCE           LL_USART_ConfigCharacter\n
;;;854      *         CR1          M             LL_USART_ConfigCharacter\n
;;;855      *         CR2          STOP          LL_USART_ConfigCharacter
;;;856      * @param  USARTx USART Instance
;;;857      * @param  DataWidth This parameter can be one of the following values:
;;;858      *         @arg @ref LL_USART_DATAWIDTH_8B
;;;859      *         @arg @ref LL_USART_DATAWIDTH_9B
;;;860      * @param  Parity This parameter can be one of the following values:
;;;861      *         @arg @ref LL_USART_PARITY_NONE
;;;862      *         @arg @ref LL_USART_PARITY_EVEN
;;;863      *         @arg @ref LL_USART_PARITY_ODD
;;;864      * @param  StopBits This parameter can be one of the following values:
;;;865      *         @arg @ref LL_USART_STOPBITS_0_5
;;;866      *         @arg @ref LL_USART_STOPBITS_1
;;;867      *         @arg @ref LL_USART_STOPBITS_1_5
;;;868      *         @arg @ref LL_USART_STOPBITS_2
;;;869      * @retval None
;;;870      */
;;;871    __STATIC_INLINE void LL_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
;;;872                                                  uint32_t StopBits)
;;;873    {
;;;874      MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
;;;875      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
;;;876    }
;;;877    
;;;878    /**
;;;879      * @brief  Set Address of the USART node.
;;;880      * @note   This is used in multiprocessor communication during Mute mode or Stop mode,
;;;881      *         for wake up with address mark detection.
;;;882      * @rmtoll CR2          ADD           LL_USART_SetNodeAddress
;;;883      * @param  USARTx USART Instance
;;;884      * @param  NodeAddress 4 bit Address of the USART node.
;;;885      * @retval None
;;;886      */
;;;887    __STATIC_INLINE void LL_USART_SetNodeAddress(USART_TypeDef *USARTx, uint32_t NodeAddress)
;;;888    {
;;;889      MODIFY_REG(USARTx->CR2, USART_CR2_ADD, (NodeAddress & USART_CR2_ADD));
;;;890    }
;;;891    
;;;892    /**
;;;893      * @brief  Return 4 bit Address of the USART node as set in ADD field of CR2.
;;;894      * @note   only 4bits (b3-b0) of returned value are relevant (b31-b4 are not relevant)
;;;895      * @rmtoll CR2          ADD           LL_USART_GetNodeAddress
;;;896      * @param  USARTx USART Instance
;;;897      * @retval Address of the USART node (Value between Min_Data=0 and Max_Data=255)
;;;898      */
;;;899    __STATIC_INLINE uint32_t LL_USART_GetNodeAddress(USART_TypeDef *USARTx)
;;;900    {
;;;901      return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_ADD));
;;;902    }
;;;903    
;;;904    /**
;;;905      * @brief  Enable RTS HW Flow Control
;;;906      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;907      *         Hardware Flow control feature is supported by the USARTx instance.
;;;908      * @rmtoll CR3          RTSE          LL_USART_EnableRTSHWFlowCtrl
;;;909      * @param  USARTx USART Instance
;;;910      * @retval None
;;;911      */
;;;912    __STATIC_INLINE void LL_USART_EnableRTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;913    {
;;;914      SET_BIT(USARTx->CR3, USART_CR3_RTSE);
;;;915    }
;;;916    
;;;917    /**
;;;918      * @brief  Disable RTS HW Flow Control
;;;919      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;920      *         Hardware Flow control feature is supported by the USARTx instance.
;;;921      * @rmtoll CR3          RTSE          LL_USART_DisableRTSHWFlowCtrl
;;;922      * @param  USARTx USART Instance
;;;923      * @retval None
;;;924      */
;;;925    __STATIC_INLINE void LL_USART_DisableRTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;926    {
;;;927      CLEAR_BIT(USARTx->CR3, USART_CR3_RTSE);
;;;928    }
;;;929    
;;;930    /**
;;;931      * @brief  Enable CTS HW Flow Control
;;;932      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;933      *         Hardware Flow control feature is supported by the USARTx instance.
;;;934      * @rmtoll CR3          CTSE          LL_USART_EnableCTSHWFlowCtrl
;;;935      * @param  USARTx USART Instance
;;;936      * @retval None
;;;937      */
;;;938    __STATIC_INLINE void LL_USART_EnableCTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;939    {
;;;940      SET_BIT(USARTx->CR3, USART_CR3_CTSE);
;;;941    }
;;;942    
;;;943    /**
;;;944      * @brief  Disable CTS HW Flow Control
;;;945      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;946      *         Hardware Flow control feature is supported by the USARTx instance.
;;;947      * @rmtoll CR3          CTSE          LL_USART_DisableCTSHWFlowCtrl
;;;948      * @param  USARTx USART Instance
;;;949      * @retval None
;;;950      */
;;;951    __STATIC_INLINE void LL_USART_DisableCTSHWFlowCtrl(USART_TypeDef *USARTx)
;;;952    {
;;;953      CLEAR_BIT(USARTx->CR3, USART_CR3_CTSE);
;;;954    }
;;;955    
;;;956    /**
;;;957      * @brief  Configure HW Flow Control mode (both CTS and RTS)
;;;958      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;959      *         Hardware Flow control feature is supported by the USARTx instance.
;;;960      * @rmtoll CR3          RTSE          LL_USART_SetHWFlowCtrl\n
;;;961      *         CR3          CTSE          LL_USART_SetHWFlowCtrl
;;;962      * @param  USARTx USART Instance
;;;963      * @param  HardwareFlowControl This parameter can be one of the following values:
;;;964      *         @arg @ref LL_USART_HWCONTROL_NONE
;;;965      *         @arg @ref LL_USART_HWCONTROL_RTS
;;;966      *         @arg @ref LL_USART_HWCONTROL_CTS
;;;967      *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
;;;968      * @retval None
;;;969      */
;;;970    __STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
;;;971    {
;;;972      MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
;;;973    }
;;;974    
;;;975    /**
;;;976      * @brief  Return HW Flow Control configuration (both CTS and RTS)
;;;977      * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;978      *         Hardware Flow control feature is supported by the USARTx instance.
;;;979      * @rmtoll CR3          RTSE          LL_USART_GetHWFlowCtrl\n
;;;980      *         CR3          CTSE          LL_USART_GetHWFlowCtrl
;;;981      * @param  USARTx USART Instance
;;;982      * @retval Returned value can be one of the following values:
;;;983      *         @arg @ref LL_USART_HWCONTROL_NONE
;;;984      *         @arg @ref LL_USART_HWCONTROL_RTS
;;;985      *         @arg @ref LL_USART_HWCONTROL_CTS
;;;986      *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
;;;987      */
;;;988    __STATIC_INLINE uint32_t LL_USART_GetHWFlowCtrl(USART_TypeDef *USARTx)
;;;989    {
;;;990      return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
;;;991    }
;;;992    
;;;993    #if defined(USART_CR3_ONEBIT)
;;;994    /**
;;;995      * @brief  Enable One bit sampling method
;;;996      * @rmtoll CR3          ONEBIT        LL_USART_EnableOneBitSamp
;;;997      * @param  USARTx USART Instance
;;;998      * @retval None
;;;999      */
;;;1000   __STATIC_INLINE void LL_USART_EnableOneBitSamp(USART_TypeDef *USARTx)
;;;1001   {
;;;1002     SET_BIT(USARTx->CR3, USART_CR3_ONEBIT);
;;;1003   }
;;;1004   
;;;1005   /**
;;;1006     * @brief  Disable One bit sampling method
;;;1007     * @rmtoll CR3          ONEBIT        LL_USART_DisableOneBitSamp
;;;1008     * @param  USARTx USART Instance
;;;1009     * @retval None
;;;1010     */
;;;1011   __STATIC_INLINE void LL_USART_DisableOneBitSamp(USART_TypeDef *USARTx)
;;;1012   {
;;;1013     CLEAR_BIT(USARTx->CR3, USART_CR3_ONEBIT);
;;;1014   }
;;;1015   
;;;1016   /**
;;;1017     * @brief  Indicate if One bit sampling method is enabled
;;;1018     * @rmtoll CR3          ONEBIT        LL_USART_IsEnabledOneBitSamp
;;;1019     * @param  USARTx USART Instance
;;;1020     * @retval State of bit (1 or 0).
;;;1021     */
;;;1022   __STATIC_INLINE uint32_t LL_USART_IsEnabledOneBitSamp(USART_TypeDef *USARTx)
;;;1023   {
;;;1024     return (READ_BIT(USARTx->CR3, USART_CR3_ONEBIT) == (USART_CR3_ONEBIT));
;;;1025   }
;;;1026   #endif /* USART_OneBitSampling_Feature */
;;;1027   
;;;1028   #if defined(USART_CR1_OVER8)
;;;1029   /**
;;;1030     * @brief  Configure USART BRR register for achieving expected Baud Rate value.
;;;1031     * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
;;;1032     *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
;;;1033     * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
;;;1034     *         (Baud rate value != 0)
;;;1035     * @rmtoll BRR          BRR           LL_USART_SetBaudRate
;;;1036     * @param  USARTx USART Instance
;;;1037     * @param  PeriphClk Peripheral Clock
;;;1038     * @param  OverSampling This parameter can be one of the following values:
;;;1039     *         @arg @ref LL_USART_OVERSAMPLING_16
;;;1040     *         @arg @ref LL_USART_OVERSAMPLING_8
;;;1041     * @param  BaudRate Baud Rate
;;;1042     * @retval None
;;;1043     */
;;;1044   __STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
;;;1045                                             uint32_t BaudRate)
;;;1046   {
;;;1047     if (OverSampling == LL_USART_OVERSAMPLING_8)
;;;1048     {
;;;1049       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
;;;1050     }
;;;1051     else
;;;1052     {
;;;1053       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
;;;1054     }
;;;1055   }
;;;1056   
;;;1057   /**
;;;1058     * @brief  Return current Baud Rate value, according to USARTDIV present in BRR register
;;;1059     *         (full BRR content), and to used Peripheral Clock and Oversampling mode values
;;;1060     * @note   In case of non-initialized or invalid value stored in BRR register, value 0 will be returned.
;;;1061     * @rmtoll BRR          BRR           LL_USART_GetBaudRate
;;;1062     * @param  USARTx USART Instance
;;;1063     * @param  PeriphClk Peripheral Clock
;;;1064     * @param  OverSampling This parameter can be one of the following values:
;;;1065     *         @arg @ref LL_USART_OVERSAMPLING_16
;;;1066     *         @arg @ref LL_USART_OVERSAMPLING_8
;;;1067     * @retval Baud Rate
;;;1068     */
;;;1069   __STATIC_INLINE uint32_t LL_USART_GetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling)
;;;1070   {
;;;1071     register uint32_t usartdiv = 0x0U;
;;;1072     register uint32_t brrresult = 0x0U;
;;;1073   
;;;1074     usartdiv = USARTx->BRR;
;;;1075   
;;;1076     if (OverSampling == LL_USART_OVERSAMPLING_8)
;;;1077     {
;;;1078       if ((usartdiv & 0xFFF7U) != 0U)
;;;1079       {
;;;1080         usartdiv = (uint16_t)((usartdiv & 0xFFF0U) | ((usartdiv & 0x0007U) << 1U)) ;
;;;1081         brrresult = (PeriphClk * 2U) / usartdiv;
;;;1082       }
;;;1083     }
;;;1084     else
;;;1085     {
;;;1086       if ((usartdiv & 0xFFFFU) != 0U)
;;;1087       {
;;;1088         brrresult = PeriphClk / usartdiv;
;;;1089       }
;;;1090     }
;;;1091     return (brrresult);
;;;1092   }
;;;1093   #else
;;;1094   /**
;;;1095     * @brief  Configure USART BRR register for achieving expected Baud Rate value.
;;;1096     * @note   Compute and set USARTDIV value in BRR Register (full BRR content)
;;;1097     *         according to used Peripheral Clock, Oversampling mode, and expected Baud Rate values
;;;1098     * @note   Peripheral clock and Baud rate values provided as function parameters should be valid
;;;1099     *         (Baud rate value != 0)
;;;1100     * @rmtoll BRR          BRR           LL_USART_SetBaudRate
;;;1101     * @param  USARTx USART Instance
;;;1102     * @param  PeriphClk Peripheral Clock
;;;1103     * @param  BaudRate Baud Rate
;;;1104     * @retval None
;;;1105     */
;;;1106   __STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t BaudRate)
;;;1107   {
        0x0800109a:    b570        p.      PUSH     {r4-r6,lr}
;;;1108       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
        0x0800109c:    eb0103c1    ....    ADD      r3,r1,r1,LSL #3
        0x080010a0:    eb031301    ....    ADD      r3,r3,r1,LSL #4
        0x080010a4:    0094        ..      LSLS     r4,r2,#2
        0x080010a6:    fbb3f3f4    ....    UDIV     r3,r3,r4
        0x080010aa:    eb0104c1    ....    ADD      r4,r1,r1,LSL #3
        0x080010ae:    eb041401    ....    ADD      r4,r4,r1,LSL #4
        0x080010b2:    0095        ..      LSLS     r5,r2,#2
        0x080010b4:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010b8:    2564        d%      MOVS     r5,#0x64
        0x080010ba:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010be:    eb0405c4    ....    ADD      r5,r4,r4,LSL #3
        0x080010c2:    eb051404    ....    ADD      r4,r5,r4,LSL #4
        0x080010c6:    eba30384    ....    SUB      r3,r3,r4,LSL #2
        0x080010ca:    2432        2$      MOVS     r4,#0x32
        0x080010cc:    eb041303    ....    ADD      r3,r4,r3,LSL #4
        0x080010d0:    2464        d$      MOVS     r4,#0x64
        0x080010d2:    fbb3f3f4    ....    UDIV     r3,r3,r4
        0x080010d6:    f00303f0    ....    AND      r3,r3,#0xf0
        0x080010da:    eb0104c1    ....    ADD      r4,r1,r1,LSL #3
        0x080010de:    eb041401    ....    ADD      r4,r4,r1,LSL #4
        0x080010e2:    0095        ..      LSLS     r5,r2,#2
        0x080010e4:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010e8:    2564        d%      MOVS     r5,#0x64
        0x080010ea:    fbb4f4f5    ....    UDIV     r4,r4,r5
        0x080010ee:    eb031404    ....    ADD      r4,r3,r4,LSL #4
        0x080010f2:    eb0103c1    ....    ADD      r3,r1,r1,LSL #3
        0x080010f6:    eb031301    ....    ADD      r3,r3,r1,LSL #4
        0x080010fa:    0095        ..      LSLS     r5,r2,#2
        0x080010fc:    fbb3f3f5    ....    UDIV     r3,r3,r5
        0x08001100:    eb0105c1    ....    ADD      r5,r1,r1,LSL #3
        0x08001104:    eb051501    ....    ADD      r5,r5,r1,LSL #4
        0x08001108:    0096        ..      LSLS     r6,r2,#2
        0x0800110a:    fbb5f5f6    ....    UDIV     r5,r5,r6
        0x0800110e:    2664        d&      MOVS     r6,#0x64
        0x08001110:    fbb5f5f6    ....    UDIV     r5,r5,r6
        0x08001114:    eb0506c5    ....    ADD      r6,r5,r5,LSL #3
        0x08001118:    eb061505    ....    ADD      r5,r6,r5,LSL #4
        0x0800111c:    eba30385    ....    SUB      r3,r3,r5,LSL #2
        0x08001120:    2532        2%      MOVS     r5,#0x32
        0x08001122:    eb051303    ....    ADD      r3,r5,r3,LSL #4
        0x08001126:    2564        d%      MOVS     r5,#0x64
        0x08001128:    fbb3f3f5    ....    UDIV     r3,r3,r5
        0x0800112c:    f003030f    ....    AND      r3,r3,#0xf
        0x08001130:    4423        #D      ADD      r3,r3,r4
        0x08001132:    b29b        ..      UXTH     r3,r3
        0x08001134:    6083        .`      STR      r3,[r0,#8]
;;;1109   }
        0x08001136:    bd70        p.      POP      {r4-r6,pc}
    i.LL_mDelay
    LL_mDelay
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;201    {
        0x08001138:    b508        ..      PUSH     {r3,lr}
;;;202      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
        0x0800113a:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x0800113e:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001140:    9100        ..      STR      r1,[sp,#0]
;;;203      /* Add this code to indicate that local variable is not used */
;;;204      ((void)tmp);
        0x08001142:    bf00        ..      NOP      
;;;205    
;;;206      /* Add a period to guaranty minimum wait */
;;;207      if (Delay < LL_MAX_DELAY)
        0x08001144:    1c41        A.      ADDS     r1,r0,#1
        0x08001146:    b101        ..      CBZ      r1,0x800114a ; LL_mDelay + 18
;;;208      {
;;;209        Delay++;
        0x08001148:    1c40        @.      ADDS     r0,r0,#1
;;;210      }
;;;211    
;;;212      while (Delay)
        0x0800114a:    e006        ..      B        0x800115a ; LL_mDelay + 34
        0x0800114c:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001150:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001152:    f4013180    ...1    AND      r1,r1,#0x10000
        0x08001156:    b101        ..      CBZ      r1,0x800115a ; LL_mDelay + 34
        0x08001158:    1e40        @.      SUBS     r0,r0,#1
        0x0800115a:    2800        .(      CMP      r0,#0
        0x0800115c:    d1f6        ..      BNE      0x800114c ; LL_mDelay + 20
;;;213      {
;;;214        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
;;;215        {
;;;216          Delay--;
;;;217        }
;;;218      }
;;;219    }
        0x0800115e:    bd08        ..      POP      {r3,pc}
    i.MX_DMA_Init
    MX_DMA_Init
;;; .\../Src/main.c
;;;932    {
        0x08001160:    b538        8.      PUSH     {r3-r5,lr}
;;;933      /* Init with LL driver */
;;;934      /* DMA controller clock enable */
;;;935      LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);
        0x08001162:    2001        .       MOVS     r0,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;288      SET_BIT(RCC->AHBENR, Periphs);
        0x08001164:    4914        .I      LDR      r1,[pc,#80] ; [0x80011b8] = 0x40021000
        0x08001166:    6949        Ii      LDR      r1,[r1,#0x14]
        0x08001168:    4301        .C      ORRS     r1,r1,r0
        0x0800116a:    4a13        .J      LDR      r2,[pc,#76] ; [0x80011b8] = 0x40021000
        0x0800116c:    6151        Qa      STR      r1,[r2,#0x14]
;;;289      /* Delay after an RCC peripheral clock enabling */
;;;290      tmpreg = READ_BIT(RCC->AHBENR, Periphs);
        0x0800116e:    4611        .F      MOV      r1,r2
        0x08001170:    6949        Ii      LDR      r1,[r1,#0x14]
        0x08001172:    4001        .@      ANDS     r1,r1,r0
        0x08001174:    9100        ..      STR      r1,[sp,#0]
;;;291      (void)tmpreg;
        0x08001176:    bf00        ..      NOP      
;;;292    }
        0x08001178:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;939      NVIC_SetPriority(DMA1_Channel4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x0800117a:    f000fc4f    ..O.    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x0800117e:    4605        .F      MOV      r5,r0
        0x08001180:    2200        ."      MOVS     r2,#0
        0x08001182:    2102        .!      MOVS     r1,#2
        0x08001184:    f000fc29    ..).    BL       NVIC_EncodePriority ; 0x80019da
        0x08001188:    4604        .F      MOV      r4,r0
        0x0800118a:    4621        !F      MOV      r1,r4
        0x0800118c:    200e        .       MOVS     r0,#0xe
        0x0800118e:    f000fc4d    ..M.    BL       NVIC_SetPriority ; 0x8001a2c
;;;940      NVIC_EnableIRQ(DMA1_Channel4_IRQn);
        0x08001192:    200e        .       MOVS     r0,#0xe
        0x08001194:    f000fc16    ....    BL       NVIC_EnableIRQ ; 0x80019c4
;;;941      /* DMA1_Channel7_IRQn interrupt configuration */
;;;942      NVIC_SetPriority(DMA1_Channel7_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08001198:    f000fc40    ..@.    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x0800119c:    4605        .F      MOV      r5,r0
        0x0800119e:    2200        ."      MOVS     r2,#0
        0x080011a0:    2102        .!      MOVS     r1,#2
        0x080011a2:    f000fc1a    ....    BL       NVIC_EncodePriority ; 0x80019da
        0x080011a6:    4604        .F      MOV      r4,r0
        0x080011a8:    4621        !F      MOV      r1,r4
        0x080011aa:    2011        .       MOVS     r0,#0x11
        0x080011ac:    f000fc3e    ..>.    BL       NVIC_SetPriority ; 0x8001a2c
;;;943      NVIC_EnableIRQ(DMA1_Channel7_IRQn);
        0x080011b0:    2011        .       MOVS     r0,#0x11
        0x080011b2:    f000fc07    ....    BL       NVIC_EnableIRQ ; 0x80019c4
;;;944    
;;;945    }
        0x080011b6:    bd38        8.      POP      {r3-r5,pc}
    $d
        0x080011b8:    40021000    ...@    DCD    1073876992
    $t
    i.MX_GPIO_Init
    MX_GPIO_Init
;;;946    
;;;947    /**
;;;948      * @brief GPIO Initialization Function
;;;949      * @param None
;;;950      * @retval None
;;;951      */
;;;952    static void MX_GPIO_Init(void)
;;;953    {
        0x080011bc:    b500        ..      PUSH     {lr}
        0x080011be:    b085        ..      SUB      sp,sp,#0x14
;;;954      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080011c0:    2114        .!      MOVS     r1,#0x14
        0x080011c2:    4668        hF      MOV      r0,sp
        0x080011c4:    f7feffe6    ....    BL       __aeabi_memclr ; 0x8000194
;;;955    
;;;956      /* GPIO Ports Clock Enable */
;;;957      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOC);
        0x080011c8:    2010        .       MOVS     r0,#0x10
        0x080011ca:    f7fffb3d    ..=.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;958      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOD);
        0x080011ce:    2020                MOVS     r0,#0x20
        0x080011d0:    f7fffb3a    ..:.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;959      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x080011d4:    2004        .       MOVS     r0,#4
        0x080011d6:    f7fffb37    ..7.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;960      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080011da:    2008        .       MOVS     r0,#8
        0x080011dc:    f7fffb34    ..4.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;961    
;;;962      /**/
;;;963      LL_GPIO_ResetOutputPin(GPIOC, LED_Pin|MOTOR_X_DIR_Pin);
        0x080011e0:    492b        +I      LDR      r1,[pc,#172] ; [0x8001290] = 0x4a000a0
        0x080011e2:    482c        ,H      LDR      r0,[pc,#176] ; [0x8001294] = 0x40011000
        0x080011e4:    f7fffc4c    ..L.    BL       LL_GPIO_ResetOutputPin ; 0x8000a80
;;;964    
;;;965      /**/
;;;966      LL_GPIO_ResetOutputPin(GPIOA, MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin);
        0x080011e8:    f2482182    H..!    MOV      r1,#0x8282
        0x080011ec:    482a        *H      LDR      r0,[pc,#168] ; [0x8001298] = 0x40010800
        0x080011ee:    f7fffc47    ..G.    BL       LL_GPIO_ResetOutputPin ; 0x8000a80
;;;967    
;;;968      /**/
;;;969      LL_GPIO_ResetOutputPin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
        0x080011f2:    f2402102    @..!    MOV      r1,#0x202
        0x080011f6:    4829        )H      LDR      r0,[pc,#164] ; [0x800129c] = 0x40010c00
        0x080011f8:    f7fffc42    ..B.    BL       LL_GPIO_ResetOutputPin ; 0x8000a80
;;;970    
;;;971      /**/
;;;972      GPIO_InitStruct.Pin = LED_Pin|MOTOR_X_DIR_Pin;
        0x080011fc:    4824        $H      LDR      r0,[pc,#144] ; [0x8001290] = 0x4a000a0
        0x080011fe:    9000        ..      STR      r0,[sp,#0]
;;;973      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08001200:    2001        .       MOVS     r0,#1
        0x08001202:    9001        ..      STR      r0,[sp,#4]
;;;974      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08001204:    2002        .       MOVS     r0,#2
        0x08001206:    9002        ..      STR      r0,[sp,#8]
;;;975      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08001208:    2000        .       MOVS     r0,#0
        0x0800120a:    9003        ..      STR      r0,[sp,#0xc]
;;;976      LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x0800120c:    4669        iF      MOV      r1,sp
        0x0800120e:    4821        !H      LDR      r0,[pc,#132] ; [0x8001294] = 0x40011000
        0x08001210:    f7fffb98    ....    BL       LL_GPIO_Init ; 0x8000944
;;;977    
;;;978      /**/
;;;979      GPIO_InitStruct.Pin = LL_GPIO_PIN_14;
        0x08001214:    4822        "H      LDR      r0,[pc,#136] ; [0x80012a0] = 0x4400040
        0x08001216:    9000        ..      STR      r0,[sp,#0]
;;;980      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08001218:    2000        .       MOVS     r0,#0
        0x0800121a:    9001        ..      STR      r0,[sp,#4]
;;;981      LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x0800121c:    4669        iF      MOV      r1,sp
        0x0800121e:    481d        .H      LDR      r0,[pc,#116] ; [0x8001294] = 0x40011000
        0x08001220:    f7fffb90    ....    BL       LL_GPIO_Init ; 0x8000944
;;;982    
;;;983      /**/
;;;984      GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_10 
        0x08001224:    481f        .H      LDR      r0,[pc,#124] ; [0x80012a4] = 0x49c31bd
        0x08001226:    9000        ..      STR      r0,[sp,#0]
;;;985                              |LL_GPIO_PIN_11|LL_GPIO_PIN_12|LL_GPIO_PIN_15;
;;;986      GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08001228:    2000        .       MOVS     r0,#0
        0x0800122a:    9001        ..      STR      r0,[sp,#4]
;;;987      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x0800122c:    4669        iF      MOV      r1,sp
        0x0800122e:    481a        .H      LDR      r0,[pc,#104] ; [0x8001298] = 0x40010800
        0x08001230:    f7fffb88    ....    BL       LL_GPIO_Init ; 0x8000944
;;;988    
;;;989      /**/
;;;990      GPIO_InitStruct.Pin = MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin;
        0x08001234:    f2482082    H..     MOV      r0,#0x8282
        0x08001238:    9000        ..      STR      r0,[sp,#0]
;;;991      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x0800123a:    2001        .       MOVS     r0,#1
        0x0800123c:    9001        ..      STR      r0,[sp,#4]
;;;992      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x0800123e:    2002        .       MOVS     r0,#2
        0x08001240:    9002        ..      STR      r0,[sp,#8]
;;;993      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08001242:    2000        .       MOVS     r0,#0
        0x08001244:    9003        ..      STR      r0,[sp,#0xc]
;;;994      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001246:    4669        iF      MOV      r1,sp
        0x08001248:    4813        .H      LDR      r0,[pc,#76] ; [0x8001298] = 0x40010800
        0x0800124a:    f7fffb7b    ..{.    BL       LL_GPIO_Init ; 0x8000944
;;;995    
;;;996      /**/
;;;997      GPIO_InitStruct.Pin = MOTOR_Z_ENABLE_Pin;
        0x0800124e:    f2402002    @..     MOV      r0,#0x202
        0x08001252:    9000        ..      STR      r0,[sp,#0]
;;;998      GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08001254:    2001        .       MOVS     r0,#1
        0x08001256:    9001        ..      STR      r0,[sp,#4]
;;;999      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08001258:    2002        .       MOVS     r0,#2
        0x0800125a:    9002        ..      STR      r0,[sp,#8]
;;;1000     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x0800125c:    2000        .       MOVS     r0,#0
        0x0800125e:    9003        ..      STR      r0,[sp,#0xc]
;;;1001     LL_GPIO_Init(MOTOR_Z_ENABLE_GPIO_Port, &GPIO_InitStruct);
        0x08001260:    4669        iF      MOV      r1,sp
        0x08001262:    480e        .H      LDR      r0,[pc,#56] ; [0x800129c] = 0x40010c00
        0x08001264:    f7fffb6e    ..n.    BL       LL_GPIO_Init ; 0x8000944
;;;1002   
;;;1003     /**/
;;;1004     GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14 
        0x08001268:    480f        .H      LDR      r0,[pc,#60] ; [0x80012a8] = 0x4f23cfe
        0x0800126a:    9000        ..      STR      r0,[sp,#0]
;;;1005                             |LL_GPIO_PIN_15|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5 
;;;1006                             |LL_GPIO_PIN_9;
;;;1007     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x0800126c:    2000        .       MOVS     r0,#0
        0x0800126e:    9001        ..      STR      r0,[sp,#4]
;;;1008     LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08001270:    4669        iF      MOV      r1,sp
        0x08001272:    480a        .H      LDR      r0,[pc,#40] ; [0x800129c] = 0x40010c00
        0x08001274:    f7fffb66    ..f.    BL       LL_GPIO_Init ; 0x8000944
;;;1009   
;;;1010     /**/
;;;1011     GPIO_InitStruct.Pin = BUTTON_1_Pin|BUTTON_2_Pin;
        0x08001278:    480c        .H      LDR      r0,[pc,#48] ; [0x80012ac] = 0x4030003
        0x0800127a:    9000        ..      STR      r0,[sp,#0]
;;;1012     GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x0800127c:    2008        .       MOVS     r0,#8
        0x0800127e:    9001        ..      STR      r0,[sp,#4]
;;;1013     GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x08001280:    2001        .       MOVS     r0,#1
        0x08001282:    9004        ..      STR      r0,[sp,#0x10]
;;;1014     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001284:    4669        iF      MOV      r1,sp
        0x08001286:    4804        .H      LDR      r0,[pc,#16] ; [0x8001298] = 0x40010800
        0x08001288:    f7fffb5c    ..\.    BL       LL_GPIO_Init ; 0x8000944
;;;1015   
;;;1016   }
        0x0800128c:    b005        ..      ADD      sp,sp,#0x14
        0x0800128e:    bd00        ..      POP      {pc}
    $d
        0x08001290:    04a000a0    ....    DCD    77594784
        0x08001294:    40011000    ...@    DCD    1073811456
        0x08001298:    40010800    ...@    DCD    1073809408
        0x0800129c:    40010c00    ...@    DCD    1073810432
        0x080012a0:    04400040    @.@.    DCD    71303232
        0x080012a4:    049c31bd    .1..    DCD    77345213
        0x080012a8:    04f23cfe    .<..    DCD    82984190
        0x080012ac:    04030003    ....    DCD    67305475
    $t
    i.MX_I2C2_Init
    MX_I2C2_Init
;;; .\../Src/main.c (524)
        0x080012b0:    b530        0.      PUSH     {r4,r5,lr}
        0x080012b2:    b08b        ..      SUB      sp,sp,#0x2c
;;;525    
;;;526      /* USER CODE BEGIN I2C2_Init 0 */
;;;527    
;;;528      /* USER CODE END I2C2_Init 0 */
;;;529    
;;;530      LL_I2C_InitTypeDef I2C_InitStruct = {0};
        0x080012b4:    2118        .!      MOVS     r1,#0x18
        0x080012b6:    a805        ..      ADD      r0,sp,#0x14
        0x080012b8:    f7feff6c    ..l.    BL       __aeabi_memclr ; 0x8000194
;;;531    
;;;532      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080012bc:    2114        .!      MOVS     r1,#0x14
        0x080012be:    4668        hF      MOV      r0,sp
        0x080012c0:    f7feff68    ..h.    BL       __aeabi_memclr ; 0x8000194
;;;533    
;;;534      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080012c4:    2008        .       MOVS     r0,#8
        0x080012c6:    f7fffabf    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;535      /**I2C2 GPIO Configuration  
;;;536      PB10   ------> I2C2_SCL
;;;537      PB11   ------> I2C2_SDA 
;;;538      */
;;;539      GPIO_InitStruct.Pin = LL_GPIO_PIN_10|LL_GPIO_PIN_11;
        0x080012ca:    4840        @H      LDR      r0,[pc,#256] ; [0x80013cc] = 0x40c000c
        0x080012cc:    9000        ..      STR      r0,[sp,#0]
;;;540      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080012ce:    2009        .       MOVS     r0,#9
        0x080012d0:    9001        ..      STR      r0,[sp,#4]
;;;541      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080012d2:    2003        .       MOVS     r0,#3
        0x080012d4:    9002        ..      STR      r0,[sp,#8]
;;;542      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
        0x080012d6:    2004        .       MOVS     r0,#4
        0x080012d8:    9003        ..      STR      r0,[sp,#0xc]
;;;543      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x080012da:    4669        iF      MOV      r1,sp
        0x080012dc:    483c        <H      LDR      r0,[pc,#240] ; [0x80013d0] = 0x40010c00
        0x080012de:    f7fffb31    ..1.    BL       LL_GPIO_Init ; 0x8000944
;;;544    
;;;545      /* Peripheral clock enable */
;;;546      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_I2C2);
        0x080012e2:    f44f0080    O...    MOV      r0,#0x400000
        0x080012e6:    f7fffaa1    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;547    
;;;548      /* I2C2 DMA Init */
;;;549      
;;;550      /* I2C2_TX Init */
;;;551      LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_4, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);
        0x080012ea:    2210        ."      MOVS     r2,#0x10
        0x080012ec:    2104        .!      MOVS     r1,#4
        0x080012ee:    4839        9H      LDR      r0,[pc,#228] ; [0x80013d4] = 0x40020000
        0x080012f0:    f7fffac8    ....    BL       LL_DMA_SetDataTransferDirection ; 0x8000884
;;;552    
;;;553      LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PRIORITY_LOW);
        0x080012f4:    2200        ."      MOVS     r2,#0
        0x080012f6:    2104        .!      MOVS     r1,#4
        0x080012f8:    4836        6H      LDR      r0,[pc,#216] ; [0x80013d4] = 0x40020000
        0x080012fa:    f7fffab3    ....    BL       LL_DMA_SetChannelPriorityLevel ; 0x8000864
;;;554    
;;;555      LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MODE_NORMAL);
        0x080012fe:    2200        ."      MOVS     r2,#0
        0x08001300:    2104        .!      MOVS     r1,#4
        0x08001302:    4834        4H      LDR      r0,[pc,#208] ; [0x80013d4] = 0x40020000
        0x08001304:    f7fffaee    ....    BL       LL_DMA_SetMode ; 0x80008e4
;;;556    
;;;557      LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PERIPH_NOINCREMENT);
        0x08001308:    2200        ."      MOVS     r2,#0
        0x0800130a:    2104        .!      MOVS     r1,#4
        0x0800130c:    4831        1H      LDR      r0,[pc,#196] ; [0x80013d4] = 0x40020000
        0x0800130e:    f7fffaf9    ....    BL       LL_DMA_SetPeriphIncMode ; 0x8000904
;;;558    
;;;559      LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MEMORY_INCREMENT);
        0x08001312:    2280        ."      MOVS     r2,#0x80
        0x08001314:    2104        .!      MOVS     r1,#4
        0x08001316:    482f        /H      LDR      r0,[pc,#188] ; [0x80013d4] = 0x40020000
        0x08001318:    f7fffac4    ....    BL       LL_DMA_SetMemoryIncMode ; 0x80008a4
;;;560    
;;;561      LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_PDATAALIGN_BYTE);
        0x0800131c:    2200        ."      MOVS     r2,#0
        0x0800131e:    2104        .!      MOVS     r1,#4
        0x08001320:    482c        ,H      LDR      r0,[pc,#176] ; [0x80013d4] = 0x40020000
        0x08001322:    f7fffaff    ....    BL       LL_DMA_SetPeriphSize ; 0x8000924
;;;562    
;;;563      LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_4, LL_DMA_MDATAALIGN_BYTE);
        0x08001326:    2200        ."      MOVS     r2,#0
        0x08001328:    2104        .!      MOVS     r1,#4
        0x0800132a:    482a        *H      LDR      r0,[pc,#168] ; [0x80013d4] = 0x40020000
        0x0800132c:    f7fffaca    ....    BL       LL_DMA_SetMemorySize ; 0x80008c4
;;;564    
;;;565      /* I2C2 interrupt Init */
;;;566      NVIC_SetPriority(I2C2_EV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),3, 0));
        0x08001330:    f000fb74    ..t.    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x08001334:    4605        .F      MOV      r5,r0
        0x08001336:    2200        ."      MOVS     r2,#0
        0x08001338:    2103        .!      MOVS     r1,#3
        0x0800133a:    f000fb4e    ..N.    BL       NVIC_EncodePriority ; 0x80019da
        0x0800133e:    4604        .F      MOV      r4,r0
        0x08001340:    4621        !F      MOV      r1,r4
        0x08001342:    2021        !       MOVS     r0,#0x21
        0x08001344:    f000fb72    ..r.    BL       NVIC_SetPriority ; 0x8001a2c
;;;567      NVIC_EnableIRQ(I2C2_EV_IRQn);
        0x08001348:    2021        !       MOVS     r0,#0x21
        0x0800134a:    f000fb3b    ..;.    BL       NVIC_EnableIRQ ; 0x80019c4
;;;568      NVIC_SetPriority(I2C2_ER_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),3, 0));
        0x0800134e:    f000fb65    ..e.    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x08001352:    4605        .F      MOV      r5,r0
        0x08001354:    2200        ."      MOVS     r2,#0
        0x08001356:    2103        .!      MOVS     r1,#3
        0x08001358:    f000fb3f    ..?.    BL       NVIC_EncodePriority ; 0x80019da
        0x0800135c:    4604        .F      MOV      r4,r0
        0x0800135e:    4621        !F      MOV      r1,r4
        0x08001360:    2022        "       MOVS     r0,#0x22
        0x08001362:    f000fb63    ..c.    BL       NVIC_SetPriority ; 0x8001a2c
;;;569      NVIC_EnableIRQ(I2C2_ER_IRQn);
        0x08001366:    2022        "       MOVS     r0,#0x22
        0x08001368:    f000fb2c    ..,.    BL       NVIC_EnableIRQ ; 0x80019c4
;;;570    
;;;571      /* USER CODE BEGIN I2C2_Init 1 */
;;;572    
;;;573      /* USER CODE END I2C2_Init 1 */
;;;574      /**I2C Initialization 
;;;575      */
;;;576      LL_I2C_DisableOwnAddress2(I2C2);
        0x0800136c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;590      CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
        0x0800136e:    481a        .H      LDR      r0,[pc,#104] ; [0x80013d8] = 0x40005800
        0x08001370:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08001372:    f0200001     ...    BIC      r0,r0,#1
        0x08001376:    4918        .I      LDR      r1,[pc,#96] ; [0x80013d8] = 0x40005800
        0x08001378:    60c8        .`      STR      r0,[r1,#0xc]
;;;591    }
        0x0800137a:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;577      LL_I2C_DisableGeneralCall(I2C2);
        0x0800137c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;526      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENGC);
        0x0800137e:    4608        .F      MOV      r0,r1
        0x08001380:    6800        .h      LDR      r0,[r0,#0]
        0x08001382:    f0200040     .@.    BIC      r0,r0,#0x40
        0x08001386:    6008        .`      STR      r0,[r1,#0]
;;;527    }
        0x08001388:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;578      LL_I2C_EnableClockStretching(I2C2);
        0x0800138a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;479      CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
        0x0800138c:    4608        .F      MOV      r0,r1
        0x0800138e:    6800        .h      LDR      r0,[r0,#0]
        0x08001390:    f0200080     ...    BIC      r0,r0,#0x80
        0x08001394:    6008        .`      STR      r0,[r1,#0]
;;;480    }
        0x08001396:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;579      I2C_InitStruct.PeripheralMode = LL_I2C_MODE_I2C;
        0x08001398:    2000        .       MOVS     r0,#0
        0x0800139a:    9005        ..      STR      r0,[sp,#0x14]
;;;580      I2C_InitStruct.ClockSpeed = 400000;
        0x0800139c:    480f        .H      LDR      r0,[pc,#60] ; [0x80013dc] = 0x61a80
        0x0800139e:    9006        ..      STR      r0,[sp,#0x18]
;;;581      I2C_InitStruct.DutyCycle = LL_I2C_DUTYCYCLE_2;
        0x080013a0:    2000        .       MOVS     r0,#0
        0x080013a2:    9007        ..      STR      r0,[sp,#0x1c]
;;;582      I2C_InitStruct.OwnAddress1 = 0;
        0x080013a4:    9008        ..      STR      r0,[sp,#0x20]
;;;583      I2C_InitStruct.TypeAcknowledge = LL_I2C_ACK;
        0x080013a6:    1508        ..      ASRS     r0,r1,#20
        0x080013a8:    9009        ..      STR      r0,[sp,#0x24]
;;;584      I2C_InitStruct.OwnAddrSize = LL_I2C_OWNADDRESS1_7BIT;
        0x080013aa:    0100        ..      LSLS     r0,r0,#4
        0x080013ac:    900a        ..      STR      r0,[sp,#0x28]
;;;585      LL_I2C_Init(I2C2, &I2C_InitStruct);
        0x080013ae:    a905        ..      ADD      r1,sp,#0x14
        0x080013b0:    4809        .H      LDR      r0,[pc,#36] ; [0x80013d8] = 0x40005800
        0x080013b2:    f7fffbc7    ....    BL       LL_I2C_Init ; 0x8000b44
;;;586      LL_I2C_SetOwnAddress2(I2C2, 0);
        0x080013b6:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;568      MODIFY_REG(I2Cx->OAR2, I2C_OAR2_ADD2, OwnAddress2);
        0x080013b8:    4907        .I      LDR      r1,[pc,#28] ; [0x80013d8] = 0x40005800
        0x080013ba:    68c9        .h      LDR      r1,[r1,#0xc]
        0x080013bc:    f02101fe    !...    BIC      r1,r1,#0xfe
        0x080013c0:    4301        .C      ORRS     r1,r1,r0
        0x080013c2:    4a05        .J      LDR      r2,[pc,#20] ; [0x80013d8] = 0x40005800
        0x080013c4:    60d1        .`      STR      r1,[r2,#0xc]
;;;569    }
        0x080013c6:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;591    }
        0x080013c8:    b00b        ..      ADD      sp,sp,#0x2c
        0x080013ca:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080013cc:    040c000c    ....    DCD    67895308
        0x080013d0:    40010c00    ...@    DCD    1073810432
        0x080013d4:    40020000    ...@    DCD    1073872896
        0x080013d8:    40005800    .X.@    DCD    1073764352
        0x080013dc:    00061a80    ....    DCD    400000
    $t
    i.MX_TIM1_Init
    MX_TIM1_Init
;;;592    
;;;593    /**
;;;594      * @brief TIM1 Initialization Function
;;;595      * @param None
;;;596      * @retval None
;;;597      */
;;;598    static void MX_TIM1_Init(void)
;;;599    {
        0x080013e0:    b530        0.      PUSH     {r4,r5,lr}
        0x080013e2:    b093        ..      SUB      sp,sp,#0x4c
;;;600    
;;;601      /* USER CODE BEGIN TIM1_Init 0 */
;;;602    
;;;603      /* USER CODE END TIM1_Init 0 */
;;;604    
;;;605      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x080013e4:    2114        .!      MOVS     r1,#0x14
        0x080013e6:    a80e        ..      ADD      r0,sp,#0x38
        0x080013e8:    f7fefed4    ....    BL       __aeabi_memclr ; 0x8000194
;;;606      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x080013ec:    2120         !      MOVS     r1,#0x20
        0x080013ee:    a806        ..      ADD      r0,sp,#0x18
        0x080013f0:    f7fefed0    ....    BL       __aeabi_memclr ; 0x8000194
;;;607      LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};
        0x080013f4:    2118        .!      MOVS     r1,#0x18
        0x080013f6:    4668        hF      MOV      r0,sp
        0x080013f8:    f7fefecc    ....    BL       __aeabi_memclr ; 0x8000194
;;;608    
;;;609      /* Peripheral clock enable */
;;;610      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);
        0x080013fc:    f44f6000    O..`    MOV      r0,#0x800
        0x08001400:    f7fffa22    ..".    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;611    
;;;612      /* TIM1 interrupt Init */
;;;613      NVIC_SetPriority(TIM1_UP_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
        0x08001404:    f000fb0a    ....    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x08001408:    4605        .F      MOV      r5,r0
        0x0800140a:    2200        ."      MOVS     r2,#0
        0x0800140c:    210f        .!      MOVS     r1,#0xf
        0x0800140e:    f000fae4    ....    BL       NVIC_EncodePriority ; 0x80019da
        0x08001412:    4604        .F      MOV      r4,r0
        0x08001414:    4621        !F      MOV      r1,r4
        0x08001416:    2019        .       MOVS     r0,#0x19
        0x08001418:    f000fb08    ....    BL       NVIC_SetPriority ; 0x8001a2c
;;;614      NVIC_EnableIRQ(TIM1_UP_IRQn);
        0x0800141c:    2019        .       MOVS     r0,#0x19
        0x0800141e:    f000fad1    ....    BL       NVIC_EnableIRQ ; 0x80019c4
;;;615    
;;;616      /* USER CODE BEGIN TIM1_Init 1 */
;;;617    
;;;618      /* USER CODE END TIM1_Init 1 */
;;;619      TIM_InitStruct.Prescaler = 720;
        0x08001422:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x08001426:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;620      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x0800142a:    2000        .       MOVS     r0,#0
        0x0800142c:    900f        ..      STR      r0,[sp,#0x3c]
;;;621      TIM_InitStruct.Autoreload = 0;
        0x0800142e:    9010        ..      STR      r0,[sp,#0x40]
;;;622      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08001430:    9011        ..      STR      r0,[sp,#0x44]
;;;623      TIM_InitStruct.RepetitionCounter = 0;
        0x08001432:    f88d0048    ..H.    STRB     r0,[sp,#0x48]
;;;624      LL_TIM_Init(TIM1, &TIM_InitStruct);
        0x08001436:    a90e        ..      ADD      r1,sp,#0x38
        0x08001438:    481d        .H      LDR      r0,[pc,#116] ; [0x80014b0] = 0x40012c00
        0x0800143a:    f7fffcfb    ....    BL       LL_TIM_Init ; 0x8000e34
;;;625      LL_TIM_DisableARRPreload(TIM1);
        0x0800143e:    481c        .H      LDR      r0,[pc,#112] ; [0x80014b0] = 0x40012c00
        0x08001440:    f7fffc0b    ....    BL       LL_TIM_DisableARRPreload ; 0x8000c5a
;;;626      LL_TIM_SetClockSource(TIM1, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x08001444:    2100        .!      MOVS     r1,#0
        0x08001446:    481a        .H      LDR      r0,[pc,#104] ; [0x80014b0] = 0x40012c00
        0x08001448:    f7fffdcc    ....    BL       LL_TIM_SetClockSource ; 0x8000fe4
;;;627      LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1);
        0x0800144c:    2101        .!      MOVS     r1,#1
        0x0800144e:    4818        .H      LDR      r0,[pc,#96] ; [0x80014b0] = 0x40012c00
        0x08001450:    f7fffd68    ..h.    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;628      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
        0x08001454:    2060        `       MOVS     r0,#0x60
        0x08001456:    9006        ..      STR      r0,[sp,#0x18]
;;;629      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001458:    2000        .       MOVS     r0,#0
        0x0800145a:    9007        ..      STR      r0,[sp,#0x1c]
;;;630      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800145c:    9008        ..      STR      r0,[sp,#0x20]
;;;631      TIM_OC_InitStruct.CompareValue = 0;
        0x0800145e:    9009        ..      STR      r0,[sp,#0x24]
;;;632      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001460:    900a        ..      STR      r0,[sp,#0x28]
;;;633      TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001462:    900b        ..      STR      r0,[sp,#0x2c]
;;;634      TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x08001464:    900c        ..      STR      r0,[sp,#0x30]
;;;635      TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x08001466:    900d        ..      STR      r0,[sp,#0x34]
;;;636      LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08001468:    aa06        ..      ADD      r2,sp,#0x18
        0x0800146a:    2101        .!      MOVS     r1,#1
        0x0800146c:    4810        .H      LDR      r0,[pc,#64] ; [0x80014b0] = 0x40012c00
        0x0800146e:    f7fffd89    ....    BL       LL_TIM_OC_Init ; 0x8000f84
;;;637      LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1);
        0x08001472:    2101        .!      MOVS     r1,#1
        0x08001474:    480e        .H      LDR      r0,[pc,#56] ; [0x80014b0] = 0x40012c00
        0x08001476:    f7fffd25    ..%.    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;638      LL_TIM_SetTriggerOutput(TIM1, LL_TIM_TRGO_RESET);
        0x0800147a:    2100        .!      MOVS     r1,#0
        0x0800147c:    480c        .H      LDR      r0,[pc,#48] ; [0x80014b0] = 0x40012c00
        0x0800147e:    f7fffdb8    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;639      LL_TIM_DisableMasterSlaveMode(TIM1);
        0x08001482:    480b        .H      LDR      r0,[pc,#44] ; [0x80014b0] = 0x40012c00
        0x08001484:    f7fffbee    ....    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000c64
;;;640      TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;
        0x08001488:    2000        .       MOVS     r0,#0
        0x0800148a:    9000        ..      STR      r0,[sp,#0]
;;;641      TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;
        0x0800148c:    9001        ..      STR      r0,[sp,#4]
;;;642      TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
        0x0800148e:    9002        ..      STR      r0,[sp,#8]
;;;643      TIM_BDTRInitStruct.DeadTime = 0;
        0x08001490:    f88d000c    ....    STRB     r0,[sp,#0xc]
;;;644      TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
        0x08001494:    f8ad000e    ....    STRH     r0,[sp,#0xe]
;;;645      TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
        0x08001498:    f44f5000    O..P    MOV      r0,#0x2000
        0x0800149c:    9004        ..      STR      r0,[sp,#0x10]
;;;646      TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
        0x0800149e:    2000        .       MOVS     r0,#0
        0x080014a0:    9005        ..      STR      r0,[sp,#0x14]
;;;647      LL_TIM_BDTR_Init(TIM1, &TIM_BDTRInitStruct);
        0x080014a2:    4669        iF      MOV      r1,sp
        0x080014a4:    4802        .H      LDR      r0,[pc,#8] ; [0x80014b0] = 0x40012c00
        0x080014a6:    f7fffba7    ....    BL       LL_TIM_BDTR_Init ; 0x8000bf8
;;;648      /* USER CODE BEGIN TIM1_Init 2 */
;;;649    
;;;650      /* USER CODE END TIM1_Init 2 */
;;;651    
;;;652    }
        0x080014aa:    b013        ..      ADD      sp,sp,#0x4c
        0x080014ac:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080014ae:    0000        ..      DCW    0
        0x080014b0:    40012c00    .,.@    DCD    1073818624
    $t
    i.MX_TIM2_Init
    MX_TIM2_Init
;;;653    
;;;654    /**
;;;655      * @brief TIM2 Initialization Function
;;;656      * @param None
;;;657      * @retval None
;;;658      */
;;;659    static void MX_TIM2_Init(void)
;;;660    {
        0x080014b4:    b530        0.      PUSH     {r4,r5,lr}
        0x080014b6:    b08d        ..      SUB      sp,sp,#0x34
;;;661    
;;;662      /* USER CODE BEGIN TIM2_Init 0 */
;;;663    
;;;664      /* USER CODE END TIM2_Init 0 */
;;;665    
;;;666      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x080014b8:    2114        .!      MOVS     r1,#0x14
        0x080014ba:    a808        ..      ADD      r0,sp,#0x20
        0x080014bc:    f7fefe6a    ..j.    BL       __aeabi_memclr ; 0x8000194
;;;667      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x080014c0:    2120         !      MOVS     r1,#0x20
        0x080014c2:    4668        hF      MOV      r0,sp
        0x080014c4:    f7fefe66    ..f.    BL       __aeabi_memclr ; 0x8000194
;;;668    
;;;669      /* Peripheral clock enable */
;;;670      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM2);
        0x080014c8:    2001        .       MOVS     r0,#1
        0x080014ca:    f7fff9af    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;671    
;;;672      /* TIM2 interrupt Init */
;;;673      NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),1, 0));
        0x080014ce:    f000faa5    ....    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x080014d2:    4605        .F      MOV      r5,r0
        0x080014d4:    2200        ."      MOVS     r2,#0
        0x080014d6:    2101        .!      MOVS     r1,#1
        0x080014d8:    f000fa7f    ....    BL       NVIC_EncodePriority ; 0x80019da
        0x080014dc:    4604        .F      MOV      r4,r0
        0x080014de:    4621        !F      MOV      r1,r4
        0x080014e0:    201c        .       MOVS     r0,#0x1c
        0x080014e2:    f000faa3    ....    BL       NVIC_SetPriority ; 0x8001a2c
;;;674      NVIC_EnableIRQ(TIM2_IRQn);
        0x080014e6:    201c        .       MOVS     r0,#0x1c
        0x080014e8:    f000fa6c    ..l.    BL       NVIC_EnableIRQ ; 0x80019c4
;;;675    
;;;676      /* USER CODE BEGIN TIM2_Init 1 */
;;;677    
;;;678      /* USER CODE END TIM2_Init 1 */
;;;679      TIM_InitStruct.Prescaler = 720;
        0x080014ec:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x080014f0:    f8ad0020    .. .    STRH     r0,[sp,#0x20]
;;;680      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x080014f4:    2000        .       MOVS     r0,#0
        0x080014f6:    9009        ..      STR      r0,[sp,#0x24]
;;;681      TIM_InitStruct.Autoreload = 50;
        0x080014f8:    2032        2       MOVS     r0,#0x32
        0x080014fa:    900a        ..      STR      r0,[sp,#0x28]
;;;682      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x080014fc:    2000        .       MOVS     r0,#0
        0x080014fe:    900b        ..      STR      r0,[sp,#0x2c]
;;;683      LL_TIM_Init(TIM2, &TIM_InitStruct);
        0x08001500:    a908        ..      ADD      r1,sp,#0x20
        0x08001502:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001506:    f7fffc95    ....    BL       LL_TIM_Init ; 0x8000e34
;;;684      LL_TIM_EnableARRPreload(TIM2);
        0x0800150a:    f04f4080    O..@    MOV      r0,#0x40000000
        0x0800150e:    f7fffbae    ....    BL       LL_TIM_EnableARRPreload ; 0x8000c6e
;;;685      LL_TIM_SetClockSource(TIM2, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x08001512:    2100        .!      MOVS     r1,#0
        0x08001514:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001518:    f7fffd64    ..d.    BL       LL_TIM_SetClockSource ; 0x8000fe4
;;;686      LL_TIM_OC_EnablePreload(TIM2, LL_TIM_CHANNEL_CH1);
        0x0800151c:    2101        .!      MOVS     r1,#1
        0x0800151e:    0788        ..      LSLS     r0,r1,#30
        0x08001520:    f7fffd00    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;687      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x08001524:    2070        p       MOVS     r0,#0x70
        0x08001526:    9000        ..      STR      r0,[sp,#0]
;;;688      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001528:    2000        .       MOVS     r0,#0
        0x0800152a:    9001        ..      STR      r0,[sp,#4]
;;;689      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800152c:    9002        ..      STR      r0,[sp,#8]
;;;690      TIM_OC_InitStruct.CompareValue = 48;
        0x0800152e:    2030        0       MOVS     r0,#0x30
        0x08001530:    9003        ..      STR      r0,[sp,#0xc]
;;;691      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08001532:    2000        .       MOVS     r0,#0
        0x08001534:    9004        ..      STR      r0,[sp,#0x10]
;;;692      LL_TIM_OC_Init(TIM2, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08001536:    466a        jF      MOV      r2,sp
        0x08001538:    2101        .!      MOVS     r1,#1
        0x0800153a:    0788        ..      LSLS     r0,r1,#30
        0x0800153c:    f7fffd22    ..".    BL       LL_TIM_OC_Init ; 0x8000f84
;;;693      LL_TIM_OC_DisableFast(TIM2, LL_TIM_CHANNEL_CH1);
        0x08001540:    2101        .!      MOVS     r1,#1
        0x08001542:    0788        ..      LSLS     r0,r1,#30
        0x08001544:    f7fffcbe    ....    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;694      LL_TIM_SetTriggerOutput(TIM2, LL_TIM_TRGO_UPDATE);
        0x08001548:    2120         !      MOVS     r1,#0x20
        0x0800154a:    0648        H.      LSLS     r0,r1,#25
        0x0800154c:    f7fffd51    ..Q.    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;695      LL_TIM_EnableMasterSlaveMode(TIM2);
        0x08001550:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001554:    f7fffb95    ....    BL       LL_TIM_EnableMasterSlaveMode ; 0x8000c82
;;;696      /* USER CODE BEGIN TIM2_Init 2 */
;;;697    
;;;698      /* USER CODE END TIM2_Init 2 */
;;;699    
;;;700    }
        0x08001558:    b00d        ..      ADD      sp,sp,#0x34
        0x0800155a:    bd30        0.      POP      {r4,r5,pc}
    i.MX_TIM3_Init
    MX_TIM3_Init
;;;701    
;;;702    /**
;;;703      * @brief TIM3 Initialization Function
;;;704      * @param None
;;;705      * @retval None
;;;706      */
;;;707    static void MX_TIM3_Init(void)
;;;708    {
        0x0800155c:    b530        0.      PUSH     {r4,r5,lr}
        0x0800155e:    b093        ..      SUB      sp,sp,#0x4c
;;;709    
;;;710      /* USER CODE BEGIN TIM3_Init 0 */
;;;711    
;;;712      /* USER CODE END TIM3_Init 0 */
;;;713    
;;;714      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x08001560:    2114        .!      MOVS     r1,#0x14
        0x08001562:    a80e        ..      ADD      r0,sp,#0x38
        0x08001564:    f7fefe16    ....    BL       __aeabi_memclr ; 0x8000194
;;;715      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x08001568:    2120         !      MOVS     r1,#0x20
        0x0800156a:    a806        ..      ADD      r0,sp,#0x18
        0x0800156c:    f7fefe12    ....    BL       __aeabi_memclr ; 0x8000194
;;;716    
;;;717      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x08001570:    2114        .!      MOVS     r1,#0x14
        0x08001572:    a801        ..      ADD      r0,sp,#4
        0x08001574:    f7fefe0e    ....    BL       __aeabi_memclr ; 0x8000194
;;;718    
;;;719      /* Peripheral clock enable */
;;;720      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM3);
        0x08001578:    2002        .       MOVS     r0,#2
        0x0800157a:    f7fff957    ..W.    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;721    
;;;722      /* TIM3 interrupt Init */
;;;723      NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x0800157e:    f000fa4d    ..M.    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x08001582:    4605        .F      MOV      r5,r0
        0x08001584:    2200        ."      MOVS     r2,#0
        0x08001586:    4611        .F      MOV      r1,r2
        0x08001588:    f000fa27    ..'.    BL       NVIC_EncodePriority ; 0x80019da
        0x0800158c:    4604        .F      MOV      r4,r0
        0x0800158e:    4621        !F      MOV      r1,r4
        0x08001590:    201d        .       MOVS     r0,#0x1d
        0x08001592:    f000fa4b    ..K.    BL       NVIC_SetPriority ; 0x8001a2c
;;;724      NVIC_EnableIRQ(TIM3_IRQn);
        0x08001596:    201d        .       MOVS     r0,#0x1d
        0x08001598:    f000fa14    ....    BL       NVIC_EnableIRQ ; 0x80019c4
;;;725    
;;;726      /* USER CODE BEGIN TIM3_Init 1 */
;;;727      NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),1, 0));
        0x0800159c:    f000fa3e    ..>.    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x080015a0:    4605        .F      MOV      r5,r0
        0x080015a2:    2200        ."      MOVS     r2,#0
        0x080015a4:    2101        .!      MOVS     r1,#1
        0x080015a6:    f000fa18    ....    BL       NVIC_EncodePriority ; 0x80019da
        0x080015aa:    4604        .F      MOV      r4,r0
        0x080015ac:    4621        !F      MOV      r1,r4
        0x080015ae:    201d        .       MOVS     r0,#0x1d
        0x080015b0:    f000fa3c    ..<.    BL       NVIC_SetPriority ; 0x8001a2c
;;;728      NVIC_EnableIRQ(TIM3_IRQn);
        0x080015b4:    201d        .       MOVS     r0,#0x1d
        0x080015b6:    f000fa05    ....    BL       NVIC_EnableIRQ ; 0x80019c4
;;;729    
;;;730      /* USER CODE END TIM3_Init 1 */
;;;731      TIM_InitStruct.Prescaler = 0;
        0x080015ba:    2000        .       MOVS     r0,#0
        0x080015bc:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;732      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x080015c0:    900f        ..      STR      r0,[sp,#0x3c]
;;;733      TIM_InitStruct.Autoreload = min_pulse;
        0x080015c2:    f24020d5    @..     MOV      r0,#0x2d5
        0x080015c6:    9010        ..      STR      r0,[sp,#0x40]
;;;734      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x080015c8:    2000        .       MOVS     r0,#0
        0x080015ca:    9011        ..      STR      r0,[sp,#0x44]
;;;735      LL_TIM_Init(TIM3, &TIM_InitStruct);
        0x080015cc:    a90e        ..      ADD      r1,sp,#0x38
        0x080015ce:    4842        BH      LDR      r0,[pc,#264] ; [0x80016d8] = 0x40000400
        0x080015d0:    f7fffc30    ..0.    BL       LL_TIM_Init ; 0x8000e34
;;;736      LL_TIM_EnableARRPreload(TIM3);
        0x080015d4:    4840        @H      LDR      r0,[pc,#256] ; [0x80016d8] = 0x40000400
        0x080015d6:    f7fffb4a    ..J.    BL       LL_TIM_EnableARRPreload ; 0x8000c6e
;;;737      LL_TIM_SetClockSource(TIM3, LL_TIM_CLOCKSOURCE_INTERNAL);
        0x080015da:    2100        .!      MOVS     r1,#0
        0x080015dc:    483e        >H      LDR      r0,[pc,#248] ; [0x80016d8] = 0x40000400
        0x080015de:    f7fffd01    ....    BL       LL_TIM_SetClockSource ; 0x8000fe4
;;;738      LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH1);
        0x080015e2:    2101        .!      MOVS     r1,#1
        0x080015e4:    483c        <H      LDR      r0,[pc,#240] ; [0x80016d8] = 0x40000400
        0x080015e6:    f7fffc9d    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;739      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x080015ea:    2070        p       MOVS     r0,#0x70
        0x080015ec:    9006        ..      STR      r0,[sp,#0x18]
;;;740      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x080015ee:    2000        .       MOVS     r0,#0
        0x080015f0:    9007        ..      STR      r0,[sp,#0x1c]
;;;741      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x080015f2:    9008        ..      STR      r0,[sp,#0x20]
;;;742      TIM_OC_InitStruct.CompareValue = 1;
        0x080015f4:    2001        .       MOVS     r0,#1
        0x080015f6:    9009        ..      STR      r0,[sp,#0x24]
;;;743      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x080015f8:    2000        .       MOVS     r0,#0
        0x080015fa:    900a        ..      STR      r0,[sp,#0x28]
;;;744      LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x080015fc:    aa06        ..      ADD      r2,sp,#0x18
        0x080015fe:    2101        .!      MOVS     r1,#1
        0x08001600:    4835        5H      LDR      r0,[pc,#212] ; [0x80016d8] = 0x40000400
        0x08001602:    f7fffcbf    ....    BL       LL_TIM_OC_Init ; 0x8000f84
;;;745      LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH1);
        0x08001606:    2101        .!      MOVS     r1,#1
        0x08001608:    4833        3H      LDR      r0,[pc,#204] ; [0x80016d8] = 0x40000400
        0x0800160a:    f7fffc5b    ..[.    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;746      LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH3);
        0x0800160e:    f44f7180    O..q    MOV      r1,#0x100
        0x08001612:    4831        1H      LDR      r0,[pc,#196] ; [0x80016d8] = 0x40000400
        0x08001614:    f7fffc86    ....    BL       LL_TIM_OC_EnablePreload ; 0x8000f24
;;;747      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08001618:    2000        .       MOVS     r0,#0
        0x0800161a:    9007        ..      STR      r0,[sp,#0x1c]
;;;748      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x0800161c:    9008        ..      STR      r0,[sp,#0x20]
;;;749      LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
        0x0800161e:    aa06        ..      ADD      r2,sp,#0x18
        0x08001620:    f44f7180    O..q    MOV      r1,#0x100
        0x08001624:    482c        ,H      LDR      r0,[pc,#176] ; [0x80016d8] = 0x40000400
        0x08001626:    f7fffcad    ....    BL       LL_TIM_OC_Init ; 0x8000f84
;;;750      LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH3);
        0x0800162a:    f44f7180    O..q    MOV      r1,#0x100
        0x0800162e:    482a        *H      LDR      r0,[pc,#168] ; [0x80016d8] = 0x40000400
        0x08001630:    f7fffc48    ..H.    BL       LL_TIM_OC_DisableFast ; 0x8000ec4
;;;751      LL_TIM_SetOnePulseMode(TIM3, LL_TIM_ONEPULSEMODE_SINGLE);
        0x08001634:    2008        .       MOVS     r0,#8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1130     MODIFY_REG(TIMx->CR1, TIM_CR1_OPM, OnePulseMode);
        0x08001636:    4928        (I      LDR      r1,[pc,#160] ; [0x80016d8] = 0x40000400
        0x08001638:    6809        .h      LDR      r1,[r1,#0]
        0x0800163a:    f0210108    !...    BIC      r1,r1,#8
        0x0800163e:    4301        .C      ORRS     r1,r1,r0
        0x08001640:    4a25        %J      LDR      r2,[pc,#148] ; [0x80016d8] = 0x40000400
        0x08001642:    6011        .`      STR      r1,[r2,#0]
;;;1131   }
        0x08001644:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;752      LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1);
        0x08001646:    2010        .       MOVS     r0,#0x10
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x08001648:    4611        .F      MOV      r1,r2
        0x0800164a:    6889        .h      LDR      r1,[r1,#8]
        0x0800164c:    f0210170    !.p.    BIC      r1,r1,#0x70
        0x08001650:    4301        .C      ORRS     r1,r1,r0
        0x08001652:    6091        .`      STR      r1,[r2,#8]
;;;2619   }
        0x08001654:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;753      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
        0x08001656:    2006        .       MOVS     r0,#6
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
        0x08001658:    4611        .F      MOV      r1,r2
        0x0800165a:    6889        .h      LDR      r1,[r1,#8]
        0x0800165c:    f0210107    !...    BIC      r1,r1,#7
        0x08001660:    4301        .C      ORRS     r1,r1,r0
        0x08001662:    6091        .`      STR      r1,[r2,#8]
;;;2597   }
        0x08001664:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;754      LL_TIM_DisableIT_TRIG(TIM3);
        0x08001666:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3412     CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
        0x08001668:    4610        .F      MOV      r0,r2
        0x0800166a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800166c:    f0200040     .@.    BIC      r0,r0,#0x40
        0x08001670:    4611        .F      MOV      r1,r2
        0x08001672:    60c8        .`      STR      r0,[r1,#0xc]
;;;3413   }
        0x08001674:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;755      LL_TIM_DisableDMAReq_TRIG(TIM3);
        0x08001676:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3683     CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
        0x08001678:    4608        .F      MOV      r0,r1
        0x0800167a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800167c:    f4204080     ..@    BIC      r0,r0,#0x4000
        0x08001680:    60c8        .`      STR      r0,[r1,#0xc]
;;;3684   }
        0x08001682:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;756      LL_TIM_SetTriggerOutput(TIM3, LL_TIM_TRGO_RESET);
        0x08001684:    2100        .!      MOVS     r1,#0
        0x08001686:    4610        .F      MOV      r0,r2
        0x08001688:    f7fffcb3    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;757      LL_TIM_DisableMasterSlaveMode(TIM3);
        0x0800168c:    4812        .H      LDR      r0,[pc,#72] ; [0x80016d8] = 0x40000400
        0x0800168e:    f7fffae9    ....    BL       LL_TIM_DisableMasterSlaveMode ; 0x8000c64
;;;758      /* USER CODE BEGIN TIM3_Init 2 */
;;;759    
;;;760      /* USER CODE END TIM3_Init 2 */
;;;761      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08001692:    2004        .       MOVS     r0,#4
        0x08001694:    f7fff8d8    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;762      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x08001698:    2008        .       MOVS     r0,#8
        0x0800169a:    f7fff8d5    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;763      /**TIM3 GPIO Configuration  
;;;764      PA6   ------> TIM3_CH1
;;;765      PB0   ------> TIM3_CH3 
;;;766      */
;;;767      GPIO_InitStruct.Pin = MOTOR_X_STEP_Pin;
        0x0800169e:    f2440040    D.@.    MOV      r0,#0x4040
        0x080016a2:    9001        ..      STR      r0,[sp,#4]
;;;768      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080016a4:    2009        .       MOVS     r0,#9
        0x080016a6:    9002        ..      STR      r0,[sp,#8]
;;;769      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080016a8:    2003        .       MOVS     r0,#3
        0x080016aa:    9003        ..      STR      r0,[sp,#0xc]
;;;770      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080016ac:    2000        .       MOVS     r0,#0
        0x080016ae:    9004        ..      STR      r0,[sp,#0x10]
;;;771      LL_GPIO_Init(MOTOR_X_STEP_GPIO_Port, &GPIO_InitStruct);
        0x080016b0:    a901        ..      ADD      r1,sp,#4
        0x080016b2:    480a        .H      LDR      r0,[pc,#40] ; [0x80016dc] = 0x40010800
        0x080016b4:    f7fff946    ..F.    BL       LL_GPIO_Init ; 0x8000944
;;;772    
;;;773      GPIO_InitStruct.Pin = MOTOR_Z_STEP_Pin;
        0x080016b8:    f2401001    @...    MOV      r0,#0x101
        0x080016bc:    9001        ..      STR      r0,[sp,#4]
;;;774      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x080016be:    2009        .       MOVS     r0,#9
        0x080016c0:    9002        ..      STR      r0,[sp,#8]
;;;775      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x080016c2:    2003        .       MOVS     r0,#3
        0x080016c4:    9003        ..      STR      r0,[sp,#0xc]
;;;776      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x080016c6:    2000        .       MOVS     r0,#0
        0x080016c8:    9004        ..      STR      r0,[sp,#0x10]
;;;777      LL_GPIO_Init(MOTOR_Z_STEP_GPIO_Port, &GPIO_InitStruct);
        0x080016ca:    a901        ..      ADD      r1,sp,#4
        0x080016cc:    4804        .H      LDR      r0,[pc,#16] ; [0x80016e0] = 0x40010c00
        0x080016ce:    f7fff939    ..9.    BL       LL_GPIO_Init ; 0x8000944
;;;778    
;;;779    }
        0x080016d2:    b013        ..      ADD      sp,sp,#0x4c
        0x080016d4:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080016d6:    0000        ..      DCW    0
        0x080016d8:    40000400    ...@    DCD    1073742848
        0x080016dc:    40010800    ...@    DCD    1073809408
        0x080016e0:    40010c00    ...@    DCD    1073810432
    $t
    i.MX_TIM4_Init
    MX_TIM4_Init
;;;780    
;;;781    /**
;;;782      * @brief TIM4 Initialization Function
;;;783      * @param None
;;;784      * @retval None
;;;785      */
;;;786    static void MX_TIM4_Init(void)
;;;787    {
        0x080016e4:    b530        0.      PUSH     {r4,r5,lr}
        0x080016e6:    b08b        ..      SUB      sp,sp,#0x2c
;;;788    
;;;789      /* USER CODE BEGIN TIM4_Init 0 */
;;;790    
;;;791      /* USER CODE END TIM4_Init 0 */
;;;792    
;;;793      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x080016e8:    2114        .!      MOVS     r1,#0x14
        0x080016ea:    a806        ..      ADD      r0,sp,#0x18
        0x080016ec:    f7fefd52    ..R.    BL       __aeabi_memclr ; 0x8000194
;;;794    
;;;795      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080016f0:    2114        .!      MOVS     r1,#0x14
        0x080016f2:    a801        ..      ADD      r0,sp,#4
        0x080016f4:    f7fefd4e    ..N.    BL       __aeabi_memclr ; 0x8000194
;;;796    
;;;797      /* Peripheral clock enable */
;;;798      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM4);
        0x080016f8:    2004        .       MOVS     r0,#4
        0x080016fa:    f7fff897    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;799      
;;;800      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080016fe:    2008        .       MOVS     r0,#8
        0x08001700:    f7fff8a2    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;801      /**TIM4 GPIO Configuration  
;;;802      PB6   ------> TIM4_CH1
;;;803      PB7   ------> TIM4_CH2
;;;804      PB8   ------> TIM4_CH3 
;;;805      */
;;;806      GPIO_InitStruct.Pin = ENC_A_Pin|ENC_B_Pin|ENC_ZERO_Pin;
        0x08001704:    483e        >H      LDR      r0,[pc,#248] ; [0x8001800] = 0x401c0c1
        0x08001706:    9001        ..      STR      r0,[sp,#4]
;;;807      GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x08001708:    2008        .       MOVS     r0,#8
        0x0800170a:    9002        ..      STR      r0,[sp,#8]
;;;808      GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x0800170c:    2001        .       MOVS     r0,#1
        0x0800170e:    9005        ..      STR      r0,[sp,#0x14]
;;;809      LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08001710:    a901        ..      ADD      r1,sp,#4
        0x08001712:    483c        <H      LDR      r0,[pc,#240] ; [0x8001804] = 0x40010c00
        0x08001714:    f7fff916    ....    BL       LL_GPIO_Init ; 0x8000944
;;;810    
;;;811      /* TIM4 interrupt Init */
;;;812      NVIC_SetPriority(TIM4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08001718:    f000f980    ....    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x0800171c:    4605        .F      MOV      r5,r0
        0x0800171e:    2200        ."      MOVS     r2,#0
        0x08001720:    4611        .F      MOV      r1,r2
        0x08001722:    f000f95a    ..Z.    BL       NVIC_EncodePriority ; 0x80019da
        0x08001726:    4604        .F      MOV      r4,r0
        0x08001728:    4621        !F      MOV      r1,r4
        0x0800172a:    201e        .       MOVS     r0,#0x1e
        0x0800172c:    f000f97e    ..~.    BL       NVIC_SetPriority ; 0x8001a2c
;;;813      NVIC_EnableIRQ(TIM4_IRQn);
        0x08001730:    201e        .       MOVS     r0,#0x1e
        0x08001732:    f000f947    ..G.    BL       NVIC_EnableIRQ ; 0x80019c4
;;;814    
;;;815      /* USER CODE BEGIN TIM4_Init 1 */
;;;816    
;;;817      /* USER CODE END TIM4_Init 1 */
;;;818      TIM_InitStruct.Prescaler = 0;
        0x08001736:    2000        .       MOVS     r0,#0
        0x08001738:    f8ad0018    ....    STRH     r0,[sp,#0x18]
;;;819      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x0800173c:    9007        ..      STR      r0,[sp,#0x1c]
;;;820      TIM_InitStruct.Autoreload = 8;
        0x0800173e:    2008        .       MOVS     r0,#8
        0x08001740:    9008        ..      STR      r0,[sp,#0x20]
;;;821      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08001742:    2000        .       MOVS     r0,#0
        0x08001744:    9009        ..      STR      r0,[sp,#0x24]
;;;822      LL_TIM_Init(TIM4, &TIM_InitStruct);
        0x08001746:    a906        ..      ADD      r1,sp,#0x18
        0x08001748:    482f        /H      LDR      r0,[pc,#188] ; [0x8001808] = 0x40000800
        0x0800174a:    f7fffb73    ..s.    BL       LL_TIM_Init ; 0x8000e34
;;;823      LL_TIM_DisableARRPreload(TIM4);
        0x0800174e:    482e        .H      LDR      r0,[pc,#184] ; [0x8001808] = 0x40000800
        0x08001750:    f7fffa83    ....    BL       LL_TIM_DisableARRPreload ; 0x8000c5a
;;;824      LL_TIM_SetEncoderMode(TIM4, LL_TIM_ENCODERMODE_X2_TI1);
        0x08001754:    2001        .       MOVS     r0,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
        0x08001756:    492c        ,I      LDR      r1,[pc,#176] ; [0x8001808] = 0x40000800
        0x08001758:    6889        .h      LDR      r1,[r1,#8]
        0x0800175a:    f0210107    !...    BIC      r1,r1,#7
        0x0800175e:    4301        .C      ORRS     r1,r1,r0
        0x08001760:    4a29        )J      LDR      r2,[pc,#164] ; [0x8001808] = 0x40000800
        0x08001762:    6091        .`      STR      r1,[r2,#8]
;;;2550   }
        0x08001764:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;825      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08001766:    0402        ..      LSLS     r2,r0,#16
        0x08001768:    2101        .!      MOVS     r1,#1
        0x0800176a:    4827        'H      LDR      r0,[pc,#156] ; [0x8001808] = 0x40000800
        0x0800176c:    f7fffa94    ....    BL       LL_TIM_IC_SetActiveInput ; 0x8000c98
;;;826      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ICPSC_DIV1);
        0x08001770:    2200        ."      MOVS     r2,#0
        0x08001772:    2101        .!      MOVS     r1,#1
        0x08001774:    4824        $H      LDR      r0,[pc,#144] ; [0x8001808] = 0x40000800
        0x08001776:    f7fffb27    ..'.    BL       LL_TIM_IC_SetPrescaler ; 0x8000dc8
;;;827      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_FILTER_FDIV32_N8);
        0x0800177a:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x0800177e:    2101        .!      MOVS     r1,#1
        0x08001780:    4821        !H      LDR      r0,[pc,#132] ; [0x8001808] = 0x40000800
        0x08001782:    f7fffabf    ....    BL       LL_TIM_IC_SetFilter ; 0x8000d04
;;;828      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_POLARITY_RISING);
        0x08001786:    2200        ."      MOVS     r2,#0
        0x08001788:    2101        .!      MOVS     r1,#1
        0x0800178a:    481f        .H      LDR      r0,[pc,#124] ; [0x8001808] = 0x40000800
        0x0800178c:    f7fffaf0    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000d70
;;;829      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08001790:    f44f3280    O..2    MOV      r2,#0x10000
        0x08001794:    2110        .!      MOVS     r1,#0x10
        0x08001796:    481c        .H      LDR      r0,[pc,#112] ; [0x8001808] = 0x40000800
        0x08001798:    f7fffa7e    ..~.    BL       LL_TIM_IC_SetActiveInput ; 0x8000c98
;;;830      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ICPSC_DIV1);
        0x0800179c:    2200        ."      MOVS     r2,#0
        0x0800179e:    2110        .!      MOVS     r1,#0x10
        0x080017a0:    4819        .H      LDR      r0,[pc,#100] ; [0x8001808] = 0x40000800
        0x080017a2:    f7fffb11    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000dc8
;;;831      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_FILTER_FDIV32_N8);
        0x080017a6:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x080017aa:    2110        .!      MOVS     r1,#0x10
        0x080017ac:    4816        .H      LDR      r0,[pc,#88] ; [0x8001808] = 0x40000800
        0x080017ae:    f7fffaa9    ....    BL       LL_TIM_IC_SetFilter ; 0x8000d04
;;;832      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_POLARITY_RISING);
        0x080017b2:    2200        ."      MOVS     r2,#0
        0x080017b4:    2110        .!      MOVS     r1,#0x10
        0x080017b6:    4814        .H      LDR      r0,[pc,#80] ; [0x8001808] = 0x40000800
        0x080017b8:    f7fffada    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000d70
;;;833      LL_TIM_SetTriggerOutput(TIM4, LL_TIM_TRGO_UPDATE);
        0x080017bc:    2120         !      MOVS     r1,#0x20
        0x080017be:    4812        .H      LDR      r0,[pc,#72] ; [0x8001808] = 0x40000800
        0x080017c0:    f7fffc17    ....    BL       LL_TIM_SetTriggerOutput ; 0x8000ff2
;;;834      LL_TIM_EnableMasterSlaveMode(TIM4);
        0x080017c4:    4810        .H      LDR      r0,[pc,#64] ; [0x8001808] = 0x40000800
        0x080017c6:    f7fffa5c    ..\.    BL       LL_TIM_EnableMasterSlaveMode ; 0x8000c82
;;;835      LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x080017ca:    f44f3280    O..2    MOV      r2,#0x10000
        0x080017ce:    1211        ..      ASRS     r1,r2,#8
        0x080017d0:    480d        .H      LDR      r0,[pc,#52] ; [0x8001808] = 0x40000800
        0x080017d2:    f7fffa61    ..a.    BL       LL_TIM_IC_SetActiveInput ; 0x8000c98
;;;836      LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ICPSC_DIV1);
        0x080017d6:    2200        ."      MOVS     r2,#0
        0x080017d8:    f44f7180    O..q    MOV      r1,#0x100
        0x080017dc:    480a        .H      LDR      r0,[pc,#40] ; [0x8001808] = 0x40000800
        0x080017de:    f7fffaf3    ....    BL       LL_TIM_IC_SetPrescaler ; 0x8000dc8
;;;837      LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_FILTER_FDIV32_N8);
        0x080017e2:    f44f0270    O.p.    MOV      r2,#0xf00000
        0x080017e6:    f44f7180    O..q    MOV      r1,#0x100
        0x080017ea:    4807        .H      LDR      r0,[pc,#28] ; [0x8001808] = 0x40000800
        0x080017ec:    f7fffa8a    ....    BL       LL_TIM_IC_SetFilter ; 0x8000d04
;;;838      LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_POLARITY_RISING);
        0x080017f0:    2200        ."      MOVS     r2,#0
        0x080017f2:    f44f7180    O..q    MOV      r1,#0x100
        0x080017f6:    4804        .H      LDR      r0,[pc,#16] ; [0x8001808] = 0x40000800
        0x080017f8:    f7fffaba    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000d70
;;;839      /* USER CODE BEGIN TIM4_Init 2 */
;;;840    
;;;841      /* USER CODE END TIM4_Init 2 */
;;;842    
;;;843    }
        0x080017fc:    b00b        ..      ADD      sp,sp,#0x2c
        0x080017fe:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001800:    0401c0c1    ....    DCD    67223745
        0x08001804:    40010c00    ...@    DCD    1073810432
        0x08001808:    40000800    ...@    DCD    1073743872
    $t
    i.MX_USART2_UART_Init
    MX_USART2_UART_Init
;;;844    
;;;845    /**
;;;846      * @brief USART2 Initialization Function
;;;847      * @param None
;;;848      * @retval None
;;;849      */
;;;850    static void MX_USART2_UART_Init(void)
;;;851    {
        0x0800180c:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0800180e:    b08b        ..      SUB      sp,sp,#0x2c
;;;852    
;;;853      /* USER CODE BEGIN USART2_Init 0 */
;;;854      pBufferReadyForReception = aRXBufferA;
        0x08001810:    4860        `H      LDR      r0,[pc,#384] ; [0x8001994] = 0x200007ac
        0x08001812:    4961        aI      LDR      r1,[pc,#388] ; [0x8001998] = 0x200004e8
        0x08001814:    6008        .`      STR      r0,[r1,#0]
;;;855      pBufferReadyForUser      = aRXBufferB;
        0x08001816:    4861        aH      LDR      r0,[pc,#388] ; [0x800199c] = 0x200007b8
        0x08001818:    4961        aI      LDR      r1,[pc,#388] ; [0x80019a0] = 0x200004e4
        0x0800181a:    6008        .`      STR      r0,[r1,#0]
;;;856      uwNbReceivedChars = 0;
        0x0800181c:    2000        .       MOVS     r0,#0
        0x0800181e:    4961        aI      LDR      r1,[pc,#388] ; [0x80019a4] = 0x200004dc
        0x08001820:    6008        .`      STR      r0,[r1,#0]
;;;857      ubUART2ReceptionComplete = 0;
        0x08001822:    4961        aI      LDR      r1,[pc,#388] ; [0x80019a8] = 0x200004ec
        0x08001824:    7008        .p      STRB     r0,[r1,#0]
;;;858      /* USER CODE END USART2_Init 0 */
;;;859    
;;;860      LL_USART_InitTypeDef USART_InitStruct = {0};
        0x08001826:    2118        .!      MOVS     r1,#0x18
        0x08001828:    a805        ..      ADD      r0,sp,#0x14
        0x0800182a:    f7fefcb3    ....    BL       __aeabi_memclr ; 0x8000194
;;;861    
;;;862      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x0800182e:    2114        .!      MOVS     r1,#0x14
        0x08001830:    4668        hF      MOV      r0,sp
        0x08001832:    f7fefcaf    ....    BL       __aeabi_memclr ; 0x8000194
;;;863    
;;;864      /* Peripheral clock enable */
;;;865      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);
        0x08001836:    f44f3000    O..0    MOV      r0,#0x20000
        0x0800183a:    f7fefff7    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;866      
;;;867      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x0800183e:    2004        .       MOVS     r0,#4
        0x08001840:    f7fff802    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;868      /**USART2 GPIO Configuration  
;;;869      PA2   ------> USART2_TX
;;;870      PA3   ------> USART2_RX 
;;;871      */
;;;872      GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
        0x08001844:    f2404004    @..@    MOV      r0,#0x404
        0x08001848:    9000        ..      STR      r0,[sp,#0]
;;;873      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x0800184a:    2009        .       MOVS     r0,#9
        0x0800184c:    9001        ..      STR      r0,[sp,#4]
;;;874      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x0800184e:    2003        .       MOVS     r0,#3
        0x08001850:    9002        ..      STR      r0,[sp,#8]
;;;875      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08001852:    2000        .       MOVS     r0,#0
        0x08001854:    9003        ..      STR      r0,[sp,#0xc]
;;;876      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001856:    4669        iF      MOV      r1,sp
        0x08001858:    4854        TH      LDR      r0,[pc,#336] ; [0x80019ac] = 0x40010800
        0x0800185a:    f7fff873    ..s.    BL       LL_GPIO_Init ; 0x8000944
;;;877    
;;;878      GPIO_InitStruct.Pin = LL_GPIO_PIN_3;
        0x0800185e:    f6400008    @...    MOV      r0,#0x808
        0x08001862:    9000        ..      STR      r0,[sp,#0]
;;;879      GPIO_InitStruct.Mode = LL_GPIO_MODE_FLOATING;
        0x08001864:    2004        .       MOVS     r0,#4
        0x08001866:    9001        ..      STR      r0,[sp,#4]
;;;880      LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08001868:    4669        iF      MOV      r1,sp
        0x0800186a:    4850        PH      LDR      r0,[pc,#320] ; [0x80019ac] = 0x40010800
        0x0800186c:    f7fff86a    ..j.    BL       LL_GPIO_Init ; 0x8000944
;;;881    
;;;882      /* USART2 DMA Init */
;;;883      
;;;884      /* USART2_TX Init */
;;;885      LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_7, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);
        0x08001870:    2210        ."      MOVS     r2,#0x10
        0x08001872:    2107        .!      MOVS     r1,#7
        0x08001874:    484e        NH      LDR      r0,[pc,#312] ; [0x80019b0] = 0x40020000
        0x08001876:    f7fff805    ....    BL       LL_DMA_SetDataTransferDirection ; 0x8000884
;;;886    
;;;887      LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_7, LL_DMA_PRIORITY_LOW);
        0x0800187a:    2200        ."      MOVS     r2,#0
        0x0800187c:    2107        .!      MOVS     r1,#7
        0x0800187e:    484c        LH      LDR      r0,[pc,#304] ; [0x80019b0] = 0x40020000
        0x08001880:    f7fefff0    ....    BL       LL_DMA_SetChannelPriorityLevel ; 0x8000864
;;;888    
;;;889      LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_7, LL_DMA_MODE_NORMAL);
        0x08001884:    2200        ."      MOVS     r2,#0
        0x08001886:    2107        .!      MOVS     r1,#7
        0x08001888:    4849        IH      LDR      r0,[pc,#292] ; [0x80019b0] = 0x40020000
        0x0800188a:    f7fff82b    ..+.    BL       LL_DMA_SetMode ; 0x80008e4
;;;890    
;;;891      LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_7, LL_DMA_PERIPH_NOINCREMENT);
        0x0800188e:    2200        ."      MOVS     r2,#0
        0x08001890:    2107        .!      MOVS     r1,#7
        0x08001892:    4847        GH      LDR      r0,[pc,#284] ; [0x80019b0] = 0x40020000
        0x08001894:    f7fff836    ..6.    BL       LL_DMA_SetPeriphIncMode ; 0x8000904
;;;892    
;;;893      LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_7, LL_DMA_MEMORY_INCREMENT);
        0x08001898:    2280        ."      MOVS     r2,#0x80
        0x0800189a:    2107        .!      MOVS     r1,#7
        0x0800189c:    4844        DH      LDR      r0,[pc,#272] ; [0x80019b0] = 0x40020000
        0x0800189e:    f7fff801    ....    BL       LL_DMA_SetMemoryIncMode ; 0x80008a4
;;;894    
;;;895      LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_7, LL_DMA_PDATAALIGN_BYTE);
        0x080018a2:    2200        ."      MOVS     r2,#0
        0x080018a4:    2107        .!      MOVS     r1,#7
        0x080018a6:    4842        BH      LDR      r0,[pc,#264] ; [0x80019b0] = 0x40020000
        0x080018a8:    f7fff83c    ..<.    BL       LL_DMA_SetPeriphSize ; 0x8000924
;;;896    
;;;897      LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_7, LL_DMA_MDATAALIGN_BYTE);
        0x080018ac:    2200        ."      MOVS     r2,#0
        0x080018ae:    2107        .!      MOVS     r1,#7
        0x080018b0:    483f        ?H      LDR      r0,[pc,#252] ; [0x80019b0] = 0x40020000
        0x080018b2:    f7fff807    ....    BL       LL_DMA_SetMemorySize ; 0x80008c4
;;;898    
;;;899      /* USART2 interrupt Init */
;;;900      NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x080018b6:    f000f8b1    ....    BL       NVIC_GetPriorityGrouping ; 0x8001a1c
        0x080018ba:    4605        .F      MOV      r5,r0
        0x080018bc:    2200        ."      MOVS     r2,#0
        0x080018be:    2102        .!      MOVS     r1,#2
        0x080018c0:    f000f88b    ....    BL       NVIC_EncodePriority ; 0x80019da
        0x080018c4:    4604        .F      MOV      r4,r0
        0x080018c6:    4621        !F      MOV      r1,r4
        0x080018c8:    2026        &       MOVS     r0,#0x26
        0x080018ca:    f000f8af    ....    BL       NVIC_SetPriority ; 0x8001a2c
;;;901      NVIC_EnableIRQ(USART2_IRQn);
        0x080018ce:    2026        &       MOVS     r0,#0x26
        0x080018d0:    f000f878    ..x.    BL       NVIC_EnableIRQ ; 0x80019c4
;;;902    
;;;903      /* USER CODE BEGIN USART2_Init 1 */
;;;904    
;;;905      LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_7,
        0x080018d4:    4836        6H      LDR      r0,[pc,#216] ; [0x80019b0] = 0x40020000
        0x080018d6:    2107        .!      MOVS     r1,#7
        0x080018d8:    4a36        6J      LDR      r2,[pc,#216] ; [0x80019b4] = 0x8003220
        0x080018da:    4d37        7M      LDR      r5,[pc,#220] ; [0x80019b8] = 0x40004400
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2451     return ((uint32_t) &(USARTx->DR));
        0x080018dc:    1d2b        +.      ADDS     r3,r5,#4
        0x080018de:    4605        .F      MOV      r5,r0
        0x080018e0:    2607        .&      MOVS     r6,#7
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;595      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
        0x080018e2:    1e77        w.      SUBS     r7,r6,#1
        0x080018e4:    f8dfc0d4    ....    LDR      r12,[pc,#212] ; [0x80019bc] = 0x80031e8
        0x080018e8:    f81c7007    ...p    LDRB     r7,[r12,r7]
        0x080018ec:    59ef        .Y      LDR      r7,[r5,r7]
        0x080018ee:    f2440c10    D...    MOV      r12,#0x4010
        0x080018f2:    ea07040c    ....    AND      r4,r7,r12
        0x080018f6:    bf00        ..      NOP      
;;;596                       DMA_CCR_DIR | DMA_CCR_MEM2MEM));
;;;597    }
;;;598    
;;;599    /**
;;;600      * @brief  Set DMA mode circular or normal.
;;;601      * @note The circular buffer mode cannot be used if the memory-to-memory
;;;602      * data transfer is configured on the selected Channel.
;;;603      * @rmtoll CCR          CIRC          LL_DMA_SetMode
;;;604      * @param  DMAx DMAx Instance
;;;605      * @param  Channel This parameter can be one of the following values:
;;;606      *         @arg @ref LL_DMA_CHANNEL_1
;;;607      *         @arg @ref LL_DMA_CHANNEL_2
;;;608      *         @arg @ref LL_DMA_CHANNEL_3
;;;609      *         @arg @ref LL_DMA_CHANNEL_4
;;;610      *         @arg @ref LL_DMA_CHANNEL_5
;;;611      *         @arg @ref LL_DMA_CHANNEL_6
;;;612      *         @arg @ref LL_DMA_CHANNEL_7
;;;613      * @param  Mode This parameter can be one of the following values:
;;;614      *         @arg @ref LL_DMA_MODE_NORMAL
;;;615      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;616      * @retval None
;;;617      */
;;;618    __STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
;;;619    {
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
;;;621                 Mode);
;;;622    }
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
;;;759    
;;;760    /**
;;;761      * @brief  Get Peripheral size.
;;;762      * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
;;;763      * @param  DMAx DMAx Instance
;;;764      * @param  Channel This parameter can be one of the following values:
;;;765      *         @arg @ref LL_DMA_CHANNEL_1
;;;766      *         @arg @ref LL_DMA_CHANNEL_2
;;;767      *         @arg @ref LL_DMA_CHANNEL_3
;;;768      *         @arg @ref LL_DMA_CHANNEL_4
;;;769      *         @arg @ref LL_DMA_CHANNEL_5
;;;770      *         @arg @ref LL_DMA_CHANNEL_6
;;;771      *         @arg @ref LL_DMA_CHANNEL_7
;;;772      * @retval Returned value can be one of the following values:
;;;773      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;774      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;775      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;776      */
;;;777    __STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;778    {
;;;779      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;780                       DMA_CCR_PSIZE));
;;;781    }
;;;782    
;;;783    /**
;;;784      * @brief  Set Memory size.
;;;785      * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
;;;786      * @param  DMAx DMAx Instance
;;;787      * @param  Channel This parameter can be one of the following values:
;;;788      *         @arg @ref LL_DMA_CHANNEL_1
;;;789      *         @arg @ref LL_DMA_CHANNEL_2
;;;790      *         @arg @ref LL_DMA_CHANNEL_3
;;;791      *         @arg @ref LL_DMA_CHANNEL_4
;;;792      *         @arg @ref LL_DMA_CHANNEL_5
;;;793      *         @arg @ref LL_DMA_CHANNEL_6
;;;794      *         @arg @ref LL_DMA_CHANNEL_7
;;;795      * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
;;;796      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;797      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;798      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;799      * @retval None
;;;800      */
;;;801    __STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
;;;802    {
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
;;;806    
;;;807    /**
;;;808      * @brief  Get Memory size.
;;;809      * @rmtoll CCR          MSIZE         LL_DMA_GetMemorySize
;;;810      * @param  DMAx DMAx Instance
;;;811      * @param  Channel This parameter can be one of the following values:
;;;812      *         @arg @ref LL_DMA_CHANNEL_1
;;;813      *         @arg @ref LL_DMA_CHANNEL_2
;;;814      *         @arg @ref LL_DMA_CHANNEL_3
;;;815      *         @arg @ref LL_DMA_CHANNEL_4
;;;816      *         @arg @ref LL_DMA_CHANNEL_5
;;;817      *         @arg @ref LL_DMA_CHANNEL_6
;;;818      *         @arg @ref LL_DMA_CHANNEL_7
;;;819      * @retval Returned value can be one of the following values:
;;;820      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;821      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;822      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;823      */
;;;824    __STATIC_INLINE uint32_t LL_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;825    {
;;;826      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;827                       DMA_CCR_MSIZE));
;;;828    }
;;;829    
;;;830    /**
;;;831      * @brief  Set Channel priority level.
;;;832      * @rmtoll CCR          PL            LL_DMA_SetChannelPriorityLevel
;;;833      * @param  DMAx DMAx Instance
;;;834      * @param  Channel This parameter can be one of the following values:
;;;835      *         @arg @ref LL_DMA_CHANNEL_1
;;;836      *         @arg @ref LL_DMA_CHANNEL_2
;;;837      *         @arg @ref LL_DMA_CHANNEL_3
;;;838      *         @arg @ref LL_DMA_CHANNEL_4
;;;839      *         @arg @ref LL_DMA_CHANNEL_5
;;;840      *         @arg @ref LL_DMA_CHANNEL_6
;;;841      *         @arg @ref LL_DMA_CHANNEL_7
;;;842      * @param  Priority This parameter can be one of the following values:
;;;843      *         @arg @ref LL_DMA_PRIORITY_LOW
;;;844      *         @arg @ref LL_DMA_PRIORITY_MEDIUM
;;;845      *         @arg @ref LL_DMA_PRIORITY_HIGH
;;;846      *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority)
;;;850    {
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
;;;852                 Priority);
;;;853    }
;;;854    
;;;855    /**
;;;856      * @brief  Get Channel priority level.
;;;857      * @rmtoll CCR          PL            LL_DMA_GetChannelPriorityLevel
;;;858      * @param  DMAx DMAx Instance
;;;859      * @param  Channel This parameter can be one of the following values:
;;;860      *         @arg @ref LL_DMA_CHANNEL_1
;;;861      *         @arg @ref LL_DMA_CHANNEL_2
;;;862      *         @arg @ref LL_DMA_CHANNEL_3
;;;863      *         @arg @ref LL_DMA_CHANNEL_4
;;;864      *         @arg @ref LL_DMA_CHANNEL_5
;;;865      *         @arg @ref LL_DMA_CHANNEL_6
;;;866      *         @arg @ref LL_DMA_CHANNEL_7
;;;867      * @retval Returned value can be one of the following values:
;;;868      *         @arg @ref LL_DMA_PRIORITY_LOW
;;;869      *         @arg @ref LL_DMA_PRIORITY_MEDIUM
;;;870      *         @arg @ref LL_DMA_PRIORITY_HIGH
;;;871      *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
;;;872      */
;;;873    __STATIC_INLINE uint32_t LL_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel)
;;;874    {
;;;875      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;876                       DMA_CCR_PL));
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  Set Number of data to transfer.
;;;881      * @note   This action has no effect if
;;;882      *         channel is enabled.
;;;883      * @rmtoll CNDTR        NDT           LL_DMA_SetDataLength
;;;884      * @param  DMAx DMAx Instance
;;;885      * @param  Channel This parameter can be one of the following values:
;;;886      *         @arg @ref LL_DMA_CHANNEL_1
;;;887      *         @arg @ref LL_DMA_CHANNEL_2
;;;888      *         @arg @ref LL_DMA_CHANNEL_3
;;;889      *         @arg @ref LL_DMA_CHANNEL_4
;;;890      *         @arg @ref LL_DMA_CHANNEL_5
;;;891      *         @arg @ref LL_DMA_CHANNEL_6
;;;892      *         @arg @ref LL_DMA_CHANNEL_7
;;;893      * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
;;;894      * @retval None
;;;895      */
;;;896    __STATIC_INLINE void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
;;;897    {
;;;898      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
;;;899                 DMA_CNDTR_NDT, NbData);
;;;900    }
;;;901    
;;;902    /**
;;;903      * @brief  Get Number of data to transfer.
;;;904      * @note   Once the channel is enabled, the return value indicate the
;;;905      *         remaining bytes to be transmitted.
;;;906      * @rmtoll CNDTR        NDT           LL_DMA_GetDataLength
;;;907      * @param  DMAx DMAx Instance
;;;908      * @param  Channel This parameter can be one of the following values:
;;;909      *         @arg @ref LL_DMA_CHANNEL_1
;;;910      *         @arg @ref LL_DMA_CHANNEL_2
;;;911      *         @arg @ref LL_DMA_CHANNEL_3
;;;912      *         @arg @ref LL_DMA_CHANNEL_4
;;;913      *         @arg @ref LL_DMA_CHANNEL_5
;;;914      *         @arg @ref LL_DMA_CHANNEL_6
;;;915      *         @arg @ref LL_DMA_CHANNEL_7
;;;916      * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;917      */
;;;918    __STATIC_INLINE uint32_t LL_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel)
;;;919    {
;;;920      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
;;;921                       DMA_CNDTR_NDT));
;;;922    }
;;;923    
;;;924    /**
;;;925      * @brief  Configure the Source and Destination addresses.
;;;926      * @note   This API must not be called when the DMA channel is enabled.
;;;927      * @note   Each IP using DMA provides an API to get directly the register adress (LL_PPP_DMA_GetRegAddr).
;;;928      * @rmtoll CPAR         PA            LL_DMA_ConfigAddresses\n
;;;929      *         CMAR         MA            LL_DMA_ConfigAddresses
;;;930      * @param  DMAx DMAx Instance
;;;931      * @param  Channel This parameter can be one of the following values:
;;;932      *         @arg @ref LL_DMA_CHANNEL_1
;;;933      *         @arg @ref LL_DMA_CHANNEL_2
;;;934      *         @arg @ref LL_DMA_CHANNEL_3
;;;935      *         @arg @ref LL_DMA_CHANNEL_4
;;;936      *         @arg @ref LL_DMA_CHANNEL_5
;;;937      *         @arg @ref LL_DMA_CHANNEL_6
;;;938      *         @arg @ref LL_DMA_CHANNEL_7
;;;939      * @param  SrcAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;940      * @param  DstAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;941      * @param  Direction This parameter can be one of the following values:
;;;942      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;943      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;944      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;945      * @retval None
;;;946      */
;;;947    __STATIC_INLINE void LL_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
;;;948                                                uint32_t DstAddress, uint32_t Direction)
;;;949    {
;;;950      /* Direction Memory to Periph */
;;;951      if (Direction == LL_DMA_DIRECTION_MEMORY_TO_PERIPH)
        0x080018f8:    2c10        .,      CMP      r4,#0x10
        0x080018fa:    d109        ..      BNE      0x8001910 ; MX_USART2_UART_Init + 260
;;;952      {
;;;953        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
        0x080018fc:    1e4d        M.      SUBS     r5,r1,#1
        0x080018fe:    4e2f        /N      LDR      r6,[pc,#188] ; [0x80019bc] = 0x80031e8
        0x08001900:    5d75        u]      LDRB     r5,[r6,r5]
        0x08001902:    4405        .D      ADD      r5,r5,r0
        0x08001904:    60ea        .`      STR      r2,[r5,#0xc]
;;;954        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
        0x08001906:    1e4d        M.      SUBS     r5,r1,#1
        0x08001908:    5d75        u]      LDRB     r5,[r6,r5]
        0x0800190a:    4405        .D      ADD      r5,r5,r0
        0x0800190c:    60ab        .`      STR      r3,[r5,#8]
        0x0800190e:    e008        ..      B        0x8001922 ; MX_USART2_UART_Init + 278
;;;955      }
;;;956      /* Direction Periph to Memory and Memory to Memory */
;;;957      else
;;;958      {
;;;959        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
        0x08001910:    1e4d        M.      SUBS     r5,r1,#1
        0x08001912:    4e2a        *N      LDR      r6,[pc,#168] ; [0x80019bc] = 0x80031e8
        0x08001914:    5d75        u]      LDRB     r5,[r6,r5]
        0x08001916:    4405        .D      ADD      r5,r5,r0
        0x08001918:    60aa        .`      STR      r2,[r5,#8]
;;;960        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
        0x0800191a:    1e4d        M.      SUBS     r5,r1,#1
        0x0800191c:    5d75        u]      LDRB     r5,[r6,r5]
        0x0800191e:    4405        .D      ADD      r5,r5,r0
        0x08001920:    60eb        .`      STR      r3,[r5,#0xc]
;;;961      }
;;;962    }
        0x08001922:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;909      LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_7, ubNbDataToTransmit);
        0x08001924:    4822        "H      LDR      r0,[pc,#136] ; [0x80019b0] = 0x40020000
        0x08001926:    2107        .!      MOVS     r1,#7
        0x08001928:    4b25        %K      LDR      r3,[pc,#148] ; [0x80019c0] = 0x200004ed
        0x0800192a:    781a        .x      LDRB     r2,[r3,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;898      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
        0x0800192c:    1e4b        K.      SUBS     r3,r1,#1
        0x0800192e:    4c23        #L      LDR      r4,[pc,#140] ; [0x80019bc] = 0x80031e8
        0x08001930:    5ce3        .\      LDRB     r3,[r4,r3]
        0x08001932:    4403        .D      ADD      r3,r3,r0
        0x08001934:    685b        [h      LDR      r3,[r3,#4]
        0x08001936:    f36f030f    o...    BFC      r3,#0,#16
        0x0800193a:    4313        .C      ORRS     r3,r3,r2
        0x0800193c:    1e4c        L.      SUBS     r4,r1,#1
        0x0800193e:    4d1f        .M      LDR      r5,[pc,#124] ; [0x80019bc] = 0x80031e8
        0x08001940:    5d2c        ,]      LDRB     r4,[r5,r4]
        0x08001942:    4404        .D      ADD      r4,r4,r0
        0x08001944:    6063        c`      STR      r3,[r4,#4]
;;;899                 DMA_CNDTR_NDT, NbData);
;;;900    }
        0x08001946:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;913      USART_InitStruct.BaudRate = 115200;
        0x08001948:    f44f30e1    O..0    MOV      r0,#0x1c200
        0x0800194c:    9005        ..      STR      r0,[sp,#0x14]
;;;914      USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
        0x0800194e:    2000        .       MOVS     r0,#0
        0x08001950:    9006        ..      STR      r0,[sp,#0x18]
;;;915      USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
        0x08001952:    9007        ..      STR      r0,[sp,#0x1c]
;;;916      USART_InitStruct.Parity = LL_USART_PARITY_NONE;
        0x08001954:    9008        ..      STR      r0,[sp,#0x20]
;;;917      USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
        0x08001956:    200c        .       MOVS     r0,#0xc
        0x08001958:    9009        ..      STR      r0,[sp,#0x24]
;;;918      USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
        0x0800195a:    2000        .       MOVS     r0,#0
        0x0800195c:    900a        ..      STR      r0,[sp,#0x28]
;;;919      LL_USART_Init(USART2, &USART_InitStruct);
        0x0800195e:    a905        ..      ADD      r1,sp,#0x14
        0x08001960:    4815        .H      LDR      r0,[pc,#84] ; [0x80019b8] = 0x40004400
        0x08001962:    f7fffb4d    ..M.    BL       LL_USART_Init ; 0x8001000
;;;920      LL_USART_ConfigAsyncMode(USART2);
        0x08001966:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1549     CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
        0x08001968:    4813        .H      LDR      r0,[pc,#76] ; [0x80019b8] = 0x40004400
        0x0800196a:    6900        .i      LDR      r0,[r0,#0x10]
        0x0800196c:    f4204090     ..@    BIC      r0,r0,#0x4800
        0x08001970:    4911        .I      LDR      r1,[pc,#68] ; [0x80019b8] = 0x40004400
        0x08001972:    6108        .a      STR      r0,[r1,#0x10]
;;;1550     CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
        0x08001974:    4608        .F      MOV      r0,r1
        0x08001976:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001978:    f020002a     .*.    BIC      r0,r0,#0x2a
        0x0800197c:    6148        Ha      STR      r0,[r1,#0x14]
;;;1551   }
        0x0800197e:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;921      LL_USART_Enable(USART2);
        0x08001980:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;431      SET_BIT(USARTx->CR1, USART_CR1_UE);
        0x08001982:    4608        .F      MOV      r0,r1
        0x08001984:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08001986:    f4405000    @..P    ORR      r0,r0,#0x2000
        0x0800198a:    60c8        .`      STR      r0,[r1,#0xc]
;;;432    }
        0x0800198c:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;926    }
        0x0800198e:    b00b        ..      ADD      sp,sp,#0x2c
        0x08001990:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08001992:    0000        ..      DCW    0
        0x08001994:    200007ac    ...     DCD    536872876
        0x08001998:    200004e8    ...     DCD    536872168
        0x0800199c:    200007b8    ...     DCD    536872888
        0x080019a0:    200004e4    ...     DCD    536872164
        0x080019a4:    200004dc    ...     DCD    536872156
        0x080019a8:    200004ec    ...     DCD    536872172
        0x080019ac:    40010800    ...@    DCD    1073809408
        0x080019b0:    40020000    ...@    DCD    1073872896
        0x080019b4:    08003220     2..    DCD    134230560
        0x080019b8:    40004400    .D.@    DCD    1073759232
        0x080019bc:    080031e8    .1..    DCD    134230504
        0x080019c0:    200004ed    ...     DCD    536872173
    $t
    i.NVIC_EnableIRQ
    NVIC_EnableIRQ
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x080019c4:    f000021f    ....    AND      r2,r0,#0x1f
        0x080019c8:    2101        .!      MOVS     r1,#1
        0x080019ca:    4091        .@      LSLS     r1,r1,r2
        0x080019cc:    0942        B.      LSRS     r2,r0,#5
        0x080019ce:    0092        ..      LSLS     r2,r2,#2
        0x080019d0:    f10222e0    ..."    ADD      r2,r2,#0xe000e000
        0x080019d4:    f8c21100    ....    STR      r1,[r2,#0x100]
;;;1455   }
        0x080019d8:    4770        pG      BX       lr
    i.NVIC_EncodePriority
    NVIC_EncodePriority
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
;;;1526     if ((int32_t)(IRQn) < 0)
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1533     }
;;;1534   }
;;;1535   
;;;1536   
;;;1537   /**
;;;1538     \brief   Get Interrupt Priority
;;;1539     \details Reads the priority of an interrupt.
;;;1540              The interrupt number can be positive to specify an external (device specific) interrupt,
;;;1541              or negative to specify an internal (core) interrupt.
;;;1542     \param [in]   IRQn  Interrupt number.
;;;1543     \return             Interrupt Priority.
;;;1544                         Value is aligned automatically to the implemented priority bits of the microcontroller.
;;;1545    */
;;;1546   __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
;;;1547   {
;;;1548   
;;;1549     if ((int32_t)(IRQn) < 0)
;;;1550     {
;;;1551       return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
;;;1552     }
;;;1553     else
;;;1554     {
;;;1555       return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
;;;1556     }
;;;1557   }
;;;1558   
;;;1559   
;;;1560   /**
;;;1561     \brief   Encode Priority
;;;1562     \details Encodes the priority for an interrupt with the given priority group,
;;;1563              preemptive priority value, and subpriority value.
;;;1564              In case of a conflict between priority grouping and available
;;;1565              priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
;;;1566     \param [in]     PriorityGroup  Used priority group.
;;;1567     \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
;;;1568     \param [in]       SubPriority  Subpriority value (starting from 0).
;;;1569     \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
;;;1570    */
;;;1571   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
;;;1572   {
        0x080019da:    b5f0        ..      PUSH     {r4-r7,lr}
        0x080019dc:    4603        .F      MOV      r3,r0
        0x080019de:    460c        .F      MOV      r4,r1
;;;1573     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
        0x080019e0:    f0030107    ....    AND      r1,r3,#7
;;;1574     uint32_t PreemptPriorityBits;
;;;1575     uint32_t SubPriorityBits;
;;;1576   
;;;1577     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
        0x080019e4:    f1c10007    ....    RSB      r0,r1,#7
        0x080019e8:    2804        .(      CMP      r0,#4
        0x080019ea:    d901        ..      BLS      0x80019f0 ; NVIC_EncodePriority + 22
        0x080019ec:    2004        .       MOVS     r0,#4
        0x080019ee:    e001        ..      B        0x80019f4 ; NVIC_EncodePriority + 26
        0x080019f0:    f1c10007    ....    RSB      r0,r1,#7
        0x080019f4:    4606        .F      MOV      r6,r0
;;;1578     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
        0x080019f6:    1d08        ..      ADDS     r0,r1,#4
        0x080019f8:    2807        .(      CMP      r0,#7
        0x080019fa:    d201        ..      BCS      0x8001a00 ; NVIC_EncodePriority + 38
        0x080019fc:    2000        .       MOVS     r0,#0
        0x080019fe:    e000        ..      B        0x8001a02 ; NVIC_EncodePriority + 40
        0x08001a00:    1ec8        ..      SUBS     r0,r1,#3
        0x08001a02:    4605        .F      MOV      r5,r0
;;;1579   
;;;1580     return (
        0x08001a04:    2001        .       MOVS     r0,#1
        0x08001a06:    40b0        .@      LSLS     r0,r0,r6
        0x08001a08:    1e40        @.      SUBS     r0,r0,#1
        0x08001a0a:    4020         @      ANDS     r0,r0,r4
        0x08001a0c:    40a8        .@      LSLS     r0,r0,r5
        0x08001a0e:    2701        .'      MOVS     r7,#1
        0x08001a10:    40af        .@      LSLS     r7,r7,r5
        0x08001a12:    1e7f        ..      SUBS     r7,r7,#1
        0x08001a14:    4017        .@      ANDS     r7,r7,r2
        0x08001a16:    4338        8C      ORRS     r0,r0,r7
;;;1581              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1582              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1583            );
;;;1584   }
        0x08001a18:    bdf0        ..      POP      {r4-r7,pc}
        0x08001a1a:    0000        ..      MOVS     r0,r0
    i.NVIC_GetPriorityGrouping
    NVIC_GetPriorityGrouping
;;; ../Drivers/CMSIS/Include/core_cm3.h (1443)
        0x08001a1c:    4802        .H      LDR      r0,[pc,#8] ; [0x8001a28] = 0xe000ed0c
        0x08001a1e:    6800        .h      LDR      r0,[r0,#0]
        0x08001a20:    f3c02002    ...     UBFX     r0,r0,#8,#3
;;;1444   }
        0x08001a24:    4770        pG      BX       lr
    $d
        0x08001a26:    0000        ..      DCW    0
        0x08001a28:    e000ed0c    ....    DCD    3758157068
    $t
    i.NVIC_SetPriority
    NVIC_SetPriority
;;;1445   
;;;1446   
;;;1447   /**
;;;1448     \brief   Enable External Interrupt
;;;1449     \details Enables a device-specific interrupt in the NVIC interrupt controller.
;;;1450     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
;;;1453   {
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1455   }
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
        0x08001a2c:    b510        ..      PUSH     {r4,lr}
;;;1526     if ((int32_t)(IRQn) < 0)
        0x08001a2e:    2800        .(      CMP      r0,#0
        0x08001a30:    da07        ..      BGE      0x8001a42 ; NVIC_SetPriority + 22
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x08001a32:    070a        ..      LSLS     r2,r1,#28
        0x08001a34:    0e14        ..      LSRS     r4,r2,#24
        0x08001a36:    4a05        .J      LDR      r2,[pc,#20] ; [0x8001a4c] = 0xe000ed18
        0x08001a38:    f000030f    ....    AND      r3,r0,#0xf
        0x08001a3c:    1f1b        ..      SUBS     r3,r3,#4
        0x08001a3e:    54d4        .T      STRB     r4,[r2,r3]
        0x08001a40:    e003        ..      B        0x8001a4a ; NVIC_SetPriority + 30
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x08001a42:    070a        ..      LSLS     r2,r1,#28
        0x08001a44:    0e13        ..      LSRS     r3,r2,#24
        0x08001a46:    4a02        .J      LDR      r2,[pc,#8] ; [0x8001a50] = 0xe000e400
        0x08001a48:    5413        .T      STRB     r3,[r2,r0]
;;;1533     }
;;;1534   }
        0x08001a4a:    bd10        ..      POP      {r4,pc}
    $d
        0x08001a4c:    e000ed18    ....    DCD    3758157080
        0x08001a50:    e000e400    ....    DCD    3758154752
    $t
    i.OC1Config
    OC1Config
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;766    {
        0x08001a54:    b570        p.      PUSH     {r4-r6,lr}
        0x08001a56:    4602        .F      MOV      r2,r0
;;;767      uint32_t tmpccmr1 = 0U;
        0x08001a58:    2400        .$      MOVS     r4,#0
;;;768      uint32_t tmpccer = 0U;
        0x08001a5a:    2300        .#      MOVS     r3,#0
;;;769      uint32_t tmpcr2 = 0U;
        0x08001a5c:    2500        .%      MOVS     r5,#0
;;;770    
;;;771      /* Check the parameters */
;;;772      assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;773      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;774      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;775      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;776      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;777      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;778    
;;;779      /* Disable the Channel 1: Reset the CC1E Bit */
;;;780      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
        0x08001a5e:    6a10        .j      LDR      r0,[r2,#0x20]
        0x08001a60:    f0200001     ...    BIC      r0,r0,#1
        0x08001a64:    6210        .b      STR      r0,[r2,#0x20]
;;;781    
;;;782      /* Get the TIMx CCER register value */
;;;783      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x08001a66:    6a13        .j      LDR      r3,[r2,#0x20]
;;;784    
;;;785      /* Get the TIMx CR2 register value */
;;;786      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001a68:    6855        Uh      LDR      r5,[r2,#4]
;;;787    
;;;788      /* Get the TIMx CCMR1 register value */
;;;789      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x08001a6a:    6994        .i      LDR      r4,[r2,#0x18]
;;;790    
;;;791      /* Reset Capture/Compare selection Bits */
;;;792      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
        0x08001a6c:    f0240403    $...    BIC      r4,r4,#3
;;;793    
;;;794      /* Set the Output Compare Mode */
;;;795      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
        0x08001a70:    f0240070    $.p.    BIC      r0,r4,#0x70
        0x08001a74:    680e        .h      LDR      r6,[r1,#0]
        0x08001a76:    ea400406    @...    ORR      r4,r0,r6
;;;796    
;;;797      /* Set the Output Compare Polarity */
;;;798      MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
        0x08001a7a:    f0230002    #...    BIC      r0,r3,#2
        0x08001a7e:    690e        .i      LDR      r6,[r1,#0x10]
        0x08001a80:    ea400306    @...    ORR      r3,r0,r6
;;;799    
;;;800      /* Set the Output State */
;;;801      MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
        0x08001a84:    f0230001    #...    BIC      r0,r3,#1
        0x08001a88:    684e        Nh      LDR      r6,[r1,#4]
        0x08001a8a:    ea400306    @...    ORR      r3,r0,r6
;;;802    
;;;803      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001a8e:    480f        .H      LDR      r0,[pc,#60] ; [0x8001acc] = 0x40012c00
        0x08001a90:    4282        .B      CMP      r2,r0
        0x08001a92:    d113        ..      BNE      0x8001abc ; OC1Config + 104
;;;804      {
;;;805        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;806        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;807    
;;;808        /* Set the complementary output Polarity */
;;;809        MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
        0x08001a94:    f0230008    #...    BIC      r0,r3,#8
        0x08001a98:    694e        Ni      LDR      r6,[r1,#0x14]
        0x08001a9a:    ea400386    @...    ORR      r3,r0,r6,LSL #2
;;;810    
;;;811        /* Set the complementary output State */
;;;812        MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
        0x08001a9e:    f0230004    #...    BIC      r0,r3,#4
        0x08001aa2:    688e        .h      LDR      r6,[r1,#8]
        0x08001aa4:    ea400386    @...    ORR      r3,r0,r6,LSL #2
;;;813    
;;;814        /* Set the Output Idle state */
;;;815        MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
        0x08001aa8:    f4257080    %..p    BIC      r0,r5,#0x100
        0x08001aac:    698e        .i      LDR      r6,[r1,#0x18]
        0x08001aae:    ea400506    @...    ORR      r5,r0,r6
;;;816    
;;;817        /* Set the complementary output Idle state */
;;;818        MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
        0x08001ab2:    f4257000    %..p    BIC      r0,r5,#0x200
        0x08001ab6:    69ce        .i      LDR      r6,[r1,#0x1c]
        0x08001ab8:    ea400546    @.F.    ORR      r5,r0,r6,LSL #1
;;;819      }
;;;820    
;;;821      /* Write to TIMx CR2 */
;;;822      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001abc:    6055        U`      STR      r5,[r2,#4]
;;;823    
;;;824      /* Write to TIMx CCMR1 */
;;;825      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x08001abe:    6194        .a      STR      r4,[r2,#0x18]
;;;826    
;;;827      /* Set the Capture Compare Register value */
;;;828      LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001ac0:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
        0x08001ac2:    6350        Pc      STR      r0,[r2,#0x34]
;;;1998   }
        0x08001ac4:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;831      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001ac6:    6213        .b      STR      r3,[r2,#0x20]
;;;832    
;;;833      return SUCCESS;
        0x08001ac8:    2001        .       MOVS     r0,#1
;;;834    }
        0x08001aca:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001acc:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC2Config
    OC2Config
;;;835    
;;;836    /**
;;;837      * @brief  Configure the TIMx output channel 2.
;;;838      * @param  TIMx Timer Instance
;;;839      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
;;;840      * @retval An ErrorStatus enumeration value:
;;;841      *          - SUCCESS: TIMx registers are de-initialized
;;;842      *          - ERROR: not applicable
;;;843      */
;;;844    static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;845    {
        0x08001ad0:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08001ad4:    4604        .F      MOV      r4,r0
        0x08001ad6:    460d        .F      MOV      r5,r1
;;;846      uint32_t tmpccmr1 = 0U;
        0x08001ad8:    2700        .'      MOVS     r7,#0
;;;847      uint32_t tmpccer = 0U;
        0x08001ada:    2600        .&      MOVS     r6,#0
;;;848      uint32_t tmpcr2 = 0U;
        0x08001adc:    46b0        .F      MOV      r8,r6
;;;849    
;;;850      /* Check the parameters */
;;;851      assert_param(IS_TIM_CC2_INSTANCE(TIMx));
;;;852      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;853      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;854      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;855      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;856      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;857    
;;;858      /* Disable the Channel 2: Reset the CC2E Bit */
;;;859      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
        0x08001ade:    6a20         j      LDR      r0,[r4,#0x20]
        0x08001ae0:    f0200010     ...    BIC      r0,r0,#0x10
        0x08001ae4:    6220         b      STR      r0,[r4,#0x20]
;;;860    
;;;861      /* Get the TIMx CCER register value */
;;;862      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x08001ae6:    6a26        &j      LDR      r6,[r4,#0x20]
;;;863    
;;;864      /* Get the TIMx CR2 register value */
;;;865      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001ae8:    f8d48004    ....    LDR      r8,[r4,#4]
;;;866    
;;;867      /* Get the TIMx CCMR1 register value */
;;;868      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x08001aec:    69a7        .i      LDR      r7,[r4,#0x18]
;;;869    
;;;870      /* Reset Capture/Compare selection Bits */
;;;871      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
        0x08001aee:    f4277740    '.@w    BIC      r7,r7,#0x300
;;;872    
;;;873      /* Select the Output Compare Mode */
;;;874      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
        0x08001af2:    f42740e0    '..@    BIC      r0,r7,#0x7000
        0x08001af6:    6829        )h      LDR      r1,[r5,#0]
        0x08001af8:    ea402701    @..'    ORR      r7,r0,r1,LSL #8
;;;875    
;;;876      /* Set the Output Compare Polarity */
;;;877      MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
        0x08001afc:    f0260020    &. .    BIC      r0,r6,#0x20
        0x08001b00:    6929        )i      LDR      r1,[r5,#0x10]
        0x08001b02:    ea401601    @...    ORR      r6,r0,r1,LSL #4
;;;878    
;;;879      /* Set the Output State */
;;;880      MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
        0x08001b06:    f0260010    &...    BIC      r0,r6,#0x10
        0x08001b0a:    6869        ih      LDR      r1,[r5,#4]
        0x08001b0c:    ea401601    @...    ORR      r6,r0,r1,LSL #4
;;;881    
;;;882      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001b10:    4810        .H      LDR      r0,[pc,#64] ; [0x8001b54] = 0x40012c00
        0x08001b12:    4284        .B      CMP      r4,r0
        0x08001b14:    d113        ..      BNE      0x8001b3e ; OC2Config + 110
;;;883      {
;;;884        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;885        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;886    
;;;887        /* Set the complementary output Polarity */
;;;888        MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
        0x08001b16:    f0260080    &...    BIC      r0,r6,#0x80
        0x08001b1a:    6969        ii      LDR      r1,[r5,#0x14]
        0x08001b1c:    ea401681    @...    ORR      r6,r0,r1,LSL #6
;;;889    
;;;890        /* Set the complementary output State */
;;;891        MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
        0x08001b20:    f0260040    &.@.    BIC      r0,r6,#0x40
        0x08001b24:    68a9        .h      LDR      r1,[r5,#8]
        0x08001b26:    ea401681    @...    ORR      r6,r0,r1,LSL #6
;;;892    
;;;893        /* Set the Output Idle state */
;;;894        MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
        0x08001b2a:    f4286080    (..`    BIC      r0,r8,#0x400
        0x08001b2e:    69a9        .i      LDR      r1,[r5,#0x18]
        0x08001b30:    ea400881    @...    ORR      r8,r0,r1,LSL #2
;;;895    
;;;896        /* Set the complementary output Idle state */
;;;897        MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
        0x08001b34:    f4286000    (..`    BIC      r0,r8,#0x800
        0x08001b38:    69e9        .i      LDR      r1,[r5,#0x1c]
        0x08001b3a:    ea4008c1    @...    ORR      r8,r0,r1,LSL #3
;;;898      }
;;;899    
;;;900      /* Write to TIMx CR2 */
;;;901      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001b3e:    f8c48004    ....    STR      r8,[r4,#4]
;;;902    
;;;903      /* Write to TIMx CCMR1 */
;;;904      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x08001b42:    61a7        .a      STR      r7,[r4,#0x18]
;;;905    
;;;906      /* Set the Capture Compare Register value */
;;;907      LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001b44:    4620         F      MOV      r0,r4
        0x08001b46:    68e9        .h      LDR      r1,[r5,#0xc]
        0x08001b48:    f7fffa4a    ..J.    BL       LL_TIM_OC_SetCompareCH2 ; 0x8000fe0
;;;908    
;;;909      /* Write to TIMx CCER */
;;;910      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001b4c:    6226        &b      STR      r6,[r4,#0x20]
;;;911    
;;;912      return SUCCESS;
        0x08001b4e:    2001        .       MOVS     r0,#1
;;;913    }
        0x08001b50:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x08001b54:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC3Config
    OC3Config
;;;914    
;;;915    /**
;;;916      * @brief  Configure the TIMx output channel 3.
;;;917      * @param  TIMx Timer Instance
;;;918      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
;;;919      * @retval An ErrorStatus enumeration value:
;;;920      *          - SUCCESS: TIMx registers are de-initialized
;;;921      *          - ERROR: not applicable
;;;922      */
;;;923    static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;924    {
        0x08001b58:    b570        p.      PUSH     {r4-r6,lr}
        0x08001b5a:    4602        .F      MOV      r2,r0
;;;925      uint32_t tmpccmr2 = 0U;
        0x08001b5c:    2400        .$      MOVS     r4,#0
;;;926      uint32_t tmpccer = 0U;
        0x08001b5e:    2300        .#      MOVS     r3,#0
;;;927      uint32_t tmpcr2 = 0U;
        0x08001b60:    2500        .%      MOVS     r5,#0
;;;928    
;;;929      /* Check the parameters */
;;;930      assert_param(IS_TIM_CC3_INSTANCE(TIMx));
;;;931      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;932      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;933      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;934      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;935      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;936    
;;;937      /* Disable the Channel 3: Reset the CC3E Bit */
;;;938      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
        0x08001b62:    6a10        .j      LDR      r0,[r2,#0x20]
        0x08001b64:    f4207080     ..p    BIC      r0,r0,#0x100
        0x08001b68:    6210        .b      STR      r0,[r2,#0x20]
;;;939    
;;;940      /* Get the TIMx CCER register value */
;;;941      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x08001b6a:    6a13        .j      LDR      r3,[r2,#0x20]
;;;942    
;;;943      /* Get the TIMx CR2 register value */
;;;944      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001b6c:    6855        Uh      LDR      r5,[r2,#4]
;;;945    
;;;946      /* Get the TIMx CCMR2 register value */
;;;947      tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x08001b6e:    69d4        .i      LDR      r4,[r2,#0x1c]
;;;948    
;;;949      /* Reset Capture/Compare selection Bits */
;;;950      CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
        0x08001b70:    f0240403    $...    BIC      r4,r4,#3
;;;951    
;;;952      /* Select the Output Compare Mode */
;;;953      MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
        0x08001b74:    f0240070    $.p.    BIC      r0,r4,#0x70
        0x08001b78:    680e        .h      LDR      r6,[r1,#0]
        0x08001b7a:    ea400406    @...    ORR      r4,r0,r6
;;;954    
;;;955      /* Set the Output Compare Polarity */
;;;956      MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
        0x08001b7e:    f4237000    #..p    BIC      r0,r3,#0x200
        0x08001b82:    690e        .i      LDR      r6,[r1,#0x10]
        0x08001b84:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;957    
;;;958      /* Set the Output State */
;;;959      MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
        0x08001b88:    f4237080    #..p    BIC      r0,r3,#0x100
        0x08001b8c:    684e        Nh      LDR      r6,[r1,#4]
        0x08001b8e:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;960    
;;;961      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001b92:    480f        .H      LDR      r0,[pc,#60] ; [0x8001bd0] = 0x40012c00
        0x08001b94:    4282        .B      CMP      r2,r0
        0x08001b96:    d113        ..      BNE      0x8001bc0 ; OC3Config + 104
;;;962      {
;;;963        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;964        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;965    
;;;966        /* Set the complementary output Polarity */
;;;967        MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
        0x08001b98:    f4236000    #..`    BIC      r0,r3,#0x800
        0x08001b9c:    694e        Ni      LDR      r6,[r1,#0x14]
        0x08001b9e:    ea402386    @..#    ORR      r3,r0,r6,LSL #10
;;;968    
;;;969        /* Set the complementary output State */
;;;970        MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
        0x08001ba2:    f4236080    #..`    BIC      r0,r3,#0x400
        0x08001ba6:    688e        .h      LDR      r6,[r1,#8]
        0x08001ba8:    ea402386    @..#    ORR      r3,r0,r6,LSL #10
;;;971    
;;;972        /* Set the Output Idle state */
;;;973        MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
        0x08001bac:    f4255080    %..P    BIC      r0,r5,#0x1000
        0x08001bb0:    698e        .i      LDR      r6,[r1,#0x18]
        0x08001bb2:    ea401506    @...    ORR      r5,r0,r6,LSL #4
;;;974    
;;;975        /* Set the complementary output Idle state */
;;;976        MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
        0x08001bb6:    f4255000    %..P    BIC      r0,r5,#0x2000
        0x08001bba:    69ce        .i      LDR      r6,[r1,#0x1c]
        0x08001bbc:    ea401546    @.F.    ORR      r5,r0,r6,LSL #5
;;;977      }
;;;978    
;;;979      /* Write to TIMx CR2 */
;;;980      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001bc0:    6055        U`      STR      r5,[r2,#4]
;;;981    
;;;982      /* Write to TIMx CCMR2 */
;;;983      LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x08001bc2:    61d4        .a      STR      r4,[r2,#0x1c]
;;;984    
;;;985      /* Set the Capture Compare Register value */
;;;986      LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001bc4:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
        0x08001bc6:    63d0        .c      STR      r0,[r2,#0x3c]
;;;2026   }
        0x08001bc8:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;989      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001bca:    6213        .b      STR      r3,[r2,#0x20]
;;;990    
;;;991      return SUCCESS;
        0x08001bcc:    2001        .       MOVS     r0,#1
;;;992    }
        0x08001bce:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001bd0:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC4Config
    OC4Config
;;;993    
;;;994    /**
;;;995      * @brief  Configure the TIMx output channel 4.
;;;996      * @param  TIMx Timer Instance
;;;997      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
;;;998      * @retval An ErrorStatus enumeration value:
;;;999      *          - SUCCESS: TIMx registers are de-initialized
;;;1000     *          - ERROR: not applicable
;;;1001     */
;;;1002   static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;1003   {
        0x08001bd4:    b570        p.      PUSH     {r4-r6,lr}
        0x08001bd6:    4602        .F      MOV      r2,r0
;;;1004     uint32_t tmpccmr2 = 0U;
        0x08001bd8:    2300        .#      MOVS     r3,#0
;;;1005     uint32_t tmpccer = 0U;
        0x08001bda:    2400        .$      MOVS     r4,#0
;;;1006     uint32_t tmpcr2 = 0U;
        0x08001bdc:    2500        .%      MOVS     r5,#0
;;;1007   
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;1010     assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;1011     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;1012     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;1013     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;1014     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;1015   
;;;1016     /* Disable the Channel 4: Reset the CC4E Bit */
;;;1017     CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
        0x08001bde:    6a10        .j      LDR      r0,[r2,#0x20]
        0x08001be0:    f4205080     ..P    BIC      r0,r0,#0x1000
        0x08001be4:    6210        .b      STR      r0,[r2,#0x20]
;;;1018   
;;;1019     /* Get the TIMx CCER register value */
;;;1020     tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x08001be6:    6a14        .j      LDR      r4,[r2,#0x20]
;;;1021   
;;;1022     /* Get the TIMx CR2 register value */
;;;1023     tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
        0x08001be8:    6855        Uh      LDR      r5,[r2,#4]
;;;1024   
;;;1025     /* Get the TIMx CCMR2 register value */
;;;1026     tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x08001bea:    69d3        .i      LDR      r3,[r2,#0x1c]
;;;1027   
;;;1028     /* Reset Capture/Compare selection Bits */
;;;1029     CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
        0x08001bec:    f4237340    #.@s    BIC      r3,r3,#0x300
;;;1030   
;;;1031     /* Select the Output Compare Mode */
;;;1032     MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
        0x08001bf0:    f42340e0    #..@    BIC      r0,r3,#0x7000
        0x08001bf4:    680e        .h      LDR      r6,[r1,#0]
        0x08001bf6:    ea402306    @..#    ORR      r3,r0,r6,LSL #8
;;;1033   
;;;1034     /* Set the Output Compare Polarity */
;;;1035     MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
        0x08001bfa:    f4245000    $..P    BIC      r0,r4,#0x2000
        0x08001bfe:    690e        .i      LDR      r6,[r1,#0x10]
        0x08001c00:    ea403406    @..4    ORR      r4,r0,r6,LSL #12
;;;1036   
;;;1037     /* Set the Output State */
;;;1038     MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
        0x08001c04:    f4245080    $..P    BIC      r0,r4,#0x1000
        0x08001c08:    684e        Nh      LDR      r6,[r1,#4]
        0x08001c0a:    ea403406    @..4    ORR      r4,r0,r6,LSL #12
;;;1039   
;;;1040     if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001c0e:    4808        .H      LDR      r0,[pc,#32] ; [0x8001c30] = 0x40012c00
        0x08001c10:    4282        .B      CMP      r2,r0
        0x08001c12:    d104        ..      BNE      0x8001c1e ; OC4Config + 74
;;;1041     {
;;;1042       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;1043       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;1044   
;;;1045       /* Set the Output Idle state */
;;;1046       MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
        0x08001c14:    f4254080    %..@    BIC      r0,r5,#0x4000
        0x08001c18:    698e        .i      LDR      r6,[r1,#0x18]
        0x08001c1a:    ea401586    @...    ORR      r5,r0,r6,LSL #6
;;;1047     }
;;;1048   
;;;1049     /* Write to TIMx CR2 */
;;;1050     LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001c1e:    6055        U`      STR      r5,[r2,#4]
;;;1051   
;;;1052     /* Write to TIMx CCMR2 */
;;;1053     LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x08001c20:    61d3        .a      STR      r3,[r2,#0x1c]
;;;1054   
;;;1055     /* Set the Capture Compare Register value */
;;;1056     LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001c22:    68c8        .h      LDR      r0,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
        0x08001c24:    6410        .d      STR      r0,[r2,#0x40]
;;;2040   }
        0x08001c26:    bf00        ..      NOP      
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;1059     LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001c28:    6214        .b      STR      r4,[r2,#0x20]
;;;1060   
;;;1061     return SUCCESS;
        0x08001c2a:    2001        .       MOVS     r0,#1
;;;1062   }
        0x08001c2c:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001c2e:    0000        ..      DCW    0
        0x08001c30:    40012c00    .,.@    DCD    1073818624
    $t
    i.PendSV_Handler
    PendSV_Handler
;;; .\../Src/stm32f1xx_it.c
;;;146    }
        0x08001c34:    4770        pG      BX       lr
        0x08001c36:    0000        ..      MOVS     r0,r0
    i.RCC_GetHCLKClockFreq
    RCC_GetHCLKClockFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;388    {
        0x08001c38:    4601        .F      MOV      r1,r0
;;;389      /* HCLK clock frequency */
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
        0x08001c3a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1116     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
        0x08001c3c:    4804        .H      LDR      r0,[pc,#16] ; [0x8001c50] = 0x40021000
        0x08001c3e:    6840        @h      LDR      r0,[r0,#4]
        0x08001c40:    f00000f0    ....    AND      r0,r0,#0xf0
        0x08001c44:    0900        ..      LSRS     r0,r0,#4
        0x08001c46:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001c54] = 0x80031a0
        0x08001c48:    5c12        .\      LDRB     r2,[r2,r0]
        0x08001c4a:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;391    }
        0x08001c4e:    4770        pG      BX       lr
    $d
        0x08001c50:    40021000    ...@    DCD    1073876992
        0x08001c54:    080031a0    .1..    DCD    134230432
    $t
    i.RCC_GetPCLK1ClockFreq
    RCC_GetPCLK1ClockFreq
;;;392    
;;;393    /**
;;;394      * @brief  Return PCLK1 clock frequency
;;;395      * @param  HCLK_Frequency HCLK clock frequency
;;;396      * @retval PCLK1 clock frequency (in Hz)
;;;397      */
;;;398    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
;;;399    {
        0x08001c58:    4601        .F      MOV      r1,r0
;;;400      /* PCLK1 clock frequency */
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
        0x08001c5a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1131     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
        0x08001c5c:    4805        .H      LDR      r0,[pc,#20] ; [0x8001c74] = 0x40021000
        0x08001c5e:    6840        @h      LDR      r0,[r0,#4]
        0x08001c60:    f40060e0    ...`    AND      r0,r0,#0x700
        0x08001c64:    4a04        .J      LDR      r2,[pc,#16] ; [0x8001c78] = 0x80031b0
        0x08001c66:    eb022010    ...     ADD      r0,r2,r0,LSR #8
        0x08001c6a:    7802        .x      LDRB     r2,[r0,#0]
        0x08001c6c:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;402    }
        0x08001c70:    4770        pG      BX       lr
    $d
        0x08001c72:    0000        ..      DCW    0
        0x08001c74:    40021000    ...@    DCD    1073876992
        0x08001c78:    080031b0    .1..    DCD    134230448
    $t
    i.RCC_GetPCLK2ClockFreq
    RCC_GetPCLK2ClockFreq
;;;403    
;;;404    /**
;;;405      * @brief  Return PCLK2 clock frequency
;;;406      * @param  HCLK_Frequency HCLK clock frequency
;;;407      * @retval PCLK2 clock frequency (in Hz)
;;;408      */
;;;409    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
;;;410    {
        0x08001c7c:    4601        .F      MOV      r1,r0
;;;411      /* PCLK2 clock frequency */
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
        0x08001c7e:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1146     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
        0x08001c80:    4805        .H      LDR      r0,[pc,#20] ; [0x8001c98] = 0x40021000
        0x08001c82:    6840        @h      LDR      r0,[r0,#4]
        0x08001c84:    f4005060    ..`P    AND      r0,r0,#0x3800
        0x08001c88:    4a04        .J      LDR      r2,[pc,#16] ; [0x8001c9c] = 0x80031b0
        0x08001c8a:    eb0220d0    ...     ADD      r0,r2,r0,LSR #11
        0x08001c8e:    7802        .x      LDRB     r2,[r0,#0]
        0x08001c90:    fa21f002    !...    LSR      r0,r1,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;413    }
        0x08001c94:    4770        pG      BX       lr
    $d
        0x08001c96:    0000        ..      DCW    0
        0x08001c98:    40021000    ...@    DCD    1073876992
        0x08001c9c:    080031b0    .1..    DCD    134230448
    $t
    i.RCC_GetSystemClockFreq
    RCC_GetSystemClockFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c (356)
        0x08001ca0:    b510        ..      PUSH     {r4,lr}
;;;357      uint32_t frequency = 0U;
        0x08001ca2:    2400        .$      MOVS     r4,#0
;;;358    
;;;359      /* Get SYSCLK source -------------------------------------------------------*/
;;;360      switch (LL_RCC_GetSysClkSource())
        0x08001ca4:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001ca6:    480b        .H      LDR      r0,[pc,#44] ; [0x8001cd4] = 0x40021000
        0x08001ca8:    6840        @h      LDR      r0,[r0,#4]
        0x08001caa:    f000000c    ....    AND      r0,r0,#0xc
        0x08001cae:    b120         .      CBZ      r0,0x8001cba ; RCC_GetSystemClockFreq + 26
        0x08001cb0:    2804        .(      CMP      r0,#4
        0x08001cb2:    d004        ..      BEQ      0x8001cbe ; RCC_GetSystemClockFreq + 30
        0x08001cb4:    2808        .(      CMP      r0,#8
        0x08001cb6:    d108        ..      BNE      0x8001cca ; RCC_GetSystemClockFreq + 42
        0x08001cb8:    e003        ..      B        0x8001cc2 ; RCC_GetSystemClockFreq + 34
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;363          frequency = HSI_VALUE;
        0x08001cba:    4c07        .L      LDR      r4,[pc,#28] ; [0x8001cd8] = 0x7a1200
;;;364          break;
        0x08001cbc:    e007        ..      B        0x8001cce ; RCC_GetSystemClockFreq + 46
;;;365    
;;;366        case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;367          frequency = HSE_VALUE;
        0x08001cbe:    4c06        .L      LDR      r4,[pc,#24] ; [0x8001cd8] = 0x7a1200
;;;368          break;
        0x08001cc0:    e005        ..      B        0x8001cce ; RCC_GetSystemClockFreq + 46
;;;369    
;;;370        case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;371          frequency = RCC_PLL_GetFreqDomain_SYS();
        0x08001cc2:    f000f80b    ....    BL       RCC_PLL_GetFreqDomain_SYS ; 0x8001cdc
        0x08001cc6:    4604        .F      MOV      r4,r0
;;;372          break;
        0x08001cc8:    e001        ..      B        0x8001cce ; RCC_GetSystemClockFreq + 46
;;;373    
;;;374        default:
;;;375          frequency = HSI_VALUE;
        0x08001cca:    4c03        .L      LDR      r4,[pc,#12] ; [0x8001cd8] = 0x7a1200
;;;376          break;
        0x08001ccc:    bf00        ..      NOP      
        0x08001cce:    bf00        ..      NOP      
;;;377      }
;;;378    
;;;379      return frequency;
        0x08001cd0:    4620         F      MOV      r0,r4
;;;380    }
        0x08001cd2:    bd10        ..      POP      {r4,pc}
    $d
        0x08001cd4:    40021000    ...@    DCD    1073876992
        0x08001cd8:    007a1200    ..z.    DCD    8000000
    $t
    i.RCC_PLL_GetFreqDomain_SYS
    RCC_PLL_GetFreqDomain_SYS
;;;381    
;;;382    /**
;;;383      * @brief  Return HCLK clock frequency
;;;384      * @param  SYSCLK_Frequency SYSCLK clock frequency
;;;385      * @retval HCLK clock frequency (in Hz)
;;;386      */
;;;387    uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
;;;388    {
;;;389      /* HCLK clock frequency */
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
;;;391    }
;;;392    
;;;393    /**
;;;394      * @brief  Return PCLK1 clock frequency
;;;395      * @param  HCLK_Frequency HCLK clock frequency
;;;396      * @retval PCLK1 clock frequency (in Hz)
;;;397      */
;;;398    uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
;;;399    {
;;;400      /* PCLK1 clock frequency */
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
;;;402    }
;;;403    
;;;404    /**
;;;405      * @brief  Return PCLK2 clock frequency
;;;406      * @param  HCLK_Frequency HCLK clock frequency
;;;407      * @retval PCLK2 clock frequency (in Hz)
;;;408      */
;;;409    uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
;;;410    {
;;;411      /* PCLK2 clock frequency */
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
;;;413    }
;;;414    
;;;415    /**
;;;416      * @brief  Return PLL clock frequency used for system domain
;;;417      * @retval PLL clock frequency (in Hz)
;;;418      */
;;;419    uint32_t RCC_PLL_GetFreqDomain_SYS(void)
;;;420    {
;;;421      uint32_t pllinputfreq = 0U, pllsource = 0U;
        0x08001cdc:    2100        .!      MOVS     r1,#0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c (421)
        0x08001cde:    2200        ."      MOVS     r2,#0
;;;422    
;;;423      /* PLL_VCO = (HSE_VALUE, HSI_VALUE or PLL2 / PLL Predivider) * PLL Multiplicator */
;;;424    
;;;425      /* Get PLL source */
;;;426      pllsource = LL_RCC_PLL_GetMainSource();
        0x08001ce0:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1543     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
        0x08001ce2:    4811        .H      LDR      r0,[pc,#68] ; [0x8001d28] = 0x40021000
        0x08001ce4:    6840        @h      LDR      r0,[r0,#4]
        0x08001ce6:    f4003080    ...0    AND      r0,r0,#0x10000
        0x08001cea:    4602        .F      MOV      r2,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;428      switch (pllsource)
        0x08001cec:    b11a        ..      CBZ      r2,0x8001cf6 ; RCC_PLL_GetFreqDomain_SYS + 26
        0x08001cee:    f5b23f80    ...?    CMP      r2,#0x10000
        0x08001cf2:    d10c        ..      BNE      0x8001d0e ; RCC_PLL_GetFreqDomain_SYS + 50
        0x08001cf4:    e001        ..      B        0x8001cfa ; RCC_PLL_GetFreqDomain_SYS + 30
;;;429      {
;;;430        case LL_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
;;;431          pllinputfreq = HSI_VALUE / 2U;
        0x08001cf6:    490d        .I      LDR      r1,[pc,#52] ; [0x8001d2c] = 0x3d0900
;;;432          break;
        0x08001cf8:    e00b        ..      B        0x8001d12 ; RCC_PLL_GetFreqDomain_SYS + 54
;;;433    
;;;434        case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
;;;435          pllinputfreq = HSE_VALUE / (LL_RCC_PLL_GetPrediv() + 1U);
        0x08001cfa:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1605     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos);
        0x08001cfc:    480a        .H      LDR      r0,[pc,#40] ; [0x8001d28] = 0x40021000
        0x08001cfe:    6840        @h      LDR      r0,[r0,#4]
        0x08001d00:    f3c04040    ..@@    UBFX     r0,r0,#17,#1
        0x08001d04:    1c40        @.      ADDS     r0,r0,#1
        0x08001d06:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8001d30] = 0x7a1200
        0x08001d08:    fbb3f1f0    ....    UDIV     r1,r3,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;436          break;
        0x08001d0c:    e001        ..      B        0x8001d12 ; RCC_PLL_GetFreqDomain_SYS + 54
;;;437    
;;;438    #if defined(RCC_PLL2_SUPPORT)
;;;439        case LL_RCC_PLLSOURCE_PLL2:       /* PLL2 used as PLL clock source */
;;;440          pllinputfreq = RCC_PLL2_GetFreqClockFreq() / (LL_RCC_PLL_GetPrediv() + 1U);
;;;441          break;
;;;442    #endif /* RCC_PLL2_SUPPORT */
;;;443    
;;;444        default:
;;;445          pllinputfreq = HSI_VALUE / 2U;
        0x08001d0e:    4907        .I      LDR      r1,[pc,#28] ; [0x8001d2c] = 0x3d0900
;;;446          break;
        0x08001d10:    bf00        ..      NOP      
        0x08001d12:    bf00        ..      NOP      
;;;447      }
;;;448      return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator());
        0x08001d14:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1572     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMULL));
        0x08001d16:    4804        .H      LDR      r0,[pc,#16] ; [0x8001d28] = 0x40021000
        0x08001d18:    6840        @h      LDR      r0,[r0,#4]
        0x08001d1a:    f4001070    ..p.    AND      r0,r0,#0x3c0000
        0x08001d1e:    2302        .#      MOVS     r3,#2
        0x08001d20:    eb034090    ...@    ADD      r0,r3,r0,LSR #18
        0x08001d24:    4348        HC      MULS     r0,r1,r0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;449    }
        0x08001d26:    4770        pG      BX       lr
    $d
        0x08001d28:    40021000    ...@    DCD    1073876992
        0x08001d2c:    003d0900    ..=.    DCD    4000000
        0x08001d30:    007a1200    ..z.    DCD    8000000
    $t
    i.SVC_Handler
    SVC_Handler
;;; .\../Src/stm32f1xx_it.c
;;;133    }
        0x08001d34:    4770        pG      BX       lr
        0x08001d36:    0000        ..      MOVS     r0,r0
    i.SysTick_Handler
    SysTick_Handler
;;;134    
;;;135    /**
;;;136      * @brief This function handles Pendable request for system service.
;;;137      */
;;;138    void PendSV_Handler(void)
;;;139    {
;;;140      /* USER CODE BEGIN PendSV_IRQn 0 */
;;;141    
;;;142      /* USER CODE END PendSV_IRQn 0 */
;;;143      /* USER CODE BEGIN PendSV_IRQn 1 */
;;;144    
;;;145      /* USER CODE END PendSV_IRQn 1 */
;;;146    }
;;;147    
;;;148    /**
;;;149      * @brief This function handles System tick timer.
;;;150      */
;;;151    void SysTick_Handler(void)
;;;152    {
;;;153      /* USER CODE BEGIN SysTick_IRQn 0 */
;;;154    
;;;155      /* USER CODE END SysTick_IRQn 0 */
;;;156      
;;;157      /* USER CODE BEGIN SysTick_IRQn 1 */
;;;158    
;;;159    /*
;;;160    #if  defined ( _SIMU )
;;;161    
;;;162    //simulate spindle
;;;163    	if(++tacho_cnt == 1800 ) {
;;;164    		tacho_debug = 1;
;;;165    		tacho_cnt = 0;
;;;166    		TIM4_IRQHandler();
;;;167    	}
;;;168    	if(++TIM4->CNT > TIM4->ARR) {
;;;169    		TIM4->CNT = 0; // overflow emulation
;;;170    		encoder = true;
;;;171    		TIM4_IRQHandler();
;;;172    	}
;;;173    #endif
;;;174    */
;;;175    //      if(auto_mode_delay > 0)
;;;176    //              auto_mode_delay--;
;;;177    	for(int a = 0; a<BT_TOTAL;a++){
        0x08001d38:    2000        .       MOVS     r0,#0
;;; .\../Src/stm32f1xx_it.c (177)
        0x08001d3a:    e00e        ..      B        0x8001d5a ; SysTick_Handler + 34
        0x08001d3c:    4908        .I      LDR      r1,[pc,#32] ; [0x8001d60] = 0x200004f0
        0x08001d3e:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001d42:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001d44:    b141        A.      CBZ      r1,0x8001d58 ; SysTick_Handler + 32
        0x08001d46:    4906        .I      LDR      r1,[pc,#24] ; [0x8001d60] = 0x200004f0
        0x08001d48:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08001d4c:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001d4e:    1c49        I.      ADDS     r1,r1,#1
        0x08001d50:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001d60] = 0x200004f0
        0x08001d52:    eb021240    ..@.    ADD      r2,r2,r0,LSL #5
        0x08001d56:    6111        .a      STR      r1,[r2,#0x10]
        0x08001d58:    1c40        @.      ADDS     r0,r0,#1
        0x08001d5a:    2801        .(      CMP      r0,#1
        0x08001d5c:    dbee        ..      BLT      0x8001d3c ; SysTick_Handler + 4
;;;178    		if( bt[a].buttons_mstick > 0 )
;;;179    			bt[a].buttons_mstick++;
;;;180    	}
;;;181      /* USER CODE END SysTick_IRQn 1 */
;;;182    }
        0x08001d5e:    4770        pG      BX       lr
    $d
        0x08001d60:    200004f0    ...     DCD    536872176
    $t
    i.SystemClock_Config
    SystemClock_Config
;;; .\../Src/main.c
;;;481    {
        0x08001d64:    b510        ..      PUSH     {r4,lr}
;;;482      LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
        0x08001d66:    2002        .       MOVS     r0,#2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;488      MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
        0x08001d68:    4942        BI      LDR      r1,[pc,#264] ; [0x8001e74] = 0x40022000
        0x08001d6a:    6809        .h      LDR      r1,[r1,#0]
        0x08001d6c:    f0210107    !...    BIC      r1,r1,#7
        0x08001d70:    4301        .C      ORRS     r1,r1,r0
        0x08001d72:    4a40        @J      LDR      r2,[pc,#256] ; [0x8001e74] = 0x40022000
        0x08001d74:    6011        .`      STR      r1,[r2,#0]
;;;489    }
        0x08001d76:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;484       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
        0x08001d78:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;501      return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
        0x08001d7a:    4610        .F      MOV      r0,r2
        0x08001d7c:    6800        .h      LDR      r0,[r0,#0]
        0x08001d7e:    f0000007    ....    AND      r0,r0,#7
        0x08001d82:    2802        .(      CMP      r0,#2
        0x08001d84:    d001        ..      BEQ      0x8001d8a ; SystemClock_Config + 38
;;; .\../Src/main.c
;;;486        Error_Handler();  
        0x08001d86:    f7fefcca    ....    BL       Error_Handler ; 0x800071e
;;;487      }
;;;488      LL_RCC_HSE_Enable();
        0x08001d8a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;792      SET_BIT(RCC->CR, RCC_CR_HSEON);
        0x08001d8c:    483a        :H      LDR      r0,[pc,#232] ; [0x8001e78] = 0x40021000
        0x08001d8e:    6800        .h      LDR      r0,[r0,#0]
        0x08001d90:    f4403080    @..0    ORR      r0,r0,#0x10000
        0x08001d94:    4938        8I      LDR      r1,[pc,#224] ; [0x8001e78] = 0x40021000
        0x08001d96:    6008        .`      STR      r0,[r1,#0]
;;;793    }
        0x08001d98:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;491      while(LL_RCC_HSE_IsReady() != 1)
        0x08001d9a:    bf00        ..      NOP      
        0x08001d9c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;812      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
        0x08001d9e:    4836        6H      LDR      r0,[pc,#216] ; [0x8001e78] = 0x40021000
        0x08001da0:    6800        .h      LDR      r0,[r0,#0]
        0x08001da2:    f3c04040    ..@@    UBFX     r0,r0,#17,#1
        0x08001da6:    2800        .(      CMP      r0,#0
        0x08001da8:    d0f8        ..      BEQ      0x8001d9c ; SystemClock_Config + 56
;;; .\../Src/main.c
;;;495      LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE_DIV_1, LL_RCC_PLL_MUL_9);
        0x08001daa:    f44f3080    O..0    MOV      r0,#0x10000
        0x08001dae:    f44f11e0    O...    MOV      r1,#0x1c0000
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1495     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
        0x08001db2:    4a31        1J      LDR      r2,[pc,#196] ; [0x8001e78] = 0x40021000
        0x08001db4:    6852        Rh      LDR      r2,[r2,#4]
        0x08001db6:    f422127c    ".|.    BIC      r2,r2,#0x3f0000
        0x08001dba:    f4003340    ..@3    AND      r3,r0,#0x30000
        0x08001dbe:    430b        .C      ORRS     r3,r3,r1
        0x08001dc0:    431a        .C      ORRS     r2,r2,r3
        0x08001dc2:    4b2d        -K      LDR      r3,[pc,#180] ; [0x8001e78] = 0x40021000
        0x08001dc4:    605a        Z`      STR      r2,[r3,#4]
;;;1496                (Source & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | PLLMul);
;;;1497   #if defined(RCC_CFGR2_PREDIV1)
;;;1498   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1499     MODIFY_REG(RCC->CFGR2, (RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC),
;;;1500                (Source & RCC_CFGR2_PREDIV1) | ((Source & (RCC_CFGR2_PREDIV1SRC << 4U)) >> 4U));
;;;1501   #else
;;;1502     MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV1, (Source & RCC_CFGR2_PREDIV1));
;;;1503   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1504   #endif /*RCC_CFGR2_PREDIV1*/
;;;1505   }
        0x08001dc6:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;496      LL_RCC_PLL_Enable();
        0x08001dc8:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1405     SET_BIT(RCC->CR, RCC_CR_PLLON);
        0x08001dca:    4618        .F      MOV      r0,r3
        0x08001dcc:    6800        .h      LDR      r0,[r0,#0]
        0x08001dce:    f0407080    @..p    ORR      r0,r0,#0x1000000
        0x08001dd2:    4619        .F      MOV      r1,r3
        0x08001dd4:    6008        .`      STR      r0,[r1,#0]
;;;1406   }
        0x08001dd6:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;499      while(LL_RCC_PLL_IsReady() != 1)
        0x08001dd8:    bf00        ..      NOP      
        0x08001dda:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1426     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
        0x08001ddc:    4826        &H      LDR      r0,[pc,#152] ; [0x8001e78] = 0x40021000
        0x08001dde:    6800        .h      LDR      r0,[r0,#0]
        0x08001de0:    f3c06040    ..@`    UBFX     r0,r0,#25,#1
        0x08001de4:    2800        .(      CMP      r0,#0
        0x08001de6:    d0f8        ..      BEQ      0x8001dda ; SystemClock_Config + 118
;;; .\../Src/main.c
;;;503      LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
        0x08001de8:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1065     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
        0x08001dea:    4923        #I      LDR      r1,[pc,#140] ; [0x8001e78] = 0x40021000
        0x08001dec:    6849        Ih      LDR      r1,[r1,#4]
        0x08001dee:    f02101f0    !...    BIC      r1,r1,#0xf0
        0x08001df2:    4301        .C      ORRS     r1,r1,r0
        0x08001df4:    4a20         J      LDR      r2,[pc,#128] ; [0x8001e78] = 0x40021000
        0x08001df6:    6051        Q`      STR      r1,[r2,#4]
;;;1066   }
        0x08001df8:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;504      LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);
        0x08001dfa:    1510        ..      ASRS     r0,r2,#20
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1081     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
        0x08001dfc:    4611        .F      MOV      r1,r2
        0x08001dfe:    6849        Ih      LDR      r1,[r1,#4]
        0x08001e00:    f42161e0    !..a    BIC      r1,r1,#0x700
        0x08001e04:    4301        .C      ORRS     r1,r1,r0
        0x08001e06:    6051        Q`      STR      r1,[r2,#4]
;;;1082   }
        0x08001e08:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;505      LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);
        0x08001e0a:    2000        .       MOVS     r0,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1097     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
        0x08001e0c:    4611        .F      MOV      r1,r2
        0x08001e0e:    6849        Ih      LDR      r1,[r1,#4]
        0x08001e10:    f4215160    !.`Q    BIC      r1,r1,#0x3800
        0x08001e14:    4301        .C      ORRS     r1,r1,r0
        0x08001e16:    6051        Q`      STR      r1,[r2,#4]
;;;1098   }
        0x08001e18:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;506      LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
        0x08001e1a:    2002        .       MOVS     r0,#2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1032     MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
        0x08001e1c:    4611        .F      MOV      r1,r2
        0x08001e1e:    6849        Ih      LDR      r1,[r1,#4]
        0x08001e20:    f0210103    !...    BIC      r1,r1,#3
        0x08001e24:    4301        .C      ORRS     r1,r1,r0
        0x08001e26:    6051        Q`      STR      r1,[r2,#4]
;;;1033   }
        0x08001e28:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;509      while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
        0x08001e2a:    bf00        ..      NOP      
        0x08001e2c:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001e2e:    4812        .H      LDR      r0,[pc,#72] ; [0x8001e78] = 0x40021000
        0x08001e30:    6840        @h      LDR      r0,[r0,#4]
        0x08001e32:    f000000c    ....    AND      r0,r0,#0xc
        0x08001e36:    2808        .(      CMP      r0,#8
        0x08001e38:    d1f8        ..      BNE      0x8001e2c ; SystemClock_Config + 200
;;; .\../Src/main.c
;;;513      LL_Init1msTick(72000000);
        0x08001e3a:    4810        .H      LDR      r0,[pc,#64] ; [0x8001e7c] = 0x44aa200
        0x08001e3c:    f7fefeb6    ....    BL       LL_Init1msTick ; 0x8000bac
;;;514      LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001e40:    2004        .       MOVS     r0,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;262      if (Source == LL_SYSTICK_CLKSOURCE_HCLK)
        0x08001e42:    2804        .(      CMP      r0,#4
        0x08001e44:    d108        ..      BNE      0x8001e58 ; SystemClock_Config + 244
;;;263      {
;;;264        SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001e46:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001e4a:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001e4c:    f0410104    A...    ORR      r1,r1,#4
        0x08001e50:    f04f22e0    O.."    MOV      r2,#0xe000e000
        0x08001e54:    6111        .a      STR      r1,[r2,#0x10]
        0x08001e56:    e007        ..      B        0x8001e68 ; SystemClock_Config + 260
;;;265      }
;;;266      else
;;;267      {
;;;268        CLEAR_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x08001e58:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08001e5c:    6909        .i      LDR      r1,[r1,#0x10]
        0x08001e5e:    f0210104    !...    BIC      r1,r1,#4
        0x08001e62:    f04f22e0    O.."    MOV      r2,#0xe000e000
        0x08001e66:    6111        .a      STR      r1,[r2,#0x10]
;;;269      }
;;;270    }
        0x08001e68:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;515      LL_SetSystemCoreClock(72000000);
        0x08001e6a:    4804        .H      LDR      r0,[pc,#16] ; [0x8001e7c] = 0x44aa200
        0x08001e6c:    f7fefebe    ....    BL       LL_SetSystemCoreClock ; 0x8000bec
;;;516    }
        0x08001e70:    bd10        ..      POP      {r4,pc}
    $d
        0x08001e72:    0000        ..      DCW    0
        0x08001e74:    40022000    . .@    DCD    1073881088
        0x08001e78:    40021000    ...@    DCD    1073876992
        0x08001e7c:    044aa200    ..J.    DCD    72000000
    $t
    i.SystemInit
    SystemInit
;;; .\../Src/system_stm32f1xx.c
;;;179      RCC->CR |= 0x00000001U;
        0x08001e80:    4811        .H      LDR      r0,[pc,#68] ; [0x8001ec8] = 0x40021000
        0x08001e82:    6800        .h      LDR      r0,[r0,#0]
        0x08001e84:    f0400001    @...    ORR      r0,r0,#1
        0x08001e88:    490f        .I      LDR      r1,[pc,#60] ; [0x8001ec8] = 0x40021000
        0x08001e8a:    6008        .`      STR      r0,[r1,#0]
;;;180    
;;;181      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;182    #if !defined(STM32F105xC) && !defined(STM32F107xC)
;;;183      RCC->CFGR &= 0xF8FF0000U;
        0x08001e8c:    4608        .F      MOV      r0,r1
        0x08001e8e:    6840        @h      LDR      r0,[r0,#4]
        0x08001e90:    490e        .I      LDR      r1,[pc,#56] ; [0x8001ecc] = 0xf8ff0000
        0x08001e92:    4008        .@      ANDS     r0,r0,r1
        0x08001e94:    490c        .I      LDR      r1,[pc,#48] ; [0x8001ec8] = 0x40021000
        0x08001e96:    6048        H`      STR      r0,[r1,#4]
;;;184    #else
;;;185      RCC->CFGR &= 0xF0FF0000U;
;;;186    #endif /* STM32F105xC */   
;;;187      
;;;188      /* Reset HSEON, CSSON and PLLON bits */
;;;189      RCC->CR &= 0xFEF6FFFFU;
        0x08001e98:    4608        .F      MOV      r0,r1
        0x08001e9a:    6800        .h      LDR      r0,[r0,#0]
        0x08001e9c:    490c        .I      LDR      r1,[pc,#48] ; [0x8001ed0] = 0xfef6ffff
        0x08001e9e:    4008        .@      ANDS     r0,r0,r1
        0x08001ea0:    4909        .I      LDR      r1,[pc,#36] ; [0x8001ec8] = 0x40021000
        0x08001ea2:    6008        .`      STR      r0,[r1,#0]
;;;190    
;;;191      /* Reset HSEBYP bit */
;;;192      RCC->CR &= 0xFFFBFFFFU;
        0x08001ea4:    4608        .F      MOV      r0,r1
        0x08001ea6:    6800        .h      LDR      r0,[r0,#0]
        0x08001ea8:    f4202080     ..     BIC      r0,r0,#0x40000
        0x08001eac:    6008        .`      STR      r0,[r1,#0]
;;;193    
;;;194      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;195      RCC->CFGR &= 0xFF80FFFFU;
        0x08001eae:    4608        .F      MOV      r0,r1
        0x08001eb0:    6840        @h      LDR      r0,[r0,#4]
        0x08001eb2:    f42000fe     ...    BIC      r0,r0,#0x7f0000
        0x08001eb6:    6048        H`      STR      r0,[r1,#4]
;;;196    
;;;197    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;198      /* Reset PLL2ON and PLL3ON bits */
;;;199      RCC->CR &= 0xEBFFFFFFU;
;;;200    
;;;201      /* Disable all interrupts and clear pending bits  */
;;;202      RCC->CIR = 0x00FF0000U;
;;;203    
;;;204      /* Reset CFGR2 register */
;;;205      RCC->CFGR2 = 0x00000000U;
;;;206    #elif defined(STM32F100xB) || defined(STM32F100xE)
;;;207      /* Disable all interrupts and clear pending bits  */
;;;208      RCC->CIR = 0x009F0000U;
;;;209    
;;;210      /* Reset CFGR2 register */
;;;211      RCC->CFGR2 = 0x00000000U;      
;;;212    #else
;;;213      /* Disable all interrupts and clear pending bits  */
;;;214      RCC->CIR = 0x009F0000U;
        0x08001eb8:    f44f001f    O...    MOV      r0,#0x9f0000
        0x08001ebc:    6088        .`      STR      r0,[r1,#8]
;;;215    #endif /* STM32F105xC */
;;;216        
;;;217    #if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
;;;218      #ifdef DATA_IN_ExtSRAM
;;;219        SystemInit_ExtMemCtl(); 
;;;220      #endif /* DATA_IN_ExtSRAM */
;;;221    #endif 
;;;222    
;;;223    #ifdef VECT_TAB_SRAM
;;;224      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;225    #else
;;;226      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
        0x08001ebe:    03c8        ..      LSLS     r0,r1,#15
        0x08001ec0:    4904        .I      LDR      r1,[pc,#16] ; [0x8001ed4] = 0xe000ed08
        0x08001ec2:    6008        .`      STR      r0,[r1,#0]
;;;227    #endif 
;;;228    }
        0x08001ec4:    4770        pG      BX       lr
    $d
        0x08001ec6:    0000        ..      DCW    0
        0x08001ec8:    40021000    ...@    DCD    1073876992
        0x08001ecc:    f8ff0000    ....    DCD    4177461248
        0x08001ed0:    fef6ffff    ....    DCD    4277600255
        0x08001ed4:    e000ed08    ....    DCD    3758157064
    $t
    i.TIM1_UP_IRQHandler
    TIM1_UP_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;233    {
        0x08001ed8:    b510        ..      PUSH     {r4,lr}
;;;234      /* USER CODE BEGIN TIM1_UP_IRQn 0 */
;;;235    
;;;236      /* USER CODE END TIM1_UP_IRQn 0 */
;;;237      /* USER CODE BEGIN TIM1_UP_IRQn 1 */
;;;238      if(LL_TIM_IsActiveFlag_UPDATE(TIM1) == 1)
        0x08001eda:    4806        .H      LDR      r0,[pc,#24] ; [0x8001ef4] = 0x40012c00
        0x08001edc:    f7feffec    ....    BL       LL_TIM_IsActiveFlag_UPDATE ; 0x8000eb8
        0x08001ee0:    2801        .(      CMP      r0,#1
        0x08001ee2:    d105        ..      BNE      0x8001ef0 ; TIM1_UP_IRQHandler + 24
;;;239      {
;;;240        /* Clear the update interrupt flag*/
;;;241        LL_TIM_ClearFlag_UPDATE(TIM1);
        0x08001ee4:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001ee6:    1ec0        ..      SUBS     r0,r0,#3
        0x08001ee8:    4902        .I      LDR      r1,[pc,#8] ; [0x8001ef4] = 0x40012c00
        0x08001eea:    6108        .a      STR      r0,[r1,#0x10]
;;;2933   }
        0x08001eec:    bf00        ..      NOP      
        0x08001eee:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;245    }
        0x08001ef0:    bd10        ..      POP      {r4,pc}
    $d
        0x08001ef2:    0000        ..      DCW    0
        0x08001ef4:    40012c00    .,.@    DCD    1073818624
    $t
    i.TIM2_IRQHandler
    TIM2_IRQHandler
;;;246    
;;;247    /**
;;;248      * @brief This function handles TIM2 global interrupt.
;;;249      */
;;;250    void TIM2_IRQHandler(void)
;;;251    {
        0x08001ef8:    b510        ..      PUSH     {r4,lr}
;;;252      /* USER CODE BEGIN TIM2_IRQn 0 */
;;;253    // prescaler=((((speed=72000000)/((period=20000)/(1/hz=1)))+0,5)-1)
;;;254    //	if ( async_z == 1) {
;;;255    	if(TIM3->SMCR == 0x16) { // TIM3 connected to TIM2 as SLAVE
        0x08001efa:    480f        .H      LDR      r0,[pc,#60] ; [0x8001f38] = 0x40000408
        0x08001efc:    6800        .h      LDR      r0,[r0,#0]
        0x08001efe:    2816        .(      CMP      r0,#0x16
        0x08001f00:    d10c        ..      BNE      0x8001f1c ; TIM2_IRQHandler + 36
;;;256    //	if ( state.async_z == 1) {
;;;257    //		state.f_encoder = encoder;
;;;258    //		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
;;;259    //		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;260    //		LED_GPIO_Port->BRR = LED_Pin;
;;;261    //    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
;;;262    //    LL_GPIO_TogglePin( LED_GPIO_Port, LED_Pin);
;;;263    
;;;264    		state.function(&state);
        0x08001f02:    480e        .H      LDR      r0,[pc,#56] ; [0x8001f3c] = 0x20000044
        0x08001f04:    6801        .h      LDR      r1,[r0,#0]
        0x08001f06:    4788        .G      BLX      r1
;;;265    
;;;266    		TIM2->ARR = state.z_period;
        0x08001f08:    480c        .H      LDR      r0,[pc,#48] ; [0x8001f3c] = 0x20000044
        0x08001f0a:    7b00        .{      LDRB     r0,[r0,#0xc]
        0x08001f0c:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08001f10:    62c8        .b      STR      r0,[r1,#0x2c]
;;;267    		TIM2->EGR |= TIM_EGR_UG;
        0x08001f12:    4608        .F      MOV      r0,r1
        0x08001f14:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001f16:    f0400001    @...    ORR      r0,r0,#1
        0x08001f1a:    6148        Ha      STR      r0,[r1,#0x14]
;;;268    
;;;269    //		state.set_pulse_function(&state);
;;;270    //		text_buffer[tbc++] = TIM2->ARR;
;;;271    	}
;;;272    
;;;273      /* USER CODE END TIM2_IRQn 0 */
;;;274      /* USER CODE BEGIN TIM2_IRQn 1 */
;;;275      /* Check whether update interrupt is pending */
;;;276      if(LL_TIM_IsActiveFlag_UPDATE(TIM2) == 1)
        0x08001f1c:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08001f20:    f7feffca    ....    BL       LL_TIM_IsActiveFlag_UPDATE ; 0x8000eb8
        0x08001f24:    2801        .(      CMP      r0,#1
        0x08001f26:    d106        ..      BNE      0x8001f36 ; TIM2_IRQHandler + 62
;;;277      {
;;;278        /* Clear the update interrupt flag*/
;;;279        LL_TIM_ClearFlag_UPDATE(TIM2);
        0x08001f28:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001f2a:    1ec0        ..      SUBS     r0,r0,#3
        0x08001f2c:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08001f30:    6108        .a      STR      r0,[r1,#0x10]
;;;2933   }
        0x08001f32:    bf00        ..      NOP      
        0x08001f34:    bf00        ..      NOP      
;;; .\../Src/stm32f1xx_it.c
;;;282    }
        0x08001f36:    bd10        ..      POP      {r4,pc}
    $d
        0x08001f38:    40000408    ...@    DCD    1073742856
        0x08001f3c:    20000044    D..     DCD    536870980
    $t
    i.TIM3_IRQHandler
    TIM3_IRQHandler
;;;283    
;;;284    /**
;;;285      * @brief This function handles TIM3 global interrupt.
;;;286      */
;;;287    void TIM3_IRQHandler(void)
;;;288    {
;;;289      /* USER CODE BEGIN TIM3_IRQn 0 */
;;;290    
;;;291      /* USER CODE END TIM3_IRQn 0 */
;;;292      /* USER CODE BEGIN TIM3_IRQn 1 */
;;;293    
;;;294      /* USER CODE END TIM3_IRQn 1 */
;;;295    }
        0x08001f40:    4770        pG      BX       lr
        0x08001f42:    0000        ..      MOVS     r0,r0
    i.TIM4_IRQHandler
    TIM4_IRQHandler
;;;296    
;;;297    /**
;;;298      * @brief This function handles TIM4 global interrupt.
;;;299      */
;;;300    void TIM4_IRQHandler(void)
;;;301    {
        0x08001f44:    b510        ..      PUSH     {r4,lr}
;;;302      /* USER CODE BEGIN TIM4_IRQn 0 */
;;;303    //	_Bool dir = t4cr1[TIM_CR1_DIR_Pos];
;;;304    //	if(t4sr[TIM_SR_CC3IF_Pos]){
;;;305    //		do_fsm_wait_tacho(&state);
;;;306    //	}
;;;307    	if (state.sync == true) {
        0x08001f46:    480d        .H      LDR      r0,[pc,#52] ; [0x8001f7c] = 0x20000044
        0x08001f48:    7c00        .|      LDRB     r0,[r0,#0x10]
        0x08001f4a:    2801        .(      CMP      r0,#1
        0x08001f4c:    d112        ..      BNE      0x8001f74 ; TIM4_IRQHandler + 48
;;;308    		state.spindle_dir = t4cr1[TIM_CR1_DIR_Pos];
        0x08001f4e:    480c        .H      LDR      r0,[pc,#48] ; [0x8001f80] = 0x42010000
        0x08001f50:    6900        .i      LDR      r0,[r0,#0x10]
        0x08001f52:    b108        ..      CBZ      r0,0x8001f58 ; TIM4_IRQHandler + 20
        0x08001f54:    2001        .       MOVS     r0,#1
        0x08001f56:    e000        ..      B        0x8001f5a ; TIM4_IRQHandler + 22
        0x08001f58:    2000        .       MOVS     r0,#0
        0x08001f5a:    4908        .I      LDR      r1,[pc,#32] ; [0x8001f7c] = 0x20000044
        0x08001f5c:    73c8        .s      STRB     r0,[r1,#0xf]
;;;309    //		state.f_encoder = encoder;
;;;310    		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
        0x08001f5e:    4809        .H      LDR      r0,[pc,#36] ; [0x8001f84] = 0x4201020c
        0x08001f60:    6800        .h      LDR      r0,[r0,#0]
        0x08001f62:    b108        ..      CBZ      r0,0x8001f68 ; TIM4_IRQHandler + 36
        0x08001f64:    2001        .       MOVS     r0,#1
        0x08001f66:    e000        ..      B        0x8001f6a ; TIM4_IRQHandler + 38
        0x08001f68:    2000        .       MOVS     r0,#0
        0x08001f6a:    4904        .I      LDR      r1,[pc,#16] ; [0x8001f7c] = 0x20000044
        0x08001f6c:    7388        .s      STRB     r0,[r1,#0xe]
;;;311    		state.function(&state);
        0x08001f6e:    4608        .F      MOV      r0,r1
        0x08001f70:    6801        .h      LDR      r1,[r0,#0]
        0x08001f72:    4788        .G      BLX      r1
;;;312    	}
;;;313    //	TIM4->SR &= ~TIM_SR_UIF; //   . 
;;;314    
;;;315      /* USER CODE END TIM4_IRQn 0 */
;;;316      /* USER CODE BEGIN TIM4_IRQn 1 */
;;;317      /* Check whether update interrupt is pending */
;;;318    //	if(LL_TIM_IsActiveFlag_CC2OVR(TIM4) == 1){
;;;319    //		TIM4->SR = 0;
;;;320    //	}
;;;321    	TIM4->SR = 0;
        0x08001f74:    2000        .       MOVS     r0,#0
        0x08001f76:    4904        .I      LDR      r1,[pc,#16] ; [0x8001f88] = 0x40000810
        0x08001f78:    6008        .`      STR      r0,[r1,#0]
;;;322    /*
;;;323    	if(LL_TIM_IsActiveFlag_CC2(TIM4) == 1)
;;;324        LL_TIM_ClearFlag_CC2(TIM4);
;;;325    	if(LL_TIM_IsActiveFlag_CC3(TIM4) == 1)
;;;326        LL_TIM_ClearFlag_CC3(TIM4);
;;;327    	if(LL_TIM_IsActiveFlag_UPDATE(TIM4) == 1)
;;;328      {
;;;329        LL_TIM_ClearFlag_UPDATE(TIM4); //Clear the update interrupt flag
;;;330      }
;;;331    */
;;;332      /* USER CODE END TIM4_IRQn 1 */
;;;333    }
        0x08001f7a:    bd10        ..      POP      {r4,pc}
    $d
        0x08001f7c:    20000044    D..     DCD    536870980
        0x08001f80:    42010000    ...B    DCD    1107361792
        0x08001f84:    4201020c    ...B    DCD    1107362316
        0x08001f88:    40000810    ...@    DCD    1073743888
    $t
    i.Transfer_Complete_Callback
    Transfer_Complete_Callback
;;; .\..\Src\i2c_interface.c
;;;321    {
        0x08001f8c:    b510        ..      PUSH     {r4,lr}
;;;322      /* Generate Stop condition */
;;;323    	while(!LL_I2C_IsActiveFlag_BTF(I2C2))
        0x08001f8e:    bf00        ..      NOP      
        0x08001f90:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
        0x08001f92:    480f        .H      LDR      r0,[pc,#60] ; [0x8001fd0] = 0x40005800
        0x08001f94:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001f96:    f3c00080    ....    UBFX     r0,r0,#2,#1
        0x08001f9a:    2800        .(      CMP      r0,#0
        0x08001f9c:    d0f8        ..      BEQ      0x8001f90 ; Transfer_Complete_Callback + 4
;;; .\..\Src\i2c_interface.c
;;;326      LL_I2C_GenerateStopCondition(I2C2);
        0x08001f9e:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1596     SET_BIT(I2Cx->CR1, I2C_CR1_STOP);
        0x08001fa0:    480b        .H      LDR      r0,[pc,#44] ; [0x8001fd0] = 0x40005800
        0x08001fa2:    6800        .h      LDR      r0,[r0,#0]
        0x08001fa4:    f4407000    @..p    ORR      r0,r0,#0x200
        0x08001fa8:    4909        .I      LDR      r1,[pc,#36] ; [0x8001fd0] = 0x40005800
        0x08001faa:    6008        .`      STR      r0,[r1,#0]
;;;1597   }
        0x08001fac:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;327      LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x08001fae:    4809        .H      LDR      r0,[pc,#36] ; [0x8001fd4] = 0x40020000
        0x08001fb0:    2104        .!      MOVS     r1,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;491      CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x08001fb2:    1e4a        J.      SUBS     r2,r1,#1
        0x08001fb4:    4b08        .K      LDR      r3,[pc,#32] ; [0x8001fd8] = 0x80031b8
        0x08001fb6:    5c9a        .\      LDRB     r2,[r3,r2]
        0x08001fb8:    5882        .X      LDR      r2,[r0,r2]
        0x08001fba:    f0220301    "...    BIC      r3,r2,#1
        0x08001fbe:    1e4a        J.      SUBS     r2,r1,#1
        0x08001fc0:    4c05        .L      LDR      r4,[pc,#20] ; [0x8001fd8] = 0x80031b8
        0x08001fc2:    5ca2        .\      LDRB     r2,[r4,r2]
        0x08001fc4:    5083        .P      STR      r3,[r0,r2]
;;;492    }
        0x08001fc6:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;329      ubTransferComplete = 1;
        0x08001fc8:    2001        .       MOVS     r0,#1
        0x08001fca:    4904        .I      LDR      r1,[pc,#16] ; [0x8001fdc] = 0x20000017
        0x08001fcc:    7008        .p      STRB     r0,[r1,#0]
;;;330    }
        0x08001fce:    bd10        ..      POP      {r4,pc}
    $d
        0x08001fd0:    40005800    .X.@    DCD    1073764352
        0x08001fd4:    40020000    ...@    DCD    1073872896
        0x08001fd8:    080031b8    .1..    DCD    134230456
        0x08001fdc:    20000017    ...     DCD    536870935
    $t
    i.Transfer_Error_Callback
    Transfer_Error_Callback
;;;331    
;;;332    /**
;;;333      * @brief  DMA transfer error callback
;;;334      * @note   This function is executed when the transfer error interrupt
;;;335      *         is generated during DMA transfer
;;;336      * @retval None
;;;337      */
;;;338    void Transfer_Error_Callback()
;;;339    {
;;;340      /* Disable DMA1_Channel4_IRQn */
;;;341      NVIC_DisableIRQ(DMA1_Channel4_IRQn);
        0x08001fe0:    200e        .       MOVS     r0,#0xe
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08001fe2:    2101        .!      MOVS     r1,#1
        0x08001fe4:    4081        .@      LSLS     r1,r1,r0
        0x08001fe6:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001ff4] = 0xe000e180
        0x08001fe8:    0943        C.      LSRS     r3,r0,#5
        0x08001fea:    f8421023    B.#.    STR      r1,[r2,r3,LSL #2]
;;;1466   }
        0x08001fee:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c
;;;343      while(1){};
        0x08001ff0:    bf00        ..      NOP      
;;; .\..\Src\i2c_interface.c (343)
        0x08001ff2:    e7fe        ..      B        0x8001ff2 ; Transfer_Error_Callback + 18
    $d
        0x08001ff4:    e000e180    ....    DCD    3758154112
    $t
    i.USART2_IRQHandler
    USART2_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;384    {
        0x08001ff8:    b510        ..      PUSH     {r4,lr}
;;;385      /* USER CODE BEGIN USART2_IRQn 0 */
;;;386      if(LL_USART_IsActiveFlag_RXNE(USART2) && LL_USART_IsEnabledIT_RXNE(USART2))
        0x08001ffa:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1859     return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
        0x08001ffc:    4806        .H      LDR      r0,[pc,#24] ; [0x8002018] = 0x40004400
        0x08001ffe:    6800        .h      LDR      r0,[r0,#0]
        0x08002000:    f3c01040    ..@.    UBFX     r0,r0,#5,#1
        0x08002004:    b138        8.      CBZ      r0,0x8002016 ; USART2_IRQHandler + 30
        0x08002006:    bf00        ..      NOP      
;;;1860   }
;;;1861   
;;;1862   /**
;;;1863     * @brief  Check if the USART Transmission Complete Flag is set or not
;;;1864     * @rmtoll SR           TC            LL_USART_IsActiveFlag_TC
;;;1865     * @param  USARTx USART Instance
;;;1866     * @retval State of bit (1 or 0).
;;;1867     */
;;;1868   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *USARTx)
;;;1869   {
;;;1870     return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
;;;1871   }
;;;1872   
;;;1873   /**
;;;1874     * @brief  Check if the USART Transmit Data Register Empty Flag is set or not
;;;1875     * @rmtoll SR           TXE           LL_USART_IsActiveFlag_TXE
;;;1876     * @param  USARTx USART Instance
;;;1877     * @retval State of bit (1 or 0).
;;;1878     */
;;;1879   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
;;;1880   {
;;;1881     return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
;;;1882   }
;;;1883   
;;;1884   /**
;;;1885     * @brief  Check if the USART LIN Break Detection Flag is set or not
;;;1886     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;1887     *         LIN feature is supported by the USARTx instance.
;;;1888     * @rmtoll SR           LBD           LL_USART_IsActiveFlag_LBD
;;;1889     * @param  USARTx USART Instance
;;;1890     * @retval State of bit (1 or 0).
;;;1891     */
;;;1892   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_LBD(USART_TypeDef *USARTx)
;;;1893   {
;;;1894     return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
;;;1895   }
;;;1896   
;;;1897   /**
;;;1898     * @brief  Check if the USART CTS Flag is set or not
;;;1899     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;1900     *         Hardware Flow control feature is supported by the USARTx instance.
;;;1901     * @rmtoll SR           CTS           LL_USART_IsActiveFlag_nCTS
;;;1902     * @param  USARTx USART Instance
;;;1903     * @retval State of bit (1 or 0).
;;;1904     */
;;;1905   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_nCTS(USART_TypeDef *USARTx)
;;;1906   {
;;;1907     return (READ_BIT(USARTx->SR, USART_SR_CTS) == (USART_SR_CTS));
;;;1908   }
;;;1909   
;;;1910   /**
;;;1911     * @brief  Check if the USART Send Break Flag is set or not
;;;1912     * @rmtoll CR1          SBK           LL_USART_IsActiveFlag_SBK
;;;1913     * @param  USARTx USART Instance
;;;1914     * @retval State of bit (1 or 0).
;;;1915     */
;;;1916   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_SBK(USART_TypeDef *USARTx)
;;;1917   {
;;;1918     return (READ_BIT(USARTx->CR1, USART_CR1_SBK) == (USART_CR1_SBK));
;;;1919   }
;;;1920   
;;;1921   /**
;;;1922     * @brief  Check if the USART Receive Wake Up from mute mode Flag is set or not
;;;1923     * @rmtoll CR1          RWU           LL_USART_IsActiveFlag_RWU
;;;1924     * @param  USARTx USART Instance
;;;1925     * @retval State of bit (1 or 0).
;;;1926     */
;;;1927   __STATIC_INLINE uint32_t LL_USART_IsActiveFlag_RWU(USART_TypeDef *USARTx)
;;;1928   {
;;;1929     return (READ_BIT(USARTx->CR1, USART_CR1_RWU) == (USART_CR1_RWU));
;;;1930   }
;;;1931   
;;;1932   /**
;;;1933     * @brief  Clear Parity Error Flag
;;;1934     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1935     *         register followed by a read access to the USARTx_DR register.
;;;1936     * @note   Please also consider that when clearing this flag, other flags as 
;;;1937     *         NE, FE, ORE, IDLE would also be cleared.
;;;1938     * @rmtoll SR           PE            LL_USART_ClearFlag_PE
;;;1939     * @param  USARTx USART Instance
;;;1940     * @retval None
;;;1941     */
;;;1942   __STATIC_INLINE void LL_USART_ClearFlag_PE(USART_TypeDef *USARTx)
;;;1943   {
;;;1944     __IO uint32_t tmpreg;
;;;1945     tmpreg = USARTx->SR;
;;;1946     (void) tmpreg;
;;;1947     tmpreg = USARTx->DR;
;;;1948     (void) tmpreg;
;;;1949   }
;;;1950   
;;;1951   /**
;;;1952     * @brief  Clear Framing Error Flag
;;;1953     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1954     *         register followed by a read access to the USARTx_DR register.
;;;1955     * @note   Please also consider that when clearing this flag, other flags as 
;;;1956     *         PE, NE, ORE, IDLE would also be cleared.
;;;1957     * @rmtoll SR           FE            LL_USART_ClearFlag_FE
;;;1958     * @param  USARTx USART Instance
;;;1959     * @retval None
;;;1960     */
;;;1961   __STATIC_INLINE void LL_USART_ClearFlag_FE(USART_TypeDef *USARTx)
;;;1962   {
;;;1963     __IO uint32_t tmpreg;
;;;1964     tmpreg = USARTx->SR;
;;;1965     (void) tmpreg;
;;;1966     tmpreg = USARTx->DR;
;;;1967     (void) tmpreg;
;;;1968   }
;;;1969   
;;;1970   /**
;;;1971     * @brief  Clear Noise detected Flag
;;;1972     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1973     *         register followed by a read access to the USARTx_DR register.
;;;1974     * @note   Please also consider that when clearing this flag, other flags as 
;;;1975     *         PE, FE, ORE, IDLE would also be cleared.
;;;1976     * @rmtoll SR           NF            LL_USART_ClearFlag_NE
;;;1977     * @param  USARTx USART Instance
;;;1978     * @retval None
;;;1979     */
;;;1980   __STATIC_INLINE void LL_USART_ClearFlag_NE(USART_TypeDef *USARTx)
;;;1981   {
;;;1982     __IO uint32_t tmpreg;
;;;1983     tmpreg = USARTx->SR;
;;;1984     (void) tmpreg;
;;;1985     tmpreg = USARTx->DR;
;;;1986     (void) tmpreg;
;;;1987   }
;;;1988   
;;;1989   /**
;;;1990     * @brief  Clear OverRun Error Flag
;;;1991     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;1992     *         register followed by a read access to the USARTx_DR register.
;;;1993     * @note   Please also consider that when clearing this flag, other flags as 
;;;1994     *         PE, NE, FE, IDLE would also be cleared.
;;;1995     * @rmtoll SR           ORE           LL_USART_ClearFlag_ORE
;;;1996     * @param  USARTx USART Instance
;;;1997     * @retval None
;;;1998     */
;;;1999   __STATIC_INLINE void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
;;;2000   {
;;;2001     __IO uint32_t tmpreg;
;;;2002     tmpreg = USARTx->SR;
;;;2003     (void) tmpreg;
;;;2004     tmpreg = USARTx->DR;
;;;2005     (void) tmpreg;
;;;2006   }
;;;2007   
;;;2008   /**
;;;2009     * @brief  Clear IDLE line detected Flag
;;;2010     * @note   Clearing this flag is done by a read access to the USARTx_SR
;;;2011     *         register followed by a read access to the USARTx_DR register.
;;;2012     * @note   Please also consider that when clearing this flag, other flags as 
;;;2013     *         PE, NE, FE, ORE would also be cleared.
;;;2014     * @rmtoll SR           IDLE          LL_USART_ClearFlag_IDLE
;;;2015     * @param  USARTx USART Instance
;;;2016     * @retval None
;;;2017     */
;;;2018   __STATIC_INLINE void LL_USART_ClearFlag_IDLE(USART_TypeDef *USARTx)
;;;2019   {
;;;2020     __IO uint32_t tmpreg;
;;;2021     tmpreg = USARTx->SR;
;;;2022     (void) tmpreg;
;;;2023     tmpreg = USARTx->DR;
;;;2024     (void) tmpreg;
;;;2025   }
;;;2026   
;;;2027   /**
;;;2028     * @brief  Clear Transmission Complete Flag
;;;2029     * @rmtoll SR           TC            LL_USART_ClearFlag_TC
;;;2030     * @param  USARTx USART Instance
;;;2031     * @retval None
;;;2032     */
;;;2033   __STATIC_INLINE void LL_USART_ClearFlag_TC(USART_TypeDef *USARTx)
;;;2034   {
;;;2035     WRITE_REG(USARTx->SR , ~(USART_SR_TC));
;;;2036   }
;;;2037   
;;;2038   /**
;;;2039     * @brief  Clear RX Not Empty Flag
;;;2040     * @rmtoll SR           RXNE          LL_USART_ClearFlag_RXNE
;;;2041     * @param  USARTx USART Instance
;;;2042     * @retval None
;;;2043     */
;;;2044   __STATIC_INLINE void LL_USART_ClearFlag_RXNE(USART_TypeDef *USARTx)
;;;2045   {
;;;2046     WRITE_REG(USARTx->SR , ~(USART_SR_RXNE));
;;;2047   }
;;;2048   
;;;2049   /**
;;;2050     * @brief  Clear LIN Break Detection Flag
;;;2051     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2052     *         LIN feature is supported by the USARTx instance.
;;;2053     * @rmtoll SR           LBD           LL_USART_ClearFlag_LBD
;;;2054     * @param  USARTx USART Instance
;;;2055     * @retval None
;;;2056     */
;;;2057   __STATIC_INLINE void LL_USART_ClearFlag_LBD(USART_TypeDef *USARTx)
;;;2058   {
;;;2059     WRITE_REG(USARTx->SR , ~(USART_SR_LBD));
;;;2060   }
;;;2061   
;;;2062   /**
;;;2063     * @brief  Clear CTS Interrupt Flag
;;;2064     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;2065     *         Hardware Flow control feature is supported by the USARTx instance.
;;;2066     * @rmtoll SR           CTS           LL_USART_ClearFlag_nCTS
;;;2067     * @param  USARTx USART Instance
;;;2068     * @retval None
;;;2069     */
;;;2070   __STATIC_INLINE void LL_USART_ClearFlag_nCTS(USART_TypeDef *USARTx)
;;;2071   {
;;;2072     WRITE_REG(USARTx->SR , ~(USART_SR_CTS));
;;;2073   }
;;;2074   
;;;2075   /**
;;;2076     * @}
;;;2077     */
;;;2078   
;;;2079   /** @defgroup USART_LL_EF_IT_Management IT_Management
;;;2080     * @{
;;;2081     */
;;;2082   
;;;2083   /**
;;;2084     * @brief  Enable IDLE Interrupt
;;;2085     * @rmtoll CR1          IDLEIE        LL_USART_EnableIT_IDLE
;;;2086     * @param  USARTx USART Instance
;;;2087     * @retval None
;;;2088     */
;;;2089   __STATIC_INLINE void LL_USART_EnableIT_IDLE(USART_TypeDef *USARTx)
;;;2090   {
;;;2091     SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @brief  Enable RX Not Empty Interrupt
;;;2096     * @rmtoll CR1          RXNEIE        LL_USART_EnableIT_RXNE
;;;2097     * @param  USARTx USART Instance
;;;2098     * @retval None
;;;2099     */
;;;2100   __STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
;;;2101   {
;;;2102     SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
;;;2103   }
;;;2104   
;;;2105   /**
;;;2106     * @brief  Enable Transmission Complete Interrupt
;;;2107     * @rmtoll CR1          TCIE          LL_USART_EnableIT_TC
;;;2108     * @param  USARTx USART Instance
;;;2109     * @retval None
;;;2110     */
;;;2111   __STATIC_INLINE void LL_USART_EnableIT_TC(USART_TypeDef *USARTx)
;;;2112   {
;;;2113     SET_BIT(USARTx->CR1, USART_CR1_TCIE);
;;;2114   }
;;;2115   
;;;2116   /**
;;;2117     * @brief  Enable TX Empty Interrupt
;;;2118     * @rmtoll CR1          TXEIE         LL_USART_EnableIT_TXE
;;;2119     * @param  USARTx USART Instance
;;;2120     * @retval None
;;;2121     */
;;;2122   __STATIC_INLINE void LL_USART_EnableIT_TXE(USART_TypeDef *USARTx)
;;;2123   {
;;;2124     SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
;;;2125   }
;;;2126   
;;;2127   /**
;;;2128     * @brief  Enable Parity Error Interrupt
;;;2129     * @rmtoll CR1          PEIE          LL_USART_EnableIT_PE
;;;2130     * @param  USARTx USART Instance
;;;2131     * @retval None
;;;2132     */
;;;2133   __STATIC_INLINE void LL_USART_EnableIT_PE(USART_TypeDef *USARTx)
;;;2134   {
;;;2135     SET_BIT(USARTx->CR1, USART_CR1_PEIE);
;;;2136   }
;;;2137   
;;;2138   /**
;;;2139     * @brief  Enable LIN Break Detection Interrupt
;;;2140     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2141     *         LIN feature is supported by the USARTx instance.
;;;2142     * @rmtoll CR2          LBDIE         LL_USART_EnableIT_LBD
;;;2143     * @param  USARTx USART Instance
;;;2144     * @retval None
;;;2145     */
;;;2146   __STATIC_INLINE void LL_USART_EnableIT_LBD(USART_TypeDef *USARTx)
;;;2147   {
;;;2148     SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
;;;2149   }
;;;2150   
;;;2151   /**
;;;2152     * @brief  Enable Error Interrupt
;;;2153     * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
;;;2154     *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register).
;;;2155     *           0: Interrupt is inhibited
;;;2156     *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.
;;;2157     * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
;;;2158     * @param  USARTx USART Instance
;;;2159     * @retval None
;;;2160     */
;;;2161   __STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
;;;2162   {
;;;2163     SET_BIT(USARTx->CR3, USART_CR3_EIE);
;;;2164   }
;;;2165   
;;;2166   /**
;;;2167     * @brief  Enable CTS Interrupt
;;;2168     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;2169     *         Hardware Flow control feature is supported by the USARTx instance.
;;;2170     * @rmtoll CR3          CTSIE         LL_USART_EnableIT_CTS
;;;2171     * @param  USARTx USART Instance
;;;2172     * @retval None
;;;2173     */
;;;2174   __STATIC_INLINE void LL_USART_EnableIT_CTS(USART_TypeDef *USARTx)
;;;2175   {
;;;2176     SET_BIT(USARTx->CR3, USART_CR3_CTSIE);
;;;2177   }
;;;2178   
;;;2179   /**
;;;2180     * @brief  Disable IDLE Interrupt
;;;2181     * @rmtoll CR1          IDLEIE        LL_USART_DisableIT_IDLE
;;;2182     * @param  USARTx USART Instance
;;;2183     * @retval None
;;;2184     */
;;;2185   __STATIC_INLINE void LL_USART_DisableIT_IDLE(USART_TypeDef *USARTx)
;;;2186   {
;;;2187     CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
;;;2188   }
;;;2189   
;;;2190   /**
;;;2191     * @brief  Disable RX Not Empty Interrupt
;;;2192     * @rmtoll CR1          RXNEIE        LL_USART_DisableIT_RXNE
;;;2193     * @param  USARTx USART Instance
;;;2194     * @retval None
;;;2195     */
;;;2196   __STATIC_INLINE void LL_USART_DisableIT_RXNE(USART_TypeDef *USARTx)
;;;2197   {
;;;2198     CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
;;;2199   }
;;;2200   
;;;2201   /**
;;;2202     * @brief  Disable Transmission Complete Interrupt
;;;2203     * @rmtoll CR1          TCIE          LL_USART_DisableIT_TC
;;;2204     * @param  USARTx USART Instance
;;;2205     * @retval None
;;;2206     */
;;;2207   __STATIC_INLINE void LL_USART_DisableIT_TC(USART_TypeDef *USARTx)
;;;2208   {
;;;2209     CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
;;;2210   }
;;;2211   
;;;2212   /**
;;;2213     * @brief  Disable TX Empty Interrupt
;;;2214     * @rmtoll CR1          TXEIE         LL_USART_DisableIT_TXE
;;;2215     * @param  USARTx USART Instance
;;;2216     * @retval None
;;;2217     */
;;;2218   __STATIC_INLINE void LL_USART_DisableIT_TXE(USART_TypeDef *USARTx)
;;;2219   {
;;;2220     CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE);
;;;2221   }
;;;2222   
;;;2223   /**
;;;2224     * @brief  Disable Parity Error Interrupt
;;;2225     * @rmtoll CR1          PEIE          LL_USART_DisableIT_PE
;;;2226     * @param  USARTx USART Instance
;;;2227     * @retval None
;;;2228     */
;;;2229   __STATIC_INLINE void LL_USART_DisableIT_PE(USART_TypeDef *USARTx)
;;;2230   {
;;;2231     CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
;;;2232   }
;;;2233   
;;;2234   /**
;;;2235     * @brief  Disable LIN Break Detection Interrupt
;;;2236     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2237     *         LIN feature is supported by the USARTx instance.
;;;2238     * @rmtoll CR2          LBDIE         LL_USART_DisableIT_LBD
;;;2239     * @param  USARTx USART Instance
;;;2240     * @retval None
;;;2241     */
;;;2242   __STATIC_INLINE void LL_USART_DisableIT_LBD(USART_TypeDef *USARTx)
;;;2243   {
;;;2244     CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
;;;2245   }
;;;2246   
;;;2247   /**
;;;2248     * @brief  Disable Error Interrupt
;;;2249     * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
;;;2250     *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register).
;;;2251     *           0: Interrupt is inhibited
;;;2252     *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.
;;;2253     * @rmtoll CR3          EIE           LL_USART_DisableIT_ERROR
;;;2254     * @param  USARTx USART Instance
;;;2255     * @retval None
;;;2256     */
;;;2257   __STATIC_INLINE void LL_USART_DisableIT_ERROR(USART_TypeDef *USARTx)
;;;2258   {
;;;2259     CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
;;;2260   }
;;;2261   
;;;2262   /**
;;;2263     * @brief  Disable CTS Interrupt
;;;2264     * @note   Macro @ref IS_UART_HWFLOW_INSTANCE(USARTx) can be used to check whether or not
;;;2265     *         Hardware Flow control feature is supported by the USARTx instance.
;;;2266     * @rmtoll CR3          CTSIE         LL_USART_DisableIT_CTS
;;;2267     * @param  USARTx USART Instance
;;;2268     * @retval None
;;;2269     */
;;;2270   __STATIC_INLINE void LL_USART_DisableIT_CTS(USART_TypeDef *USARTx)
;;;2271   {
;;;2272     CLEAR_BIT(USARTx->CR3, USART_CR3_CTSIE);
;;;2273   }
;;;2274   
;;;2275   /**
;;;2276     * @brief  Check if the USART IDLE Interrupt  source is enabled or disabled.
;;;2277     * @rmtoll CR1          IDLEIE        LL_USART_IsEnabledIT_IDLE
;;;2278     * @param  USARTx USART Instance
;;;2279     * @retval State of bit (1 or 0).
;;;2280     */
;;;2281   __STATIC_INLINE uint32_t LL_USART_IsEnabledIT_IDLE(USART_TypeDef *USARTx)
;;;2282   {
;;;2283     return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
;;;2284   }
;;;2285   
;;;2286   /**
;;;2287     * @brief  Check if the USART RX Not Empty Interrupt is enabled or disabled.
;;;2288     * @rmtoll CR1          RXNEIE        LL_USART_IsEnabledIT_RXNE
;;;2289     * @param  USARTx USART Instance
;;;2290     * @retval State of bit (1 or 0).
;;;2291     */
;;;2292   __STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXNE(USART_TypeDef *USARTx)
;;;2293   {
;;;2294     return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
        0x08002008:    4803        .H      LDR      r0,[pc,#12] ; [0x8002018] = 0x40004400
        0x0800200a:    68c0        .h      LDR      r0,[r0,#0xc]
        0x0800200c:    f3c01040    ..@.    UBFX     r0,r0,#5,#1
        0x08002010:    b108        ..      CBZ      r0,0x8002016 ; USART2_IRQHandler + 30
;;; .\../Src/stm32f1xx_it.c
;;;390        USART_CharReception_Callback();
        0x08002012:    f000f803    ....    BL       USART_CharReception_Callback ; 0x800201c
;;;391      }
;;;392      /* USER CODE END USART2_IRQn 0 */
;;;393      /* USER CODE BEGIN USART2_IRQn 1 */
;;;394    
;;;395      /* USER CODE END USART2_IRQn 1 */
;;;396    }
        0x08002016:    bd10        ..      POP      {r4,pc}
    $d
        0x08002018:    40004400    .D.@    DCD    1073759232
    $t
    i.USART_CharReception_Callback
    USART_CharReception_Callback
;;; .\../Src/main.c
;;;223    {
        0x0800201c:    b510        ..      PUSH     {r4,lr}
;;;224    	uint8_t *ptemp;
;;;225      /* Read Received character. RXNE flag is cleared by reading of DR register */
;;;226    	uint8_t symbol = LL_USART_ReceiveData8(USART2);
        0x0800201e:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2470     return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
        0x08002020:    4a0e        .J      LDR      r2,[pc,#56] ; [0x800205c] = 0x40004400
        0x08002022:    6852        Rh      LDR      r2,[r2,#4]
        0x08002024:    b2d2        ..      UXTB     r2,r2
        0x08002026:    4611        .F      MOV      r1,r2
;;; .\../Src/main.c
;;;227    	if(symbol == '\n'){
        0x08002028:    290a        .)      CMP      r1,#0xa
        0x0800202a:    d10e        ..      BNE      0x800204a ; USART_CharReception_Callback + 46
;;;228        /* Set Buffer swap indication */
;;;229    		ubUART2ReceptionComplete = 1;
        0x0800202c:    2201        ."      MOVS     r2,#1
        0x0800202e:    4b0c        .K      LDR      r3,[pc,#48] ; [0x8002060] = 0x200004ec
        0x08002030:    701a        .p      STRB     r2,[r3,#0]
;;;230    
;;;231        /* Swap buffers for next bytes to be received */
;;;232        ptemp = pBufferReadyForUser;
        0x08002032:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8002064] = 0x200004e4
        0x08002034:    6810        .h      LDR      r0,[r2,#0]
;;;233        pBufferReadyForUser = pBufferReadyForReception;
        0x08002036:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8002068] = 0x200004e8
        0x08002038:    6812        .h      LDR      r2,[r2,#0]
        0x0800203a:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8002064] = 0x200004e4
        0x0800203c:    601a        .`      STR      r2,[r3,#0]
;;;234        pBufferReadyForReception = ptemp;
        0x0800203e:    4a0a        .J      LDR      r2,[pc,#40] ; [0x8002068] = 0x200004e8
        0x08002040:    6010        .`      STR      r0,[r2,#0]
;;;235        uwNbReceivedChars = 0;
        0x08002042:    2200        ."      MOVS     r2,#0
        0x08002044:    4b09        .K      LDR      r3,[pc,#36] ; [0x800206c] = 0x200004dc
        0x08002046:    601a        .`      STR      r2,[r3,#0]
        0x08002048:    e007        ..      B        0x800205a ; USART_CharReception_Callback + 62
;;;236    	} else {
;;;237    		pBufferReadyForReception[uwNbReceivedChars++] = symbol;
        0x0800204a:    4b08        .K      LDR      r3,[pc,#32] ; [0x800206c] = 0x200004dc
        0x0800204c:    681a        .h      LDR      r2,[r3,#0]
        0x0800204e:    1c53        S.      ADDS     r3,r2,#1
        0x08002050:    4c06        .L      LDR      r4,[pc,#24] ; [0x800206c] = 0x200004dc
        0x08002052:    6023        #`      STR      r3,[r4,#0]
        0x08002054:    4b04        .K      LDR      r3,[pc,#16] ; [0x8002068] = 0x200004e8
        0x08002056:    681b        .h      LDR      r3,[r3,#0]
        0x08002058:    5499        .T      STRB     r1,[r3,r2]
;;;238    	}
;;;239    }
        0x0800205a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800205c:    40004400    .D.@    DCD    1073759232
        0x08002060:    200004ec    ...     DCD    536872172
        0x08002064:    200004e4    ...     DCD    536872164
        0x08002068:    200004e8    ...     DCD    536872168
        0x0800206c:    200004dc    ...     DCD    536872156
    $t
    i.__scatterload_copy
    __scatterload_copy
        0x08002070:    e002        ..      B        0x8002078 ; __scatterload_copy + 8
        0x08002072:    c808        ..      LDM      r0!,{r3}
        0x08002074:    1f12        ..      SUBS     r2,r2,#4
        0x08002076:    c108        ..      STM      r1!,{r3}
        0x08002078:    2a00        .*      CMP      r2,#0
        0x0800207a:    d1fa        ..      BNE      0x8002072 ; __scatterload_copy + 2
        0x0800207c:    4770        pG      BX       lr
    i.__scatterload_null
    __scatterload_null
        0x0800207e:    4770        pG      BX       lr
    i.__scatterload_zeroinit
    __scatterload_zeroinit
        0x08002080:    2000        .       MOVS     r0,#0
        0x08002082:    e001        ..      B        0x8002088 ; __scatterload_zeroinit + 8
        0x08002084:    c101        ..      STM      r1!,{r0}
        0x08002086:    1f12        ..      SUBS     r2,r2,#4
        0x08002088:    2a00        .*      CMP      r2,#0
        0x0800208a:    d1fb        ..      BNE      0x8002084 ; __scatterload_zeroinit + 4
        0x0800208c:    4770        pG      BX       lr
        0x0800208e:    0000        ..      MOVS     r0,r0
    i.do_fsm_menu
    do_fsm_menu
;;; .\..\Src\fsm.c
;;;69     {
        0x08002090:    b570        p.      PUSH     {r4-r6,lr}
        0x08002092:    4604        .F      MOV      r4,r0
;;;70     	uint8_t level = Thread_Info[Menu_Step].level;
        0x08002094:    4875        uH      LDR      r0,[pc,#468] ; [0x800226c] = 0x200000b4
        0x08002096:    4976        vI      LDR      r1,[pc,#472] ; [0x8002270] = 0x200004d4
        0x08002098:    7809        .x      LDRB     r1,[r1,#0]
        0x0800209a:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x0800209e:    7c45        E|      LDRB     r5,[r0,#0x11]
;;;71     #ifdef _SIMU
;;;72     	buttons_flag_set = long_press_start_Msk;
        0x080020a0:    2001        .       MOVS     r0,#1
        0x080020a2:    4974        tI      LDR      r1,[pc,#464] ; [0x8002274] = 0x200005dc
        0x080020a4:    6008        .`      STR      r0,[r1,#0]
;;;73     #endif	
;;;74     	switch(buttons_flag_set) {
        0x080020a6:    4608        .F      MOV      r0,r1
        0x080020a8:    6800        .h      LDR      r0,[r0,#0]
        0x080020aa:    2808        .(      CMP      r0,#8
        0x080020ac:    d077        w.      BEQ      0x800219e ; do_fsm_menu + 270
        0x080020ae:    dc06        ..      BGT      0x80020be ; do_fsm_menu + 46
        0x080020b0:    2801        .(      CMP      r0,#1
        0x080020b2:    d07f        ..      BEQ      0x80021b4 ; do_fsm_menu + 292
        0x080020b4:    2802        .(      CMP      r0,#2
        0x080020b6:    d070        p.      BEQ      0x800219a ; do_fsm_menu + 266
        0x080020b8:    2804        .(      CMP      r0,#4
        0x080020ba:    d110        ..      BNE      0x80020de ; do_fsm_menu + 78
        0x080020bc:    e01a        ..      B        0x80020f4 ; do_fsm_menu + 100
        0x080020be:    2811        .(      CMP      r0,#0x11
        0x080020c0:    d077        w.      BEQ      0x80021b2 ; do_fsm_menu + 290
        0x080020c2:    2840        @(      CMP      r0,#0x40
        0x080020c4:    d00c        ..      BEQ      0x80020e0 ; do_fsm_menu + 80
        0x080020c6:    f5b06f80    ...o    CMP      r0,#0x400
        0x080020ca:    d1f6        ..      BNE      0x80020ba ; do_fsm_menu + 42
;;;75     	case single_click_Msk3: {
;;;76     		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x080020cc:    486a        jH      LDR      r0,[pc,#424] ; [0x8002278] = 0x200000a1
        0x080020ce:    7800        .x      LDRB     r0,[r0,#0]
        0x080020d0:    f0800001    ....    EOR      r0,r0,#1
        0x080020d4:    4968        hI      LDR      r1,[pc,#416] ; [0x8002278] = 0x200000a1
        0x080020d6:    7008        .p      STRB     r0,[r1,#0]
;;;77     		menu_changed = 1;
        0x080020d8:    2001        .       MOVS     r0,#1
        0x080020da:    4968        hI      LDR      r1,[pc,#416] ; [0x800227c] = 0x200000a4
        0x080020dc:    6008        .`      STR      r0,[r1,#0]
;;;78     		break;
        0x080020de:    e0c3        ..      B        0x8002268 ; do_fsm_menu + 472
;;;79     	}
;;;80     	case single_click_Msk2: {
;;;81     		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x080020e0:    4865        eH      LDR      r0,[pc,#404] ; [0x8002278] = 0x200000a1
        0x080020e2:    7800        .x      LDRB     r0,[r0,#0]
        0x080020e4:    f0800001    ....    EOR      r0,r0,#1
        0x080020e8:    4963        cI      LDR      r1,[pc,#396] ; [0x8002278] = 0x200000a1
        0x080020ea:    7008        .p      STRB     r0,[r1,#0]
;;;82     		menu_changed = 1;
        0x080020ec:    2001        .       MOVS     r0,#1
        0x080020ee:    4963        cI      LDR      r1,[pc,#396] ; [0x800227c] = 0x200000a4
        0x080020f0:    6008        .`      STR      r0,[r1,#0]
;;;83     		break;
        0x080020f2:    e0b9        ..      B        0x8002268 ; do_fsm_menu + 472
;;;84     	}
;;;85     	case single_click_Msk: {
;;;86     		if(z_axis.end_pos != 0) {
        0x080020f4:    4862        bH      LDR      r0,[pc,#392] ; [0x8002280] = 0x200005e0
        0x080020f6:    6840        @h      LDR      r0,[r0,#4]
        0x080020f8:    b1e0        ..      CBZ      r0,0x8002134 ; do_fsm_menu + 164
;;;87     			// first pass of thread cut was complete, so just use single click
;;;88     			//	to switch between modes to process all other cuts
;;;89     
;;;90     //			z_move(feed_direction, z_axis.end_pos, s->main_feed_direction == feed_direction ? true : false, true);
;;;91     			if(demo)
        0x080020fa:    4862        bH      LDR      r0,[pc,#392] ; [0x8002284] = 0x20000041
        0x080020fc:    7800        .x      LDRB     r0,[r0,#0]
        0x080020fe:    b140        @.      CBZ      r0,0x8002112 ; do_fsm_menu + 130
;;;92     				z_move(feed_direction, z_axis.end_pos, false, true); //test case, always async
        0x08002100:    485f        _H      LDR      r0,[pc,#380] ; [0x8002280] = 0x200005e0
        0x08002102:    2301        .#      MOVS     r3,#1
        0x08002104:    2200        ."      MOVS     r2,#0
        0x08002106:    6841        Ah      LDR      r1,[r0,#4]
        0x08002108:    485b        [H      LDR      r0,[pc,#364] ; [0x8002278] = 0x200000a1
        0x0800210a:    7800        .x      LDRB     r0,[r0,#0]
        0x0800210c:    f000fff8    ....    BL       z_move ; 0x8003100
        0x08002110:    e040        @.      B        0x8002194 ; do_fsm_menu + 260
;;;93     			else
;;;94     				z_move(feed_direction, z_axis.end_pos, s->main_feed_direction == feed_direction ? true : false, true);
        0x08002112:    7c60        `|      LDRB     r0,[r4,#0x11]
        0x08002114:    4b58        XK      LDR      r3,[pc,#352] ; [0x8002278] = 0x200000a1
        0x08002116:    781b        .x      LDRB     r3,[r3,#0]
        0x08002118:    4298        .B      CMP      r0,r3
        0x0800211a:    d101        ..      BNE      0x8002120 ; do_fsm_menu + 144
        0x0800211c:    2001        .       MOVS     r0,#1
        0x0800211e:    e000        ..      B        0x8002122 ; do_fsm_menu + 146
        0x08002120:    2000        .       MOVS     r0,#0
        0x08002122:    4602        .F      MOV      r2,r0
        0x08002124:    4856        VH      LDR      r0,[pc,#344] ; [0x8002280] = 0x200005e0
        0x08002126:    2301        .#      MOVS     r3,#1
        0x08002128:    6841        Ah      LDR      r1,[r0,#4]
        0x0800212a:    4853        SH      LDR      r0,[pc,#332] ; [0x8002278] = 0x200000a1
        0x0800212c:    7800        .x      LDRB     r0,[r0,#0]
        0x0800212e:    f000ffe7    ....    BL       z_move ; 0x8003100
        0x08002132:    e02f        /.      B        0x8002194 ; do_fsm_menu + 260
;;;95     //			z_move(feed_direction, 400*2, false, true);
;;;96     		} else { // controller in initial state, scroll menu
;;;97     			s->function = do_fsm_menu_lps;
        0x08002134:    4854        TH      LDR      r0,[pc,#336] ; [0x8002288] = 0x80022a1
        0x08002136:    6020         `      STR      r0,[r4,#0]
;;;98     			for (int a = Menu_Step+1; a<Menu_size; a++) {
        0x08002138:    494d        MI      LDR      r1,[pc,#308] ; [0x8002270] = 0x200004d4
        0x0800213a:    7809        .x      LDRB     r1,[r1,#0]
        0x0800213c:    1c48        H.      ADDS     r0,r1,#1
        0x0800213e:    e00c        ..      B        0x800215a ; do_fsm_menu + 202
;;;99     				if(Thread_Info[a].level == level) {
        0x08002140:    494a        JI      LDR      r1,[pc,#296] ; [0x800226c] = 0x200000b4
        0x08002142:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08002146:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x08002148:    42a9        .B      CMP      r1,r5
        0x0800214a:    d105        ..      BNE      0x8002158 ; do_fsm_menu + 200
;;;100    					Menu_Step = a;
        0x0800214c:    4a48        HJ      LDR      r2,[pc,#288] ; [0x8002270] = 0x200004d4
        0x0800214e:    7010        .p      STRB     r0,[r2,#0]
;;;101    					menu_changed = 1;
        0x08002150:    2101        .!      MOVS     r1,#1
        0x08002152:    4a4a        JJ      LDR      r2,[pc,#296] ; [0x800227c] = 0x200000a4
        0x08002154:    6011        .`      STR      r1,[r2,#0]
;;;102    					break;
        0x08002156:    e004        ..      B        0x8002162 ; do_fsm_menu + 210
        0x08002158:    1c40        @.      ADDS     r0,r0,#1
        0x0800215a:    494c        LI      LDR      r1,[pc,#304] ; [0x800228c] = 0x8003212
        0x0800215c:    7809        .x      LDRB     r1,[r1,#0]
        0x0800215e:    4288        .B      CMP      r0,r1
        0x08002160:    dbee        ..      BLT      0x8002140 ; do_fsm_menu + 176
        0x08002162:    bf00        ..      NOP      
;;;103    				}
;;;104    			}
;;;105    			if(menu_changed != 1) {
        0x08002164:    4845        EH      LDR      r0,[pc,#276] ; [0x800227c] = 0x200000a4
        0x08002166:    6800        .h      LDR      r0,[r0,#0]
        0x08002168:    2801        .(      CMP      r0,#1
        0x0800216a:    d013        ..      BEQ      0x8002194 ; do_fsm_menu + 260
;;;106    				for (int a = 0; a<Menu_Step; a++) {
        0x0800216c:    2000        .       MOVS     r0,#0
        0x0800216e:    e00c        ..      B        0x800218a ; do_fsm_menu + 250
;;;107    					if(Thread_Info[a].level == level) {
        0x08002170:    493e        >I      LDR      r1,[pc,#248] ; [0x800226c] = 0x200000b4
        0x08002172:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x08002176:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x08002178:    42a9        .B      CMP      r1,r5
        0x0800217a:    d105        ..      BNE      0x8002188 ; do_fsm_menu + 248
;;;108    						Menu_Step = a;
        0x0800217c:    4a3c        <J      LDR      r2,[pc,#240] ; [0x8002270] = 0x200004d4
        0x0800217e:    7010        .p      STRB     r0,[r2,#0]
;;;109    						menu_changed = 1;
        0x08002180:    2101        .!      MOVS     r1,#1
        0x08002182:    4a3e        >J      LDR      r2,[pc,#248] ; [0x800227c] = 0x200000a4
        0x08002184:    6011        .`      STR      r1,[r2,#0]
;;;110    						break;
        0x08002186:    e004        ..      B        0x8002192 ; do_fsm_menu + 258
        0x08002188:    1c40        @.      ADDS     r0,r0,#1
        0x0800218a:    4939        9I      LDR      r1,[pc,#228] ; [0x8002270] = 0x200004d4
        0x0800218c:    7809        .x      LDRB     r1,[r1,#0]
        0x0800218e:    4288        .B      CMP      r0,r1
        0x08002190:    dbee        ..      BLT      0x8002170 ; do_fsm_menu + 224
        0x08002192:    bf00        ..      NOP      
;;;111    					}
;;;112    				}
;;;113    			}
;;;114    		}
;;;115    		break;
        0x08002194:    e068        h.      B        0x8002268 ; do_fsm_menu + 472
        0x08002196:    e002        ..      B        0x800219e ; do_fsm_menu + 270
        0x08002198:    e00c        ..      B        0x80021b4 ; do_fsm_menu + 292
        0x0800219a:    e05e        ^.      B        0x800225a ; do_fsm_menu + 458
        0x0800219c:    e009        ..      B        0x80021b2 ; do_fsm_menu + 290
;;;116    	}
;;;117    	case double_click_Msk: {
;;;118    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
        0x0800219e:    4836        6H      LDR      r0,[pc,#216] ; [0x8002278] = 0x200000a1
        0x080021a0:    7800        .x      LDRB     r0,[r0,#0]
        0x080021a2:    f0800001    ....    EOR      r0,r0,#1
        0x080021a6:    4934        4I      LDR      r1,[pc,#208] ; [0x8002278] = 0x200000a1
        0x080021a8:    7008        .p      STRB     r0,[r1,#0]
;;;119    		menu_changed = 1;
        0x080021aa:    2001        .       MOVS     r0,#1
        0x080021ac:    4933        3I      LDR      r1,[pc,#204] ; [0x800227c] = 0x200000a4
        0x080021ae:    6008        .`      STR      r0,[r1,#0]
;;;120    		break;
        0x080021b0:    e05a        Z.      B        0x8002268 ; do_fsm_menu + 472
;;;121    	}
;;;122    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;123    		// todo check if it work
;;;124    		break;
        0x080021b2:    e059        Y.      B        0x8002268 ; do_fsm_menu + 472
;;;125    	}
;;;126    	case long_press_start_Msk: {
;;;127    		if(s->function == do_fsm_menu_lps){
        0x080021b4:    4934        4I      LDR      r1,[pc,#208] ; [0x8002288] = 0x80022a1
        0x080021b6:    6820         h      LDR      r0,[r4,#0]
        0x080021b8:    4288        .B      CMP      r0,r1
        0x080021ba:    d14d        M.      BNE      0x8002258 ; do_fsm_menu + 456
;;;128    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
        0x080021bc:    482b        +H      LDR      r0,[pc,#172] ; [0x800226c] = 0x200000b4
        0x080021be:    492c        ,I      LDR      r1,[pc,#176] ; [0x8002270] = 0x200004d4
        0x080021c0:    7809        .x      LDRB     r1,[r1,#0]
        0x080021c2:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x080021c6:    6800        .h      LDR      r0,[r0,#0]
        0x080021c8:    b360        `.      CBZ      r0,0x8002224 ; do_fsm_menu + 404
;;;129    
;;;130    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
        0x080021ca:    4828        (H      LDR      r0,[pc,#160] ; [0x800226c] = 0x200000b4
        0x080021cc:    4928        (I      LDR      r1,[pc,#160] ; [0x8002270] = 0x200004d4
        0x080021ce:    7809        .x      LDRB     r1,[r1,#0]
        0x080021d0:    eb001041    ..A.    ADD      r0,r0,r1,LSL #5
        0x080021d4:    6800        .h      LDR      r0,[r0,#0]
        0x080021d6:    492a        *I      LDR      r1,[pc,#168] ; [0x8002280] = 0x200005e0
        0x080021d8:    60c8        .`      STR      r0,[r1,#0xc]
;;;131    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
        0x080021da:    bf00        ..      NOP      
;;;132    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
        0x080021dc:    4608        .F      MOV      r0,r1
        0x080021de:    68c6        .h      LDR      r6,[r0,#0xc]
        0x080021e0:    4632        2F      MOV      r2,r6
        0x080021e2:    2300        .#      MOVS     r3,#0
        0x080021e4:    4618        .F      MOV      r0,r3
        0x080021e6:    f04f6161    O.aa    MOV      r1,#0xe100000
        0x080021ea:    f7fdff9b    ....    BL       __aeabi_uldivmod ; 0x8000124
        0x080021ee:    4a24        $J      LDR      r2,[pc,#144] ; [0x8002280] = 0x200005e0
        0x080021f0:    e9c20106    ....    STRD     r0,r1,[r2,#0x18]
;;;133    				// 200*step_divider*z_feed_screw(mm)*len(mm) = desired length in steps, in my case its 200*2*1*x
;;;134    
;;;135    				
;;;136    				MOTOR_X_Enable();
        0x080021f4:    f2402002    @..     MOV      r0,#0x202
        0x080021f8:    4925        %I      LDR      r1,[pc,#148] ; [0x8002290] = 0x40010810
        0x080021fa:    6008        .`      STR      r0,[r1,#0]
;;;137    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x080021fc:    4925        %I      LDR      r1,[pc,#148] ; [0x8002294] = 0x40010c10
        0x080021fe:    6008        .`      STR      r0,[r1,#0]
;;;138    //				LL_mDelay(2);
;;;139    				if(demo){
        0x08002200:    4820         H      LDR      r0,[pc,#128] ; [0x8002284] = 0x20000041
        0x08002202:    7800        .x      LDRB     r0,[r0,#0]
        0x08002204:    b130        0.      CBZ      r0,0x8002214 ; do_fsm_menu + 388
;;;140    					G01(steps_x,steps_z,0);
        0x08002206:    2200        ."      MOVS     r2,#0
        0x08002208:    f44f7196    O..q    MOV      r1,#0x12c
        0x0800220c:    2001        .       MOVS     r0,#1
        0x0800220e:    f7fefa89    ....    BL       G01 ; 0x8000724
        0x08002212:    e006        ..      B        0x8002222 ; do_fsm_menu + 402
;;;141    //					z_move(feed_direction, steps, false, true); //test case, move async 10mm
;;;142    //					z_move(feed_direction, 31, false, true); //test case, move async 10mm
;;;143    				}
;;;144    				else
;;;145    					z_move(feed_direction, 0, true, true);
        0x08002214:    2301        .#      MOVS     r3,#1
        0x08002216:    461a        .F      MOV      r2,r3
        0x08002218:    2100        .!      MOVS     r1,#0
        0x0800221a:    4817        .H      LDR      r0,[pc,#92] ; [0x8002278] = 0x200000a1
        0x0800221c:    7800        .x      LDRB     r0,[r0,#0]
        0x0800221e:    f000ff6f    ..o.    BL       z_move ; 0x8003100
;;;146    
;;;147    				//do_fsm_move_start
;;;148    			} else { // goto submenu
        0x08002222:    e019        ..      B        0x8002258 ; do_fsm_menu + 456
;;;149    				for (int a = 0; a<Menu_size; a++) {
        0x08002224:    2000        .       MOVS     r0,#0
        0x08002226:    e012        ..      B        0x800224e ; do_fsm_menu + 446
;;;150    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
        0x08002228:    4910        .I      LDR      r1,[pc,#64] ; [0x800226c] = 0x200000b4
        0x0800222a:    eb011140    ..@.    ADD      r1,r1,r0,LSL #5
        0x0800222e:    7c49        I|      LDRB     r1,[r1,#0x11]
        0x08002230:    4a0e        .J      LDR      r2,[pc,#56] ; [0x800226c] = 0x200000b4
        0x08002232:    4b0f        .K      LDR      r3,[pc,#60] ; [0x8002270] = 0x200004d4
        0x08002234:    781b        .x      LDRB     r3,[r3,#0]
        0x08002236:    eb021243    ..C.    ADD      r2,r2,r3,LSL #5
        0x0800223a:    7912        .y      LDRB     r2,[r2,#4]
        0x0800223c:    4291        .B      CMP      r1,r2
        0x0800223e:    d105        ..      BNE      0x800224c ; do_fsm_menu + 444
;;;151    						Menu_Step = a;
        0x08002240:    4a0b        .J      LDR      r2,[pc,#44] ; [0x8002270] = 0x200004d4
        0x08002242:    7010        .p      STRB     r0,[r2,#0]
;;;152    						menu_changed = 1;
        0x08002244:    2101        .!      MOVS     r1,#1
        0x08002246:    4a0d        .J      LDR      r2,[pc,#52] ; [0x800227c] = 0x200000a4
        0x08002248:    6011        .`      STR      r1,[r2,#0]
;;;153    						break;
        0x0800224a:    e004        ..      B        0x8002256 ; do_fsm_menu + 454
        0x0800224c:    1c40        @.      ADDS     r0,r0,#1
        0x0800224e:    490f        .I      LDR      r1,[pc,#60] ; [0x800228c] = 0x8003212
        0x08002250:    7809        .x      LDRB     r1,[r1,#0]
        0x08002252:    4288        .B      CMP      r0,r1
        0x08002254:    dbe8        ..      BLT      0x8002228 ; do_fsm_menu + 408
        0x08002256:    bf00        ..      NOP      
;;;154    					}
;;;155    				}
;;;156    			}
;;;157    		} 
;;;158    /* todo prolong
;;;159    		else if(s->function == do_fsm_main_cut_back){
;;;160    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
;;;161    		}
;;;162    */
;;;163    		break;
        0x08002258:    e006        ..      B        0x8002268 ; do_fsm_menu + 472
;;;164    	}
;;;165    	case long_press_end_Msk: {
;;;166    		if(s->function == do_fsm_move)
        0x0800225a:    490f        .I      LDR      r1,[pc,#60] ; [0x8002298] = 0x80022a5
        0x0800225c:    6820         h      LDR      r0,[r4,#0]
        0x0800225e:    4288        .B      CMP      r0,r1
        0x08002260:    d101        ..      BNE      0x8002266 ; do_fsm_menu + 470
;;;167    			s->function = do_long_press_end_callback;
        0x08002262:    480e        .H      LDR      r0,[pc,#56] ; [0x800229c] = 0x8002595
        0x08002264:    6020         `      STR      r0,[r4,#0]
;;;168    		break;
        0x08002266:    bf00        ..      NOP      
        0x08002268:    bf00        ..      NOP      
;;;169    	}
;;;170    	}
;;;171    }
        0x0800226a:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0800226c:    200000b4    ...     DCD    536871092
        0x08002270:    200004d4    ...     DCD    536872148
        0x08002274:    200005dc    ...     DCD    536872412
        0x08002278:    200000a1    ...     DCD    536871073
        0x0800227c:    200000a4    ...     DCD    536871076
        0x08002280:    200005e0    ...     DCD    536872416
        0x08002284:    20000041    A..     DCD    536870977
        0x08002288:    080022a1    ."..    DCD    134226593
        0x0800228c:    08003212    .2..    DCD    134230546
        0x08002290:    40010810    ...@    DCD    1073809424
        0x08002294:    40010c10    ...@    DCD    1073810448
        0x08002298:    080022a5    ."..    DCD    134226597
        0x0800229c:    08002595    .%..    DCD    134227349
    $t
    i.do_fsm_menu_lps
    do_fsm_menu_lps
;;;172    
;;;173    void do_fsm_menu_lps(state_t* s)
;;;174    {
;;;175    }
        0x080022a0:    4770        pG      BX       lr
        0x080022a2:    0000        ..      MOVS     r0,r0
    i.do_fsm_move
    do_fsm_move
;;;176    
;;;177    /*
;;;178    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;179    {
;;;180    	MOTOR_Z_SetPulse();
;;;181    	--z_axis.current_pos;
;;;182    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;183    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;184    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;185    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;186    		z_axis.end_pos += prolong_fixpart;
;;;187    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;188    		// when long_press end, get back to 46 mode to proceed
;;;189    	}
;;;190    }
;;;191    */
;;;192    
;;;193    void do_fsm_wait_sclick(state_t* s)
;;;194    {
;;;195    }
;;;196    
;;;197    void z_move(uint32_t direction, uint32_t length, bool sync, bool autostart){
;;;198    	MOTOR_X_Enable();
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;200    
;;;201    	if(direction == feed_direction_left) {
;;;202    		feed_direction = feed_direction_left;
;;;203    		MOTOR_Z_Reverse();
;;;204    		MOTOR_X_Reverse();
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
;;;207    		MOTOR_Z_Forward();
;;;208    		MOTOR_X_Forward();
;;;209    	}
;;;210    	LL_mDelay(2);
;;;211    
;;;212    	state.sync = sync;
;;;213    	if(sync){
;;;214    		state.main_feed_direction = feed_direction;
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
;;;218    	z_axis.end_pos = length;
;;;219    	if(z_axis.end_pos > 0){
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
;;;228    }
;;;229    
;;;230    //---------------------------------------------------------------------------------------------
;;;231    void do_fsm_move_start(state_t* s){
;;;232    	if(s->sync && !s->f_tacho){
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
;;;242    			s->function = do_fsm_ramp_up;
;;;243    			s->async_z = 0;
;;;244    			s->syncbase = TIM4; 									// sync with spindle
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;247    
;;;248    // disable TACHO events, we dont need'em until next start			
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
;;;261    //			LL_TIM_EnableCounter(TIM3);
;;;262    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;263    //			LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;264    
;;;265    //			TIM3->SR = 0;
;;;266    //			LL_TIM_EnableCounter(TIM3);
;;;267    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;268    //			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;269    
;;;270    			
;;;271    //			LL_TIM_EnableCounter(TIM2); /* Enable counter */
;;;272    
;;;273    //			MOTOR_Z_AllowPulse();
;;;274    //			MOTOR_X_AllowPulse();
;;;275    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;276    
;;;277    			TIM2->ARR = 10;
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
;;;280    
;;;281    
;;;282    //			TIM2->ARR = 1;
;;;283    //			LL_TIM_EnableCounter(TIM2);
;;;284    
;;;285    //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
;;;286    //			TIM3->SR = 0;
;;;287    //			LL_TIM_EnableCounter(TIM3);
;;;288    //			LL_TIM_GenerateEvent_TRIG(TIM2); // start first step on motor
;;;289    	//		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;290    //			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;291    			s->async_z = 1;
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
        0x080022a4:    b510        ..      PUSH     {r4,lr}
        0x080022a6:    4604        .F      MOV      r4,r0
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
        0x080022a8:    4811        .H      LDR      r0,[pc,#68] ; [0x80022f0] = 0x200005e0
        0x080022aa:    6840        @h      LDR      r0,[r0,#4]
        0x080022ac:    4910        .I      LDR      r1,[pc,#64] ; [0x80022f0] = 0x200005e0
        0x080022ae:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x080022b2:    1a41        A.      SUBS     r1,r0,r1
        0x080022b4:    480e        .H      LDR      r0,[pc,#56] ; [0x80022f0] = 0x200005e0
        0x080022b6:    6800        .h      LDR      r0,[r0,#0]
        0x080022b8:    1c40        @.      ADDS     r0,r0,#1
        0x080022ba:    4a0d        .J      LDR      r2,[pc,#52] ; [0x80022f0] = 0x200005e0
        0x080022bc:    6010        .`      STR      r0,[r2,#0]
        0x080022be:    4281        .B      CMP      r1,r0
        0x080022c0:    d303        ..      BCC      0x80022ca ; do_fsm_move + 38
;;;314    		z_axis_move2(s);
        0x080022c2:    4620         F      MOV      r0,r4
        0x080022c4:    f000feb0    ....    BL       z_axis_move2 ; 0x8003028
        0x080022c8:    e011        ..      B        0x80022ee ; do_fsm_move + 74
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
        0x080022ca:    4620         F      MOV      r0,r4
        0x080022cc:    f000fec6    ....    BL       z_axis_ramp_down2 ; 0x800305c
        0x080022d0:    b158        X.      CBZ      r0,0x80022ea ; do_fsm_move + 70
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
        0x080022d2:    4807        .H      LDR      r0,[pc,#28] ; [0x80022f0] = 0x200005e0
        0x080022d4:    6840        @h      LDR      r0,[r0,#4]
        0x080022d6:    4906        .I      LDR      r1,[pc,#24] ; [0x80022f0] = 0x200005e0
        0x080022d8:    6809        .h      LDR      r1,[r1,#0]
        0x080022da:    4288        .B      CMP      r0,r1
        0x080022dc:    d003        ..      BEQ      0x80022e6 ; do_fsm_move + 66
;;;318    				z_axis.end_pos = z_axis.current_pos;
        0x080022de:    4804        .H      LDR      r0,[pc,#16] ; [0x80022f0] = 0x200005e0
        0x080022e0:    6800        .h      LDR      r0,[r0,#0]
        0x080022e2:    4903        .I      LDR      r1,[pc,#12] ; [0x80022f0] = 0x200005e0
        0x080022e4:    6048        H`      STR      r0,[r1,#4]
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
        0x080022e6:    4803        .H      LDR      r0,[pc,#12] ; [0x80022f4] = 0x800232d
        0x080022e8:    6020         `      STR      r0,[r4,#0]
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
        0x080022ea:    4803        .H      LDR      r0,[pc,#12] ; [0x80022f8] = 0x8002475
        0x080022ec:    6020         `      STR      r0,[r4,#0]
;;;323    	}
;;;324    }
        0x080022ee:    bd10        ..      POP      {r4,pc}
    $d
        0x080022f0:    200005e0    ...     DCD    536872416
        0x080022f4:    0800232d    -#..    DCD    134226733
        0x080022f8:    08002475    u$..    DCD    134227061
    $t
    i.do_fsm_move_async
    do_fsm_move_async
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
;;;340    //	if(s->spindle_dir)	
;;;341    		z_axis.current_pos++;
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
;;;346    			z_axis.end_pos = z_axis.current_pos;
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
;;;349    	}
;;;350    }
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
;;;436    		if( rs2 < z_axis.end_pos) {
;;;437    			s->z_period = slew_speed_period;
;;;438    			s->function = do_fsm_move_async;
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
;;;442    			s->function = do_fsm_ramp_down_async;
;;;443    			z_axis.ramp_step--;
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
;;;448    	}
;;;449    }
;;;450    
;;;451    void do_fsm_move_async(state_t* s)
;;;452    {
;;;453    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;454    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;455    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
        0x080022fc:    4a09        .J      LDR      r2,[pc,#36] ; [0x8002324] = 0x200005e0
        0x080022fe:    6852        Rh      LDR      r2,[r2,#4]
        0x08002300:    4b08        .K      LDR      r3,[pc,#32] ; [0x8002324] = 0x200005e0
        0x08002302:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x08002306:    1ad2        ..      SUBS     r2,r2,r3
        0x08002308:    1e51        Q.      SUBS     r1,r2,#1
;;;456    	if( ++z_axis.current_pos < pre ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
        0x0800230a:    4a06        .J      LDR      r2,[pc,#24] ; [0x8002324] = 0x200005e0
        0x0800230c:    6812        .h      LDR      r2,[r2,#0]
        0x0800230e:    1c52        R.      ADDS     r2,r2,#1
        0x08002310:    4b04        .K      LDR      r3,[pc,#16] ; [0x8002324] = 0x200005e0
        0x08002312:    601a        .`      STR      r2,[r3,#0]
        0x08002314:    428a        .B      CMP      r2,r1
        0x08002316:    d202        ..      BCS      0x800231e ; do_fsm_move_async + 34
;;;457    		s->z_period = slew_speed_period;
        0x08002318:    2232        2"      MOVS     r2,#0x32
        0x0800231a:    7302        .s      STRB     r2,[r0,#0xc]
        0x0800231c:    e001        ..      B        0x8002322 ; do_fsm_move_async + 38
;;;458    	} else {
;;;459    		s->function = do_fsm_ramp_down_async;
        0x0800231e:    4a02        .J      LDR      r2,[pc,#8] ; [0x8002328] = 0x80024ad
        0x08002320:    6002        .`      STR      r2,[r0,#0]
;;;460    	}
;;;461    }
        0x08002322:    4770        pG      BX       lr
    $d
        0x08002324:    200005e0    ...     DCD    536872416
        0x08002328:    080024ad    .$..    DCD    134227117
    $t
    i.do_fsm_move_end
    do_fsm_move_end
;;; .\..\Src\fsm.c (352)
        0x0800232c:    b510        ..      PUSH     {r4,lr}
        0x0800232e:    4604        .F      MOV      r4,r0
;;;353    	s->async_z = 0;
        0x08002330:    2000        .       MOVS     r0,#0
        0x08002332:    6060        ``      STR      r0,[r4,#4]
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
        0x08002334:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
        0x08002336:    491a        .I      LDR      r1,[pc,#104] ; [0x80023a0] = 0x40000400
        0x08002338:    6889        .h      LDR      r1,[r1,#8]
        0x0800233a:    f0210107    !...    BIC      r1,r1,#7
        0x0800233e:    4301        .C      ORRS     r1,r1,r0
        0x08002340:    4a17        .J      LDR      r2,[pc,#92] ; [0x80023a0] = 0x40000400
        0x08002342:    6091        .`      STR      r1,[r2,#8]
;;;2597   }
        0x08002344:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;357    	if (s->sync) {
        0x08002346:    7c20         |      LDRB     r0,[r4,#0x10]
        0x08002348:    b138        8.      CBZ      r0,0x800235a ; do_fsm_move_end + 46
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
        0x0800234a:    2000        .       MOVS     r0,#0
        0x0800234c:    4915        .I      LDR      r1,[pc,#84] ; [0x80023a4] = 0x42010180
        0x0800234e:    6008        .`      STR      r0,[r1,#0]
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x08002350:    1591        ..      ASRS     r1,r2,#22
        0x08002352:    4815        .H      LDR      r0,[pc,#84] ; [0x80023a8] = 0x40000800
        0x08002354:    f7fefc79    ..y.    BL       LL_TIM_CC_DisableChannel ; 0x8000c4a
        0x08002358:    e00a        ..      B        0x8002370 ; do_fsm_move_end + 68
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
        0x0800235a:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1038     CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x0800235c:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08002360:    6800        .h      LDR      r0,[r0,#0]
        0x08002362:    f0200001     ...    BIC      r0,r0,#1
        0x08002366:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0800236a:    6008        .`      STR      r0,[r1,#0]
;;;1039   }
        0x0800236c:    bf00        ..      NOP      
        0x0800236e:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
        0x08002370:    2000        .       MOVS     r0,#0
        0x08002372:    6160        `a      STR      r0,[r4,#0x14]
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
        0x08002374:    2002        .       MOVS     r0,#2
        0x08002376:    f7fefedf    ....    BL       LL_mDelay ; 0x8001138
;;;368      MOTOR_Z_Disable();
        0x0800237a:    f2402002    @..     MOV      r0,#0x202
        0x0800237e:    490b        .I      LDR      r1,[pc,#44] ; [0x80023ac] = 0x40010c14
        0x08002380:    6008        .`      STR      r0,[r1,#0]
;;;369      MOTOR_X_Disable();
        0x08002382:    490b        .I      LDR      r1,[pc,#44] ; [0x80023b0] = 0x40010814
        0x08002384:    6008        .`      STR      r0,[r1,#0]
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
        0x08002386:    480b        .H      LDR      r0,[pc,#44] ; [0x80023b4] = 0x200000a1
        0x08002388:    7800        .x      LDRB     r0,[r0,#0]
        0x0800238a:    f0800001    ....    EOR      r0,r0,#1
        0x0800238e:    4909        .I      LDR      r1,[pc,#36] ; [0x80023b4] = 0x200000a1
        0x08002390:    7008        .p      STRB     r0,[r1,#0]
;;;372    	menu_changed = 1; 													//update menu
        0x08002392:    2001        .       MOVS     r0,#1
        0x08002394:    4908        .I      LDR      r1,[pc,#32] ; [0x80023b8] = 0x200000a4
        0x08002396:    6008        .`      STR      r0,[r1,#0]
;;;373    	s->function = do_fsm_wait_sclick;
        0x08002398:    4808        .H      LDR      r0,[pc,#32] ; [0x80023bc] = 0x8002591
        0x0800239a:    6020         `      STR      r0,[r4,#0]
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
        0x0800239c:    bd10        ..      POP      {r4,pc}
    $d
        0x0800239e:    0000        ..      DCW    0
        0x080023a0:    40000400    ...@    DCD    1073742848
        0x080023a4:    42010180    ...B    DCD    1107362176
        0x080023a8:    40000800    ...@    DCD    1073743872
        0x080023ac:    40010c14    ...@    DCD    1073810452
        0x080023b0:    40010814    ...@    DCD    1073809428
        0x080023b4:    200000a1    ...     DCD    536871073
        0x080023b8:    200000a4    ...     DCD    536871076
        0x080023bc:    08002591    .%..    DCD    134227345
    $t
    i.do_fsm_move_start
    do_fsm_move_start
;;; .\..\Src\fsm.c (231)
        0x080023c0:    b510        ..      PUSH     {r4,lr}
        0x080023c2:    4604        .F      MOV      r4,r0
;;;232    	if(s->sync && !s->f_tacho){
        0x080023c4:    7c20         |      LDRB     r0,[r4,#0x10]
        0x080023c6:    b150        P.      CBZ      r0,0x80023de ; do_fsm_move_start + 30
        0x080023c8:    7ba0        .{      LDRB     r0,[r4,#0xe]
        0x080023ca:    b940        @.      CBNZ     r0,0x80023de ; do_fsm_move_start + 30
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
        0x080023cc:    f2af000f    ....    ADR      r0,{pc}-0xb ; 0x80023c1
        0x080023d0:    6020         `      STR      r0,[r4,#0]
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x080023d2:    f44f7180    O..q    MOV      r1,#0x100
        0x080023d6:    4822        "H      LDR      r0,[pc,#136] ; [0x8002460] = 0x40000800
        0x080023d8:    f7fefc3b    ..;.    BL       LL_TIM_CC_EnableChannel ; 0x8000c52
        0x080023dc:    bd10        ..      POP      {r4,pc}
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
        0x080023de:    7ba0        .{      LDRB     r0,[r4,#0xe]
        0x080023e0:    b910        ..      CBNZ     r0,0x80023e8 ; do_fsm_move_start + 40
        0x080023e2:    7c20         |      LDRB     r0,[r4,#0x10]
        0x080023e4:    2800        .(      CMP      r0,#0
        0x080023e6:    d138        8.      BNE      0x800245a ; do_fsm_move_start + 154
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
        0x080023e8:    7c20         |      LDRB     r0,[r4,#0x10]
        0x080023ea:    b1c0        ..      CBZ      r0,0x800241e ; do_fsm_move_start + 94
        0x080023ec:    7ba0        .{      LDRB     r0,[r4,#0xe]
        0x080023ee:    b1b0        ..      CBZ      r0,0x800241e ; do_fsm_move_start + 94
;;;242    			s->function = do_fsm_ramp_up;
        0x080023f0:    481c        .H      LDR      r0,[pc,#112] ; [0x8002464] = 0x80024f9
        0x080023f2:    6020         `      STR      r0,[r4,#0]
;;;243    			s->async_z = 0;
        0x080023f4:    2000        .       MOVS     r0,#0
        0x080023f6:    6060        ``      STR      r0,[r4,#4]
;;;244    			s->syncbase = TIM4; 									// sync with spindle
        0x080023f8:    4819        .H      LDR      r0,[pc,#100] ; [0x8002460] = 0x40000800
        0x080023fa:    6160        `a      STR      r0,[r4,#0x14]
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
        0x080023fc:    2030        0       MOVS     r0,#0x30
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x080023fe:    491a        .I      LDR      r1,[pc,#104] ; [0x8002468] = 0x40000400
        0x08002400:    6889        .h      LDR      r1,[r1,#8]
        0x08002402:    f0210170    !.p.    BIC      r1,r1,#0x70
        0x08002406:    4301        .C      ORRS     r1,r1,r0
        0x08002408:    4a17        .J      LDR      r2,[pc,#92] ; [0x8002468] = 0x40000400
        0x0800240a:    6091        .`      STR      r1,[r2,#8]
;;;2619   }
        0x0800240c:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x0800240e:    1591        ..      ASRS     r1,r2,#22
        0x08002410:    4813        .H      LDR      r0,[pc,#76] ; [0x8002460] = 0x40000800
        0x08002412:    f7fefc1a    ....    BL       LL_TIM_CC_DisableChannel ; 0x8000c4a
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
        0x08002416:    2001        .       MOVS     r0,#1
        0x08002418:    4914        .I      LDR      r1,[pc,#80] ; [0x800246c] = 0x42010180
        0x0800241a:    6008        .`      STR      r0,[r1,#0]
        0x0800241c:    e01d        ..      B        0x800245a ; do_fsm_move_start + 154
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
        0x0800241e:    4814        .H      LDR      r0,[pc,#80] ; [0x8002470] = 0x800251d
        0x08002420:    6020         `      STR      r0,[r4,#0]
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
        0x08002422:    f04f4080    O..@    MOV      r0,#0x40000000
        0x08002426:    6160        `a      STR      r0,[r4,#0x14]
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
        0x08002428:    f6406029    @.)`    MOV      r0,#0xe29
        0x0800242c:    490e        .I      LDR      r1,[pc,#56] ; [0x8002468] = 0x40000400
        0x0800242e:    312c        ,1      ADDS     r1,r1,#0x2c
        0x08002430:    6008        .`      STR      r0,[r1,#0]
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
        0x08002432:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08002434:    480c        .H      LDR      r0,[pc,#48] ; [0x8002468] = 0x40000400
        0x08002436:    6940        @i      LDR      r0,[r0,#0x14]
        0x08002438:    f0400001    @...    ORR      r0,r0,#1
        0x0800243c:    490a        .I      LDR      r1,[pc,#40] ; [0x8002468] = 0x40000400
        0x0800243e:    6148        Ha      STR      r0,[r1,#0x14]
;;;3713   }
        0x08002440:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;277    			TIM2->ARR = 10;
        0x08002442:    200a        .       MOVS     r0,#0xa
        0x08002444:    0741        A.      LSLS     r1,r0,#29
        0x08002446:    62c8        .b      STR      r0,[r1,#0x2c]
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
        0x08002448:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x0800244a:    0740        @.      LSLS     r0,r0,#29
        0x0800244c:    6800        .h      LDR      r0,[r0,#0]
        0x0800244e:    f0400001    @...    ORR      r0,r0,#1
        0x08002452:    6008        .`      STR      r0,[r1,#0]
;;;1028   }
        0x08002454:    bf00        ..      NOP      
;;; .\..\Src\fsm.c
;;;291    			s->async_z = 1;
        0x08002456:    2001        .       MOVS     r0,#1
        0x08002458:    6060        ``      STR      r0,[r4,#4]
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
        0x0800245a:    bf00        ..      NOP      
        0x0800245c:    e7be        ..      B        0x80023dc ; do_fsm_move_start + 28
    $d
        0x0800245e:    0000        ..      DCW    0
        0x08002460:    40000800    ...@    DCD    1073743872
        0x08002464:    080024f9    .$..    DCD    134227193
        0x08002468:    40000400    ...@    DCD    1073742848
        0x0800246c:    42010180    ...B    DCD    1107362176
        0x08002470:    0800251d    .%..    DCD    134227229
    $t
    i.do_fsm_ramp_down
    do_fsm_ramp_down
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
        0x08002474:    b500        ..      PUSH     {lr}
        0x08002476:    4603        .F      MOV      r3,r0
;;;340    //	if(s->spindle_dir)	
;;;341    		z_axis.current_pos++;
        0x08002478:    480a        .H      LDR      r0,[pc,#40] ; [0x80024a4] = 0x200005e0
        0x0800247a:    6800        .h      LDR      r0,[r0,#0]
        0x0800247c:    1c40        @.      ADDS     r0,r0,#1
        0x0800247e:    4909        .I      LDR      r1,[pc,#36] ; [0x80024a4] = 0x200005e0
        0x08002480:    6008        .`      STR      r0,[r1,#0]
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
        0x08002482:    4618        .F      MOV      r0,r3
        0x08002484:    f000fdea    ....    BL       z_axis_ramp_down2 ; 0x800305c
        0x08002488:    b158        X.      CBZ      r0,0x80024a2 ; do_fsm_ramp_down + 46
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
        0x0800248a:    4806        .H      LDR      r0,[pc,#24] ; [0x80024a4] = 0x200005e0
        0x0800248c:    6840        @h      LDR      r0,[r0,#4]
        0x0800248e:    4905        .I      LDR      r1,[pc,#20] ; [0x80024a4] = 0x200005e0
        0x08002490:    6809        .h      LDR      r1,[r1,#0]
        0x08002492:    4288        .B      CMP      r0,r1
        0x08002494:    d003        ..      BEQ      0x800249e ; do_fsm_ramp_down + 42
;;;346    			z_axis.end_pos = z_axis.current_pos;
        0x08002496:    4803        .H      LDR      r0,[pc,#12] ; [0x80024a4] = 0x200005e0
        0x08002498:    6800        .h      LDR      r0,[r0,#0]
        0x0800249a:    4902        .I      LDR      r1,[pc,#8] ; [0x80024a4] = 0x200005e0
        0x0800249c:    6048        H`      STR      r0,[r1,#4]
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
        0x0800249e:    4802        .H      LDR      r0,[pc,#8] ; [0x80024a8] = 0x800232d
        0x080024a0:    6018        .`      STR      r0,[r3,#0]
;;;349    	}
;;;350    }
        0x080024a2:    bd00        ..      POP      {pc}
    $d
        0x080024a4:    200005e0    ...     DCD    536872416
        0x080024a8:    0800232d    -#..    DCD    134226733
    $t
    i.do_fsm_ramp_down_async
    do_fsm_ramp_down_async
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
;;;436    		if( rs2 < z_axis.end_pos) {
;;;437    			s->z_period = slew_speed_period;
;;;438    			s->function = do_fsm_move_async;
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
;;;442    			s->function = do_fsm_ramp_down_async;
;;;443    			z_axis.ramp_step--;
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
;;;448    	}
;;;449    }
;;;450    
;;;451    void do_fsm_move_async(state_t* s)
;;;452    {
;;;453    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;454    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;455    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
;;;456    	if( ++z_axis.current_pos < pre ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;457    		s->z_period = slew_speed_period;
;;;458    	} else {
;;;459    		s->function = do_fsm_ramp_down_async;
;;;460    	}
;;;461    }
;;;462    
;;;463    void do_fsm_ramp_down_async(state_t* s)
;;;464    {
;;;465    	z_axis.current_pos++;
        0x080024ac:    490f        .I      LDR      r1,[pc,#60] ; [0x80024ec] = 0x200005e0
        0x080024ae:    6809        .h      LDR      r1,[r1,#0]
        0x080024b0:    1c49        I.      ADDS     r1,r1,#1
        0x080024b2:    4a0e        .J      LDR      r2,[pc,#56] ; [0x80024ec] = 0x200005e0
        0x080024b4:    6011        .`      STR      r1,[r2,#0]
;;;466    
;;;467    	s->z_period = async_ramp_profile[--z_axis.ramp_step];
        0x080024b6:    4611        .F      MOV      r1,r2
        0x080024b8:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x080024bc:    1e49        I.      SUBS     r1,r1,#1
        0x080024be:    b2c9        ..      UXTB     r1,r1
        0x080024c0:    f8821028    ..(.    STRB     r1,[r2,#0x28]
        0x080024c4:    4a0a        .J      LDR      r2,[pc,#40] ; [0x80024f0] = 0x20000018
        0x080024c6:    5c51        Q\      LDRB     r1,[r2,r1]
        0x080024c8:    7301        .s      STRB     r1,[r0,#0xc]
;;;468    	if (z_axis.ramp_step == 0) {
        0x080024ca:    4908        .I      LDR      r1,[pc,#32] ; [0x80024ec] = 0x200005e0
        0x080024cc:    f8911028    ..(.    LDRB     r1,[r1,#0x28]
        0x080024d0:    b959        Y.      CBNZ     r1,0x80024ea ; do_fsm_ramp_down_async + 62
;;;469    //	} else {
;;;470    // for last step there is no need to wail long, motor can be start to disabled after 145 processor ticks, so with prescaler =145 and more ARR = 1 is enought
;;;471    //		s->z_period = 2; 
;;;472    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED); // stop pulse generation on timer
;;;473    		if(z_axis.end_pos != z_axis.current_pos) {
        0x080024d2:    4906        .I      LDR      r1,[pc,#24] ; [0x80024ec] = 0x200005e0
        0x080024d4:    6849        Ih      LDR      r1,[r1,#4]
        0x080024d6:    4a05        .J      LDR      r2,[pc,#20] ; [0x80024ec] = 0x200005e0
        0x080024d8:    6812        .h      LDR      r2,[r2,#0]
        0x080024da:    4291        .B      CMP      r1,r2
        0x080024dc:    d003        ..      BEQ      0x80024e6 ; do_fsm_ramp_down_async + 58
;;;474    			z_axis.end_pos = z_axis.current_pos;
        0x080024de:    4903        .I      LDR      r1,[pc,#12] ; [0x80024ec] = 0x200005e0
        0x080024e0:    6809        .h      LDR      r1,[r1,#0]
        0x080024e2:    4a02        .J      LDR      r2,[pc,#8] ; [0x80024ec] = 0x200005e0
        0x080024e4:    6051        Q`      STR      r1,[r2,#4]
;;;475    		}
;;;476    		s->function = do_fsm_move_end;
        0x080024e6:    4903        .I      LDR      r1,[pc,#12] ; [0x80024f4] = 0x800232d
        0x080024e8:    6001        .`      STR      r1,[r0,#0]
;;;477    //		do_fsm_move_end(s);
;;;478    	}
;;;479    }
        0x080024ea:    4770        pG      BX       lr
    $d
        0x080024ec:    200005e0    ...     DCD    536872416
        0x080024f0:    20000018    ...     DCD    536870936
        0x080024f4:    0800232d    -#..    DCD    134226733
    $t
    i.do_fsm_ramp_up
    do_fsm_ramp_up
;;; .\..\Src\fsm.c (302)
        0x080024f8:    b510        ..      PUSH     {r4,lr}
        0x080024fa:    4604        .F      MOV      r4,r0
;;;303    	z_axis.current_pos++;
        0x080024fc:    4805        .H      LDR      r0,[pc,#20] ; [0x8002514] = 0x200005e0
        0x080024fe:    6800        .h      LDR      r0,[r0,#0]
        0x08002500:    1c40        @.      ADDS     r0,r0,#1
        0x08002502:    4904        .I      LDR      r1,[pc,#16] ; [0x8002514] = 0x200005e0
        0x08002504:    6008        .`      STR      r0,[r1,#0]
;;;304    	if(z_axis_ramp_up2(s)) {
        0x08002506:    4620         F      MOV      r0,r4
        0x08002508:    f000fdc8    ....    BL       z_axis_ramp_up2 ; 0x800309c
        0x0800250c:    b108        ..      CBZ      r0,0x8002512 ; do_fsm_ramp_up + 26
;;;305    		s->function = do_fsm_move;
        0x0800250e:    4802        .H      LDR      r0,[pc,#8] ; [0x8002518] = 0x80022a5
        0x08002510:    6020         `      STR      r0,[r4,#0]
;;;306    	}
;;;307    }
        0x08002512:    bd10        ..      POP      {r4,pc}
    $d
        0x08002514:    200005e0    ...     DCD    536872416
        0x08002518:    080022a5    ."..    DCD    134226597
    $t
    i.do_fsm_ramp_up_async
    do_fsm_ramp_up_async
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
;;;340    //	if(s->spindle_dir)	
;;;341    		z_axis.current_pos++;
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
;;;346    			z_axis.end_pos = z_axis.current_pos;
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
;;;349    	}
;;;350    }
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
        0x0800251c:    b530        0.      PUSH     {r4,r5,lr}
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
        0x0800251e:    4b18        .K      LDR      r3,[pc,#96] ; [0x8002580] = 0x200005e0
        0x08002520:    681b        .h      LDR      r3,[r3,#0]
        0x08002522:    1c5b        [.      ADDS     r3,r3,#1
        0x08002524:    4c16        .L      LDR      r4,[pc,#88] ; [0x8002580] = 0x200005e0
        0x08002526:    6023        #`      STR      r3,[r4,#0]
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
        0x08002528:    4623        #F      MOV      r3,r4
        0x0800252a:    f8934028    ..(@    LDRB     r4,[r3,#0x28]
        0x0800252e:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x08002532:    1c5b        [.      ADDS     r3,r3,#1
        0x08002534:    4d12        .M      LDR      r5,[pc,#72] ; [0x8002580] = 0x200005e0
        0x08002536:    f8853028    ..(0    STRB     r3,[r5,#0x28]
        0x0800253a:    4b12        .K      LDR      r3,[pc,#72] ; [0x8002584] = 0x20000018
        0x0800253c:    5d19        .]      LDRB     r1,[r3,r4]
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
        0x0800253e:    462b        +F      MOV      r3,r5
        0x08002540:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x08002544:    005a        Z.      LSLS     r2,r3,#1
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
        0x08002546:    2932        2)      CMP      r1,#0x32
        0x08002548:    db03        ..      BLT      0x8002552 ; do_fsm_ramp_up_async + 54
        0x0800254a:    462b        +F      MOV      r3,r5
        0x0800254c:    685b        [h      LDR      r3,[r3,#4]
        0x0800254e:    4293        .B      CMP      r3,r2
        0x08002550:    d813        ..      BHI      0x800257a ; do_fsm_ramp_up_async + 94
;;;436    		if( rs2 < z_axis.end_pos) {
        0x08002552:    4b0b        .K      LDR      r3,[pc,#44] ; [0x8002580] = 0x200005e0
        0x08002554:    685b        [h      LDR      r3,[r3,#4]
        0x08002556:    4293        .B      CMP      r3,r2
        0x08002558:    d904        ..      BLS      0x8002564 ; do_fsm_ramp_up_async + 72
;;;437    			s->z_period = slew_speed_period;
        0x0800255a:    2332        2#      MOVS     r3,#0x32
        0x0800255c:    7303        .s      STRB     r3,[r0,#0xc]
;;;438    			s->function = do_fsm_move_async;
        0x0800255e:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8002588] = 0x80022fd
        0x08002560:    6003        .`      STR      r3,[r0,#0]
        0x08002562:    e00b        ..      B        0x800257c ; do_fsm_ramp_up_async + 96
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
        0x08002564:    7301        .s      STRB     r1,[r0,#0xc]
;;;442    			s->function = do_fsm_ramp_down_async;
        0x08002566:    4b09        .K      LDR      r3,[pc,#36] ; [0x800258c] = 0x80024ad
        0x08002568:    6003        .`      STR      r3,[r0,#0]
;;;443    			z_axis.ramp_step--;
        0x0800256a:    4b05        .K      LDR      r3,[pc,#20] ; [0x8002580] = 0x200005e0
        0x0800256c:    f8933028    ..(0    LDRB     r3,[r3,#0x28]
        0x08002570:    1e5b        [.      SUBS     r3,r3,#1
        0x08002572:    4c03        .L      LDR      r4,[pc,#12] ; [0x8002580] = 0x200005e0
        0x08002574:    f8843028    ..(0    STRB     r3,[r4,#0x28]
        0x08002578:    e000        ..      B        0x800257c ; do_fsm_ramp_up_async + 96
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
        0x0800257a:    7301        .s      STRB     r1,[r0,#0xc]
;;;448    	}
;;;449    }
        0x0800257c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800257e:    0000        ..      DCW    0
        0x08002580:    200005e0    ...     DCD    536872416
        0x08002584:    20000018    ...     DCD    536870936
        0x08002588:    080022fd    ."..    DCD    134226685
        0x0800258c:    080024ad    .$..    DCD    134227117
    $t
    i.do_fsm_wait_sclick
    do_fsm_wait_sclick
;;; .\..\Src\fsm.c (195)
        0x08002590:    4770        pG      BX       lr
        0x08002592:    0000        ..      MOVS     r0,r0
    i.do_long_press_end_callback
    do_long_press_end_callback
;;;196    
;;;197    void z_move(uint32_t direction, uint32_t length, bool sync, bool autostart){
;;;198    	MOTOR_X_Enable();
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;200    
;;;201    	if(direction == feed_direction_left) {
;;;202    		feed_direction = feed_direction_left;
;;;203    		MOTOR_Z_Reverse();
;;;204    		MOTOR_X_Reverse();
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
;;;207    		MOTOR_Z_Forward();
;;;208    		MOTOR_X_Forward();
;;;209    	}
;;;210    	LL_mDelay(2);
;;;211    
;;;212    	state.sync = sync;
;;;213    	if(sync){
;;;214    		state.main_feed_direction = feed_direction;
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
;;;218    	z_axis.end_pos = length;
;;;219    	if(z_axis.end_pos > 0){
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
;;;228    }
;;;229    
;;;230    //---------------------------------------------------------------------------------------------
;;;231    void do_fsm_move_start(state_t* s){
;;;232    	if(s->sync && !s->f_tacho){
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
;;;242    			s->function = do_fsm_ramp_up;
;;;243    			s->async_z = 0;
;;;244    			s->syncbase = TIM4; 									// sync with spindle
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;247    
;;;248    // disable TACHO events, we dont need'em until next start			
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
;;;261    //			LL_TIM_EnableCounter(TIM3);
;;;262    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;263    //			LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;264    
;;;265    //			TIM3->SR = 0;
;;;266    //			LL_TIM_EnableCounter(TIM3);
;;;267    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;268    //			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;269    
;;;270    			
;;;271    //			LL_TIM_EnableCounter(TIM2); /* Enable counter */
;;;272    
;;;273    //			MOTOR_Z_AllowPulse();
;;;274    //			MOTOR_X_AllowPulse();
;;;275    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;276    
;;;277    			TIM2->ARR = 10;
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
;;;280    
;;;281    
;;;282    //			TIM2->ARR = 1;
;;;283    //			LL_TIM_EnableCounter(TIM2);
;;;284    
;;;285    //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
;;;286    //			TIM3->SR = 0;
;;;287    //			LL_TIM_EnableCounter(TIM3);
;;;288    //			LL_TIM_GenerateEvent_TRIG(TIM2); // start first step on motor
;;;289    	//		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;290    //			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;291    			s->async_z = 1;
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
        0x08002594:    b510        ..      PUSH     {r4,lr}
        0x08002596:    4604        .F      MOV      r4,r0
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
        0x08002598:    4809        .H      LDR      r0,[pc,#36] ; [0x80025c0] = 0x200005e0
        0x0800259a:    6840        @h      LDR      r0,[r0,#4]
        0x0800259c:    b948        H.      CBNZ     r0,0x80025b2 ; do_long_press_end_callback + 30
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
        0x0800259e:    4808        .H      LDR      r0,[pc,#32] ; [0x80025c0] = 0x200005e0
        0x080025a0:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x080025a4:    4906        .I      LDR      r1,[pc,#24] ; [0x80025c0] = 0x200005e0
        0x080025a6:    6809        .h      LDR      r1,[r1,#0]
        0x080025a8:    4408        .D      ADD      r0,r0,r1
        0x080025aa:    f0400001    @...    ORR      r0,r0,#1
        0x080025ae:    4904        .I      LDR      r1,[pc,#16] ; [0x80025c0] = 0x200005e0
        0x080025b0:    6048        H`      STR      r0,[r1,#4]
;;;333    	s->function = do_fsm_move;
        0x080025b2:    4804        .H      LDR      r0,[pc,#16] ; [0x80025c4] = 0x80022a5
        0x080025b4:    6020         `      STR      r0,[r4,#0]
;;;334    	do_fsm_move(s);
        0x080025b6:    4620         F      MOV      r0,r4
        0x080025b8:    f7fffe74    ..t.    BL       do_fsm_move ; 0x80022a4
;;;335    }
        0x080025bc:    bd10        ..      POP      {r4,pc}
    $d
        0x080025be:    0000        ..      DCW    0
        0x080025c0:    200005e0    ...     DCD    536872416
        0x080025c4:    080022a5    ."..    DCD    134226597
    $t
    i.dxdz_callback
    dxdz_callback
;;; ../Inc/fsm.h
;;;94     __STATIC_INLINE void dxdz_callback(state_t* s){
        0x080025c8:    b510        ..      PUSH     {r4,lr}
        0x080025ca:    4604        .F      MOV      r4,r0
;;;95     	TIM3->CCER = 0;	//	LL_TIM_CC_DisableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x080025cc:    2000        .       MOVS     r0,#0
        0x080025ce:    4910        .I      LDR      r1,[pc,#64] ; [0x8002610] = 0x40000420
        0x080025d0:    6008        .`      STR      r0,[r1,#0]
;;;96     	s->e2 = s->err;
        0x080025d2:    6c60        `l      LDR      r0,[r4,#0x44]
        0x080025d4:    64a0        .d      STR      r0,[r4,#0x48]
;;;97     	if (s->e2 > -s->dx)	{ 
        0x080025d6:    6aa1        .j      LDR      r1,[r4,#0x28]
        0x080025d8:    4249        IB      RSBS     r1,r1,#0
        0x080025da:    6ca0        .l      LDR      r0,[r4,#0x48]
        0x080025dc:    4288        .B      CMP      r0,r1
        0x080025de:    dd08        ..      BLE      0x80025f2 ; dxdz_callback + 42
;;;98     		s->err -= s->dz; 
        0x080025e0:    6ae1        .j      LDR      r1,[r4,#0x2c]
        0x080025e2:    6c60        `l      LDR      r0,[r4,#0x44]
        0x080025e4:    1a40        @.      SUBS     r0,r0,r1
        0x080025e6:    6460        `d      STR      r0,[r4,#0x44]
;;;99     		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x080025e8:    2101        .!      MOVS     r1,#1
        0x080025ea:    4809        .H      LDR      r0,[pc,#36] ; [0x8002610] = 0x40000420
        0x080025ec:    3820         8      SUBS     r0,r0,#0x20
        0x080025ee:    f7fefb30    ..0.    BL       LL_TIM_CC_EnableChannel ; 0x8000c52
;;;100    	}
;;;101    	if (s->e2 < s->dz)	{ 
        0x080025f2:    6ae1        .j      LDR      r1,[r4,#0x2c]
        0x080025f4:    6ca0        .l      LDR      r0,[r4,#0x48]
        0x080025f6:    4288        .B      CMP      r0,r1
        0x080025f8:    da09        ..      BGE      0x800260e ; dxdz_callback + 70
;;;102    		s->err += s->dx; 
        0x080025fa:    6aa1        .j      LDR      r1,[r4,#0x28]
        0x080025fc:    6c60        `l      LDR      r0,[r4,#0x44]
        0x080025fe:    4408        .D      ADD      r0,r0,r1
        0x08002600:    6460        `d      STR      r0,[r4,#0x44]
;;;103    		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3); 
        0x08002602:    f44f7180    O..q    MOV      r1,#0x100
        0x08002606:    4802        .H      LDR      r0,[pc,#8] ; [0x8002610] = 0x40000420
        0x08002608:    3820         8      SUBS     r0,r0,#0x20
        0x0800260a:    f7fefb22    ..".    BL       LL_TIM_CC_EnableChannel ; 0x8000c52
;;;104    	}
;;;105    }
        0x0800260e:    bd10        ..      POP      {r4,pc}
    $d
        0x08002610:    40000420     ..@    DCD    1073742880
    $t
    i.dzdx_init
    dzdx_init
;;; .\..\Src\fsm.c
;;;481    void dzdx_init(int dx, int dz, state_t* s) {
        0x08002614:    b530        0.      PUSH     {r4,r5,lr}
;;;482    	s->dx = abs(dx); 
        0x08002616:    1e03        ..      SUBS     r3,r0,#0
        0x08002618:    db01        ..      BLT      0x800261e ; dzdx_init + 10
        0x0800261a:    461c        .F      MOV      r4,r3
        0x0800261c:    e000        ..      B        0x8002620 ; dzdx_init + 12
        0x0800261e:    425c        \B      RSBS     r4,r3,#0
        0x08002620:    6294        .b      STR      r4,[r2,#0x28]
;;;483    	s->sx = dx > 0 ? 1 : -1;
        0x08002622:    2800        .(      CMP      r0,#0
        0x08002624:    dd01        ..      BLE      0x800262a ; dzdx_init + 22
        0x08002626:    2301        .#      MOVS     r3,#1
        0x08002628:    e001        ..      B        0x800262e ; dzdx_init + 26
        0x0800262a:    f04f33ff    O..3    MOV      r3,#0xffffffff
        0x0800262e:    6313        .c      STR      r3,[r2,#0x30]
;;;484      s->dz = abs(dz);
        0x08002630:    1e0b        ..      SUBS     r3,r1,#0
        0x08002632:    db01        ..      BLT      0x8002638 ; dzdx_init + 36
        0x08002634:    461c        .F      MOV      r4,r3
        0x08002636:    e000        ..      B        0x800263a ; dzdx_init + 38
        0x08002638:    425c        \B      RSBS     r4,r3,#0
        0x0800263a:    62d4        .b      STR      r4,[r2,#0x2c]
;;;485    	s->sz = dz > 0 ? 1 : -1; 
        0x0800263c:    2900        .)      CMP      r1,#0
        0x0800263e:    dd01        ..      BLE      0x8002644 ; dzdx_init + 48
        0x08002640:    2301        .#      MOVS     r3,#1
        0x08002642:    e001        ..      B        0x8002648 ; dzdx_init + 52
        0x08002644:    f04f33ff    O..3    MOV      r3,#0xffffffff
        0x08002648:    6353        Sc      STR      r3,[r2,#0x34]
;;;486      s->e2 = s->err = (s->dx > s->dz ? s->dx : -s->dz)/2;
        0x0800264a:    e9d2450a    ...E    LDRD     r4,r5,[r2,#0x28]
        0x0800264e:    42ac        .B      CMP      r4,r5
        0x08002650:    dd01        ..      BLE      0x8002656 ; dzdx_init + 66
        0x08002652:    6a94        .j      LDR      r4,[r2,#0x28]
        0x08002654:    e001        ..      B        0x800265a ; dzdx_init + 70
        0x08002656:    6ad4        .j      LDR      r4,[r2,#0x2c]
        0x08002658:    4264        dB      RSBS     r4,r4,#0
        0x0800265a:    4623        #F      MOV      r3,r4
        0x0800265c:    eb0474d3    ...t    ADD      r4,r4,r3,LSR #31
        0x08002660:    1064        d.      ASRS     r4,r4,#1
        0x08002662:    6454        Td      STR      r4,[r2,#0x44]
        0x08002664:    6494        .d      STR      r4,[r2,#0x48]
;;;487    	s->set_pulse_function = dxdz_callback;
        0x08002666:    4b01        .K      LDR      r3,[pc,#4] ; [0x800266c] = 0x80025c9
        0x08002668:    6593        .e      STR      r3,[r2,#0x58]
;;;488    }
        0x0800266a:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800266c:    080025c9    .%..    DCD    134227401
    $t
    i.gc_execute_line
    gc_execute_line
;;; .\..\Src\gcode.c
;;;164    {
        0x08002670:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x08002674:    4680        .F      MOV      r8,r0
;;;165    //	double feed_rate;
;;;166    //	double extrudeLength;
;;;167    	int char_counter = 0;
        0x08002676:    2000        .       MOVS     r0,#0
        0x08002678:    9003        ..      STR      r0,[sp,#0xc]
;;;168    	char letter;
;;;169    	double value;
;;;170    //	int pause_value = 0;
;;;171    //	uint8_t radius_mode = false;
;;;172    
;;;173    	gc.status_code = GCSTATUS_OK;
        0x0800267a:    49bf        .I      LDR      r1,[pc,#764] ; [0x8002978] = 0x20000510
        0x0800267c:    7008        .p      STRB     r0,[r1,#0]
;;;174    	
;;;175    	if (line[0] == ';'
        0x0800267e:    f8980000    ....    LDRB     r0,[r8,#0]
        0x08002682:    283b        ;(      CMP      r0,#0x3b
        0x08002684:    d007        ..      BEQ      0x8002696 ; gc_execute_line + 38
;;;176    		|| line[0] == '('
        0x08002686:    f8980000    ....    LDRB     r0,[r8,#0]
        0x0800268a:    2828        ((      CMP      r0,#0x28
        0x0800268c:    d003        ..      BEQ      0x8002696 ; gc_execute_line + 38
;;;177    		|| line[0] == '%'
        0x0800268e:    f8980000    ....    LDRB     r0,[r8,#0]
        0x08002692:    2825        %(      CMP      r0,#0x25
        0x08002694:    d103        ..      BNE      0x800269e ; gc_execute_line + 46
;;;178    		)
;;;179    		return GCSTATUS_OK;	// comments
        0x08002696:    2000        .       MOVS     r0,#0
        0x08002698:    b004        ..      ADD      sp,sp,#0x10
        0x0800269a:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;180    
;;;181    	// Pass 1: Commands
;;;182    	while (next_statement(&letter, &value, line, &char_counter))
        0x0800269e:    e0ec        ..      B        0x800287a ; gc_execute_line + 522
;;;183    	{
;;;184    		int int_value = (int)value;
        0x080026a0:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x080026a4:    f7fdff1a    ....    BL       __aeabi_d2iz ; 0x80004dc
        0x080026a8:    4604        .F      MOV      r4,r0
;;;185    		switch (letter)
        0x080026aa:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x080026ae:    2847        G(      CMP      r0,#0x47
        0x080026b0:    d004        ..      BEQ      0x80026bc ; gc_execute_line + 76
        0x080026b2:    284d        M(      CMP      r0,#0x4d
        0x080026b4:    d072        r.      BEQ      0x800279c ; gc_execute_line + 300
        0x080026b6:    284e        N(      CMP      r0,#0x4e
        0x080026b8:    d1ff        ..      BNE      0x80026ba ; gc_execute_line + 74
;;;186    		{
;;;187    		case 'N':
;;;188    			break;
        0x080026ba:    e0d6        ..      B        0x800286a ; gc_execute_line + 506
;;;189    		case 'G':
;;;190    			switch (int_value)
        0x080026bc:    2c28        (,      CMP      r4,#0x28
        0x080026be:    d05d        ].      BEQ      0x800277c ; gc_execute_line + 268
        0x080026c0:    dc12        ..      BGT      0x80026e8 ; gc_execute_line + 120
        0x080026c2:    2c11        .,      CMP      r4,#0x11
        0x080026c4:    d05b        [.      BEQ      0x800277e ; gc_execute_line + 270
        0x080026c6:    dc06        ..      BGT      0x80026d6 ; gc_execute_line + 102
        0x080026c8:    2c05        .,      CMP      r4,#5
        0x080026ca:    d25e        ^.      BCS      0x800278a ; gc_execute_line + 282
        0x080026cc:    e8dff004    ....    TBB      [pc,r4]
    $d
        0x080026d0:    302b2621    !&+0    DCD    808134177
        0x080026d4:    0035        5.      DCW    53
    $t
        0x080026d6:    2c14        .,      CMP      r4,#0x14
        0x080026d8:    d034        4.      BEQ      0x8002744 ; gc_execute_line + 212
        0x080026da:    2c15        .,      CMP      r4,#0x15
        0x080026dc:    d036        6.      BEQ      0x800274c ; gc_execute_line + 220
        0x080026de:    2c1c        .,      CMP      r4,#0x1c
        0x080026e0:    d039        9.      BEQ      0x8002756 ; gc_execute_line + 230
        0x080026e2:    2c1e        .,      CMP      r4,#0x1e
        0x080026e4:    d151        Q.      BNE      0x800278a ; gc_execute_line + 282
        0x080026e6:    e035        5.      B        0x8002754 ; gc_execute_line + 228
        0x080026e8:    2c5b        [,      CMP      r4,#0x5b
        0x080026ea:    d03d        =.      BEQ      0x8002768 ; gc_execute_line + 248
        0x080026ec:    dc08        ..      BGT      0x8002700 ; gc_execute_line + 144
        0x080026ee:    2c31        1,      CMP      r4,#0x31
        0x080026f0:    d049        I.      BEQ      0x8002786 ; gc_execute_line + 278
        0x080026f2:    2c40        @,      CMP      r4,#0x40
        0x080026f4:    d041        A.      BEQ      0x800277a ; gc_execute_line + 266
        0x080026f6:    2c50        P,      CMP      r4,#0x50
        0x080026f8:    d046        F.      BEQ      0x8002788 ; gc_execute_line + 280
        0x080026fa:    2c5a        Z,      CMP      r4,#0x5a
        0x080026fc:    d145        E.      BNE      0x800278a ; gc_execute_line + 282
        0x080026fe:    e02f        /.      B        0x8002760 ; gc_execute_line + 240
        0x08002700:    2c5c        \,      CMP      r4,#0x5c
        0x08002702:    d035        5.      BEQ      0x8002770 ; gc_execute_line + 256
        0x08002704:    2c5e        ^,      CMP      r4,#0x5e
        0x08002706:    d03b        ;.      BEQ      0x8002780 ; gc_execute_line + 272
        0x08002708:    2c61        a,      CMP      r4,#0x61
        0x0800270a:    d03b        ;.      BEQ      0x8002784 ; gc_execute_line + 276
        0x0800270c:    2c62        b,      CMP      r4,#0x62
        0x0800270e:    d13c        <.      BNE      0x800278a ; gc_execute_line + 282
        0x08002710:    e037        7.      B        0x8002782 ; gc_execute_line + 274
;;;191    			{
;;;192    			case 0: gc.next_action = NEXT_ACTION_SEEK_G0; break;
        0x08002712:    2005        .       MOVS     r0,#5
        0x08002714:    4998        .I      LDR      r1,[pc,#608] ; [0x8002978] = 0x20000510
        0x08002716:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x0800271a:    e03d        =.      B        0x8002798 ; gc_execute_line + 296
;;;193    			case 1: gc.next_action = NEXT_ACTION_LINEAR_G1; break;
        0x0800271c:    2006        .       MOVS     r0,#6
        0x0800271e:    4996        .I      LDR      r1,[pc,#600] ; [0x8002978] = 0x20000510
        0x08002720:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x08002724:    e038        8.      B        0x8002798 ; gc_execute_line + 296
;;;194    			case 2: gc.next_action = NEXT_ACTION_CW_ARC; break;
        0x08002726:    200b        .       MOVS     r0,#0xb
        0x08002728:    4993        .I      LDR      r1,[pc,#588] ; [0x8002978] = 0x20000510
        0x0800272a:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x0800272e:    e033        3.      B        0x8002798 ; gc_execute_line + 296
;;;195    			case 3: gc.next_action = NEXT_ACTION_CCW_ARC; break;
        0x08002730:    200c        .       MOVS     r0,#0xc
        0x08002732:    4991        .I      LDR      r1,[pc,#580] ; [0x8002978] = 0x20000510
        0x08002734:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x08002738:    e02e        ..      B        0x8002798 ; gc_execute_line + 296
;;;196    			case 4: gc.next_action = NEXT_ACTION_DWELL_G4; break;
        0x0800273a:    2001        .       MOVS     r0,#1
        0x0800273c:    498e        .I      LDR      r1,[pc,#568] ; [0x8002978] = 0x20000510
        0x0800273e:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x08002742:    e029        ).      B        0x8002798 ; gc_execute_line + 296
;;;197    			case 20: gc.inches_mode = true; break;
        0x08002744:    2001        .       MOVS     r0,#1
        0x08002746:    498c        .I      LDR      r1,[pc,#560] ; [0x8002978] = 0x20000510
        0x08002748:    7048        Hp      STRB     r0,[r1,#1]
        0x0800274a:    e025        %.      B        0x8002798 ; gc_execute_line + 296
;;;198    			case 21: gc.inches_mode = false; break;
        0x0800274c:    2000        .       MOVS     r0,#0
        0x0800274e:    498a        .I      LDR      r1,[pc,#552] ; [0x8002978] = 0x20000510
        0x08002750:    7048        Hp      STRB     r0,[r1,#1]
        0x08002752:    e021        !.      B        0x8002798 ; gc_execute_line + 296
;;;199    			case 30:
;;;200    			case 28: gc.next_action = NEXT_ACTION_GO_HOME_G28; break;
        0x08002754:    bf00        ..      NOP      
        0x08002756:    2002        .       MOVS     r0,#2
        0x08002758:    4987        .I      LDR      r1,[pc,#540] ; [0x8002978] = 0x20000510
        0x0800275a:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x0800275e:    e01b        ..      B        0x8002798 ; gc_execute_line + 296
;;;201    			case 90: gc.absolute_mode = true; break;
        0x08002760:    2001        .       MOVS     r0,#1
        0x08002762:    4985        .I      LDR      r1,[pc,#532] ; [0x8002978] = 0x20000510
        0x08002764:    7088        .p      STRB     r0,[r1,#2]
        0x08002766:    e017        ..      B        0x8002798 ; gc_execute_line + 296
;;;202    			case 91: gc.absolute_mode = false; break;
        0x08002768:    2000        .       MOVS     r0,#0
        0x0800276a:    4983        .I      LDR      r1,[pc,#524] ; [0x8002978] = 0x20000510
        0x0800276c:    7088        .p      STRB     r0,[r1,#2]
        0x0800276e:    e013        ..      B        0x8002798 ; gc_execute_line + 296
;;;203    			case 92: gc.next_action = NEXT_ACTION_RESET_XYZ_G92; break;
        0x08002770:    2003        .       MOVS     r0,#3
        0x08002772:    4981        .I      LDR      r1,[pc,#516] ; [0x8002978] = 0x20000510
        0x08002774:    f8810042    ..B.    STRB     r0,[r1,#0x42]
        0x08002778:    e00e        ..      B        0x8002798 ; gc_execute_line + 296
;;;204    			case 64:
;;;205    			case 40:
        0x0800277a:    bf00        ..      NOP      
;;;206    			case 17:	// G17    X-Y
        0x0800277c:    bf00        ..      NOP      
;;;207    			case 94:	// Feedrate per minute
        0x0800277e:    bf00        ..      NOP      
;;;208    			case 98:	// Feedrate per minute (group type A)
        0x08002780:    bf00        ..      NOP      
;;;209    			case 97:	// Constant spindle speed M T Takes an S address integer, which is interpreted as rev/min (rpm). The default speed mode per system parameter if no mode is programmed. 
        0x08002782:    bf00        ..      NOP      
;;;210    			case 49:	// Tool length offset compensation cancel
        0x08002784:    bf00        ..      NOP      
;;;211    			case 80:	// Cancel canned cycle
        0x08002786:    bf00        ..      NOP      
;;;212    				break;
        0x08002788:    e006        ..      B        0x8002798 ; gc_execute_line + 296
;;;213    			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
        0x0800278a:    2003        .       MOVS     r0,#3
        0x0800278c:    497a        zI      LDR      r1,[pc,#488] ; [0x8002978] = 0x20000510
        0x0800278e:    7008        .p      STRB     r0,[r1,#0]
        0x08002790:    4608        .F      MOV      r0,r1
        0x08002792:    7800        .x      LDRB     r0,[r0,#0]
        0x08002794:    e780        ..      B        0x8002698 ; gc_execute_line + 40
        0x08002796:    e001        ..      B        0x800279c ; gc_execute_line + 300
        0x08002798:    bf00        ..      NOP      
;;;214    			}
;;;215    			break;
        0x0800279a:    e066        f.      B        0x800286a ; gc_execute_line + 506
;;;216    		case 'M':
;;;217    			switch (int_value)
        0x0800279c:    2c31        1,      CMP      r4,#0x31
        0x0800279e:    d04c        L.      BEQ      0x800283a ; gc_execute_line + 458
        0x080027a0:    dc17        ..      BGT      0x80027d2 ; gc_execute_line + 354
        0x080027a2:    2c08        .,      CMP      r4,#8
        0x080027a4:    d04b        K.      BEQ      0x800283e ; gc_execute_line + 462
        0x080027a6:    dc07        ..      BGT      0x80027b8 ; gc_execute_line + 328
        0x080027a8:    2c07        .,      CMP      r4,#7
        0x080027aa:    d256        V.      BCS      0x800285a ; gc_execute_line + 490
        0x080027ac:    e8dff004    ....    TBB      [pc,r4]
    $d
        0x080027b0:    3a333231    123:    DCD    976433713
        0x080027b4:    00523e55    U>R.    DCD    5389909
    $t
        0x080027b8:    2c18        .,      CMP      r4,#0x18
        0x080027ba:    d03c        <.      BEQ      0x8002836 ; gc_execute_line + 454
        0x080027bc:    dc04        ..      BGT      0x80027c8 ; gc_execute_line + 344
        0x080027be:    2c09        .,      CMP      r4,#9
        0x080027c0:    d03e        >.      BEQ      0x8002840 ; gc_execute_line + 464
        0x080027c2:    2c17        .,      CMP      r4,#0x17
        0x080027c4:    d149        I.      BNE      0x800285a ; gc_execute_line + 490
        0x080027c6:    e035        5.      B        0x8002834 ; gc_execute_line + 452
        0x080027c8:    2c1e        .,      CMP      r4,#0x1e
        0x080027ca:    d025        %.      BEQ      0x8002818 ; gc_execute_line + 424
        0x080027cc:    2c30        0,      CMP      r4,#0x30
        0x080027ce:    d144        D.      BNE      0x800285a ; gc_execute_line + 490
        0x080027d0:    e034        4.      B        0x800283c ; gc_execute_line + 460
        0x080027d2:    2c6e        n,      CMP      r4,#0x6e
        0x080027d4:    d039        9.      BEQ      0x800284a ; gc_execute_line + 474
        0x080027d6:    dc0e        ..      BGT      0x80027f6 ; gc_execute_line + 390
        0x080027d8:    2c6a        j,      CMP      r4,#0x6a
        0x080027da:    d033        3.      BEQ      0x8002844 ; gc_execute_line + 468
        0x080027dc:    dc06        ..      BGT      0x80027ec ; gc_execute_line + 380
        0x080027de:    2c34        4,      CMP      r4,#0x34
        0x080027e0:    d02a        *.      BEQ      0x8002838 ; gc_execute_line + 456
        0x080027e2:    2c3c        <,      CMP      r4,#0x3c
        0x080027e4:    d019        ..      BEQ      0x800281a ; gc_execute_line + 426
        0x080027e6:    2c69        i,      CMP      r4,#0x69
        0x080027e8:    d137        7.      BNE      0x800285a ; gc_execute_line + 490
        0x080027ea:    e02a        *.      B        0x8002842 ; gc_execute_line + 466
        0x080027ec:    2c6b        k,      CMP      r4,#0x6b
        0x080027ee:    d02a        *.      BEQ      0x8002846 ; gc_execute_line + 470
        0x080027f0:    2c6c        l,      CMP      r4,#0x6c
        0x080027f2:    d132        2.      BNE      0x800285a ; gc_execute_line + 490
        0x080027f4:    e028        (.      B        0x8002848 ; gc_execute_line + 472
        0x080027f6:    2c8c        .,      CMP      r4,#0x8c
        0x080027f8:    d029        ).      BEQ      0x800284e ; gc_execute_line + 478
        0x080027fa:    dc04        ..      BGT      0x8002806 ; gc_execute_line + 406
        0x080027fc:    2c70        p,      CMP      r4,#0x70
        0x080027fe:    d007        ..      BEQ      0x8002810 ; gc_execute_line + 416
        0x08002800:    2c71        q,      CMP      r4,#0x71
        0x08002802:    d12a        *.      BNE      0x800285a ; gc_execute_line + 490
        0x08002804:    e022        ".      B        0x800284c ; gc_execute_line + 476
        0x08002806:    2c8d        .,      CMP      r4,#0x8d
        0x08002808:    d022        ".      BEQ      0x8002850 ; gc_execute_line + 480
        0x0800280a:    2c8e        .,      CMP      r4,#0x8e
        0x0800280c:    d125        %.      BNE      0x800285a ; gc_execute_line + 490
        0x0800280e:    e020         .      B        0x8002852 ; gc_execute_line + 482
;;;218    			{
;;;219    			case 112: // Emergency Stop 
;;;220    			case 0:
        0x08002810:    bf00        ..      NOP      
;;;221    			case 1:
        0x08002812:    bf00        ..      NOP      
;;;222    			case 2:
        0x08002814:    bf00        ..      NOP      
;;;223    			case 30:
        0x08002816:    bf00        ..      NOP      
;;;224    			case 60:
        0x08002818:    bf00        ..      NOP      
;;;225    				gc.next_action = NEXT_ACTION_STOP;
        0x0800281a:    2004        .       MOVS     r0,#4
        0x0800281c:    4956        VI      LDR      r1,[pc,#344] ; [0x8002978] = 0x20000510
        0x0800281e:    f8810042    ..B.    STRB     r0,[r1,#0x42]
;;;226    				break;
        0x08002822:    e020         .      B        0x8002866 ; gc_execute_line + 502
;;;227    			case 3: gc.spindle_on = 1; break;
        0x08002824:    2001        .       MOVS     r0,#1
        0x08002826:    4954        TI      LDR      r1,[pc,#336] ; [0x8002978] = 0x20000510
        0x08002828:    70c8        .p      STRB     r0,[r1,#3]
        0x0800282a:    e01c        ..      B        0x8002866 ; gc_execute_line + 502
;;;228    			//	case 4: gc.spindle_direction = -1; break;
;;;229    			case 5: gc.spindle_on = 0; break;
        0x0800282c:    2000        .       MOVS     r0,#0
        0x0800282e:    4952        RI      LDR      r1,[pc,#328] ; [0x8002978] = 0x20000510
        0x08002830:    70c8        .p      STRB     r0,[r1,#3]
        0x08002832:    e018        ..      B        0x8002866 ; gc_execute_line + 502
;;;230    			case 23: // Thread gradual pullout ON
;;;231    			case 24: // Thread gradual pullout OFF
        0x08002834:    bf00        ..      NOP      
;;;232    			case 52: // Unload Last tool from spindle
        0x08002836:    bf00        ..      NOP      
;;;233    			case 49: // Feedrate override NOT allowed
        0x08002838:    bf00        ..      NOP      
;;;234    			case 48: // Feedrate override allowed
        0x0800283a:    bf00        ..      NOP      
;;;235    			case 8:  // Coolant on
        0x0800283c:    bf00        ..      NOP      
;;;236    			case 9:  // Coolant off
        0x0800283e:    bf00        ..      NOP      
;;;237    			case 105: // M105: Get Extruder Temperature Example: M105 Request the temperature of the current extruder and the build base in degrees Celsius. The temperatures are returned to the host computer. For example, the line sent to the host in response to this command looks like 
        0x08002840:    bf00        ..      NOP      
;;;238    			case 106: // M106: Fan On Example: M106 S127 Turn on the cooling fan at half speed. Optional parameter 'S' declares the PWM value (0-255) 
        0x08002842:    bf00        ..      NOP      
;;;239    			case 107: // Fan Off 
        0x08002844:    bf00        ..      NOP      
;;;240    			case 108: // M108: Set Extruder Speed  Sets speed of extruder motor. (Deprecated in current firmware, see M113) 
        0x08002846:    bf00        ..      NOP      
;;;241    			case 110: // Set Current Line Number 
        0x08002848:    bf00        ..      NOP      
;;;242    			case 113: // Set Extruder PWM 
        0x0800284a:    bf00        ..      NOP      
;;;243    			case 140: // Bed Temperature (Fast) Example: M140 S55 Set the temperature of the build bed to 55oC 
        0x0800284c:    bf00        ..      NOP      
;;;244    			case 141: //Chamber Temperature (Fast) Example: M141 S30 Set the temperature of the chamber to 30oC
        0x0800284e:    bf00        ..      NOP      
;;;245    			case 142: // Holding Pressure Example: M142 S1 Set the holding pressure of the bed to 1 bar. 
        0x08002850:    bf00        ..      NOP      
;;;246    			case 6:
        0x08002852:    bf00        ..      NOP      
;;;247    				return gc.status_code;
        0x08002854:    4848        HH      LDR      r0,[pc,#288] ; [0x8002978] = 0x20000510
        0x08002856:    7800        .x      LDRB     r0,[r0,#0]
        0x08002858:    e71e        ..      B        0x8002698 ; gc_execute_line + 40
;;;248    			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
        0x0800285a:    2003        .       MOVS     r0,#3
        0x0800285c:    4946        FI      LDR      r1,[pc,#280] ; [0x8002978] = 0x20000510
        0x0800285e:    7008        .p      STRB     r0,[r1,#0]
        0x08002860:    4608        .F      MOV      r0,r1
        0x08002862:    7800        .x      LDRB     r0,[r0,#0]
        0x08002864:    e718        ..      B        0x8002698 ; gc_execute_line + 40
        0x08002866:    bf00        ..      NOP      
;;;249    			}
;;;250    			break;
        0x08002868:    bf00        ..      NOP      
        0x0800286a:    bf00        ..      NOP      
;;;251    		}
;;;252    		if (gc.status_code)
        0x0800286c:    4842        BH      LDR      r0,[pc,#264] ; [0x8002978] = 0x20000510
        0x0800286e:    7800        .x      LDRB     r0,[r0,#0]
        0x08002870:    b110        ..      CBZ      r0,0x8002878 ; gc_execute_line + 520
;;;253    			return (gc.status_code);
        0x08002872:    4841        AH      LDR      r0,[pc,#260] ; [0x8002978] = 0x20000510
        0x08002874:    7800        .x      LDRB     r0,[r0,#0]
        0x08002876:    e70f        ..      B        0x8002698 ; gc_execute_line + 40
;;;254    	}
        0x08002878:    bf00        ..      NOP      
        0x0800287a:    ab03        ..      ADD      r3,sp,#0xc
        0x0800287c:    4642        BF      MOV      r2,r8
        0x0800287e:    4669        iF      MOV      r1,sp
        0x08002880:    a802        ..      ADD      r0,sp,#8
        0x08002882:    f000f99f    ....    BL       next_statement ; 0x8002bc4
        0x08002886:    2800        .(      CMP      r0,#0
        0x08002888:    f47faf0a    ....    BNE      0x80026a0 ; gc_execute_line + 48
;;;255    	if (gc.status_code)
        0x0800288c:    483a        :H      LDR      r0,[pc,#232] ; [0x8002978] = 0x20000510
        0x0800288e:    7800        .x      LDRB     r0,[r0,#0]
        0x08002890:    b110        ..      CBZ      r0,0x8002898 ; gc_execute_line + 552
;;;256    		return(gc.status_code);
        0x08002892:    4839        9H      LDR      r0,[pc,#228] ; [0x8002978] = 0x20000510
        0x08002894:    7800        .x      LDRB     r0,[r0,#0]
        0x08002896:    e6ff        ..      B        0x8002698 ; gc_execute_line + 40
;;;257    
;;;258    	char_counter = 0;
        0x08002898:    2000        .       MOVS     r0,#0
        0x0800289a:    9003        ..      STR      r0,[sp,#0xc]
;;;259    
;;;260    	// Pass 2: Parameters
;;;261    	while (next_statement(&letter, &value, line, &char_counter))
        0x0800289c:    e061        a.      B        0x8002962 ; gc_execute_line + 754
;;;262    	{
;;;263    		double unit_millimeters_value = to_millimeters(value);
        0x0800289e:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x080028a2:    f000fba9    ....    BL       to_millimeters ; 0x8002ff8
        0x080028a6:    4604        .F      MOV      r4,r0
        0x080028a8:    460d        .F      MOV      r5,r1
;;;264    		switch (letter)
        0x080028aa:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x080028ae:    3846        F8      SUBS     r0,r0,#0x46
        0x080028b0:    2815        .(      CMP      r0,#0x15
        0x080028b2:    d24e        N.      BCS      0x8002952 ; gc_execute_line + 738
        0x080028b4:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x080028b8:    464d4a0b    .JMF    DCD    1179470347
        0x080028bc:    4c4d4847    GHML    DCD    1280133191
        0x080028c0:    4d4d4d4b    KMMM    DCD    1296911691
        0x080028c4:    4d4d1849    I.MM    DCD    1296898121
        0x080028c8:    22214d4d    MM!"    DCD    572607821
        0x080028cc:    0023        #.      DCW    35
    $t
;;;265    		{
;;;266    //		case 'E': extrudeLength = value; break;
;;;267    		case 'F':
;;;268    			if (gc.next_action == NEXT_ACTION_SEEK_G0)
        0x080028ce:    482a        *H      LDR      r0,[pc,#168] ; [0x8002978] = 0x20000510
        0x080028d0:    f8900042    ..B.    LDRB     r0,[r0,#0x42]
        0x080028d4:    2805        .(      CMP      r0,#5
        0x080028d6:    d103        ..      BNE      0x80028e0 ; gc_execute_line + 624
;;;269    				gc.seek_rate = unit_millimeters_value;
        0x080028d8:    4827        'H      LDR      r0,[pc,#156] ; [0x8002978] = 0x20000510
        0x080028da:    e9c04504    ...E    STRD     r4,r5,[r0,#0x10]
        0x080028de:    e002        ..      B        0x80028e6 ; gc_execute_line + 630
;;;270    			else
;;;271    				gc.feed_rate = unit_millimeters_value; // millimeters pr min
        0x080028e0:    4825        %H      LDR      r0,[pc,#148] ; [0x8002978] = 0x20000510
        0x080028e2:    e9c04502    ...E    STRD     r4,r5,[r0,#8]
;;;272    			//	if (unit_millimeters_value > SM_MAX_FEEDRATE)
;;;273    			//		FAIL(GCSTATUS_UNSOPORTED_FEEDRATE);
;;;274    			break;
        0x080028e6:    e03a        :.      B        0x800295e ; gc_execute_line + 750
;;;275    //		case 'P': pause_value = (int)value; break;
;;;276    		case 'S': gc.s_value = (int16_t)value; break;
        0x080028e8:    e9dd0100    ....    LDRD     r0,r1,[sp,#0]
        0x080028ec:    f7fdfdf6    ....    BL       __aeabi_d2iz ; 0x80004dc
        0x080028f0:    b200        ..      SXTH     r0,r0
        0x080028f2:    4921        !I      LDR      r1,[pc,#132] ; [0x8002978] = 0x20000510
        0x080028f4:    f8a10040    ..@.    STRH     r0,[r1,#0x40]
        0x080028f8:    e031        1.      B        0x800295e ; gc_execute_line + 750
;;;277    		case 'X':
;;;278    		case 'Y':
        0x080028fa:    bf00        ..      NOP      
;;;279    		case 'Z':
        0x080028fc:    bf00        ..      NOP      
;;;280    			if (gc.absolute_mode)
        0x080028fe:    481e        .H      LDR      r0,[pc,#120] ; [0x8002978] = 0x20000510
        0x08002900:    7880        .x      LDRB     r0,[r0,#2]
        0x08002902:    b140        @.      CBZ      r0,0x8002916 ; gc_execute_line + 678
;;;281    				gc.position[letter - 'X'] = unit_millimeters_value;
        0x08002904:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x08002908:    3858        X8      SUBS     r0,r0,#0x58
        0x0800290a:    491b        .I      LDR      r1,[pc,#108] ; [0x8002978] = 0x20000510
        0x0800290c:    3128        (1      ADDS     r1,r1,#0x28
        0x0800290e:    eb0100c0    ....    ADD      r0,r1,r0,LSL #3
        0x08002912:    c030        0.      STM      r0!,{r4,r5}
        0x08002914:    e015        ..      B        0x8002942 ; gc_execute_line + 722
;;;282    			else
;;;283    				gc.position[letter - 'X'] += unit_millimeters_value;
        0x08002916:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x0800291a:    3858        X8      SUBS     r0,r0,#0x58
        0x0800291c:    4916        .I      LDR      r1,[pc,#88] ; [0x8002978] = 0x20000510
        0x0800291e:    3128        (1      ADDS     r1,r1,#0x28
        0x08002920:    eb0100c0    ....    ADD      r0,r1,r0,LSL #3
        0x08002924:    4622        "F      MOV      r2,r4
        0x08002926:    462b        +F      MOV      r3,r5
        0x08002928:    e9d06100    ...a    LDRD     r6,r1,[r0,#0]
        0x0800292c:    4630        0F      MOV      r0,r6
        0x0800292e:    f7fdfc3c    ..<.    BL       __aeabi_dadd ; 0x80001aa
        0x08002932:    f89d2008    ...     LDRB     r2,[sp,#8]
        0x08002936:    3a58        X:      SUBS     r2,r2,#0x58
        0x08002938:    4b0f        .K      LDR      r3,[pc,#60] ; [0x8002978] = 0x20000510
        0x0800293a:    3328        (3      ADDS     r3,r3,#0x28
        0x0800293c:    eb0302c2    ....    ADD      r2,r3,r2,LSL #3
        0x08002940:    c203        ..      STM      r2!,{r0,r1}
;;;284    			break;
        0x08002942:    e00c        ..      B        0x800295e ; gc_execute_line + 750
;;;285    		case 'I':
;;;286    		case 'J':
        0x08002944:    bf00        ..      NOP      
;;;287    		case 'K':
        0x08002946:    bf00        ..      NOP      
;;;288    //			offset[letter - 'I'] = unit_millimeters_value;
;;;289    			break;
        0x08002948:    e009        ..      B        0x800295e ; gc_execute_line + 750
;;;290    		case 'R':
;;;291    //			radius = unit_millimeters_value;
;;;292    //			radius_mode = true;
;;;293    			break;
        0x0800294a:    e008        ..      B        0x800295e ; gc_execute_line + 750
;;;294    		case 'G':
;;;295    		case 'N':
        0x0800294c:    bf00        ..      NOP      
;;;296    		case 'M':
        0x0800294e:    bf00        ..      NOP      
;;;297    			break;
        0x08002950:    e005        ..      B        0x800295e ; gc_execute_line + 750
;;;298    		default:
;;;299    			FAIL(GCSTATUS_UNSUPPORTED_PARAM);
        0x08002952:    2005        .       MOVS     r0,#5
        0x08002954:    4908        .I      LDR      r1,[pc,#32] ; [0x8002978] = 0x20000510
        0x08002956:    7008        .p      STRB     r0,[r1,#0]
        0x08002958:    4608        .F      MOV      r0,r1
        0x0800295a:    7800        .x      LDRB     r0,[r0,#0]
        0x0800295c:    e69c        ..      B        0x8002698 ; gc_execute_line + 40
        0x0800295e:    bf00        ..      NOP      
;;;300    		}
;;;301    	}
        0x08002960:    bf00        ..      NOP      
        0x08002962:    ab03        ..      ADD      r3,sp,#0xc
        0x08002964:    4642        BF      MOV      r2,r8
        0x08002966:    4669        iF      MOV      r1,sp
        0x08002968:    a802        ..      ADD      r0,sp,#8
        0x0800296a:    f000f92b    ..+.    BL       next_statement ; 0x8002bc4
        0x0800296e:    2800        .(      CMP      r0,#0
        0x08002970:    d195        ..      BNE      0x800289e ; gc_execute_line + 558
;;;302    	
;;;303    	return(gc.status_code);
        0x08002972:    4801        .H      LDR      r0,[pc,#4] ; [0x8002978] = 0x20000510
        0x08002974:    7800        .x      LDRB     r0,[r0,#0]
        0x08002976:    e68f        ..      B        0x8002698 ; gc_execute_line + 40
    $d
        0x08002978:    20000510    ...     DCD    536872208
    $t
    i.init_buttons
    init_buttons
;;; .\..\Src\buttons.c
;;;11     void init_buttons(void){
        0x0800297c:    b510        ..      PUSH     {r4,lr}
;;;12     
;;;13     	bt[0].clk_mode = 10;
        0x0800297e:    200a        .       MOVS     r0,#0xa
        0x08002980:    4906        .I      LDR      r1,[pc,#24] ; [0x800299c] = 0x200004f0
        0x08002982:    61c8        .a      STR      r0,[r1,#0x1c]
;;;14     	bt[0].GPIOx = BUTTON_1_GPIO_Port;
        0x08002984:    4806        .H      LDR      r0,[pc,#24] ; [0x80029a0] = 0x40010800
        0x08002986:    6008        .`      STR      r0,[r1,#0]
;;;15     	bt[0].button_pin = BUTTON_1_Pin;
        0x08002988:    4806        .H      LDR      r0,[pc,#24] ; [0x80029a4] = 0x4010001
        0x0800298a:    6048        H`      STR      r0,[r1,#4]
;;;16     	bt[0].buttons = bt[0].buttons_mask = LL_GPIO_IsInputPinSet(bt[0].GPIOx,BUTTON_1_Pin); //bt[0].GPIOx->IDR & bt[0].button_pin;
        0x0800298c:    6808        .h      LDR      r0,[r1,#0]
        0x0800298e:    4905        .I      LDR      r1,[pc,#20] ; [0x80029a4] = 0x4010001
        0x08002990:    f7fef869    ..i.    BL       LL_GPIO_IsInputPinSet ; 0x8000a66
        0x08002994:    4901        .I      LDR      r1,[pc,#4] ; [0x800299c] = 0x200004f0
        0x08002996:    6188        .a      STR      r0,[r1,#0x18]
        0x08002998:    60c8        .`      STR      r0,[r1,#0xc]
;;;17     	return;
;;;18     	bt[1] = bt[0];
;;;19     	bt[1].clk_mode = 10;
;;;20     	bt[1].GPIOx = BUTTON_2_GPIO_Port;
;;;21     	bt[1].button_pin = BUTTON_2_Pin;
;;;22     	bt[1].buttons = bt[1].buttons_mask = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;23     
;;;24     	if(device_ready == 1){
;;;25     //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);		
;;;26     		reqest_sample_i2c_dma();
;;;27     //		while(ubTransferComplete == 0){
;;;28     //		}
;;;29     	}
;;;30     	bt[2].clk_mode = 10;
;;;31     	bt[2].button_pin = 0x02; // button_c code
;;;32     	bt[2].buttons = bt[2].buttons_mask = dma_data[5]&bt[2].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;33     	
;;;34     	bt[3].clk_mode = 10;
;;;35     	bt[3].button_pin = 0x01; // button_c code
;;;36     	bt[3].buttons = bt[3].buttons_mask = dma_data[5]&bt[3].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;37     
;;;38     }
        0x0800299a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800299c:    200004f0    ...     DCD    536872176
        0x080029a0:    40010800    ...@    DCD    1073809408
        0x080029a4:    04010001    ....    DCD    67174401
    $t
    i.main
    main
;;; .\../Src/main.c
;;;251    {
        0x080029a8:    b51f        ..      PUSH     {r0-r4,lr}
;;;252      /* USER CODE BEGIN 1 */
;;;253    //	z_axis.mode = fsm_menu_lps;
;;;254    	rs = 11;
        0x080029aa:    200b        .       MOVS     r0,#0xb
        0x080029ac:    496f        oI      LDR      r1,[pc,#444] ; [0x8002b6c] = 0x200000b0
        0x080029ae:    6008        .`      STR      r0,[r1,#0]
;;;255    
;;;256    	char code[] = "G01 X.2 Z100F10";
        0x080029b0:    a36f        o.      ADR      r3,{pc}+0x1c0 ; 0x8002b70
        0x080029b2:    e9d31200    ....    LDRD     r1,r2,[r3,#0]
        0x080029b6:    e9d30302    ....    LDRD     r0,r3,[r3,#8]
        0x080029ba:    e9cd0302    ....    STRD     r0,r3,[sp,#8]
        0x080029be:    e9cd1200    ....    STRD     r1,r2,[sp,#0]
;;;257    	gc_execute_line(code);
        0x080029c2:    4668        hF      MOV      r0,sp
        0x080029c4:    f7fffe54    ..T.    BL       gc_execute_line ; 0x8002670
;;;258    //	z_axis.end_pos = 50;
;;;259    //	z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;260    
;;;261    //	state.main_feed_direction = 1;
;;;262    
;;;263    	//	do_fsm_move_start(&state);
;;;264    	//	do_fsm_wait_tacho(&state);
;;;265    	
;;;266    //	TIM4_IRQHandler();
;;;267      /* USER CODE END 1 */
;;;268    
;;;269      /* MCU Configuration--------------------------------------------------------*/
;;;270    
;;;271      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;272      
;;;273    
;;;274      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_AFIO);
        0x080029c8:    2001        .       MOVS     r0,#1
        0x080029ca:    f7fdff3d    ..=.    BL       LL_APB2_GRP1_EnableClock ; 0x8000848
;;;275      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
        0x080029ce:    f04f5080    O..P    MOV      r0,#0x10000000
        0x080029d2:    f7fdff2b    ..+.    BL       LL_APB1_GRP1_EnableClock ; 0x800082c
;;;276    
;;;277      NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
        0x080029d6:    2003        .       MOVS     r0,#3
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1425     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
        0x080029d8:    4602        .F      MOV      r2,r0
;;;1426   
;;;1427     reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
        0x080029da:    4b69        iK      LDR      r3,[pc,#420] ; [0x8002b80] = 0xe000ed0c
        0x080029dc:    6819        .h      LDR      r1,[r3,#0]
;;;1428     reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
        0x080029de:    f64f03ff    O...    MOV      r3,#0xf8ff
        0x080029e2:    4019        .@      ANDS     r1,r1,r3
;;;1429     reg_value  =  (reg_value                                   |
        0x080029e4:    4b67        gK      LDR      r3,[pc,#412] ; [0x8002b84] = 0x5fa0000
        0x080029e6:    430b        .C      ORRS     r3,r3,r1
        0x080029e8:    ea432102    C..!    ORR      r1,r3,r2,LSL #8
;;;1430                   ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
;;;1431                   (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
;;;1432     SCB->AIRCR =  reg_value;
        0x080029ec:    4b64        dK      LDR      r3,[pc,#400] ; [0x8002b80] = 0xe000ed0c
        0x080029ee:    6019        .`      STR      r1,[r3,#0]
;;;1433   }
        0x080029f0:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;283      LL_GPIO_AF_Remap_SWJ_NOJTAG();
        0x080029f2:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;1597     CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
        0x080029f4:    4864        dH      LDR      r0,[pc,#400] ; [0x8002b88] = 0x40010000
        0x080029f6:    6840        @h      LDR      r0,[r0,#4]
        0x080029f8:    f02060e0     ..`    BIC      r0,r0,#0x7000000
        0x080029fc:    4962        bI      LDR      r1,[pc,#392] ; [0x8002b88] = 0x40010000
        0x080029fe:    6048        H`      STR      r0,[r1,#4]
;;;1598     SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);
        0x08002a00:    4608        .F      MOV      r0,r1
        0x08002a02:    6840        @h      LDR      r0,[r0,#4]
        0x08002a04:    f0407000    @..p    ORR      r0,r0,#0x2000000
        0x08002a08:    6048        H`      STR      r0,[r1,#4]
;;;1599   }
        0x08002a0a:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;289      SystemClock_Config();
        0x08002a0c:    f7fff9aa    ....    BL       SystemClock_Config ; 0x8001d64
;;;290    
;;;291      /* USER CODE BEGIN SysInit */
;;;292    	LL_SYSTICK_EnableIT();
        0x08002a10:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;291      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
        0x08002a12:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x08002a16:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002a18:    f0400002    @...    ORR      r0,r0,#2
        0x08002a1c:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08002a20:    6108        .a      STR      r0,[r1,#0x10]
;;;292    }
        0x08002a22:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;296      MX_GPIO_Init();
        0x08002a24:    f7fefbca    ....    BL       MX_GPIO_Init ; 0x80011bc
;;;297      MX_DMA_Init();
        0x08002a28:    f7fefb9a    ....    BL       MX_DMA_Init ; 0x8001160
;;;298      MX_I2C2_Init();
        0x08002a2c:    f7fefc40    ..@.    BL       MX_I2C2_Init ; 0x80012b0
;;;299      MX_TIM1_Init();
        0x08002a30:    f7fefcd6    ....    BL       MX_TIM1_Init ; 0x80013e0
;;;300      MX_TIM2_Init();
        0x08002a34:    f7fefd3e    ..>.    BL       MX_TIM2_Init ; 0x80014b4
;;;301      MX_TIM3_Init();
        0x08002a38:    f7fefd90    ....    BL       MX_TIM3_Init ; 0x800155c
;;;302      MX_TIM4_Init();
        0x08002a3c:    f7fefe52    ..R.    BL       MX_TIM4_Init ; 0x80016e4
;;;303      MX_USART2_UART_Init();
        0x08002a40:    f7fefee4    ....    BL       MX_USART2_UART_Init ; 0x800180c
;;;304      /* USER CODE BEGIN 2 */
;;;305    
;;;306      /* Enable DMA TX Interrupt */
;;;307      LL_USART_EnableDMAReq_TX(USART2);
        0x08002a44:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2416     SET_BIT(USARTx->CR3, USART_CR3_DMAT);
        0x08002a46:    4851        QH      LDR      r0,[pc,#324] ; [0x8002b8c] = 0x40004400
        0x08002a48:    6940        @i      LDR      r0,[r0,#0x14]
        0x08002a4a:    f0400080    @...    ORR      r0,r0,#0x80
        0x08002a4e:    494f        OI      LDR      r1,[pc,#316] ; [0x8002b8c] = 0x40004400
        0x08002a50:    6148        Ha      STR      r0,[r1,#0x14]
;;;2417   }
        0x08002a52:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;309      LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_7);
        0x08002a54:    484e        NH      LDR      r0,[pc,#312] ; [0x8002b90] = 0x40020000
        0x08002a56:    2107        .!      MOVS     r1,#7
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;472      SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x08002a58:    1e4a        J.      SUBS     r2,r1,#1
        0x08002a5a:    4b4e        NK      LDR      r3,[pc,#312] ; [0x8002b94] = 0x80031e8
        0x08002a5c:    5c9a        .\      LDRB     r2,[r3,r2]
        0x08002a5e:    5882        .X      LDR      r2,[r0,r2]
        0x08002a60:    f0420301    B...    ORR      r3,r2,#1
        0x08002a64:    1e4a        J.      SUBS     r2,r1,#1
        0x08002a66:    4c4b        KL      LDR      r4,[pc,#300] ; [0x8002b94] = 0x80031e8
        0x08002a68:    5ca2        .\      LDRB     r2,[r4,r2]
        0x08002a6a:    5083        .P      STR      r3,[r0,r2]
;;;473    }
        0x08002a6c:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;314    	LL_TIM_GenerateEvent_UPDATE(TIM2);
        0x08002a6e:    0340        @.      LSLS     r0,r0,#13
        0x08002a70:    f7fef90c    ....    BL       LL_TIM_GenerateEvent_UPDATE ; 0x8000c8c
;;;315    //  LL_TIM_CC_EnableChannel(TIM2, LL_TIM_CHANNEL_CH1); // if we need output on leg
;;;316      LL_TIM_ClearFlag_UPDATE(TIM2);
        0x08002a74:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08002a76:    f06f0001    o...    MVN      r0,#1
        0x08002a7a:    f04f4180    O..A    MOV      r1,#0x40000000
        0x08002a7e:    6108        .a      STR      r0,[r1,#0x10]
;;;2933   }
        0x08002a80:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;317    	LL_TIM_EnableIT_UPDATE(TIM2);
        0x08002a82:    4608        .F      MOV      r0,r1
        0x08002a84:    f7fef8f8    ....    BL       LL_TIM_EnableIT_UPDATE ; 0x8000c78
;;;318    
;;;319    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;320    
;;;321    
;;;322    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;323    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1);
;;;324    //	TIM3->SR = 0;
;;;325    //	TIM2->SR = 0;
;;;326    	TIM3->ARR = 0;
        0x08002a88:    2000        .       MOVS     r0,#0
        0x08002a8a:    4943        CI      LDR      r1,[pc,#268] ; [0x8002b98] = 0x4000042c
        0x08002a8c:    6008        .`      STR      r0,[r1,#0]
;;;327    	LL_TIM_GenerateEvent_UPDATE(TIM3);
        0x08002a8e:    4842        BH      LDR      r0,[pc,#264] ; [0x8002b98] = 0x4000042c
        0x08002a90:    382c        ,8      SUBS     r0,r0,#0x2c
        0x08002a92:    f7fef8fb    ....    BL       LL_TIM_GenerateEvent_UPDATE ; 0x8000c8c
;;;328    	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x08002a96:    f2401001    @...    MOV      r0,#0x101
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1493     SET_BIT(TIMx->CCER, Channels);
        0x08002a9a:    493f        ?I      LDR      r1,[pc,#252] ; [0x8002b98] = 0x4000042c
        0x08002a9c:    392c        ,9      SUBS     r1,r1,#0x2c
        0x08002a9e:    6a09        .j      LDR      r1,[r1,#0x20]
        0x08002aa0:    4301        .C      ORRS     r1,r1,r0
        0x08002aa2:    4a3d        =J      LDR      r2,[pc,#244] ; [0x8002b98] = 0x4000042c
        0x08002aa4:    3a2c        ,:      SUBS     r2,r2,#0x2c
        0x08002aa6:    6211        .b      STR      r1,[r2,#0x20]
;;;1494   }
        0x08002aa8:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;329    	TIM3->SR = 0;
        0x08002aaa:    2000        .       MOVS     r0,#0
        0x08002aac:    493a        :I      LDR      r1,[pc,#232] ; [0x8002b98] = 0x4000042c
        0x08002aae:    391c        .9      SUBS     r1,r1,#0x1c
        0x08002ab0:    6008        .`      STR      r0,[r1,#0]
;;;330    	LL_TIM_EnableIT_UPDATE(TIM3);
        0x08002ab2:    4610        .F      MOV      r0,r2
        0x08002ab4:    f7fef8e0    ....    BL       LL_TIM_EnableIT_UPDATE ; 0x8000c78
;;;331    
;;;332    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;333    
;;;334    
;;;335    
;;;336    	if(LL_GPIO_IsInputPinSet(BUTTON_1_GPIO_Port, BUTTON_1_Pin)){
        0x08002ab8:    4838        8H      LDR      r0,[pc,#224] ; [0x8002b9c] = 0x4010001
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08002aba:    4939        9I      LDR      r1,[pc,#228] ; [0x8002ba0] = 0x40010800
        0x08002abc:    6889        .h      LDR      r1,[r1,#8]
        0x08002abe:    f3c0220f    ..."    UBFX     r2,r0,#8,#16
        0x08002ac2:    4011        .@      ANDS     r1,r1,r2
        0x08002ac4:    f3c0220f    ..."    UBFX     r2,r0,#8,#16
        0x08002ac8:    4291        .B      CMP      r1,r2
        0x08002aca:    d101        ..      BNE      0x8002ad0 ; main + 296
        0x08002acc:    2101        .!      MOVS     r1,#1
        0x08002ace:    e000        ..      B        0x8002ad2 ; main + 298
        0x08002ad0:    2100        .!      MOVS     r1,#0
        0x08002ad2:    b111        ..      CBZ      r1,0x8002ada ; main + 306
;;; .\../Src/main.c
;;;337    		demo = true;
        0x08002ad4:    2001        .       MOVS     r0,#1
        0x08002ad6:    4933        3I      LDR      r1,[pc,#204] ; [0x8002ba4] = 0x20000041
        0x08002ad8:    7008        .p      STRB     r0,[r1,#0]
;;;338    	}
;;;339    //	MOTOR_Z_Disable();
;;;340    //	MOTOR_X_Disable();
;;;341    //  
;;;342    #ifndef _SIMU
;;;343    	Activate_I2C_Master();
;;;344    	init_screen(I2C2);
;;;345    //	update_screen();
;;;346    //	i2c_device_init(I2C2);
;;;347    	LL_mDelay(250);
;;;348    #endif
;;;349    	init_buttons();
        0x08002ada:    f7ffff4f    ..O.    BL       init_buttons ; 0x800297c
;;;350      /* USER CODE END 2 */
;;;351    
;;;352      /* Infinite loop */
;;;353      /* USER CODE BEGIN WHILE */
;;;354    
;;;355    
;;;356    ///// from STM examples:
;;;357    //  /**************************/
;;;358    //  /* Start pulse generation */
;;;359    //  /**************************/
;;;360    //  /* Enable channel 1 */
;;;361    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;362    //  
;;;363    //  /* Enable TIM3 outputs */
;;;364    //  LL_TIM_EnableAllOutputs(TIM3);
;;;365    //  
;;;366    //  /* Enable auto-reload register preload */
;;;367    //  LL_TIM_EnableARRPreload(TIM3);
;;;368    
;;;369    //  /* Force update generation */
;;;370    //  LL_TIM_GenerateEvent_UPDATE(TIM3);  
;;;371    
;;;372    
;;;373    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;374    
;;;375    
;;;376    
;;;377    
;;;378    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;379    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;380    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;381    
;;;382    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;383    //  LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;384    //  LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;385    
;;;386    
;;;387    //	MOTOR_X_BlockPulse(); // LL_TIM_OC_SetCompareCH3(TIM3, 0);
;;;388    //	MOTOR_Z_BlockPulse(); // LL_TIM_OC_SetCompareCH3(TIM3, 0);
;;;389    
;;;390    //LL_TIM_EnableCounter(TIM3);
;;;391    
;;;392    
;;;393    //TIM3->SR = 0;
;;;394    //TIM3->EGR |= TIM_EGR_UG;
;;;395    //		LL_TIM_GenerateEvent_UPDATE(TIM3); /* Force update generation */
;;;396    
;;;397    //  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1);
;;;398    	//GPIOB->BSRR
;;;399    //	LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_0);
;;;400    //	LL_mDelay(50);
;;;401    //	LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_0);
;;;402    //	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;403    	
;;;404    //	LL_TIM_EnableAllOutputs(TIM3);
;;;405    //MOTOR_X_AllowPulse();
;;;406    //MOTOR_Z_AllowPulse();
;;;407    //		LL_mDelay(50);
;;;408    //	LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;409      LL_TIM_EnableIT_CC3(TIM4);													// enable interrupts for TACHO events from encoder
        0x08002ade:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
        0x08002ae0:    4831        1H      LDR      r0,[pc,#196] ; [0x8002ba8] = 0x40000800
        0x08002ae2:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002ae4:    f0400008    @...    ORR      r0,r0,#8
        0x08002ae8:    492f        /I      LDR      r1,[pc,#188] ; [0x8002ba8] = 0x40000800
        0x08002aea:    60c8        .`      STR      r0,[r1,#0xc]
;;;3303   }
        0x08002aec:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;410      LL_TIM_EnableCounter(TIM4); 												//Enable timer 4
        0x08002aee:    bf00        ..      NOP      
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x08002af0:    4608        .F      MOV      r0,r1
        0x08002af2:    6800        .h      LDR      r0,[r0,#0]
        0x08002af4:    f0400001    @...    ORR      r0,r0,#1
        0x08002af8:    6008        .`      STR      r0,[r1,#0]
;;;1028   }
        0x08002afa:    bf00        ..      NOP      
;;; .\../Src/main.c
;;;412    	TIM4->SR = 0; 																			// reset interrup flags
        0x08002afc:    2000        .       MOVS     r0,#0
        0x08002afe:    492a        *I      LDR      r1,[pc,#168] ; [0x8002ba8] = 0x40000800
        0x08002b00:    3110        .1      ADDS     r1,r1,#0x10
        0x08002b02:    6008        .`      STR      r0,[r1,#0]
;;;413    
;;;414    //	LL_TIM_EnableIT_UPDATE(TIM1);
;;;415    //	LL_TIM_EnableIT_UPDATE(TIM2);
;;;416    //	LL_TIM_EnableCounter(TIM2);
;;;417    	
;;;418    //	do_fsm_move_start(&state);
;;;419    
;;;420    	
;;;421      /* Enable counter */
;;;422    //  LL_TIM_EnableCounter(TIM2);
;;;423      /* Force update generation */
;;;424    //  LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;425    
;;;426    // init buttons
;;;427    //	LL_mDelay(5);
;;;428    	do_fsm_menu(&state);
        0x08002b04:    4829        )H      LDR      r0,[pc,#164] ; [0x8002bac] = 0x20000044
        0x08002b06:    f7fffac3    ....    BL       do_fsm_menu ; 0x8002090
;;;429    //	LL_mDelay(5);
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;431    	LED_GPIO_Port->BSRR = LED_Pin; // led off
        0x08002b0a:    4829        )H      LDR      r0,[pc,#164] ; [0x8002bb0] = 0x4200020
        0x08002b0c:    4929        )I      LDR      r1,[pc,#164] ; [0x8002bb4] = 0x40011000
        0x08002b0e:    6108        .a      STR      r0,[r1,#0x10]
;;;432    	while (1) {
        0x08002b10:    e02b        +.      B        0x8002b6a ; main + 450
;;;433        /* USER CODE END WHILE */
;;;434    
;;;435        /* USER CODE BEGIN 3 */
;;;436    #ifndef _SIMU		
;;;437    //		reqest_sample_i2c_dma(); // init reqest to joystick by DMA, when process_button complete i2c done its job
;;;438    #endif		
;;;439    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;440    		process_button();
        0x08002b12:    f000f891    ....    BL       process_button ; 0x8002c38
;;;441    //		process_joystick();
;;;442    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;443    
;;;444    
;;;445    //		uint8_t level = Thread_Info[Menu_Step].level;
;;;446    
;;;447    //		if(auto_mode == true) {
;;;448    //			if ( auto_mode_delay == 0 ) {
;;;449    //				buttons_flag_set = single_click_Msk; //
;;;450    //			}
;;;451    //		}
;;;452    
;;;453    		if(buttons_flag_set) {
        0x08002b16:    4828        (H      LDR      r0,[pc,#160] ; [0x8002bb8] = 0x200005dc
        0x08002b18:    6800        .h      LDR      r0,[r0,#0]
        0x08002b1a:    b128        (.      CBZ      r0,0x8002b28 ; main + 384
;;;454    			do_fsm_menu(&state);
        0x08002b1c:    4823        #H      LDR      r0,[pc,#140] ; [0x8002bac] = 0x20000044
        0x08002b1e:    f7fffab7    ....    BL       do_fsm_menu ; 0x8002090
;;;455    			buttons_flag_set = 0; // reset button flags
        0x08002b22:    2000        .       MOVS     r0,#0
        0x08002b24:    4924        $I      LDR      r1,[pc,#144] ; [0x8002bb8] = 0x200005dc
        0x08002b26:    6008        .`      STR      r0,[r1,#0]
;;;456    		}
;;;457    
;;;458    		if(z_axis.ramp_step != rs) {
        0x08002b28:    4824        $H      LDR      r0,[pc,#144] ; [0x8002bbc] = 0x200005e0
        0x08002b2a:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b2e:    490f        .I      LDR      r1,[pc,#60] ; [0x8002b6c] = 0x200000b0
        0x08002b30:    6809        .h      LDR      r1,[r1,#0]
        0x08002b32:    4288        .B      CMP      r0,r1
        0x08002b34:    d007        ..      BEQ      0x8002b46 ; main + 414
;;;459    			rs = z_axis.ramp_step;
        0x08002b36:    4821        !H      LDR      r0,[pc,#132] ; [0x8002bbc] = 0x200005e0
        0x08002b38:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08002b3c:    490b        .I      LDR      r1,[pc,#44] ; [0x8002b6c] = 0x200000b0
        0x08002b3e:    6008        .`      STR      r0,[r1,#0]
;;;460    			menu_changed = 1;
        0x08002b40:    2001        .       MOVS     r0,#1
        0x08002b42:    491f        .I      LDR      r1,[pc,#124] ; [0x8002bc0] = 0x200000a4
        0x08002b44:    6008        .`      STR      r0,[r1,#0]
;;;461    		}
;;;462    
;;;463    		if(z_axis.current_pos != rs) {
        0x08002b46:    481d        .H      LDR      r0,[pc,#116] ; [0x8002bbc] = 0x200005e0
        0x08002b48:    6800        .h      LDR      r0,[r0,#0]
        0x08002b4a:    4908        .I      LDR      r1,[pc,#32] ; [0x8002b6c] = 0x200000b0
        0x08002b4c:    6809        .h      LDR      r1,[r1,#0]
        0x08002b4e:    4288        .B      CMP      r0,r1
        0x08002b50:    d003        ..      BEQ      0x8002b5a ; main + 434
;;;464    			rs = z_axis.current_pos;
        0x08002b52:    481a        .H      LDR      r0,[pc,#104] ; [0x8002bbc] = 0x200005e0
        0x08002b54:    6800        .h      LDR      r0,[r0,#0]
        0x08002b56:    4905        .I      LDR      r1,[pc,#20] ; [0x8002b6c] = 0x200000b0
        0x08002b58:    6008        .`      STR      r0,[r1,#0]
;;;465    //			menu_changed = 1;
;;;466    		}
;;;467    
;;;468    // update display info
;;;469    		if(menu_changed == 1){ // haltodo && hi2c2.hdmatx->State == HAL_DMA_STATE_READY) {
        0x08002b5a:    4819        .H      LDR      r0,[pc,#100] ; [0x8002bc0] = 0x200000a4
        0x08002b5c:    6800        .h      LDR      r0,[r0,#0]
        0x08002b5e:    2801        .(      CMP      r0,#1
        0x08002b60:    d103        ..      BNE      0x8002b6a ; main + 450
;;;470    			menu_changed = update_screen();
        0x08002b62:    f000fa5f    .._.    BL       update_screen ; 0x8003024
        0x08002b66:    4916        .I      LDR      r1,[pc,#88] ; [0x8002bc0] = 0x200000a4
        0x08002b68:    6008        .`      STR      r0,[r1,#0]
        0x08002b6a:    e7d2        ..      B        0x8002b12 ; main + 362
    $d
        0x08002b6c:    200000b0    ...     DCD    536871088
        0x08002b70:    20313047    G01     DCD    540094535
        0x08002b74:    20322e58    X.2     DCD    540159576
        0x08002b78:    3030315a    Z100    DCD    808464730
        0x08002b7c:    00303146    F10.    DCD    3158342
        0x08002b80:    e000ed0c    ....    DCD    3758157068
        0x08002b84:    05fa0000    ....    DCD    100270080
        0x08002b88:    40010000    ...@    DCD    1073807360
        0x08002b8c:    40004400    .D.@    DCD    1073759232
        0x08002b90:    40020000    ...@    DCD    1073872896
        0x08002b94:    080031e8    .1..    DCD    134230504
        0x08002b98:    4000042c    ,..@    DCD    1073742892
        0x08002b9c:    04010001    ....    DCD    67174401
        0x08002ba0:    40010800    ...@    DCD    1073809408
        0x08002ba4:    20000041    A..     DCD    536870977
        0x08002ba8:    40000800    ...@    DCD    1073743872
        0x08002bac:    20000044    D..     DCD    536870980
        0x08002bb0:    04200020     . .    DCD    69206048
        0x08002bb4:    40011000    ...@    DCD    1073811456
        0x08002bb8:    200005dc    ...     DCD    536872412
        0x08002bbc:    200005e0    ...     DCD    536872416
        0x08002bc0:    200000a4    ...     DCD    536871076
    $t
    i.next_statement
    next_statement
;;; .\..\Src\gcode.c
;;;126    {
        0x08002bc4:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08002bc8:    4606        .F      MOV      r6,r0
        0x08002bca:    460f        .F      MOV      r7,r1
        0x08002bcc:    4615        .F      MOV      r5,r2
        0x08002bce:    461c        .F      MOV      r4,r3
;;;127    	while (line[*char_counter] == ' ') (*char_counter)++;
        0x08002bd0:    e002        ..      B        0x8002bd8 ; next_statement + 20
        0x08002bd2:    6820         h      LDR      r0,[r4,#0]
        0x08002bd4:    1c40        @.      ADDS     r0,r0,#1
        0x08002bd6:    6020         `      STR      r0,[r4,#0]
        0x08002bd8:    6820         h      LDR      r0,[r4,#0]
        0x08002bda:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002bdc:    2820         (      CMP      r0,#0x20
        0x08002bde:    d0f8        ..      BEQ      0x8002bd2 ; next_statement + 14
;;;128    
;;;129    	if (line[*char_counter] == 0 || line[*char_counter] == ';' ||
        0x08002be0:    6820         h      LDR      r0,[r4,#0]
        0x08002be2:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002be4:    b158        X.      CBZ      r0,0x8002bfe ; next_statement + 58
        0x08002be6:    6820         h      LDR      r0,[r4,#0]
        0x08002be8:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002bea:    283b        ;(      CMP      r0,#0x3b
        0x08002bec:    d007        ..      BEQ      0x8002bfe ; next_statement + 58
;;;130    		line[*char_counter] == '\n' || line[*char_counter] == '\r') return false;
        0x08002bee:    6820         h      LDR      r0,[r4,#0]
        0x08002bf0:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002bf2:    280a        .(      CMP      r0,#0xa
        0x08002bf4:    d003        ..      BEQ      0x8002bfe ; next_statement + 58
        0x08002bf6:    6820         h      LDR      r0,[r4,#0]
        0x08002bf8:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002bfa:    280d        .(      CMP      r0,#0xd
        0x08002bfc:    d102        ..      BNE      0x8002c04 ; next_statement + 64
        0x08002bfe:    2000        .       MOVS     r0,#0
        0x08002c00:    e8bd81f0    ....    POP      {r4-r8,pc}
;;;131    	*letter = line[*char_counter];
        0x08002c04:    6820         h      LDR      r0,[r4,#0]
        0x08002c06:    5c28        (\      LDRB     r0,[r5,r0]
        0x08002c08:    7030        0p      STRB     r0,[r6,#0]
;;;132    	if ((*letter < 'A') || (*letter > 'Z'))
        0x08002c0a:    7830        0x      LDRB     r0,[r6,#0]
        0x08002c0c:    2841        A(      CMP      r0,#0x41
        0x08002c0e:    db02        ..      BLT      0x8002c16 ; next_statement + 82
        0x08002c10:    7830        0x      LDRB     r0,[r6,#0]
        0x08002c12:    285a        Z(      CMP      r0,#0x5a
        0x08002c14:    dd04        ..      BLE      0x8002c20 ; next_statement + 92
;;;133    	{
;;;134    		gc.status_code = GCSTATUS_EXPECTED_COMMAND_LETTER;
        0x08002c16:    2002        .       MOVS     r0,#2
        0x08002c18:    4906        .I      LDR      r1,[pc,#24] ; [0x8002c34] = 0x20000510
        0x08002c1a:    7008        .p      STRB     r0,[r1,#0]
;;;135    		return false;
        0x08002c1c:    2000        .       MOVS     r0,#0
        0x08002c1e:    e7ef        ..      B        0x8002c00 ; next_statement + 60
;;;136    	}
;;;137    	(*char_counter)++;
        0x08002c20:    6820         h      LDR      r0,[r4,#0]
        0x08002c22:    1c40        @.      ADDS     r0,r0,#1
        0x08002c24:    6020         `      STR      r0,[r4,#0]
;;;138    	return read_double(line, char_counter, double_ptr);
        0x08002c26:    463a        :F      MOV      r2,r7
        0x08002c28:    4621        !F      MOV      r1,r4
        0x08002c2a:    4628        (F      MOV      r0,r5
        0x08002c2c:    f000f930    ..0.    BL       read_double ; 0x8002e90
        0x08002c30:    e7e6        ..      B        0x8002c00 ; next_statement + 60
    $d
        0x08002c32:    0000        ..      DCW    0
        0x08002c34:    20000510    ...     DCD    536872208
    $t
    i.process_button
    process_button
;;; .\..\Src\buttons.c
;;;57     {
        0x08002c38:    b570        p.      PUSH     {r4-r6,lr}
;;;58     	for(int a =0; a<BT_TOTAL;a++){
        0x08002c3a:    2400        .$      MOVS     r4,#0
        0x08002c3c:    e11c        ..      B        0x8002e78 ; process_button + 576
;;;59     	/*
;;;60     	click Nondeterministic finite automaton(NFA):
;;;61     	10.    
;;;62     	20.  ,  .   > 1000   ,   30
;;;63     	30.  long_press_start,   40
;;;64     	40.   ,   50
;;;65     	50.  ,    200   70,   60
;;;66     	60.   < 1000   CLICK,      long_press_end,   10
;;;67     	70.   200,    -,   100,     60,     80
;;;68     	80.   ,   90
;;;69     	90.  ,  DOUBLE_CLICK,   10
;;;70     	*/
;;;71      
;;;72     //	#if defined ( _SIMU )
;;;73     //		uint32_t tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin;
;;;74     //	#else
;;;75     		uint32_t tmp_buttons;
;;;76     		if(bt[a].GPIOx != 0)
        0x08002c3e:    4891        .H      LDR      r0,[pc,#580] ; [0x8002e84] = 0x200004f0
        0x08002c40:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c44:    6800        .h      LDR      r0,[r0,#0]
        0x08002c46:    b158        X.      CBZ      r0,0x8002c60 ; process_button + 40
;;;77     			tmp_buttons = LL_GPIO_IsInputPinSet(bt[a].GPIOx,bt[a].button_pin);
        0x08002c48:    4a8e        .J      LDR      r2,[pc,#568] ; [0x8002e84] = 0x200004f0
        0x08002c4a:    eb021244    ..D.    ADD      r2,r2,r4,LSL #5
        0x08002c4e:    6851        Qh      LDR      r1,[r2,#4]
        0x08002c50:    4a8c        .J      LDR      r2,[pc,#560] ; [0x8002e84] = 0x200004f0
        0x08002c52:    eb021244    ..D.    ADD      r2,r2,r4,LSL #5
        0x08002c56:    6810        .h      LDR      r0,[r2,#0]
        0x08002c58:    f7fdff05    ....    BL       LL_GPIO_IsInputPinSet ; 0x8000a66
        0x08002c5c:    4605        .F      MOV      r5,r0
        0x08002c5e:    e007        ..      B        0x8002c70 ; process_button + 56
;;;78     //			tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin; //BUTTON_1_GPIO_Port->IDR & bt[a].button_pin;
;;;79     		else{
;;;80     			
;;;81     //			if(ubTransferComplete == 0)
;;;82     //				continue;
;;;83     			//	dma_delay = 0;
;;;84     //	while(hi2c2->hdmarx->State != HAL_DMA_STATE_READY){
;;;85     //		dma_delay++;
;;;86     //		HAL_Delay(1);
;;;87     //	}
;;;88     //	dma_delay2 = dma_delay;
;;;89     
;;;90     			tmp_buttons = dma_data[5] & bt[a].button_pin;
        0x08002c60:    4889        .H      LDR      r0,[pc,#548] ; [0x8002e88] = 0x20000011
        0x08002c62:    7940        @y      LDRB     r0,[r0,#5]
        0x08002c64:    4987        .I      LDR      r1,[pc,#540] ; [0x8002e84] = 0x200004f0
        0x08002c66:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c6a:    6849        Ih      LDR      r1,[r1,#4]
        0x08002c6c:    ea000501    ....    AND      r5,r0,r1
;;;91     		}
;;;92     //	#endif
;;;93     
;;;94     //		if(z_axis.current_pos < 20)
;;;95     //			tmp_buttons = 0;
;;;96     		
;;;97     		if( tmp_buttons != bt[a].buttons ) { // start debounce
        0x08002c70:    4884        .H      LDR      r0,[pc,#528] ; [0x8002e84] = 0x200004f0
        0x08002c72:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c76:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08002c78:    42a8        .B      CMP      r0,r5
        0x08002c7a:    d009        ..      BEQ      0x8002c90 ; process_button + 88
;;;98     			bt[a].buttons = tmp_buttons;
        0x08002c7c:    4881        .H      LDR      r0,[pc,#516] ; [0x8002e84] = 0x200004f0
        0x08002c7e:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c82:    60c5        .`      STR      r5,[r0,#0xc]
;;;99     			// reset debounce counter and start count every one ms
;;;100    			bt[a].buttons_mstick = 1;
        0x08002c84:    2001        .       MOVS     r0,#1
        0x08002c86:    497f        .I      LDR      r1,[pc,#508] ; [0x8002e84] = 0x200004f0
        0x08002c88:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002c8c:    6108        .a      STR      r0,[r1,#0x10]
        0x08002c8e:    bd70        p.      POP      {r4-r6,pc}
;;;101    			return;
;;;102    		}
;;;103    
;;;104    		if( bt[a].buttons_mstick > DEBOUNCE_MS ) {
        0x08002c90:    487c        |H      LDR      r0,[pc,#496] ; [0x8002e84] = 0x200004f0
        0x08002c92:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002c96:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002c98:    2814        .(      CMP      r0,#0x14
        0x08002c9a:    d971        q.      BLS      0x8002d80 ; process_button + 328
;;;105    			switch(bt[a].clk_mode) {
        0x08002c9c:    4879        yH      LDR      r0,[pc,#484] ; [0x8002e84] = 0x200004f0
        0x08002c9e:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002ca2:    69c0        .i      LDR      r0,[r0,#0x1c]
        0x08002ca4:    2832        2(      CMP      r0,#0x32
        0x08002ca6:    d063        c.      BEQ      0x8002d70 ; process_button + 312
        0x08002ca8:    dc08        ..      BGT      0x8002cbc ; process_button + 132
        0x08002caa:    280a        .(      CMP      r0,#0xa
        0x08002cac:    d00f        ..      BEQ      0x8002cce ; process_button + 150
        0x08002cae:    2814        .(      CMP      r0,#0x14
        0x08002cb0:    d019        ..      BEQ      0x8002ce6 ; process_button + 174
        0x08002cb2:    281e        .(      CMP      r0,#0x1e
        0x08002cb4:    d038        8.      BEQ      0x8002d28 ; process_button + 240
        0x08002cb6:    2828        ((      CMP      r0,#0x28
        0x08002cb8:    d114        ..      BNE      0x8002ce4 ; process_button + 172
        0x08002cba:    e044        D.      B        0x8002d46 ; process_button + 270
        0x08002cbc:    283c        <(      CMP      r0,#0x3c
        0x08002cbe:    d066        f.      BEQ      0x8002d8e ; process_button + 342
        0x08002cc0:    2846        F(      CMP      r0,#0x46
        0x08002cc2:    d075        u.      BEQ      0x8002db0 ; process_button + 376
        0x08002cc4:    2850        P(      CMP      r0,#0x50
        0x08002cc6:    d074        t.      BEQ      0x8002db2 ; process_button + 378
        0x08002cc8:    285a        Z(      CMP      r0,#0x5a
        0x08002cca:    d1f5        ..      BNE      0x8002cb8 ; process_button + 128
        0x08002ccc:    e0be        ..      B        0x8002e4c ; process_button + 532
;;;106    			case 10: {
;;;107    				if ( tmp_buttons & bt[a].button_pin ) {   // released
        0x08002cce:    486d        mH      LDR      r0,[pc,#436] ; [0x8002e84] = 0x200004f0
        0x08002cd0:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002cd4:    6840        @h      LDR      r0,[r0,#4]
        0x08002cd6:    4028        (@      ANDS     r0,r0,r5
        0x08002cd8:    b920         .      CBNZ     r0,0x8002ce4 ; process_button + 172
;;;108    				} else { // pressed
;;;109    //					buttons_mstick = 1;
;;;110    					bt[a].clk_mode = 20;
        0x08002cda:    2014        .       MOVS     r0,#0x14
        0x08002cdc:    4969        iI      LDR      r1,[pc,#420] ; [0x8002e84] = 0x200004f0
        0x08002cde:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002ce2:    61c8        .a      STR      r0,[r1,#0x1c]
;;;111    				}
;;;112    				break;
        0x08002ce4:    e0c6        ..      B        0x8002e74 ; process_button + 572
;;;113    			}
;;;114    			case 20: {
;;;115    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x08002ce6:    4867        gH      LDR      r0,[pc,#412] ; [0x8002e84] = 0x200004f0
        0x08002ce8:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002cec:    6840        @h      LDR      r0,[r0,#4]
        0x08002cee:    4028        (@      ANDS     r0,r0,r5
        0x08002cf0:    b128        (.      CBZ      r0,0x8002cfe ; process_button + 198
;;;116    					bt[a].clk_mode = 50;
        0x08002cf2:    2032        2       MOVS     r0,#0x32
        0x08002cf4:    4963        cI      LDR      r1,[pc,#396] ; [0x8002e84] = 0x200004f0
        0x08002cf6:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002cfa:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002cfc:    e007        ..      B        0x8002d0e ; process_button + 214
;;;117    				} else {
;;;118    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002cfe:    4861        aH      LDR      r0,[pc,#388] ; [0x8002e84] = 0x200004f0
        0x08002d00:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d04:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002d06:    495f        _I      LDR      r1,[pc,#380] ; [0x8002e84] = 0x200004f0
        0x08002d08:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d0c:    6088        .`      STR      r0,[r1,#8]
;;;119    				}
;;;120    				if (bt[a].downTime > HOLDTIME_MS ) { // long press detected
        0x08002d0e:    485d        ]H      LDR      r0,[pc,#372] ; [0x8002e84] = 0x200004f0
        0x08002d10:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d14:    6880        .h      LDR      r0,[r0,#8]
        0x08002d16:    f5b07ffa    ....    CMP      r0,#0x1f4
        0x08002d1a:    d904        ..      BLS      0x8002d26 ; process_button + 238
;;;121    					bt[a].clk_mode = 30;
        0x08002d1c:    201e        .       MOVS     r0,#0x1e
        0x08002d1e:    4959        YI      LDR      r1,[pc,#356] ; [0x8002e84] = 0x200004f0
        0x08002d20:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d24:    61c8        .a      STR      r0,[r1,#0x1c]
;;;122    				}
;;;123    				break;
        0x08002d26:    e0a5        ..      B        0x8002e74 ; process_button + 572
;;;124    			}
;;;125    			case 30: { // long_press_start event
;;;126    				buttons_flag_setbb[(a<<2)+long_press_start_Pos]  = 1; //long_press_start = 1;
        0x08002d28:    2001        .       MOVS     r0,#1
        0x08002d2a:    2100        .!      MOVS     r1,#0
        0x08002d2c:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002d30:    4a56        VJ      LDR      r2,[pc,#344] ; [0x8002e8c] = 0x2200b000
        0x08002d32:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002d36:    f8c10b80    ....    STR      r0,[r1,#0xb80]
;;;127    				bt[a].clk_mode = 40;
        0x08002d3a:    2028        (       MOVS     r0,#0x28
        0x08002d3c:    4951        QI      LDR      r1,[pc,#324] ; [0x8002e84] = 0x200004f0
        0x08002d3e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d42:    61c8        .a      STR      r0,[r1,#0x1c]
;;;128    				break;
        0x08002d44:    e096        ..      B        0x8002e74 ; process_button + 572
;;;129    			}
;;;130    			case 40: {
;;;131    				if ( tmp_buttons & bt[a].button_pin ) { //released
        0x08002d46:    484f        OH      LDR      r0,[pc,#316] ; [0x8002e84] = 0x200004f0
        0x08002d48:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d4c:    6840        @h      LDR      r0,[r0,#4]
        0x08002d4e:    4028        (@      ANDS     r0,r0,r5
        0x08002d50:    b128        (.      CBZ      r0,0x8002d5e ; process_button + 294
;;;132    					bt[a].clk_mode = 50;
        0x08002d52:    2032        2       MOVS     r0,#0x32
        0x08002d54:    494b        KI      LDR      r1,[pc,#300] ; [0x8002e84] = 0x200004f0
        0x08002d56:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d5a:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002d5c:    e007        ..      B        0x8002d6e ; process_button + 310
;;;133    				} else {
;;;134    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002d5e:    4849        IH      LDR      r0,[pc,#292] ; [0x8002e84] = 0x200004f0
        0x08002d60:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d64:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002d66:    4947        GI      LDR      r1,[pc,#284] ; [0x8002e84] = 0x200004f0
        0x08002d68:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d6c:    6088        .`      STR      r0,[r1,#8]
;;;135    				}
;;;136    				break;
        0x08002d6e:    e081        ..      B        0x8002e74 ; process_button + 572
;;;137    			}
;;;138    			case 50: {
;;;139    				bt[a].clk_mode = bt[a].downTime < CLICKTIME_MS ? 70 : 60;
        0x08002d70:    4844        DH      LDR      r0,[pc,#272] ; [0x8002e84] = 0x200004f0
        0x08002d72:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d76:    6880        .h      LDR      r0,[r0,#8]
        0x08002d78:    28fa        .(      CMP      r0,#0xfa
        0x08002d7a:    d202        ..      BCS      0x8002d82 ; process_button + 330
        0x08002d7c:    2046        F       MOVS     r0,#0x46
        0x08002d7e:    e001        ..      B        0x8002d84 ; process_button + 332
        0x08002d80:    e079        y.      B        0x8002e76 ; process_button + 574
        0x08002d82:    203c        <       MOVS     r0,#0x3c
        0x08002d84:    493f        ?I      LDR      r1,[pc,#252] ; [0x8002e84] = 0x200004f0
        0x08002d86:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002d8a:    61c8        .a      STR      r0,[r1,#0x1c]
;;;140    				break;
        0x08002d8c:    e072        r.      B        0x8002e74 ; process_button + 572
;;;141    			}
;;;142    			case 60: {//60 if tick count < 1000 generate CLICK event, else generate long_press_end event, go to 10 state
;;;143    				if(bt[a].downTime < HOLDTIME_MS) { //single CLICK event
        0x08002d8e:    483d        =H      LDR      r0,[pc,#244] ; [0x8002e84] = 0x200004f0
        0x08002d90:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002d94:    6880        .h      LDR      r0,[r0,#8]
        0x08002d96:    f5b07ffa    ....    CMP      r0,#0x1f4
        0x08002d9a:    d20b        ..      BCS      0x8002db4 ; process_button + 380
;;;144    					buttons_flag_setbb[(a<<2)+single_click_Pos]  = 1; //single_click = 1;
        0x08002d9c:    2001        .       MOVS     r0,#1
        0x08002d9e:    2102        .!      MOVS     r1,#2
        0x08002da0:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002da4:    4a39        9J      LDR      r2,[pc,#228] ; [0x8002e8c] = 0x2200b000
        0x08002da6:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002daa:    f8c10b80    ....    STR      r0,[r1,#0xb80]
        0x08002dae:    e009        ..      B        0x8002dc4 ; process_button + 396
        0x08002db0:    e017        ..      B        0x8002de2 ; process_button + 426
        0x08002db2:    e036        6.      B        0x8002e22 ; process_button + 490
;;;145    				} else { //  long_press_end event
;;;146    					buttons_flag_setbb[(a<<2)+long_press_end_Pos]  = 1; //long_press_end = 1;
        0x08002db4:    2001        .       MOVS     r0,#1
        0x08002db6:    eb000184    ....    ADD      r1,r0,r4,LSL #2
        0x08002dba:    4a34        4J      LDR      r2,[pc,#208] ; [0x8002e8c] = 0x2200b000
        0x08002dbc:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002dc0:    f8c10b80    ....    STR      r0,[r1,#0xb80]
;;;147    				}
;;;148    				bt[a].downTime = bt[a].buttons_mstick = 0;
        0x08002dc4:    2000        .       MOVS     r0,#0
        0x08002dc6:    492f        /I      LDR      r1,[pc,#188] ; [0x8002e84] = 0x200004f0
        0x08002dc8:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002dcc:    6108        .a      STR      r0,[r1,#0x10]
        0x08002dce:    492d        -I      LDR      r1,[pc,#180] ; [0x8002e84] = 0x200004f0
        0x08002dd0:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002dd4:    6088        .`      STR      r0,[r1,#8]
;;;149    				bt[a].clk_mode = 10;
        0x08002dd6:    200a        .       MOVS     r0,#0xa
        0x08002dd8:    492a        *I      LDR      r1,[pc,#168] ; [0x8002e84] = 0x200004f0
        0x08002dda:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002dde:    61c8        .a      STR      r0,[r1,#0x1c]
;;;150    				break;
        0x08002de0:    e048        H.      B        0x8002e74 ; process_button + 572
;;;151    			}
;;;152    			case 70: { //70.   200,    -,    100,     60,     80
;;;153    				if ( tmp_buttons & bt[a].button_pin ) {
        0x08002de2:    4828        (H      LDR      r0,[pc,#160] ; [0x8002e84] = 0x200004f0
        0x08002de4:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002de8:    6840        @h      LDR      r0,[r0,#4]
        0x08002dea:    4028        (@      ANDS     r0,r0,r5
        0x08002dec:    b198        ..      CBZ      r0,0x8002e16 ; process_button + 478
;;;154    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002dee:    4825        %H      LDR      r0,[pc,#148] ; [0x8002e84] = 0x200004f0
        0x08002df0:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002df4:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002df6:    4923        #I      LDR      r1,[pc,#140] ; [0x8002e84] = 0x200004f0
        0x08002df8:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002dfc:    6088        .`      STR      r0,[r1,#8]
;;;155    					if( bt[a].downTime > DOUBLECLICK_GAP_MS ) {
        0x08002dfe:    4821        !H      LDR      r0,[pc,#132] ; [0x8002e84] = 0x200004f0
        0x08002e00:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002e04:    6880        .h      LDR      r0,[r0,#8]
        0x08002e06:    2896        .(      CMP      r0,#0x96
        0x08002e08:    d90a        ..      BLS      0x8002e20 ; process_button + 488
;;;156    						bt[a].clk_mode = 60;
        0x08002e0a:    203c        <       MOVS     r0,#0x3c
        0x08002e0c:    491d        .I      LDR      r1,[pc,#116] ; [0x8002e84] = 0x200004f0
        0x08002e0e:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002e12:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002e14:    e004        ..      B        0x8002e20 ; process_button + 488
;;;157    					}
;;;158    				} else {
;;;159    					bt[a].clk_mode = 80;
        0x08002e16:    2050        P       MOVS     r0,#0x50
        0x08002e18:    491a        .I      LDR      r1,[pc,#104] ; [0x8002e84] = 0x200004f0
        0x08002e1a:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002e1e:    61c8        .a      STR      r0,[r1,#0x1c]
;;;160    				}
;;;161    				break;
        0x08002e20:    e028        (.      B        0x8002e74 ; process_button + 572
;;;162    			}
;;;163    			case 80: {
;;;164    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x08002e22:    4818        .H      LDR      r0,[pc,#96] ; [0x8002e84] = 0x200004f0
        0x08002e24:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002e28:    6840        @h      LDR      r0,[r0,#4]
        0x08002e2a:    4028        (@      ANDS     r0,r0,r5
        0x08002e2c:    b128        (.      CBZ      r0,0x8002e3a ; process_button + 514
;;;165    					bt[a].clk_mode = 90;
        0x08002e2e:    205a        Z       MOVS     r0,#0x5a
        0x08002e30:    4914        .I      LDR      r1,[pc,#80] ; [0x8002e84] = 0x200004f0
        0x08002e32:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002e36:    61c8        .a      STR      r0,[r1,#0x1c]
        0x08002e38:    e007        ..      B        0x8002e4a ; process_button + 530
;;;166    				} else {
;;;167    					bt[a].downTime = bt[a].buttons_mstick;
        0x08002e3a:    4812        .H      LDR      r0,[pc,#72] ; [0x8002e84] = 0x200004f0
        0x08002e3c:    eb001044    ..D.    ADD      r0,r0,r4,LSL #5
        0x08002e40:    6900        .i      LDR      r0,[r0,#0x10]
        0x08002e42:    4910        .I      LDR      r1,[pc,#64] ; [0x8002e84] = 0x200004f0
        0x08002e44:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002e48:    6088        .`      STR      r0,[r1,#8]
;;;168    				}
;;;169    				break;
        0x08002e4a:    e013        ..      B        0x8002e74 ; process_button + 572
;;;170    			}
;;;171    			case 90: { //  DOUBLE_CLICK
;;;172    				buttons_flag_setbb[(a<<2)+double_click_Pos]  = 1; //double_click = 1;
        0x08002e4c:    2001        .       MOVS     r0,#1
        0x08002e4e:    2103        .!      MOVS     r1,#3
        0x08002e50:    eb010184    ....    ADD      r1,r1,r4,LSL #2
        0x08002e54:    4a0d        .J      LDR      r2,[pc,#52] ; [0x8002e8c] = 0x2200b000
        0x08002e56:    eb020181    ....    ADD      r1,r2,r1,LSL #2
        0x08002e5a:    f8c10b80    ....    STR      r0,[r1,#0xb80]
;;;173    				bt[a].clk_mode = 10;
        0x08002e5e:    200a        .       MOVS     r0,#0xa
        0x08002e60:    4908        .I      LDR      r1,[pc,#32] ; [0x8002e84] = 0x200004f0
        0x08002e62:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002e66:    61c8        .a      STR      r0,[r1,#0x1c]
;;;174    				bt[a].buttons_mstick = 0;
        0x08002e68:    2000        .       MOVS     r0,#0
        0x08002e6a:    4906        .I      LDR      r1,[pc,#24] ; [0x8002e84] = 0x200004f0
        0x08002e6c:    eb011144    ..D.    ADD      r1,r1,r4,LSL #5
        0x08002e70:    6108        .a      STR      r0,[r1,#0x10]
;;;175    				break;
        0x08002e72:    bf00        ..      NOP      
        0x08002e74:    bf00        ..      NOP      
        0x08002e76:    1c64        d.      ADDS     r4,r4,#1
        0x08002e78:    2c01        .,      CMP      r4,#1
        0x08002e7a:    f6ffaee0    ....    BLT      0x8002c3e ; process_button + 6
;;;176    			}
;;;177    			}
;;;178    		}
;;;179    	}
;;;180    //	ubTransferComplete = 0;
;;;181    }
        0x08002e7e:    bf00        ..      NOP      
        0x08002e80:    e705        ..      B        0x8002c8e ; process_button + 86
    $d
        0x08002e82:    0000        ..      DCW    0
        0x08002e84:    200004f0    ...     DCD    536872176
        0x08002e88:    20000011    ...     DCD    536870929
        0x08002e8c:    2200b000    ..."    DCD    570470400
    $t
    i.read_double
    read_double
;;; .\..\Src\gcode.c
;;;111    {
        0x08002e90:    b5f8        ..      PUSH     {r3-r7,lr}
        0x08002e92:    4604        .F      MOV      r4,r0
        0x08002e94:    460d        .F      MOV      r5,r1
        0x08002e96:    4617        .F      MOV      r7,r2
;;;112    	char *start = line + *char_counter;
        0x08002e98:    6828        (h      LDR      r0,[r5,#0]
        0x08002e9a:    1906        ..      ADDS     r6,r0,r4
;;;113    	char *end;
;;;114    
;;;115    	*double_ptr = strtod_M(start, &end);
        0x08002e9c:    4669        iF      MOV      r1,sp
        0x08002e9e:    4630        0F      MOV      r0,r6
        0x08002ea0:    f000f812    ....    BL       strtod_M ; 0x8002ec8
        0x08002ea4:    e9c70100    ....    STRD     r0,r1,[r7,#0]
;;;116    	if (end == start)
        0x08002ea8:    9800        ..      LDR      r0,[sp,#0]
        0x08002eaa:    42b0        .B      CMP      r0,r6
        0x08002eac:    d104        ..      BNE      0x8002eb8 ; read_double + 40
;;;117    	{
;;;118    		gc.status_code = GCSTATUS_BAD_NUMBER_FORMAT;
        0x08002eae:    2001        .       MOVS     r0,#1
        0x08002eb0:    4904        .I      LDR      r1,[pc,#16] ; [0x8002ec4] = 0x20000510
        0x08002eb2:    7008        .p      STRB     r0,[r1,#0]
;;;119    		return false;
        0x08002eb4:    2000        .       MOVS     r0,#0
        0x08002eb6:    bdf8        ..      POP      {r3-r7,pc}
;;;120    	}
;;;121    	*char_counter = (int)(end - line);
        0x08002eb8:    9800        ..      LDR      r0,[sp,#0]
        0x08002eba:    1b00        ..      SUBS     r0,r0,r4
        0x08002ebc:    6028        (`      STR      r0,[r5,#0]
;;;122    	return true;
        0x08002ebe:    2001        .       MOVS     r0,#1
        0x08002ec0:    e7f9        ..      B        0x8002eb6 ; read_double + 38
    $d
        0x08002ec2:    0000        ..      DCW    0
        0x08002ec4:    20000510    ...     DCD    536872208
    $t
    i.strtod_M
    strtod_M
;;; .\..\Src\gcode.c (51)
        0x08002ec8:    e92d4ff0    -..O    PUSH     {r4-r11,lr}
        0x08002ecc:    b087        ..      SUB      sp,sp,#0x1c
        0x08002ece:    4681        .F      MOV      r9,r0
        0x08002ed0:    468b        .F      MOV      r11,r1
;;;52     	double number = 0.0;
        0x08002ed2:    2100        .!      MOVS     r1,#0
        0x08002ed4:    460d        .F      MOV      r5,r1
        0x08002ed6:    460e        .F      MOV      r6,r1
;;;53     	double div = 0.0;
        0x08002ed8:    460f        .F      MOV      r7,r1
        0x08002eda:    4688        .F      MOV      r8,r1
;;;54     	bool negative = false;
        0x08002edc:    2000        .       MOVS     r0,#0
        0x08002ede:    9005        ..      STR      r0,[sp,#0x14]
;;;55     	bool plus = false;
        0x08002ee0:    9004        ..      STR      r0,[sp,#0x10]
;;;56     	bool skip = true;
        0x08002ee2:    f04f0a01    O...    MOV      r10,#1
;;;57     	char c;
;;;58     	while ((c = *str) != 0)
        0x08002ee6:    e06f        o.      B        0x8002fc8 ; strtod_M + 256
;;;59     	{
;;;60     		if (c == '+')
        0x08002ee8:    2c2b        +,      CMP      r4,#0x2b
        0x08002eea:    d10a        ..      BNE      0x8002f02 ; strtod_M + 58
;;;61     		{
;;;62     			if (skip && !plus)
        0x08002eec:    f1ba0f00    ....    CMP      r10,#0
        0x08002ef0:    d006        ..      BEQ      0x8002f00 ; strtod_M + 56
        0x08002ef2:    9804        ..      LDR      r0,[sp,#0x10]
        0x08002ef4:    b920         .      CBNZ     r0,0x8002f00 ; strtod_M + 56
;;;63     			{
;;;64     				plus = true;
        0x08002ef6:    2001        .       MOVS     r0,#1
        0x08002ef8:    9004        ..      STR      r0,[sp,#0x10]
;;;65     				skip = false;
        0x08002efa:    f04f0a00    O...    MOV      r10,#0
        0x08002efe:    e061        a.      B        0x8002fc4 ; strtod_M + 252
;;;66     			}
;;;67     			else
;;;68     				break;
        0x08002f00:    e066        f.      B        0x8002fd0 ; strtod_M + 264
;;;69     		}
;;;70     		else if (skip && !negative && c == '-')
        0x08002f02:    f1ba0f00    ....    CMP      r10,#0
        0x08002f06:    d00e        ..      BEQ      0x8002f26 ; strtod_M + 94
        0x08002f08:    9805        ..      LDR      r0,[sp,#0x14]
        0x08002f0a:    b960        `.      CBNZ     r0,0x8002f26 ; strtod_M + 94
        0x08002f0c:    2c2d        -,      CMP      r4,#0x2d
        0x08002f0e:    d10a        ..      BNE      0x8002f26 ; strtod_M + 94
;;;71     		{
;;;72     			if (skip && !negative)
        0x08002f10:    f1ba0f00    ....    CMP      r10,#0
        0x08002f14:    d006        ..      BEQ      0x8002f24 ; strtod_M + 92
        0x08002f16:    9805        ..      LDR      r0,[sp,#0x14]
        0x08002f18:    b920         .      CBNZ     r0,0x8002f24 ; strtod_M + 92
;;;73     			{
;;;74     				negative = true;
        0x08002f1a:    2001        .       MOVS     r0,#1
        0x08002f1c:    9005        ..      STR      r0,[sp,#0x14]
;;;75     				skip = false;
        0x08002f1e:    f04f0a00    O...    MOV      r10,#0
        0x08002f22:    e04f        O.      B        0x8002fc4 ; strtod_M + 252
;;;76     			}
;;;77     			else
;;;78     				break;
        0x08002f24:    e054        T.      B        0x8002fd0 ; strtod_M + 264
;;;79     		}
;;;80     		else if (c == '.')
        0x08002f26:    2c2e        .,      CMP      r4,#0x2e
        0x08002f28:    d10b        ..      BNE      0x8002f42 ; strtod_M + 122
;;;81     		{
;;;82     			if (div == 0.0)
        0x08002f2a:    2200        ."      MOVS     r2,#0
        0x08002f2c:    4613        .F      MOV      r3,r2
        0x08002f2e:    4638        8F      MOV      r0,r7
        0x08002f30:    4641        AF      MOV      r1,r8
        0x08002f32:    f7fdfaf3    ....    BL       __aeabi_cdcmpeq ; 0x800051c
        0x08002f36:    d103        ..      BNE      0x8002f40 ; strtod_M + 120
;;;83     				div = 1.0;
        0x08002f38:    2700        .'      MOVS     r7,#0
        0x08002f3a:    f8df80b4    ....    LDR      r8,[pc,#180] ; [0x8002ff0] = 0x3ff00000
        0x08002f3e:    e041        A.      B        0x8002fc4 ; strtod_M + 252
;;;84     			else
;;;85     				break;
        0x08002f40:    e046        F.      B        0x8002fd0 ; strtod_M + 264
;;;86     		}
;;;87     		else if (c >= '0' && c <= '9')
        0x08002f42:    2c30        0,      CMP      r4,#0x30
        0x08002f44:    db3a        :.      BLT      0x8002fbc ; strtod_M + 244
        0x08002f46:    2c39        9,      CMP      r4,#0x39
        0x08002f48:    dc38        8.      BGT      0x8002fbc ; strtod_M + 244
;;;88     		{
;;;89     			skip = false;
        0x08002f4a:    f04f0a00    O...    MOV      r10,#0
;;;90     			if (div == 0.0)
        0x08002f4e:    2200        ."      MOVS     r2,#0
        0x08002f50:    4613        .F      MOV      r3,r2
        0x08002f52:    4638        8F      MOV      r0,r7
        0x08002f54:    4641        AF      MOV      r1,r8
        0x08002f56:    f7fdfae1    ....    BL       __aeabi_cdcmpeq ; 0x800051c
        0x08002f5a:    d114        ..      BNE      0x8002f86 ; strtod_M + 190
;;;91     				number = number * 10.0 + (double)(c - '0');
        0x08002f5c:    f1a40030    ..0.    SUB      r0,r4,#0x30
        0x08002f60:    f7fdfaab    ....    BL       __aeabi_i2d ; 0x80004ba
        0x08002f64:    2200        ."      MOVS     r2,#0
        0x08002f66:    4b23        #K      LDR      r3,[pc,#140] ; [0x8002ff4] = 0x40240000
        0x08002f68:    e9cd0102    ....    STRD     r0,r1,[sp,#8]
        0x08002f6c:    4628        (F      MOV      r0,r5
        0x08002f6e:    4631        1F      MOV      r1,r6
        0x08002f70:    f7fdf9c2    ....    BL       __aeabi_dmul ; 0x80002f8
        0x08002f74:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x08002f78:    e9dd2302    ...#    LDRD     r2,r3,[sp,#8]
        0x08002f7c:    f7fdf915    ....    BL       __aeabi_dadd ; 0x80001aa
        0x08002f80:    4605        .F      MOV      r5,r0
        0x08002f82:    460e        .F      MOV      r6,r1
        0x08002f84:    e01e        ..      B        0x8002fc4 ; strtod_M + 252
;;;92     			else
;;;93     			{
;;;94     				div *= 10.0;
        0x08002f86:    2200        ."      MOVS     r2,#0
        0x08002f88:    4b1a        .K      LDR      r3,[pc,#104] ; [0x8002ff4] = 0x40240000
        0x08002f8a:    4638        8F      MOV      r0,r7
        0x08002f8c:    4641        AF      MOV      r1,r8
        0x08002f8e:    f7fdf9b3    ....    BL       __aeabi_dmul ; 0x80002f8
        0x08002f92:    4607        .F      MOV      r7,r0
        0x08002f94:    4688        .F      MOV      r8,r1
;;;95     				number += ((double)(c - '0') / div);
        0x08002f96:    f1a40030    ..0.    SUB      r0,r4,#0x30
        0x08002f9a:    f7fdfa8e    ....    BL       __aeabi_i2d ; 0x80004ba
        0x08002f9e:    463a        :F      MOV      r2,r7
        0x08002fa0:    4643        CF      MOV      r3,r8
        0x08002fa2:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x08002fa6:    f7fdfa19    ....    BL       __aeabi_ddiv ; 0x80003dc
        0x08002faa:    462a        *F      MOV      r2,r5
        0x08002fac:    4633        3F      MOV      r3,r6
        0x08002fae:    e9cd0102    ....    STRD     r0,r1,[sp,#8]
        0x08002fb2:    f7fdf8fa    ....    BL       __aeabi_dadd ; 0x80001aa
        0x08002fb6:    4605        .F      MOV      r5,r0
        0x08002fb8:    460e        .F      MOV      r6,r1
        0x08002fba:    e003        ..      B        0x8002fc4 ; strtod_M + 252
;;;96     			}
;;;97     		}
;;;98     		else if (!skip)
        0x08002fbc:    f1ba0f00    ....    CMP      r10,#0
        0x08002fc0:    d100        ..      BNE      0x8002fc4 ; strtod_M + 252
;;;99     		{
;;;100    			break;
        0x08002fc2:    e005        ..      B        0x8002fd0 ; strtod_M + 264
;;;101    		}
;;;102    		str++;
        0x08002fc4:    f1090901    ....    ADD      r9,r9,#1
        0x08002fc8:    f8994000    ...@    LDRB     r4,[r9,#0]
        0x08002fcc:    2c00        .,      CMP      r4,#0
        0x08002fce:    d18b        ..      BNE      0x8002ee8 ; strtod_M + 32
        0x08002fd0:    bf00        ..      NOP      
;;;103    	}
;;;104    
;;;105    	if (negative) number = -number;
        0x08002fd2:    9805        ..      LDR      r0,[sp,#0x14]
        0x08002fd4:    b108        ..      CBZ      r0,0x8002fda ; strtod_M + 274
        0x08002fd6:    f0864600    ...F    EOR      r6,r6,#0x80000000
;;;106    	if (endptr != NULL) *endptr = (char *)str;
        0x08002fda:    f1bb0f00    ....    CMP      r11,#0
        0x08002fde:    d001        ..      BEQ      0x8002fe4 ; strtod_M + 284
        0x08002fe0:    f8cb9000    ....    STR      r9,[r11,#0]
;;;107    	return number;
        0x08002fe4:    4628        (F      MOV      r0,r5
        0x08002fe6:    4631        1F      MOV      r1,r6
;;;108    }
        0x08002fe8:    b007        ..      ADD      sp,sp,#0x1c
        0x08002fea:    e8bd8ff0    ....    POP      {r4-r11,pc}
    $d
        0x08002fee:    0000        ..      DCW    0
        0x08002ff0:    3ff00000    ...?    DCD    1072693248
        0x08002ff4:    40240000    ..$@    DCD    1076101120
    $t
    i.to_millimeters
    to_millimeters
;;;109    
;;;110    static int read_double(char *line, int *char_counter, double *double_ptr)
;;;111    {
;;;112    	char *start = line + *char_counter;
;;;113    	char *end;
;;;114    
;;;115    	*double_ptr = strtod_M(start, &end);
;;;116    	if (end == start)
;;;117    	{
;;;118    		gc.status_code = GCSTATUS_BAD_NUMBER_FORMAT;
;;;119    		return false;
;;;120    	}
;;;121    	*char_counter = (int)(end - line);
;;;122    	return true;
;;;123    }
;;;124    
;;;125    static int next_statement(char *letter, double *double_ptr, char *line, int *char_counter)
;;;126    {
;;;127    	while (line[*char_counter] == ' ') (*char_counter)++;
;;;128    
;;;129    	if (line[*char_counter] == 0 || line[*char_counter] == ';' ||
;;;130    		line[*char_counter] == '\n' || line[*char_counter] == '\r') return false;
;;;131    	*letter = line[*char_counter];
;;;132    	if ((*letter < 'A') || (*letter > 'Z'))
;;;133    	{
;;;134    		gc.status_code = GCSTATUS_EXPECTED_COMMAND_LETTER;
;;;135    		return false;
;;;136    	}
;;;137    	(*char_counter)++;
;;;138    	return read_double(line, char_counter, double_ptr);
;;;139    }
;;;140    
;;;141    void gc_init(void)
;;;142    {
;;;143    	memset(&gc, 0, sizeof(gc));
;;;144    	gc.feed_rate = SM_DEFAULT_FEED_RATE;
;;;145    	gc.seek_rate = SM_DEFAULT_SEEK_RATE;
;;;146    	gc.absolute_mode = true;
;;;147    	// gc.startPosX = commonValues.startX;
;;;148    	// gc.startPosY = commonValues.startY;
;;;149    	// gc.startPosZ = commonValues.startZ;
;;;150    	gc.extruder_k = 1;
;;;151    	// commonValues.extruder_k;
;;;152    	gc.next_action = NEXT_ACTION_DEFAULT;
;;;153    }
;;;154    
;;;155    static double to_millimeters(double value)
;;;156    {
        0x08002ff8:    b570        p.      PUSH     {r4-r6,lr}
        0x08002ffa:    4604        .F      MOV      r4,r0
        0x08002ffc:    460d        .F      MOV      r5,r1
;;;157    	return (gc.inches_mode ? (value * MM_PER_INCH) : value);
        0x08002ffe:    4807        .H      LDR      r0,[pc,#28] ; [0x800301c] = 0x20000510
        0x08003000:    7840        @x      LDRB     r0,[r0,#1]
        0x08003002:    b138        8.      CBZ      r0,0x8003014 ; to_millimeters + 28
        0x08003004:    f04f3266    O.f2    MOV      r2,#0x66666666
        0x08003008:    4b05        .K      LDR      r3,[pc,#20] ; [0x8003020] = 0x40396666
        0x0800300a:    4620         F      MOV      r0,r4
        0x0800300c:    4629        )F      MOV      r1,r5
        0x0800300e:    f7fdf973    ..s.    BL       __aeabi_dmul ; 0x80002f8
        0x08003012:    bd70        p.      POP      {r4-r6,pc}
        0x08003014:    4620         F      MOV      r0,r4
        0x08003016:    4629        )F      MOV      r1,r5
        0x08003018:    e7fb        ..      B        0x8003012 ; to_millimeters + 26
    $d
        0x0800301a:    0000        ..      DCW    0
        0x0800301c:    20000510    ...     DCD    536872208
        0x08003020:    40396666    ff9@    DCD    1077503590
    $t
    i.update_screen
    update_screen
;;; .\..\Src\screen.c
;;;86     	return 0;
        0x08003024:    2000        .       MOVS     r0,#0
;;;87     }
        0x08003026:    4770        pG      BX       lr
    i.z_axis_move2
    z_axis_move2
;;; .\..\Src\fsm.c
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
        0x08003028:    4a0b        .J      LDR      r2,[pc,#44] ; [0x8003058] = 0x200005e0
        0x0800302a:    68d2        .h      LDR      r2,[r2,#0xc]
        0x0800302c:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8003058] = 0x200005e0
        0x0800302e:    691b        .i      LDR      r3,[r3,#0x10]
        0x08003030:    18d1        ..      ADDS     r1,r2,r3
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08003032:    2201        ."      MOVS     r2,#1
        0x08003034:    ebc26211    ...b    RSB      r2,r2,r1,LSR #24
        0x08003038:    6943        Ci      LDR      r3,[r0,#0x14]
        0x0800303a:    62da        .b      STR      r2,[r3,#0x2c]
;;;416    	s->syncbase->CNT = 0;
        0x0800303c:    2200        ."      MOVS     r2,#0
        0x0800303e:    6943        Ci      LDR      r3,[r0,#0x14]
        0x08003040:    625a        Zb      STR      r2,[r3,#0x24]
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
        0x08003042:    6942        Bi      LDR      r2,[r0,#0x14]
        0x08003044:    6952        Ri      LDR      r2,[r2,#0x14]
        0x08003046:    f0420201    B...    ORR      r2,r2,#1
        0x0800304a:    6943        Ci      LDR      r3,[r0,#0x14]
        0x0800304c:    615a        Za      STR      r2,[r3,#0x14]
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
        0x0800304e:    f021427f    !..B    BIC      r2,r1,#0xff000000
        0x08003052:    4b01        .K      LDR      r3,[pc,#4] ; [0x8003058] = 0x200005e0
        0x08003054:    611a        .a      STR      r2,[r3,#0x10]
;;;419    }
        0x08003056:    4770        pG      BX       lr
    $d
        0x08003058:    200005e0    ...     DCD    536872416
    $t
    i.z_axis_ramp_down2
    z_axis_ramp_down2
;;; .\..\Src\fsm.c (398)
        0x0800305c:    4601        .F      MOV      r1,r0
;;;399    	if (z_axis.ramp_step == 0)
        0x0800305e:    480d        .H      LDR      r0,[pc,#52] ; [0x8003094] = 0x200005e0
        0x08003060:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08003064:    b908        ..      CBNZ     r0,0x800306a ; z_axis_ramp_down2 + 14
;;;400    		return true;
        0x08003066:    2001        .       MOVS     r0,#1
        0x08003068:    4770        pG      BX       lr
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
        0x0800306a:    480a        .H      LDR      r0,[pc,#40] ; [0x8003094] = 0x200005e0
        0x0800306c:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08003070:    1e40        @.      SUBS     r0,r0,#1
        0x08003072:    b2c0        ..      UXTB     r0,r0
        0x08003074:    4a07        .J      LDR      r2,[pc,#28] ; [0x8003094] = 0x200005e0
        0x08003076:    f8820028    ..(.    STRB     r0,[r2,#0x28]
        0x0800307a:    4a07        .J      LDR      r2,[pc,#28] ; [0x8003098] = 0x20000038
        0x0800307c:    5c10        .\      LDRB     r0,[r2,r0]
        0x0800307e:    694a        Ji      LDR      r2,[r1,#0x14]
        0x08003080:    62d0        .b      STR      r0,[r2,#0x2c]
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
        0x08003082:    4804        .H      LDR      r0,[pc,#16] ; [0x8003094] = 0x200005e0
        0x08003084:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x08003088:    b908        ..      CBNZ     r0,0x800308e ; z_axis_ramp_down2 + 50
;;;408    		return true;
        0x0800308a:    2001        .       MOVS     r0,#1
        0x0800308c:    e7ec        ..      B        0x8003068 ; z_axis_ramp_down2 + 12
;;;409    	return false;
        0x0800308e:    2000        .       MOVS     r0,#0
        0x08003090:    e7ea        ..      B        0x8003068 ; z_axis_ramp_down2 + 12
    $d
        0x08003092:    0000        ..      DCW    0
        0x08003094:    200005e0    ...     DCD    536872416
        0x08003098:    20000038    8..     DCD    536870968
    $t
    i.z_axis_ramp_up2
    z_axis_ramp_up2
;;; .\..\Src\fsm.c (380)
        0x0800309c:    4601        .F      MOV      r1,r0
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
        0x0800309e:    4816        .H      LDR      r0,[pc,#88] ; [0x80030f8] = 0x200005e0
        0x080030a0:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x080030a4:    4b15        .K      LDR      r3,[pc,#84] ; [0x80030fc] = 0x20000038
        0x080030a6:    5c18        .\      LDRB     r0,[r3,r0]
        0x080030a8:    0602        ..      LSLS     r2,r0,#24
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
        0x080030aa:    4813        .H      LDR      r0,[pc,#76] ; [0x80030f8] = 0x200005e0
        0x080030ac:    68c0        .h      LDR      r0,[r0,#0xc]
        0x080030ae:    4290        .B      CMP      r0,r2
        0x080030b0:    d804        ..      BHI      0x80030bc ; z_axis_ramp_up2 + 32
        0x080030b2:    4811        .H      LDR      r0,[pc,#68] ; [0x80030f8] = 0x200005e0
        0x080030b4:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x080030b8:    2805        .(      CMP      r0,#5
        0x080030ba:    d10e        ..      BNE      0x80030da ; z_axis_ramp_up2 + 62
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
        0x080030bc:    480e        .H      LDR      r0,[pc,#56] ; [0x80030f8] = 0x200005e0
        0x080030be:    68c0        .h      LDR      r0,[r0,#0xc]
        0x080030c0:    2301        .#      MOVS     r3,#1
        0x080030c2:    ebc36010    ...`    RSB      r0,r3,r0,LSR #24
        0x080030c6:    694b        Ki      LDR      r3,[r1,#0x14]
        0x080030c8:    62d8        .b      STR      r0,[r3,#0x2c]
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
        0x080030ca:    480b        .H      LDR      r0,[pc,#44] ; [0x80030f8] = 0x200005e0
        0x080030cc:    68c0        .h      LDR      r0,[r0,#0xc]
        0x080030ce:    f020407f     ..@    BIC      r0,r0,#0xff000000
        0x080030d2:    4b09        .K      LDR      r3,[pc,#36] ; [0x80030f8] = 0x200005e0
        0x080030d4:    6118        .a      STR      r0,[r3,#0x10]
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
        0x080030d6:    2001        .       MOVS     r0,#1
        0x080030d8:    4770        pG      BX       lr
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
        0x080030da:    4807        .H      LDR      r0,[pc,#28] ; [0x80030f8] = 0x200005e0
        0x080030dc:    f8900028    ..(.    LDRB     r0,[r0,#0x28]
        0x080030e0:    1c40        @.      ADDS     r0,r0,#1
        0x080030e2:    4b05        .K      LDR      r3,[pc,#20] ; [0x80030f8] = 0x200005e0
        0x080030e4:    f8830028    ..(.    STRB     r0,[r3,#0x28]
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
        0x080030e8:    2001        .       MOVS     r0,#1
        0x080030ea:    ebc06012    ...`    RSB      r0,r0,r2,LSR #24
        0x080030ee:    694b        Ki      LDR      r3,[r1,#0x14]
        0x080030f0:    62d8        .b      STR      r0,[r3,#0x2c]
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
        0x080030f2:    2000        .       MOVS     r0,#0
        0x080030f4:    e7f0        ..      B        0x80030d8 ; z_axis_ramp_up2 + 60
    $d
        0x080030f6:    0000        ..      DCW    0
        0x080030f8:    200005e0    ...     DCD    536872416
        0x080030fc:    20000038    8..     DCD    536870968
    $t
    i.z_move
    z_move
;;; .\..\Src\fsm.c (197)
        0x08003100:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08003104:    4605        .F      MOV      r5,r0
        0x08003106:    460e        .F      MOV      r6,r1
        0x08003108:    4614        .F      MOV      r4,r2
        0x0800310a:    461f        .F      MOV      r7,r3
;;;198    	MOTOR_X_Enable();
        0x0800310c:    f2402002    @..     MOV      r0,#0x202
        0x08003110:    491c        .I      LDR      r1,[pc,#112] ; [0x8003184] = 0x40010810
        0x08003112:    6008        .`      STR      r0,[r1,#0]
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x08003114:    491c        .I      LDR      r1,[pc,#112] ; [0x8003188] = 0x40010c10
        0x08003116:    6008        .`      STR      r0,[r1,#0]
;;;200    
;;;201    	if(direction == feed_direction_left) {
        0x08003118:    b95d        ].      CBNZ     r5,0x8003132 ; z_move + 50
;;;202    		feed_direction = feed_direction_left;
        0x0800311a:    2000        .       MOVS     r0,#0
        0x0800311c:    491b        .I      LDR      r1,[pc,#108] ; [0x800318c] = 0x200000a1
        0x0800311e:    7008        .p      STRB     r0,[r1,#0]
;;;203    		MOTOR_Z_Reverse();
        0x08003120:    f2480080    H...    MOV      r0,#0x8080
        0x08003124:    4917        .I      LDR      r1,[pc,#92] ; [0x8003184] = 0x40010810
        0x08003126:    1d09        ..      ADDS     r1,r1,#4
        0x08003128:    6008        .`      STR      r0,[r1,#0]
;;;204    		MOTOR_X_Reverse();
        0x0800312a:    4819        .H      LDR      r0,[pc,#100] ; [0x8003190] = 0x4800080
        0x0800312c:    4919        .I      LDR      r1,[pc,#100] ; [0x8003194] = 0x40011000
        0x0800312e:    6148        Ha      STR      r0,[r1,#0x14]
        0x08003130:    e009        ..      B        0x8003146 ; z_move + 70
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
        0x08003132:    2001        .       MOVS     r0,#1
        0x08003134:    4915        .I      LDR      r1,[pc,#84] ; [0x800318c] = 0x200000a1
        0x08003136:    7008        .p      STRB     r0,[r1,#0]
;;;207    		MOTOR_Z_Forward();
        0x08003138:    f2480080    H...    MOV      r0,#0x8080
        0x0800313c:    4911        .I      LDR      r1,[pc,#68] ; [0x8003184] = 0x40010810
        0x0800313e:    6008        .`      STR      r0,[r1,#0]
;;;208    		MOTOR_X_Forward();
        0x08003140:    4813        .H      LDR      r0,[pc,#76] ; [0x8003190] = 0x4800080
        0x08003142:    4914        .I      LDR      r1,[pc,#80] ; [0x8003194] = 0x40011000
        0x08003144:    6108        .a      STR      r0,[r1,#0x10]
;;;209    	}
;;;210    	LL_mDelay(2);
        0x08003146:    2002        .       MOVS     r0,#2
        0x08003148:    f7fdfff6    ....    BL       LL_mDelay ; 0x8001138
;;;211    
;;;212    	state.sync = sync;
        0x0800314c:    4812        .H      LDR      r0,[pc,#72] ; [0x8003198] = 0x20000044
        0x0800314e:    7404        .t      STRB     r4,[r0,#0x10]
;;;213    	if(sync){
        0x08003150:    b11c        ..      CBZ      r4,0x800315a ; z_move + 90
;;;214    		state.main_feed_direction = feed_direction;
        0x08003152:    480e        .H      LDR      r0,[pc,#56] ; [0x800318c] = 0x200000a1
        0x08003154:    7800        .x      LDRB     r0,[r0,#0]
        0x08003156:    4910        .I      LDR      r1,[pc,#64] ; [0x8003198] = 0x20000044
        0x08003158:    7448        Ht      STRB     r0,[r1,#0x11]
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
        0x0800315a:    2000        .       MOVS     r0,#0
        0x0800315c:    490f        .I      LDR      r1,[pc,#60] ; [0x800319c] = 0x200005e0
        0x0800315e:    6008        .`      STR      r0,[r1,#0]
;;;218    	z_axis.end_pos = length;
        0x08003160:    4608        .F      MOV      r0,r1
        0x08003162:    6046        F`      STR      r6,[r0,#4]
;;;219    	if(z_axis.end_pos > 0){
        0x08003164:    6840        @h      LDR      r0,[r0,#4]
        0x08003166:    b128        (.      CBZ      r0,0x8003174 ; z_move + 116
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
        0x08003168:    4608        .F      MOV      r0,r1
        0x0800316a:    6840        @h      LDR      r0,[r0,#4]
        0x0800316c:    f0200001     ...    BIC      r0,r0,#1
        0x08003170:    6048        H`      STR      r0,[r1,#4]
        0x08003172:    e002        ..      B        0x800317a ; z_move + 122
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
        0x08003174:    2001        .       MOVS     r0,#1
        0x08003176:    4908        .I      LDR      r1,[pc,#32] ; [0x8003198] = 0x20000044
        0x08003178:    7408        .t      STRB     r0,[r1,#0x10]
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
        0x0800317a:    4807        .H      LDR      r0,[pc,#28] ; [0x8003198] = 0x20000044
        0x0800317c:    f7fff920    .. .    BL       do_fsm_move_start ; 0x80023c0
;;;228    }
        0x08003180:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x08003184:    40010810    ...@    DCD    1073809424
        0x08003188:    40010c10    ...@    DCD    1073810448
        0x0800318c:    200000a1    ...     DCD    536871073
        0x08003190:    04800080    ....    DCD    75497600
        0x08003194:    40011000    ...@    DCD    1073811456
        0x08003198:    20000044    D..     DCD    536870980
        0x0800319c:    200005e0    ...     DCD    536872416
    $d.realdata
    .constdata
    AHBPrescTable
        0x080031a0:    00000000    ....    DCD    0
        0x080031a4:    00000000    ....    DCD    0
        0x080031a8:    04030201    ....    DCD    67305985
        0x080031ac:    09080706    ....    DCD    151521030
    APBPrescTable
        0x080031b0:    00000000    ....    DCD    0
        0x080031b4:    04030201    ....    DCD    67305985
    .constdata
    CHANNEL_OFFSET_TAB
        0x080031b8:    44301c08    ..0D    DCD    1144003592
        0x080031bc:    6c58        Xl      DCW    27736
        0x080031be:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x080031bf:    00          .       DCB    0
        0x080031c0:    04000000    ....    DCD    67108864
        0x080031c4:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x080031c6:    0000        ..      DCW    0
        0x080031c8:    00000008    ....    DCD    8
        0x080031cc:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x080031cd:    000008      ...     DCB    0,0,8
        0x080031d0:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x080031d4:    06040200    ....    DCD    100925952
        0x080031d8:    0a08        ..      DCW    2568
        0x080031da:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x080031db:    00          .       DCB    0
        0x080031dc:    04030201    ....    DCD    67305985
        0x080031e0:    00000605    ....    DCD    1541
        0x080031e4:    00000000    ....    DCD    0
    .constdata
    CHANNEL_OFFSET_TAB
        0x080031e8:    44301c08    ..0D    DCD    1144003592
        0x080031ec:    6c58        Xl      DCW    27736
        0x080031ee:    80          .       DCB    128
    OFFSET_TAB_CCMRx
        0x080031ef:    00          .       DCB    0
        0x080031f0:    04000000    ....    DCD    67108864
        0x080031f4:    0404        ..      DCW    1028
    SHIFT_TAB_OCxx
        0x080031f6:    0000        ..      DCW    0
        0x080031f8:    00000008    ....    DCD    8
        0x080031fc:    08          .       DCB    8
    SHIFT_TAB_ICxx
        0x080031fd:    000008      ...     DCB    0,0,8
        0x08003200:    08000000    ....    DCD    134217728
    SHIFT_TAB_CCxP
        0x08003204:    06040200    ....    DCD    100925952
        0x08003208:    0a08        ..      DCW    2568
        0x0800320a:    0c          .       DCB    12
    SHIFT_TAB_OISx
        0x0800320b:    00          .       DCB    0
        0x0800320c:    04030201    ....    DCD    67305985
        0x08003210:    0605        ..      DCW    1541
    Menu_size
        0x08003212:    0021        !.      DCW    33
        0x08003214:    00000000    ....    DCD    0
    enc_setup
        0x08003218:    00000000    ....    DCD    0
        0x0800321c:    00090000    ....    DCD    589824
    aTxBuffer
        0x08003220:    334d5453    STM3    DCD    860705875
        0x08003224:    78314632    2F1x    DCD    2016495154
        0x08003228:    53552078    x US    DCD    1398087800
        0x0800322c:    20545241    ART     DCD    542396993
        0x08003230:    41204c4c    LL A    DCD    1092635724
        0x08003234:    45204950    PI E    DCD    1159743824
        0x08003238:    706d6178    xamp    DCD    1886216568
        0x0800323c:    3a20656c    le :    DCD    975201644
        0x08003240:    2f585420     TX/    DCD    794317856
        0x08003244:    69205852    RX i    DCD    1763727442
        0x08003248:    4d44206e    n DM    DCD    1296310382
        0x0800324c:    6f6d2041    A mo    DCD    1869422657
        0x08003250:    0a0d6564    de..    DCD    168650084
        0x08003254:    666e6f43    Conf    DCD    1718513475
        0x08003258:    72756769    igur    DCD    1920296809
        0x0800325c:    6f697461    atio    DCD    1869182049
        0x08003260:    4155206e    n UA    DCD    1096097902
        0x08003264:    31205452    RT 1    DCD    824202322
        0x08003268:    30323531    1520    DCD    808596785
        0x0800326c:    70622030    0 bp    DCD    1885478960
        0x08003270:    38202c73    s, 8    DCD    941632627
        0x08003274:    74616420     dat    DCD    1952539680
        0x08003278:    69622061    a bi    DCD    1768038497
        0x0800327c:    20312f74    t/1     DCD    540094324
        0x08003280:    706f7473    stop    DCD    1886352499
        0x08003284:    74696220     bit    DCD    1953063456
        0x08003288:    206f4e2f    /No     DCD    544165423
        0x0800328c:    69726170    pari    DCD    1769103728
        0x08003290:    4e2f7974    ty/N    DCD    1311734132
        0x08003294:    5748206f    o HW    DCD    1464344687
        0x08003298:    6f6c6620     flo    DCD    1869375008
        0x0800329c:    6f632077    w co    DCD    1868767351
        0x080032a0:    6f72746e    ntro    DCD    1869771886
        0x080032a4:    500a0d6c    l..P    DCD    1342836076
        0x080032a8:    7361656c    leas    DCD    1935762796
        0x080032ac:    6e652065    e en    DCD    1852121189
        0x080032b0:    20726574    ter     DCD    544367988
        0x080032b4:    444e4527    'END    DCD    1145980199
        0x080032b8:    74732027    ' st    DCD    1953701927
        0x080032bc:    676e6972    ring    DCD    1735289202
        0x080032c0:    2e2e2e20     ...    DCD    774778400
        0x080032c4:    00000a0d    ....    DCD    2573
    Region$$Table$$Base
        0x080032c8:    080032e8    .2..    DCD    134230760
        0x080032cc:    20000000    ...     DCD    536870912
        0x080032d0:    000004f0    ....    DCD    1264
        0x080032d4:    0800068c    ....    DCD    134219404
        0x080032d8:    08003484    .4..    DCD    134231172
        0x080032dc:    200004f0    ...     DCD    536872176
        0x080032e0:    000006d8    ....    DCD    1752
        0x080032e4:    08002080    . ..    DCD    134226048
    Region$$Table$$Limit

** Section #2 'RW_IRAM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 412 bytes (alignment 4)
    Address: 0x20000000


** Section #3 'RW_IRAM1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 1752 bytes (alignment 8)
    Address: 0x200004f0


** Section #4 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #5 '.debug_frame' (SHT_PROGBITS)
    Size   : 3944 bytes


** Section #6 '.debug_info' (SHT_PROGBITS)
    Size   : 207364 bytes


** Section #7 '.debug_line' (SHT_PROGBITS)
    Size   : 26352 bytes


** Section #8 '.debug_loc' (SHT_PROGBITS)
    Size   : 8456 bytes


** Section #9 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 530448 bytes


** Section #10 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 3377 bytes


** Section #11 '.symtab' (SHT_SYMTAB)
    Size   : 10176 bytes (alignment 4)
    String table #12 '.strtab'
    Last local symbol no. 447


** Section #12 '.strtab' (SHT_STRTAB)
    Size   : 8696 bytes


** Section #13 '.note' (SHT_NOTE)
    Size   : 28 bytes (alignment 4)


** Section #14 '.comment' (SHT_PROGBITS)
    Size   : 25672 bytes


** Section #15 '.shstrtab' (SHT_STRTAB)
    Size   : 156 bytes


