
========================================================================

** ELF Header Information

    File Name: C:\STM32\project\efeed\MDK-ARM\efeed\efeed.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x080000ed
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_SOFT (0x05000202)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Soft float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armasm [4d35cf]
    Component: ARM Compiler 5.06 update 4 (build 422) Tool: armlink [4d35d2]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 1
    Section header entries: 16

    Program header offset: 776832 (0x000bda80)
    Section header offset: 776864 (0x000bdaa0)

    Section header string table index: 15

========================================================================

** Program header #0 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 10772 bytes (8656 bytes in file)
    Virtual address: 0x08000000 (Alignment 8)


========================================================================

** Section #1 'ER_IROM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 8244 bytes (alignment 4)
    Address: 0x08000000

    $d.realdata
    RESET
    __Vectors
        0x08000000:    200009e0    ...     DCD    536873440
        0x08000004:    08000101    ....    DCD    134217985
        0x08000008:    08000109    ....    DCD    134217993
        0x0800000c:    0800010b    ....    DCD    134217995
        0x08000010:    0800010d    ....    DCD    134217997
        0x08000014:    0800010f    ....    DCD    134217999
        0x08000018:    08000111    ....    DCD    134218001
        0x0800001c:    00000000    ....    DCD    0
        0x08000020:    00000000    ....    DCD    0
        0x08000024:    00000000    ....    DCD    0
        0x08000028:    00000000    ....    DCD    0
        0x0800002c:    080012d1    ....    DCD    134222545
        0x08000030:    08000115    ....    DCD    134218005
        0x08000034:    00000000    ....    DCD    0
        0x08000038:    08001219    ....    DCD    134222361
        0x0800003c:    080012d5    ....    DCD    134222549
        0x08000040:    0800011b    ....    DCD    134218011
        0x08000044:    0800011b    ....    DCD    134218011
        0x08000048:    0800011b    ....    DCD    134218011
        0x0800004c:    0800011b    ....    DCD    134218011
        0x08000050:    0800011b    ....    DCD    134218011
        0x08000054:    0800011b    ....    DCD    134218011
        0x08000058:    0800011b    ....    DCD    134218011
        0x0800005c:    0800011b    ....    DCD    134218011
        0x08000060:    0800011b    ....    DCD    134218011
        0x08000064:    0800011b    ....    DCD    134218011
        0x08000068:    0800011b    ....    DCD    134218011
        0x0800006c:    0800011b    ....    DCD    134218011
        0x08000070:    0800011b    ....    DCD    134218011
        0x08000074:    0800011b    ....    DCD    134218011
        0x08000078:    08000265    e...    DCD    134218341
        0x0800007c:    0800011b    ....    DCD    134218011
        0x08000080:    0800011b    ....    DCD    134218011
        0x08000084:    0800028d    ....    DCD    134218381
        0x08000088:    0800011b    ....    DCD    134218011
        0x0800008c:    0800011b    ....    DCD    134218011
        0x08000090:    0800011b    ....    DCD    134218011
        0x08000094:    0800011b    ....    DCD    134218011
        0x08000098:    0800011b    ....    DCD    134218011
        0x0800009c:    0800011b    ....    DCD    134218011
        0x080000a0:    0800011b    ....    DCD    134218011
        0x080000a4:    080013e5    ....    DCD    134222821
        0x080000a8:    0800011b    ....    DCD    134218011
        0x080000ac:    0800011b    ....    DCD    134218011
        0x080000b0:    080013fd    ....    DCD    134222845
        0x080000b4:    08001439    9...    DCD    134222905
        0x080000b8:    0800148d    ....    DCD    134222989
        0x080000bc:    0800011b    ....    DCD    134218011
        0x080000c0:    0800011b    ....    DCD    134218011
        0x080000c4:    08000311    ....    DCD    134218513
        0x080000c8:    0800030d    ....    DCD    134218509
        0x080000cc:    0800011b    ....    DCD    134218011
        0x080000d0:    0800011b    ....    DCD    134218011
        0x080000d4:    0800011b    ....    DCD    134218011
        0x080000d8:    08001515    ....    DCD    134223125
        0x080000dc:    0800011b    ....    DCD    134218011
        0x080000e0:    0800011b    ....    DCD    134218011
        0x080000e4:    0800011b    ....    DCD    134218011
        0x080000e8:    0800011b    ....    DCD    134218011
    $t
    .ARM.Collect$$$$00000000
    .ARM.Collect$$$$00000001
    __Vectors_End
    __main
    _main_stk
        0x080000ec:    f8dfd00c    ....    LDR      sp,__lit__00000000 ; [0x80000fc] = 0x200009e0
    .ARM.Collect$$$$00000004
    _main_scatterload
        0x080000f0:    f000f87a    ..z.    BL       __scatterload ; 0x80001e8
    .ARM.Collect$$$$00000008
    .ARM.Collect$$$$0000000A
    .ARM.Collect$$$$0000000B
    __main_after_scatterload
    _main_clock
    _main_cpp_init
    _main_init
        0x080000f4:    4800        .H      LDR      r0,[pc,#0] ; [0x80000f8] = 0x8001979
        0x080000f6:    4700        .G      BX       r0
    $d
        0x080000f8:    08001979    y...    DCD    134224249
    .ARM.Collect$$$$00002712
    __lit__00000000
    .ARM.Collect$$$$0000000D
    .ARM.Collect$$$$0000000F
    __rt_final_cpp
    __rt_final_exit
        0x080000fc:    200009e0    ...     DCD    536873440
    $t
    .text
    Reset_Handler
;;;150                     LDR     R0, =SystemInit
        0x08000100:    4806        .H      LDR      r0,[pc,#24] ; [0x800011c] = 0x800139d
;;;151                     BLX     R0
        0x08000102:    4780        .G      BLX      r0
;;;152                     LDR     R0, =__main
        0x08000104:    4806        .H      LDR      r0,[pc,#24] ; [0x8000120] = 0x80000ed
;;;153                     BX      R0
        0x08000106:    4700        .G      BX       r0
    NMI_Handler
;;;154                     ENDP
;;;155    
;;;156    ; Dummy Exception Handlers (infinite loops which can be modified)
;;;157    
;;;158    NMI_Handler     PROC
;;;159                    EXPORT  NMI_Handler                [WEAK]
;;;160                    B       .
        0x08000108:    e7fe        ..      B        NMI_Handler ; 0x8000108
    HardFault_Handler
;;;161                    ENDP
;;;162    HardFault_Handler\
;;;163                    PROC
;;;164                    EXPORT  HardFault_Handler          [WEAK]
;;;165                    B       .
        0x0800010a:    e7fe        ..      B        HardFault_Handler ; 0x800010a
    MemManage_Handler
;;;166                    ENDP
;;;167    MemManage_Handler\
;;;168                    PROC
;;;169                    EXPORT  MemManage_Handler          [WEAK]
;;;170                    B       .
        0x0800010c:    e7fe        ..      B        MemManage_Handler ; 0x800010c
    BusFault_Handler
;;;171                    ENDP
;;;172    BusFault_Handler\
;;;173                    PROC
;;;174                    EXPORT  BusFault_Handler           [WEAK]
;;;175                    B       .
        0x0800010e:    e7fe        ..      B        BusFault_Handler ; 0x800010e
    UsageFault_Handler
;;;176                    ENDP
;;;177    UsageFault_Handler\
;;;178                    PROC
;;;179                    EXPORT  UsageFault_Handler         [WEAK]
;;;180                    B       .
        0x08000110:    e7fe        ..      B        UsageFault_Handler ; 0x8000110
;;;181                    ENDP
;;;182    SVC_Handler     PROC
;;;183                    EXPORT  SVC_Handler                [WEAK]
;;;184                    B       .
        0x08000112:    e7fe        ..      B        0x8000112 ; UsageFault_Handler + 2
    DebugMon_Handler
;;;185                    ENDP
;;;186    DebugMon_Handler\
;;;187                    PROC
;;;188                    EXPORT  DebugMon_Handler           [WEAK]
;;;189                    B       .
        0x08000114:    e7fe        ..      B        DebugMon_Handler ; 0x8000114
;;;190                    ENDP
;;;191    PendSV_Handler  PROC
;;;192                    EXPORT  PendSV_Handler             [WEAK]
;;;193                    B       .
        0x08000116:    e7fe        ..      B        0x8000116 ; DebugMon_Handler + 2
;;;194                    ENDP
;;;195    SysTick_Handler PROC
;;;196                    EXPORT  SysTick_Handler            [WEAK]
;;;197                    B       .
        0x08000118:    e7fe        ..      B        0x8000118 ; DebugMon_Handler + 4
    ADC1_2_IRQHandler
    CAN1_RX1_IRQHandler
    CAN1_SCE_IRQHandler
    DMA1_Channel1_IRQHandler
    DMA1_Channel2_IRQHandler
    DMA1_Channel3_IRQHandler
    DMA1_Channel5_IRQHandler
    DMA1_Channel6_IRQHandler
    EXTI0_IRQHandler
    EXTI15_10_IRQHandler
    EXTI1_IRQHandler
    EXTI2_IRQHandler
    EXTI3_IRQHandler
    EXTI4_IRQHandler
    EXTI9_5_IRQHandler
    FLASH_IRQHandler
    I2C1_ER_IRQHandler
    I2C1_EV_IRQHandler
    PVD_IRQHandler
    RCC_IRQHandler
    RTC_Alarm_IRQHandler
    RTC_IRQHandler
    SPI1_IRQHandler
    SPI2_IRQHandler
    TAMPER_IRQHandler
    TIM1_BRK_IRQHandler
    TIM1_CC_IRQHandler
    TIM1_TRG_COM_IRQHandler
    USART1_IRQHandler
    USART3_IRQHandler
    USBWakeUp_IRQHandler
    USB_HP_CAN1_TX_IRQHandler
    USB_LP_CAN1_RX0_IRQHandler
    WWDG_IRQHandler
;;;198                    ENDP
;;;199    
;;;200    Default_Handler PROC
;;;201    
;;;202                    EXPORT  WWDG_IRQHandler            [WEAK]
;;;203                    EXPORT  PVD_IRQHandler             [WEAK]
;;;204                    EXPORT  TAMPER_IRQHandler          [WEAK]
;;;205                    EXPORT  RTC_IRQHandler             [WEAK]
;;;206                    EXPORT  FLASH_IRQHandler           [WEAK]
;;;207                    EXPORT  RCC_IRQHandler             [WEAK]
;;;208                    EXPORT  EXTI0_IRQHandler           [WEAK]
;;;209                    EXPORT  EXTI1_IRQHandler           [WEAK]
;;;210                    EXPORT  EXTI2_IRQHandler           [WEAK]
;;;211                    EXPORT  EXTI3_IRQHandler           [WEAK]
;;;212                    EXPORT  EXTI4_IRQHandler           [WEAK]
;;;213                    EXPORT  DMA1_Channel1_IRQHandler   [WEAK]
;;;214                    EXPORT  DMA1_Channel2_IRQHandler   [WEAK]
;;;215                    EXPORT  DMA1_Channel3_IRQHandler   [WEAK]
;;;216                    EXPORT  DMA1_Channel4_IRQHandler   [WEAK]
;;;217                    EXPORT  DMA1_Channel5_IRQHandler   [WEAK]
;;;218                    EXPORT  DMA1_Channel6_IRQHandler   [WEAK]
;;;219                    EXPORT  DMA1_Channel7_IRQHandler   [WEAK]
;;;220                    EXPORT  ADC1_2_IRQHandler          [WEAK]
;;;221                    EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]
;;;222                    EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]
;;;223                    EXPORT  CAN1_RX1_IRQHandler        [WEAK]
;;;224                    EXPORT  CAN1_SCE_IRQHandler        [WEAK]
;;;225                    EXPORT  EXTI9_5_IRQHandler         [WEAK]
;;;226                    EXPORT  TIM1_BRK_IRQHandler        [WEAK]
;;;227                    EXPORT  TIM1_UP_IRQHandler         [WEAK]
;;;228                    EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]
;;;229                    EXPORT  TIM1_CC_IRQHandler         [WEAK]
;;;230                    EXPORT  TIM2_IRQHandler            [WEAK]
;;;231                    EXPORT  TIM3_IRQHandler            [WEAK]
;;;232                    EXPORT  TIM4_IRQHandler            [WEAK]
;;;233                    EXPORT  I2C1_EV_IRQHandler         [WEAK]
;;;234                    EXPORT  I2C1_ER_IRQHandler         [WEAK]
;;;235                    EXPORT  I2C2_EV_IRQHandler         [WEAK]
;;;236                    EXPORT  I2C2_ER_IRQHandler         [WEAK]
;;;237                    EXPORT  SPI1_IRQHandler            [WEAK]
;;;238                    EXPORT  SPI2_IRQHandler            [WEAK]
;;;239                    EXPORT  USART1_IRQHandler          [WEAK]
;;;240                    EXPORT  USART2_IRQHandler          [WEAK]
;;;241                    EXPORT  USART3_IRQHandler          [WEAK]
;;;242                    EXPORT  EXTI15_10_IRQHandler       [WEAK]
;;;243                    EXPORT  RTC_Alarm_IRQHandler        [WEAK]
;;;244                    EXPORT  USBWakeUp_IRQHandler       [WEAK]
;;;245    
;;;246    WWDG_IRQHandler
;;;247    PVD_IRQHandler
;;;248    TAMPER_IRQHandler
;;;249    RTC_IRQHandler
;;;250    FLASH_IRQHandler
;;;251    RCC_IRQHandler
;;;252    EXTI0_IRQHandler
;;;253    EXTI1_IRQHandler
;;;254    EXTI2_IRQHandler
;;;255    EXTI3_IRQHandler
;;;256    EXTI4_IRQHandler
;;;257    DMA1_Channel1_IRQHandler
;;;258    DMA1_Channel2_IRQHandler
;;;259    DMA1_Channel3_IRQHandler
;;;260    DMA1_Channel4_IRQHandler
;;;261    DMA1_Channel5_IRQHandler
;;;262    DMA1_Channel6_IRQHandler
;;;263    DMA1_Channel7_IRQHandler
;;;264    ADC1_2_IRQHandler
;;;265    USB_HP_CAN1_TX_IRQHandler
;;;266    USB_LP_CAN1_RX0_IRQHandler
;;;267    CAN1_RX1_IRQHandler
;;;268    CAN1_SCE_IRQHandler
;;;269    EXTI9_5_IRQHandler
;;;270    TIM1_BRK_IRQHandler
;;;271    TIM1_UP_IRQHandler
;;;272    TIM1_TRG_COM_IRQHandler
;;;273    TIM1_CC_IRQHandler
;;;274    TIM2_IRQHandler
;;;275    TIM3_IRQHandler
;;;276    TIM4_IRQHandler
;;;277    I2C1_EV_IRQHandler
;;;278    I2C1_ER_IRQHandler
;;;279    I2C2_EV_IRQHandler
;;;280    I2C2_ER_IRQHandler
;;;281    SPI1_IRQHandler
;;;282    SPI2_IRQHandler
;;;283    USART1_IRQHandler
;;;284    USART2_IRQHandler
;;;285    USART3_IRQHandler
;;;286    EXTI15_10_IRQHandler
;;;287    RTC_Alarm_IRQHandler
;;;288    USBWakeUp_IRQHandler
;;;289    
;;;290                    B       .
        0x0800011a:    e7fe        ..      B        ADC1_2_IRQHandler ; 0x800011a
    $d
        0x0800011c:    0800139d    ....    DCD    134222749
        0x08000120:    080000ed    ....    DCD    134217965
    $t
    .text
    __aeabi_uldivmod
        0x08000124:    e92d5ff0    -.._    PUSH     {r4-r12,lr}
        0x08000128:    4605        .F      MOV      r5,r0
        0x0800012a:    2000        .       MOVS     r0,#0
        0x0800012c:    4692        .F      MOV      r10,r2
        0x0800012e:    469b        .F      MOV      r11,r3
        0x08000130:    4688        .F      MOV      r8,r1
        0x08000132:    4606        .F      MOV      r6,r0
        0x08000134:    4681        .F      MOV      r9,r0
        0x08000136:    2440        @$      MOVS     r4,#0x40
        0x08000138:    e01b        ..      B        0x8000172 ; __aeabi_uldivmod + 78
        0x0800013a:    4628        (F      MOV      r0,r5
        0x0800013c:    4641        AF      MOV      r1,r8
        0x0800013e:    4647        GF      MOV      r7,r8
        0x08000140:    4622        "F      MOV      r2,r4
        0x08000142:    f000f841    ..A.    BL       __aeabi_llsr ; 0x80001c8
        0x08000146:    4653        SF      MOV      r3,r10
        0x08000148:    465a        ZF      MOV      r2,r11
        0x0800014a:    1ac0        ..      SUBS     r0,r0,r3
        0x0800014c:    4191        .A      SBCS     r1,r1,r2
        0x0800014e:    d310        ..      BCC      0x8000172 ; __aeabi_uldivmod + 78
        0x08000150:    4611        .F      MOV      r1,r2
        0x08000152:    4618        .F      MOV      r0,r3
        0x08000154:    4622        "F      MOV      r2,r4
        0x08000156:    f000f828    ..(.    BL       __aeabi_llsl ; 0x80001aa
        0x0800015a:    1a2d        -.      SUBS     r5,r5,r0
        0x0800015c:    eb670801    g...    SBC      r8,r7,r1
        0x08000160:    464f        OF      MOV      r7,r9
        0x08000162:    4622        "F      MOV      r2,r4
        0x08000164:    2001        .       MOVS     r0,#1
        0x08000166:    2100        .!      MOVS     r1,#0
        0x08000168:    f000f81f    ....    BL       __aeabi_llsl ; 0x80001aa
        0x0800016c:    eb170900    ....    ADDS     r9,r7,r0
        0x08000170:    414e        NA      ADCS     r6,r6,r1
        0x08000172:    1e20         .      SUBS     r0,r4,#0
        0x08000174:    f1a40401    ....    SUB      r4,r4,#1
        0x08000178:    dcdf        ..      BGT      0x800013a ; __aeabi_uldivmod + 22
        0x0800017a:    4648        HF      MOV      r0,r9
        0x0800017c:    4631        1F      MOV      r1,r6
        0x0800017e:    462a        *F      MOV      r2,r5
        0x08000180:    4643        CF      MOV      r3,r8
        0x08000182:    e8bd9ff0    ....    POP      {r4-r12,pc}
    .text
    __aeabi_memset
    __aeabi_memset4
    __aeabi_memset8
        0x08000186:    b2d2        ..      UXTB     r2,r2
        0x08000188:    e001        ..      B        0x800018e ; __aeabi_memset + 8
        0x0800018a:    f8002b01    ...+    STRB     r2,[r0],#1
        0x0800018e:    1e49        I.      SUBS     r1,r1,#1
        0x08000190:    d2fb        ..      BCS      0x800018a ; __aeabi_memset + 4
        0x08000192:    4770        pG      BX       lr
    __aeabi_memclr
    __aeabi_memclr4
    __aeabi_memclr8
        0x08000194:    2200        ."      MOVS     r2,#0
        0x08000196:    e7f6        ..      B        __aeabi_memset ; 0x8000186
    _memset$wrapper
        0x08000198:    b510        ..      PUSH     {r4,lr}
        0x0800019a:    4613        .F      MOV      r3,r2
        0x0800019c:    460a        .F      MOV      r2,r1
        0x0800019e:    4604        .F      MOV      r4,r0
        0x080001a0:    4619        .F      MOV      r1,r3
        0x080001a2:    f7fffff0    ....    BL       __aeabi_memset ; 0x8000186
        0x080001a6:    4620         F      MOV      r0,r4
        0x080001a8:    bd10        ..      POP      {r4,pc}
    .text
    __aeabi_llsl
    _ll_shift_l
        0x080001aa:    2a20         *      CMP      r2,#0x20
        0x080001ac:    db04        ..      BLT      0x80001b8 ; __aeabi_llsl + 14
        0x080001ae:    3a20         :      SUBS     r2,r2,#0x20
        0x080001b0:    fa00f102    ....    LSL      r1,r0,r2
        0x080001b4:    2000        .       MOVS     r0,#0
        0x080001b6:    4770        pG      BX       lr
        0x080001b8:    4091        .@      LSLS     r1,r1,r2
        0x080001ba:    f1c20320    .. .    RSB      r3,r2,#0x20
        0x080001be:    fa20f303     ...    LSR      r3,r0,r3
        0x080001c2:    4319        .C      ORRS     r1,r1,r3
        0x080001c4:    4090        .@      LSLS     r0,r0,r2
        0x080001c6:    4770        pG      BX       lr
    .text
    __aeabi_llsr
    _ll_ushift_r
        0x080001c8:    2a20         *      CMP      r2,#0x20
        0x080001ca:    db04        ..      BLT      0x80001d6 ; __aeabi_llsr + 14
        0x080001cc:    3a20         :      SUBS     r2,r2,#0x20
        0x080001ce:    fa21f002    !...    LSR      r0,r1,r2
        0x080001d2:    2100        .!      MOVS     r1,#0
        0x080001d4:    4770        pG      BX       lr
        0x080001d6:    fa21f302    !...    LSR      r3,r1,r2
        0x080001da:    40d0        .@      LSRS     r0,r0,r2
        0x080001dc:    f1c20220    .. .    RSB      r2,r2,#0x20
        0x080001e0:    4091        .@      LSLS     r1,r1,r2
        0x080001e2:    4308        .C      ORRS     r0,r0,r1
        0x080001e4:    4619        .F      MOV      r1,r3
        0x080001e6:    4770        pG      BX       lr
    .text
    __scatterload
    __scatterload_rt2
        0x080001e8:    4c06        .L      LDR      r4,[pc,#24] ; [0x8000204] = 0x8002014
        0x080001ea:    4d07        .M      LDR      r5,[pc,#28] ; [0x8000208] = 0x8002034
        0x080001ec:    e006        ..      B        0x80001fc ; __scatterload + 20
        0x080001ee:    68e0        .h      LDR      r0,[r4,#0xc]
        0x080001f0:    f0400301    @...    ORR      r3,r0,#1
        0x080001f4:    e8940007    ....    LDM      r4,{r0-r2}
        0x080001f8:    4798        .G      BLX      r3
        0x080001fa:    3410        .4      ADDS     r4,r4,#0x10
        0x080001fc:    42ac        .B      CMP      r4,r5
        0x080001fe:    d3f6        ..      BCC      0x80001ee ; __scatterload + 6
        0x08000200:    f7ffff78    ..x.    BL       __main_after_scatterload ; 0x80000f4
    $d
        0x08000204:    08002014    . ..    DCD    134225940
        0x08000208:    08002034    4 ..    DCD    134225972
    $t
    .text
    __decompress
    __decompress1
        0x0800020c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800020e:    188c        ..      ADDS     r4,r1,r2
        0x08000210:    f8105b01    ...[    LDRB     r5,[r0],#1
        0x08000214:    f0150307    ....    ANDS     r3,r5,#7
        0x08000218:    d101        ..      BNE      0x800021e ; __decompress + 18
        0x0800021a:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x0800021e:    112a        *.      ASRS     r2,r5,#4
        0x08000220:    d106        ..      BNE      0x8000230 ; __decompress + 36
        0x08000222:    f8102b01    ...+    LDRB     r2,[r0],#1
        0x08000226:    e003        ..      B        0x8000230 ; __decompress + 36
        0x08000228:    f8106b01    ...k    LDRB     r6,[r0],#1
        0x0800022c:    f8016b01    ...k    STRB     r6,[r1],#1
        0x08000230:    1e5b        [.      SUBS     r3,r3,#1
        0x08000232:    d1f9        ..      BNE      0x8000228 ; __decompress + 28
        0x08000234:    072b        +.      LSLS     r3,r5,#28
        0x08000236:    d405        ..      BMI      0x8000244 ; __decompress + 56
        0x08000238:    2300        .#      MOVS     r3,#0
        0x0800023a:    1e52        R.      SUBS     r2,r2,#1
        0x0800023c:    d40d        ..      BMI      0x800025a ; __decompress + 78
        0x0800023e:    f8013b01    ...;    STRB     r3,[r1],#1
        0x08000242:    e7fa        ..      B        0x800023a ; __decompress + 46
        0x08000244:    f8103b01    ...;    LDRB     r3,[r0],#1
        0x08000248:    1acb        ..      SUBS     r3,r1,r3
        0x0800024a:    1c92        ..      ADDS     r2,r2,#2
        0x0800024c:    e003        ..      B        0x8000256 ; __decompress + 74
        0x0800024e:    f8135b01    ...[    LDRB     r5,[r3],#1
        0x08000252:    f8015b01    ...[    STRB     r5,[r1],#1
        0x08000256:    1e52        R.      SUBS     r2,r2,#1
        0x08000258:    d5f9        ..      BPL      0x800024e ; __decompress + 66
        0x0800025a:    42a1        .B      CMP      r1,r4
        0x0800025c:    d3d8        ..      BCC      0x8000210 ; __decompress + 4
        0x0800025e:    2000        .       MOVS     r0,#0
        0x08000260:    bd70        p.      POP      {r4-r6,pc}
        0x08000262:    0000        ..      MOVS     r0,r0
    i.DMA1_Channel4_IRQHandler
    DMA1_Channel4_IRQHandler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1258     return (READ_BIT(DMAx->ISR, DMA_ISR_TCIF4) == (DMA_ISR_TCIF4));
        0x08000264:    4808        .H      LDR      r0,[pc,#32] ; [0x8000288] = 0x40020000
        0x08000266:    6801        .h      LDR      r1,[r0,#0]
        0x08000268:    f3c13140    ..@1    UBFX     r1,r1,#13,#1
        0x0800026c:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c
;;;195    {
        0x0800026e:    d003        ..      BEQ      0x8000278 ; DMA1_Channel4_IRQHandler + 20
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1489     WRITE_REG(DMAx->IFCR, DMA_IFCR_CGIF4);
        0x08000270:    1481        ..      ASRS     r1,r0,#18
        0x08000272:    6041        A`      STR      r1,[r0,#4]
;;; .\../Src/stm32f1xx_it.c
;;;200        Transfer_Complete_Callback();
        0x08000274:    f001b926    ..&.    B.W      Transfer_Complete_Callback ; 0x80014c4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;1412     return (READ_BIT(DMAx->ISR, DMA_ISR_TEIF4) == (DMA_ISR_TEIF4));
        0x08000278:    6800        .h      LDR      r0,[r0,#0]
        0x0800027a:    f3c030c0    ...0    UBFX     r0,r0,#15,#1
;;; .\../Src/stm32f1xx_it.c
;;;203      else if(LL_DMA_IsActiveFlag_TE4(DMA1))
        0x0800027e:    2800        .(      CMP      r0,#0
        0x08000280:    d001        ..      BEQ      0x8000286 ; DMA1_Channel4_IRQHandler + 34
;;;204      {
;;;205        Transfer_Error_Callback();
        0x08000282:    f001b93f    ..?.    B.W      Transfer_Error_Callback ; 0x8001504
;;;206      }
;;;207    
;;;208      /* USER CODE END DMA1_Channel4_IRQn 0 */
;;;209      
;;;210      /* USER CODE BEGIN DMA1_Channel4_IRQn 1 */
;;;211    
;;;212      /* USER CODE END DMA1_Channel4_IRQn 1 */
;;;213    }
        0x08000286:    4770        pG      BX       lr
    $d
        0x08000288:    40020000    ...@    DCD    1073872896
    $t
    i.DMA1_Channel7_IRQHandler
    DMA1_Channel7_IRQHandler
;;;214    
;;;215    /**
;;;216      * @brief This function handles DMA1 channel7 global interrupt.
;;;217      */
;;;218    void DMA1_Channel7_IRQHandler(void)
;;;219    {
;;;220      /* USER CODE BEGIN DMA1_Channel7_IRQn 0 */
;;;221    
;;;222      /* USER CODE END DMA1_Channel7_IRQn 0 */
;;;223      
;;;224      /* USER CODE BEGIN DMA1_Channel7_IRQn 1 */
;;;225    
;;;226      /* USER CODE END DMA1_Channel7_IRQn 1 */
;;;227    }
        0x0800028c:    4770        pG      BX       lr
    i.Error_Handler
    Error_Handler
;;; .\../Src/main.c
;;;1386   	while (1) {
        0x0800028e:    e7fe        ..      B        Error_Handler ; 0x800028e
    i.G01
    G01
;;; .\..\Src\fsm.c
;;;495    void G01(int dx, int dz, int feed){
        0x08000290:    b570        p.      PUSH     {r4-r6,lr}
        0x08000292:    4605        .F      MOV      r5,r0
        0x08000294:    460c        .F      MOV      r4,r1
;;;496    	dzdx_init(dx, dz, &state);
        0x08000296:    4a17        .J      LDR      r2,[pc,#92] ; [0x80002f4] = 0x20000060
        0x08000298:    4621        !F      MOV      r1,r4
        0x0800029a:    4628        (F      MOV      r0,r5
        0x0800029c:    f001fb36    ..6.    BL       dzdx_init ; 0x800190c
        0x080002a0:    4b15        .K      LDR      r3,[pc,#84] ; [0x80002f8] = 0x200000bc
        0x080002a2:    2201        ."      MOVS     r2,#1
        0x080002a4:    2100        .!      MOVS     r1,#0
        0x080002a6:    f2480680    H...    MOV      r6,#0x8080
;;;497    
;;;498    	if(dz<0) {
        0x080002aa:    2c00        .,      CMP      r4,#0
        0x080002ac:    da03        ..      BGE      0x80002b6 ; G01 + 38
;;;499    		feed_direction = feed_direction_left;
        0x080002ae:    7019        .p      STRB     r1,[r3,#0]
;;;500    		MOTOR_Z_Reverse();
        0x080002b0:    4812        .H      LDR      r0,[pc,#72] ; [0x80002fc] = 0x40010814
        0x080002b2:    6006        .`      STR      r6,[r0,#0]
        0x080002b4:    e003        ..      B        0x80002be ; G01 + 46
;;;501    	} else {
;;;502    		feed_direction = feed_direction_right;
        0x080002b6:    701a        .p      STRB     r2,[r3,#0]
;;;503    		MOTOR_Z_Forward();
        0x080002b8:    4810        .H      LDR      r0,[pc,#64] ; [0x80002fc] = 0x40010814
        0x080002ba:    1f00        ..      SUBS     r0,r0,#4
        0x080002bc:    6006        .`      STR      r6,[r0,#0]
        0x080002be:    4810        .H      LDR      r0,[pc,#64] ; [0x8000300] = 0x4800080
        0x080002c0:    4b10        .K      LDR      r3,[pc,#64] ; [0x8000304] = 0x40011000
;;;504    	}
;;;505    
;;;506    	if(dx<0) {
        0x080002c2:    2d00        .-      CMP      r5,#0
        0x080002c4:    da01        ..      BGE      0x80002ca ; G01 + 58
;;;507    		MOTOR_X_Reverse();
        0x080002c6:    6158        Xa      STR      r0,[r3,#0x14]
        0x080002c8:    e000        ..      B        0x80002cc ; G01 + 60
;;;508    	} else {
;;;509    		MOTOR_X_Forward();
        0x080002ca:    6118        .a      STR      r0,[r3,#0x10]
;;;510    	}
;;;511    
;;;512    	state.sync = false;
        0x080002cc:    4b09        .K      LDR      r3,[pc,#36] ; [0x80002f4] = 0x20000060
        0x080002ce:    7419        .t      STRB     r1,[r3,#0x10]
        0x080002d0:    480d        .H      LDR      r0,[pc,#52] ; [0x8000308] = 0x20000508
        0x080002d2:    6001        .`      STR      r1,[r0,#0]
        0x080002d4:    2c00        .,      CMP      r4,#0
;;;513    	if(state.sync){
        0x080002d6:    da00        ..      BGE      0x80002da ; G01 + 74
;;;514    		state.main_feed_direction = feed_direction;
;;;515    	}
;;;516    
;;;517    	z_axis.current_pos = 0;
;;;518    	z_axis.end_pos = abs(dz);
        0x080002d8:    4264        dB      RSBS     r4,r4,#0
        0x080002da:    6044        D`      STR      r4,[r0,#4]
;;;519    	if(z_axis.end_pos > 0){
        0x080002dc:    b11c        ..      CBZ      r4,0x80002e6 ; G01 + 86
;;;520    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
        0x080002de:    f0240101    $...    BIC      r1,r4,#1
        0x080002e2:    6041        A`      STR      r1,[r0,#4]
        0x080002e4:    e000        ..      B        0x80002e8 ; G01 + 88
;;;521    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;522    
;;;523    	} else {
;;;524    		state.sync = true;
        0x080002e6:    741a        .t      STRB     r2,[r3,#0x10]
;;;525    	}
;;;526    	do_fsm_move_start(&state);
        0x080002e8:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x080002ec:    4801        .H      LDR      r0,[pc,#4] ; [0x80002f4] = 0x20000060
        0x080002ee:    f001ba29    ..).    B.W      do_fsm_move_start ; 0x8001744
    $d
        0x080002f2:    0000        ..      DCW    0
        0x080002f4:    20000060    `..     DCD    536871008
        0x080002f8:    200000bc    ...     DCD    536871100
        0x080002fc:    40010814    ...@    DCD    1073809428
        0x08000300:    04800080    ....    DCD    75497600
        0x08000304:    40011000    ...@    DCD    1073811456
        0x08000308:    20000508    ...     DCD    536872200
    $t
    i.I2C2_ER_IRQHandler
    I2C2_ER_IRQHandler
;;; .\../Src/stm32f1xx_it.c
;;;374      while(1){
        0x0800030c:    e7fe        ..      B        I2C2_ER_IRQHandler ; 0x800030c
        0x0800030e:    0000        ..      MOVS     r0,r0
    i.I2C2_EV_IRQHandler
    I2C2_EV_IRQHandler
;;; .\../Src/stm32f1xx_it.c (343)
        0x08000310:    b508        ..      PUSH     {r3,lr}
        0x08000312:    480d        .H      LDR      r0,[pc,#52] ; [0x8000348] = 0x40005800
        0x08000314:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08000316:    f3c10100    ....    UBFX     r1,r1,#0,#1
        0x0800031a:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c (343)
        0x0800031c:    d006        ..      BEQ      0x800032c ; I2C2_EV_IRQHandler + 28
        0x0800031e:    6901        .i      LDR      r1,[r0,#0x10]
        0x08000320:    f02101ff    !...    BIC      r1,r1,#0xff
        0x08000324:    f0410178    A.x.    ORR      r1,r1,#0x78
        0x08000328:    6101        .a      STR      r1,[r0,#0x10]
        0x0800032a:    bd08        ..      POP      {r3,pc}
        0x0800032c:    6941        Ai      LDR      r1,[r0,#0x14]
        0x0800032e:    f3c10140    ..@.    UBFX     r1,r1,#1,#1
;;;344      /* USER CODE BEGIN I2C2_EV_IRQn 0 */
;;;345      /* Check SB flag value in ISR register */
;;;346      if(LL_I2C_IsActiveFlag_SB(I2C2))
;;;347      {
;;;348        /* Send Slave address with a 7-Bit SLAVE_OWN_ADDRESS for a write request */
;;;349        LL_I2C_TransmitData8(I2C2, SSD1306_I2C_ADDR);
;;;350      }
;;;351      /* Check ADDR flag value in ISR register */
;;;352      else if(LL_I2C_IsActiveFlag_ADDR(I2C2))
        0x08000332:    2900        .)      CMP      r1,#0
        0x08000334:    d0f9        ..      BEQ      0x800032a ; I2C2_EV_IRQHandler + 26
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;401      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
        0x08000336:    6841        Ah      LDR      r1,[r0,#4]
        0x08000338:    f4416100    A..a    ORR      r1,r1,#0x800
        0x0800033c:    6041        A`      STR      r1,[r0,#4]
;;;402    }
;;;403    
;;;404    /**
;;;405      * @brief  Disable DMA transmission requests.
;;;406      * @rmtoll CR2          DMAEN         LL_I2C_DisableDMAReq_TX
;;;407      * @param  I2Cx I2C Instance.
;;;408      * @retval None
;;;409      */
;;;410    __STATIC_INLINE void LL_I2C_DisableDMAReq_TX(I2C_TypeDef *I2Cx)
;;;411    {
;;;412      CLEAR_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
;;;413    }
;;;414    
;;;415    /**
;;;416      * @brief  Check if DMA transmission requests are enabled or disabled.
;;;417      * @rmtoll CR2          DMAEN         LL_I2C_IsEnabledDMAReq_TX
;;;418      * @param  I2Cx I2C Instance.
;;;419      * @retval State of bit (1 or 0).
;;;420      */
;;;421    __STATIC_INLINE uint32_t LL_I2C_IsEnabledDMAReq_TX(I2C_TypeDef *I2Cx)
;;;422    {
;;;423      return (READ_BIT(I2Cx->CR2, I2C_CR2_DMAEN) == (I2C_CR2_DMAEN));
;;;424    }
;;;425    
;;;426    /**
;;;427      * @brief  Enable DMA reception requests.
;;;428      * @rmtoll CR2          DMAEN         LL_I2C_EnableDMAReq_RX
;;;429      * @param  I2Cx I2C Instance.
;;;430      * @retval None
;;;431      */
;;;432    __STATIC_INLINE void LL_I2C_EnableDMAReq_RX(I2C_TypeDef *I2Cx)
;;;433    {
;;;434      SET_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
;;;435    }
;;;436    
;;;437    /**
;;;438      * @brief  Disable DMA reception requests.
;;;439      * @rmtoll CR2          DMAEN         LL_I2C_DisableDMAReq_RX
;;;440      * @param  I2Cx I2C Instance.
;;;441      * @retval None
;;;442      */
;;;443    __STATIC_INLINE void LL_I2C_DisableDMAReq_RX(I2C_TypeDef *I2Cx)
;;;444    {
;;;445      CLEAR_BIT(I2Cx->CR2, I2C_CR2_DMAEN);
;;;446    }
;;;447    
;;;448    /**
;;;449      * @brief  Check if DMA reception requests are enabled or disabled.
;;;450      * @rmtoll CR2          DMAEN         LL_I2C_IsEnabledDMAReq_RX
;;;451      * @param  I2Cx I2C Instance.
;;;452      * @retval State of bit (1 or 0).
;;;453      */
;;;454    __STATIC_INLINE uint32_t LL_I2C_IsEnabledDMAReq_RX(I2C_TypeDef *I2Cx)
;;;455    {
;;;456      return (READ_BIT(I2Cx->CR2, I2C_CR2_DMAEN) == (I2C_CR2_DMAEN));
;;;457    }
;;;458    
;;;459    /**
;;;460      * @brief  Get the data register address used for DMA transfer.
;;;461      * @rmtoll DR           DR            LL_I2C_DMA_GetRegAddr
;;;462      * @param  I2Cx I2C Instance.
;;;463      * @retval Address of data register
;;;464      */
;;;465    __STATIC_INLINE uint32_t LL_I2C_DMA_GetRegAddr(I2C_TypeDef *I2Cx)
;;;466    {
;;;467      return (uint32_t) & (I2Cx->DR);
;;;468    }
;;;469    
;;;470    /**
;;;471      * @brief  Enable Clock stretching.
;;;472      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;473      * @rmtoll CR1          NOSTRETCH     LL_I2C_EnableClockStretching
;;;474      * @param  I2Cx I2C Instance.
;;;475      * @retval None
;;;476      */
;;;477    __STATIC_INLINE void LL_I2C_EnableClockStretching(I2C_TypeDef *I2Cx)
;;;478    {
;;;479      CLEAR_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
;;;480    }
;;;481    
;;;482    /**
;;;483      * @brief  Disable Clock stretching.
;;;484      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;485      * @rmtoll CR1          NOSTRETCH     LL_I2C_DisableClockStretching
;;;486      * @param  I2Cx I2C Instance.
;;;487      * @retval None
;;;488      */
;;;489    __STATIC_INLINE void LL_I2C_DisableClockStretching(I2C_TypeDef *I2Cx)
;;;490    {
;;;491      SET_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH);
;;;492    }
;;;493    
;;;494    /**
;;;495      * @brief  Check if Clock stretching is enabled or disabled.
;;;496      * @rmtoll CR1          NOSTRETCH     LL_I2C_IsEnabledClockStretching
;;;497      * @param  I2Cx I2C Instance.
;;;498      * @retval State of bit (1 or 0).
;;;499      */
;;;500    __STATIC_INLINE uint32_t LL_I2C_IsEnabledClockStretching(I2C_TypeDef *I2Cx)
;;;501    {
;;;502      return (READ_BIT(I2Cx->CR1, I2C_CR1_NOSTRETCH) != (I2C_CR1_NOSTRETCH));
;;;503    }
;;;504    
;;;505    /**
;;;506      * @brief  Enable General Call.
;;;507      * @note   When enabled the Address 0x00 is ACKed.
;;;508      * @rmtoll CR1          ENGC          LL_I2C_EnableGeneralCall
;;;509      * @param  I2Cx I2C Instance.
;;;510      * @retval None
;;;511      */
;;;512    __STATIC_INLINE void LL_I2C_EnableGeneralCall(I2C_TypeDef *I2Cx)
;;;513    {
;;;514      SET_BIT(I2Cx->CR1, I2C_CR1_ENGC);
;;;515    }
;;;516    
;;;517    /**
;;;518      * @brief  Disable General Call.
;;;519      * @note   When disabled the Address 0x00 is NACKed.
;;;520      * @rmtoll CR1          ENGC          LL_I2C_DisableGeneralCall
;;;521      * @param  I2Cx I2C Instance.
;;;522      * @retval None
;;;523      */
;;;524    __STATIC_INLINE void LL_I2C_DisableGeneralCall(I2C_TypeDef *I2Cx)
;;;525    {
;;;526      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENGC);
;;;527    }
;;;528    
;;;529    /**
;;;530      * @brief  Check if General Call is enabled or disabled.
;;;531      * @rmtoll CR1          ENGC          LL_I2C_IsEnabledGeneralCall
;;;532      * @param  I2Cx I2C Instance.
;;;533      * @retval State of bit (1 or 0).
;;;534      */
;;;535    __STATIC_INLINE uint32_t LL_I2C_IsEnabledGeneralCall(I2C_TypeDef *I2Cx)
;;;536    {
;;;537      return (READ_BIT(I2Cx->CR1, I2C_CR1_ENGC) == (I2C_CR1_ENGC));
;;;538    }
;;;539    
;;;540    /**
;;;541      * @brief  Set the Own Address1.
;;;542      * @rmtoll OAR1         ADD0          LL_I2C_SetOwnAddress1\n
;;;543      *         OAR1         ADD1_7        LL_I2C_SetOwnAddress1\n
;;;544      *         OAR1         ADD8_9        LL_I2C_SetOwnAddress1\n
;;;545      *         OAR1         ADDMODE       LL_I2C_SetOwnAddress1
;;;546      * @param  I2Cx I2C Instance.
;;;547      * @param  OwnAddress1 This parameter must be a value between Min_Data=0 and Max_Data=0x3FF.
;;;548      * @param  OwnAddrSize This parameter can be one of the following values:
;;;549      *         @arg @ref LL_I2C_OWNADDRESS1_7BIT
;;;550      *         @arg @ref LL_I2C_OWNADDRESS1_10BIT
;;;551      * @retval None
;;;552      */
;;;553    __STATIC_INLINE void LL_I2C_SetOwnAddress1(I2C_TypeDef *I2Cx, uint32_t OwnAddress1, uint32_t OwnAddrSize)
;;;554    {
;;;555      MODIFY_REG(I2Cx->OAR1, I2C_OAR1_ADD0 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD8_9 | I2C_OAR1_ADDMODE, OwnAddress1 | OwnAddrSize);
;;;556    }
;;;557    
;;;558    /**
;;;559      * @brief  Set the 7bits Own Address2.
;;;560      * @note   This action has no effect if own address2 is enabled.
;;;561      * @rmtoll OAR2         ADD2          LL_I2C_SetOwnAddress2
;;;562      * @param  I2Cx I2C Instance.
;;;563      * @param  OwnAddress2 This parameter must be a value between Min_Data=0 and Max_Data=0x7F.
;;;564      * @retval None
;;;565      */
;;;566    __STATIC_INLINE void LL_I2C_SetOwnAddress2(I2C_TypeDef *I2Cx, uint32_t OwnAddress2)
;;;567    {
;;;568      MODIFY_REG(I2Cx->OAR2, I2C_OAR2_ADD2, OwnAddress2);
;;;569    }
;;;570    
;;;571    /**
;;;572      * @brief  Enable acknowledge on Own Address2 match address.
;;;573      * @rmtoll OAR2         ENDUAL        LL_I2C_EnableOwnAddress2
;;;574      * @param  I2Cx I2C Instance.
;;;575      * @retval None
;;;576      */
;;;577    __STATIC_INLINE void LL_I2C_EnableOwnAddress2(I2C_TypeDef *I2Cx)
;;;578    {
;;;579      SET_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
;;;580    }
;;;581    
;;;582    /**
;;;583      * @brief  Disable  acknowledge on Own Address2 match address.
;;;584      * @rmtoll OAR2         ENDUAL        LL_I2C_DisableOwnAddress2
;;;585      * @param  I2Cx I2C Instance.
;;;586      * @retval None
;;;587      */
;;;588    __STATIC_INLINE void LL_I2C_DisableOwnAddress2(I2C_TypeDef *I2Cx)
;;;589    {
;;;590      CLEAR_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL);
;;;591    }
;;;592    
;;;593    /**
;;;594      * @brief  Check if Own Address1 acknowledge is enabled or disabled.
;;;595      * @rmtoll OAR2         ENDUAL        LL_I2C_IsEnabledOwnAddress2
;;;596      * @param  I2Cx I2C Instance.
;;;597      * @retval State of bit (1 or 0).
;;;598      */
;;;599    __STATIC_INLINE uint32_t LL_I2C_IsEnabledOwnAddress2(I2C_TypeDef *I2Cx)
;;;600    {
;;;601      return (READ_BIT(I2Cx->OAR2, I2C_OAR2_ENDUAL) == (I2C_OAR2_ENDUAL));
;;;602    }
;;;603    
;;;604    /**
;;;605      * @brief  Configure the Peripheral clock frequency.
;;;606      * @rmtoll CR2          FREQ          LL_I2C_SetPeriphClock
;;;607      * @param  I2Cx I2C Instance.
;;;608      * @param  PeriphClock Peripheral Clock (in Hz)
;;;609      * @retval None
;;;610      */
;;;611    __STATIC_INLINE void LL_I2C_SetPeriphClock(I2C_TypeDef *I2Cx, uint32_t PeriphClock)
;;;612    {
;;;613      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock));
;;;614    }
;;;615    
;;;616    /**
;;;617      * @brief  Get the Peripheral clock frequency.
;;;618      * @rmtoll CR2          FREQ          LL_I2C_GetPeriphClock
;;;619      * @param  I2Cx I2C Instance.
;;;620      * @retval Value of Peripheral Clock (in Hz)
;;;621      */
;;;622    __STATIC_INLINE uint32_t LL_I2C_GetPeriphClock(I2C_TypeDef *I2Cx)
;;;623    {
;;;624      return (uint32_t)(__LL_I2C_FREQ_MHZ_TO_HZ(READ_BIT(I2Cx->CR2, I2C_CR2_FREQ)));
;;;625    }
;;;626    
;;;627    /**
;;;628      * @brief  Configure the Duty cycle (Fast mode only).
;;;629      * @rmtoll CCR          DUTY          LL_I2C_SetDutyCycle
;;;630      * @param  I2Cx I2C Instance.
;;;631      * @param  DutyCycle This parameter can be one of the following values:
;;;632      *         @arg @ref LL_I2C_DUTYCYCLE_2
;;;633      *         @arg @ref LL_I2C_DUTYCYCLE_16_9
;;;634      * @retval None
;;;635      */
;;;636    __STATIC_INLINE void LL_I2C_SetDutyCycle(I2C_TypeDef *I2Cx, uint32_t DutyCycle)
;;;637    {
;;;638      MODIFY_REG(I2Cx->CCR, I2C_CCR_DUTY, DutyCycle);
;;;639    }
;;;640    
;;;641    /**
;;;642      * @brief  Get the Duty cycle (Fast mode only).
;;;643      * @rmtoll CCR          DUTY          LL_I2C_GetDutyCycle
;;;644      * @param  I2Cx I2C Instance.
;;;645      * @retval Returned value can be one of the following values:
;;;646      *         @arg @ref LL_I2C_DUTYCYCLE_2
;;;647      *         @arg @ref LL_I2C_DUTYCYCLE_16_9
;;;648      */
;;;649    __STATIC_INLINE uint32_t LL_I2C_GetDutyCycle(I2C_TypeDef *I2Cx)
;;;650    {
;;;651      return (uint32_t)(READ_BIT(I2Cx->CCR, I2C_CCR_DUTY));
;;;652    }
;;;653    
;;;654    /**
;;;655      * @brief  Configure the I2C master clock speed mode.
;;;656      * @rmtoll CCR          FS            LL_I2C_SetClockSpeedMode
;;;657      * @param  I2Cx I2C Instance.
;;;658      * @param  ClockSpeedMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_I2C_CLOCK_SPEED_STANDARD_MODE
;;;660      *         @arg @ref LL_I2C_CLOCK_SPEED_FAST_MODE
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_I2C_SetClockSpeedMode(I2C_TypeDef *I2Cx, uint32_t ClockSpeedMode)
;;;664    {
;;;665      MODIFY_REG(I2Cx->CCR, I2C_CCR_FS, ClockSpeedMode);
;;;666    }
;;;667    
;;;668    /**
;;;669      * @brief  Get the the I2C master speed mode.
;;;670      * @rmtoll CCR          FS            LL_I2C_GetClockSpeedMode
;;;671      * @param  I2Cx I2C Instance.
;;;672      * @retval Returned value can be one of the following values:
;;;673      *         @arg @ref LL_I2C_CLOCK_SPEED_STANDARD_MODE
;;;674      *         @arg @ref LL_I2C_CLOCK_SPEED_FAST_MODE
;;;675      */
;;;676    __STATIC_INLINE uint32_t LL_I2C_GetClockSpeedMode(I2C_TypeDef *I2Cx)
;;;677    {
;;;678      return (uint32_t)(READ_BIT(I2Cx->CCR, I2C_CCR_FS));
;;;679    }
;;;680    
;;;681    /**
;;;682      * @brief  Configure the SCL, SDA rising time.
;;;683      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;684      * @rmtoll TRISE        TRISE         LL_I2C_SetRiseTime
;;;685      * @param  I2Cx I2C Instance.
;;;686      * @param  RiseTime This parameter must be a value between Min_Data=0x02 and Max_Data=0x3F.
;;;687      * @retval None
;;;688      */
;;;689    __STATIC_INLINE void LL_I2C_SetRiseTime(I2C_TypeDef *I2Cx, uint32_t RiseTime)
;;;690    {
;;;691      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, RiseTime);
;;;692    }
;;;693    
;;;694    /**
;;;695      * @brief  Get the SCL, SDA rising time.
;;;696      * @rmtoll TRISE        TRISE         LL_I2C_GetRiseTime
;;;697      * @param  I2Cx I2C Instance.
;;;698      * @retval Value between Min_Data=0x02 and Max_Data=0x3F
;;;699      */
;;;700    __STATIC_INLINE uint32_t LL_I2C_GetRiseTime(I2C_TypeDef *I2Cx)
;;;701    {
;;;702      return (uint32_t)(READ_BIT(I2Cx->TRISE, I2C_TRISE_TRISE));
;;;703    }
;;;704    
;;;705    /**
;;;706      * @brief  Configure the SCL high and low period.
;;;707      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;708      * @rmtoll CCR          CCR           LL_I2C_SetClockPeriod
;;;709      * @param  I2Cx I2C Instance.
;;;710      * @param  ClockPeriod This parameter must be a value between Min_Data=0x004 and Max_Data=0xFFF, except in FAST DUTY mode where Min_Data=0x001.
;;;711      * @retval None
;;;712      */
;;;713    __STATIC_INLINE void LL_I2C_SetClockPeriod(I2C_TypeDef *I2Cx, uint32_t ClockPeriod)
;;;714    {
;;;715      MODIFY_REG(I2Cx->CCR, I2C_CCR_CCR, ClockPeriod);
;;;716    }
;;;717    
;;;718    /**
;;;719      * @brief  Get the SCL high and low period.
;;;720      * @rmtoll CCR          CCR           LL_I2C_GetClockPeriod
;;;721      * @param  I2Cx I2C Instance.
;;;722      * @retval Value between Min_Data=0x004 and Max_Data=0xFFF, except in FAST DUTY mode where Min_Data=0x001.
;;;723      */
;;;724    __STATIC_INLINE uint32_t LL_I2C_GetClockPeriod(I2C_TypeDef *I2Cx)
;;;725    {
;;;726      return (uint32_t)(READ_BIT(I2Cx->CCR, I2C_CCR_CCR));
;;;727    }
;;;728    
;;;729    /**
;;;730      * @brief  Configure the SCL speed.
;;;731      * @note   This bit can only be programmed when the I2C is disabled (PE = 0).
;;;732      * @rmtoll CR2          FREQ          LL_I2C_ConfigSpeed\n
;;;733      *         TRISE        TRISE         LL_I2C_ConfigSpeed\n
;;;734      *         CCR          FS            LL_I2C_ConfigSpeed\n
;;;735      *         CCR          DUTY          LL_I2C_ConfigSpeed\n
;;;736      *         CCR          CCR           LL_I2C_ConfigSpeed
;;;737      * @param  I2Cx I2C Instance.
;;;738      * @param  PeriphClock Peripheral Clock (in Hz)
;;;739      * @param  ClockSpeed This parameter must be a value lower than 400kHz (in Hz).
;;;740      * @param  DutyCycle This parameter can be one of the following values:
;;;741      *         @arg @ref LL_I2C_DUTYCYCLE_2
;;;742      *         @arg @ref LL_I2C_DUTYCYCLE_16_9
;;;743      * @retval None
;;;744      */
;;;745    __STATIC_INLINE void LL_I2C_ConfigSpeed(I2C_TypeDef *I2Cx, uint32_t PeriphClock, uint32_t ClockSpeed,
;;;746                                            uint32_t DutyCycle)
;;;747    {
;;;748      register uint32_t freqrange = 0x0U;
;;;749      register uint32_t clockconfig = 0x0U;
;;;750    
;;;751      /* Compute frequency range */
;;;752      freqrange = __LL_I2C_FREQ_HZ_TO_MHZ(PeriphClock);
;;;753    
;;;754      /* Configure I2Cx: Frequency range register */
;;;755      MODIFY_REG(I2Cx->CR2, I2C_CR2_FREQ, freqrange);
;;;756    
;;;757      /* Configure I2Cx: Rise Time register */
;;;758      MODIFY_REG(I2Cx->TRISE, I2C_TRISE_TRISE, __LL_I2C_RISE_TIME(freqrange, ClockSpeed));
;;;759    
;;;760      /* Configure Speed mode, Duty Cycle and Clock control register value */
;;;761      if (ClockSpeed > LL_I2C_MAX_SPEED_STANDARD)
;;;762      {
;;;763        /* Set Speed mode at fast and duty cycle for Clock Speed request in fast clock range */
;;;764        clockconfig = LL_I2C_CLOCK_SPEED_FAST_MODE                                          | \
;;;765                      __LL_I2C_SPEED_FAST_TO_CCR(PeriphClock, ClockSpeed, DutyCycle)        | \
;;;766                      DutyCycle;
;;;767      }
;;;768      else
;;;769      {
;;;770        /* Set Speed mode at standard for Clock Speed request in standard clock range */
;;;771        clockconfig = LL_I2C_CLOCK_SPEED_STANDARD_MODE                                      | \
;;;772                      __LL_I2C_SPEED_STANDARD_TO_CCR(PeriphClock, ClockSpeed);
;;;773      }
;;;774    
;;;775      /* Configure I2Cx: Clock control register */
;;;776      MODIFY_REG(I2Cx->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), clockconfig);
;;;777    }
;;;778    
;;;779    /**
;;;780      * @brief  Configure peripheral mode.
;;;781      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;782      *         SMBus feature is supported by the I2Cx Instance.
;;;783      * @rmtoll CR1          SMBUS         LL_I2C_SetMode\n
;;;784      *         CR1          SMBTYPE       LL_I2C_SetMode\n
;;;785      *         CR1          ENARP         LL_I2C_SetMode
;;;786      * @param  I2Cx I2C Instance.
;;;787      * @param  PeripheralMode This parameter can be one of the following values:
;;;788      *         @arg @ref LL_I2C_MODE_I2C
;;;789      *         @arg @ref LL_I2C_MODE_SMBUS_HOST
;;;790      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
;;;791      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
;;;792      * @retval None
;;;793      */
;;;794    __STATIC_INLINE void LL_I2C_SetMode(I2C_TypeDef *I2Cx, uint32_t PeripheralMode)
;;;795    {
;;;796      MODIFY_REG(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP, PeripheralMode);
;;;797    }
;;;798    
;;;799    /**
;;;800      * @brief  Get peripheral mode.
;;;801      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;802      *         SMBus feature is supported by the I2Cx Instance.
;;;803      * @rmtoll CR1          SMBUS         LL_I2C_GetMode\n
;;;804      *         CR1          SMBTYPE       LL_I2C_GetMode\n
;;;805      *         CR1          ENARP         LL_I2C_GetMode
;;;806      * @param  I2Cx I2C Instance.
;;;807      * @retval Returned value can be one of the following values:
;;;808      *         @arg @ref LL_I2C_MODE_I2C
;;;809      *         @arg @ref LL_I2C_MODE_SMBUS_HOST
;;;810      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE
;;;811      *         @arg @ref LL_I2C_MODE_SMBUS_DEVICE_ARP
;;;812      */
;;;813    __STATIC_INLINE uint32_t LL_I2C_GetMode(I2C_TypeDef *I2Cx)
;;;814    {
;;;815      return (uint32_t)(READ_BIT(I2Cx->CR1, I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_ENARP));
;;;816    }
;;;817    
;;;818    /**
;;;819      * @brief  Enable SMBus alert (Host or Device mode)
;;;820      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;821      *         SMBus feature is supported by the I2Cx Instance.
;;;822      * @note   SMBus Device mode:
;;;823      *         - SMBus Alert pin is drived low and
;;;824      *           Alert Response Address Header acknowledge is enabled.
;;;825      *         SMBus Host mode:
;;;826      *         - SMBus Alert pin management is supported.
;;;827      * @rmtoll CR1          ALERT         LL_I2C_EnableSMBusAlert
;;;828      * @param  I2Cx I2C Instance.
;;;829      * @retval None
;;;830      */
;;;831    __STATIC_INLINE void LL_I2C_EnableSMBusAlert(I2C_TypeDef *I2Cx)
;;;832    {
;;;833      SET_BIT(I2Cx->CR1, I2C_CR1_ALERT);
;;;834    }
;;;835    
;;;836    /**
;;;837      * @brief  Disable SMBus alert (Host or Device mode)
;;;838      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;839      *         SMBus feature is supported by the I2Cx Instance.
;;;840      * @note   SMBus Device mode:
;;;841      *         - SMBus Alert pin is not drived (can be used as a standard GPIO) and
;;;842      *           Alert Response Address Header acknowledge is disabled.
;;;843      *         SMBus Host mode:
;;;844      *         - SMBus Alert pin management is not supported.
;;;845      * @rmtoll CR1          ALERT         LL_I2C_DisableSMBusAlert
;;;846      * @param  I2Cx I2C Instance.
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_I2C_DisableSMBusAlert(I2C_TypeDef *I2Cx)
;;;850    {
;;;851      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ALERT);
;;;852    }
;;;853    
;;;854    /**
;;;855      * @brief  Check if SMBus alert (Host or Device mode) is enabled or disabled.
;;;856      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;857      *         SMBus feature is supported by the I2Cx Instance.
;;;858      * @rmtoll CR1          ALERT         LL_I2C_IsEnabledSMBusAlert
;;;859      * @param  I2Cx I2C Instance.
;;;860      * @retval State of bit (1 or 0).
;;;861      */
;;;862    __STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusAlert(I2C_TypeDef *I2Cx)
;;;863    {
;;;864      return (READ_BIT(I2Cx->CR1, I2C_CR1_ALERT) == (I2C_CR1_ALERT));
;;;865    }
;;;866    
;;;867    /**
;;;868      * @brief  Enable SMBus Packet Error Calculation (PEC).
;;;869      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;870      *         SMBus feature is supported by the I2Cx Instance.
;;;871      * @rmtoll CR1          ENPEC         LL_I2C_EnableSMBusPEC
;;;872      * @param  I2Cx I2C Instance.
;;;873      * @retval None
;;;874      */
;;;875    __STATIC_INLINE void LL_I2C_EnableSMBusPEC(I2C_TypeDef *I2Cx)
;;;876    {
;;;877      SET_BIT(I2Cx->CR1, I2C_CR1_ENPEC);
;;;878    }
;;;879    
;;;880    /**
;;;881      * @brief  Disable SMBus Packet Error Calculation (PEC).
;;;882      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;883      *         SMBus feature is supported by the I2Cx Instance.
;;;884      * @rmtoll CR1          ENPEC         LL_I2C_DisableSMBusPEC
;;;885      * @param  I2Cx I2C Instance.
;;;886      * @retval None
;;;887      */
;;;888    __STATIC_INLINE void LL_I2C_DisableSMBusPEC(I2C_TypeDef *I2Cx)
;;;889    {
;;;890      CLEAR_BIT(I2Cx->CR1, I2C_CR1_ENPEC);
;;;891    }
;;;892    
;;;893    /**
;;;894      * @brief  Check if SMBus Packet Error Calculation (PEC) is enabled or disabled.
;;;895      * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;896      *         SMBus feature is supported by the I2Cx Instance.
;;;897      * @rmtoll CR1          ENPEC         LL_I2C_IsEnabledSMBusPEC
;;;898      * @param  I2Cx I2C Instance.
;;;899      * @retval State of bit (1 or 0).
;;;900      */
;;;901    __STATIC_INLINE uint32_t LL_I2C_IsEnabledSMBusPEC(I2C_TypeDef *I2Cx)
;;;902    {
;;;903      return (READ_BIT(I2Cx->CR1, I2C_CR1_ENPEC) == (I2C_CR1_ENPEC));
;;;904    }
;;;905    
;;;906    /**
;;;907      * @}
;;;908      */
;;;909    
;;;910    /** @defgroup I2C_LL_EF_IT_Management IT_Management
;;;911      * @{
;;;912      */
;;;913    
;;;914    /**
;;;915      * @brief  Enable TXE interrupt.
;;;916      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_TX\n
;;;917      *         CR2          ITBUFEN       LL_I2C_EnableIT_TX
;;;918      * @param  I2Cx I2C Instance.
;;;919      * @retval None
;;;920      */
;;;921    __STATIC_INLINE void LL_I2C_EnableIT_TX(I2C_TypeDef *I2Cx)
;;;922    {
;;;923      SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;924    }
;;;925    
;;;926    /**
;;;927      * @brief  Disable TXE interrupt.
;;;928      * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_TX\n
;;;929      *         CR2          ITBUFEN       LL_I2C_DisableIT_TX
;;;930      * @param  I2Cx I2C Instance.
;;;931      * @retval None
;;;932      */
;;;933    __STATIC_INLINE void LL_I2C_DisableIT_TX(I2C_TypeDef *I2Cx)
;;;934    {
;;;935      CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;936    }
;;;937    
;;;938    /**
;;;939      * @brief  Check if the TXE Interrupt is enabled or disabled.
;;;940      * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_TX\n
;;;941      *         CR2          ITBUFEN       LL_I2C_IsEnabledIT_TX
;;;942      * @param  I2Cx I2C Instance.
;;;943      * @retval State of bit (1 or 0).
;;;944      */
;;;945    __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_TX(I2C_TypeDef *I2Cx)
;;;946    {
;;;947      return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN) == (I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN));
;;;948    }
;;;949    
;;;950    /**
;;;951      * @brief  Enable RXNE interrupt.
;;;952      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_RX\n
;;;953      *         CR2          ITBUFEN       LL_I2C_EnableIT_RX
;;;954      * @param  I2Cx I2C Instance.
;;;955      * @retval None
;;;956      */
;;;957    __STATIC_INLINE void LL_I2C_EnableIT_RX(I2C_TypeDef *I2Cx)
;;;958    {
;;;959      SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;960    }
;;;961    
;;;962    /**
;;;963      * @brief  Disable RXNE interrupt.
;;;964      * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_RX\n
;;;965      *         CR2          ITBUFEN       LL_I2C_DisableIT_RX
;;;966      * @param  I2Cx I2C Instance.
;;;967      * @retval None
;;;968      */
;;;969    __STATIC_INLINE void LL_I2C_DisableIT_RX(I2C_TypeDef *I2Cx)
;;;970    {
;;;971      CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);
;;;972    }
;;;973    
;;;974    /**
;;;975      * @brief  Check if the RXNE Interrupt is enabled or disabled.
;;;976      * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_RX\n
;;;977      *         CR2          ITBUFEN       LL_I2C_IsEnabledIT_RX
;;;978      * @param  I2Cx I2C Instance.
;;;979      * @retval State of bit (1 or 0).
;;;980      */
;;;981    __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_RX(I2C_TypeDef *I2Cx)
;;;982    {
;;;983      return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN) == (I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN));
;;;984    }
;;;985    
;;;986    /**
;;;987      * @brief  Enable Events interrupts.
;;;988      * @note   Any of these events will generate interrupt :
;;;989      *         Start Bit (SB)
;;;990      *         Address sent, Address matched (ADDR)
;;;991      *         10-bit header sent (ADD10)
;;;992      *         Stop detection  (STOPF)
;;;993      *         Byte transfer finished (BTF)
;;;994      *
;;;995      * @note   Any of these events will generate interrupt if Buffer interrupts are enabled too(using unitary function @ref LL_I2C_EnableIT_BUF()) :
;;;996      *         Receive buffer not empty (RXNE)
;;;997      *         Transmit buffer empty (TXE)
;;;998      * @rmtoll CR2          ITEVTEN       LL_I2C_EnableIT_EVT
;;;999      * @param  I2Cx I2C Instance.
;;;1000     * @retval None
;;;1001     */
;;;1002   __STATIC_INLINE void LL_I2C_EnableIT_EVT(I2C_TypeDef *I2Cx)
;;;1003   {
;;;1004     SET_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
;;;1005   }
;;;1006   
;;;1007   /**
;;;1008     * @brief  Disable Events interrupts.
;;;1009     * @note   Any of these events will generate interrupt :
;;;1010     *         Start Bit (SB)
;;;1011     *         Address sent, Address matched (ADDR)
;;;1012     *         10-bit header sent (ADD10)
;;;1013     *         Stop detection  (STOPF)
;;;1014     *         Byte transfer finished (BTF)
;;;1015     *         Receive buffer not empty (RXNE)
;;;1016     *         Transmit buffer empty (TXE)
;;;1017     * @rmtoll CR2          ITEVTEN       LL_I2C_DisableIT_EVT
;;;1018     * @param  I2Cx I2C Instance.
;;;1019     * @retval None
;;;1020     */
;;;1021   __STATIC_INLINE void LL_I2C_DisableIT_EVT(I2C_TypeDef *I2Cx)
;;;1022   {
;;;1023     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN);
;;;1024   }
;;;1025   
;;;1026   /**
;;;1027     * @brief  Check if Events interrupts are enabled or disabled.
;;;1028     * @rmtoll CR2          ITEVTEN       LL_I2C_IsEnabledIT_EVT
;;;1029     * @param  I2Cx I2C Instance.
;;;1030     * @retval State of bit (1 or 0).
;;;1031     */
;;;1032   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_EVT(I2C_TypeDef *I2Cx)
;;;1033   {
;;;1034     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITEVTEN) == (I2C_CR2_ITEVTEN));
;;;1035   }
;;;1036   
;;;1037   /**
;;;1038     * @brief  Enable Buffer interrupts.
;;;1039     * @note   Any of these Buffer events will generate interrupt if Events interrupts are enabled too(using unitary function @ref LL_I2C_EnableIT_EVT()) :
;;;1040     *         Receive buffer not empty (RXNE)
;;;1041     *         Transmit buffer empty (TXE)
;;;1042     * @rmtoll CR2          ITBUFEN       LL_I2C_EnableIT_BUF
;;;1043     * @param  I2Cx I2C Instance.
;;;1044     * @retval None
;;;1045     */
;;;1046   __STATIC_INLINE void LL_I2C_EnableIT_BUF(I2C_TypeDef *I2Cx)
;;;1047   {
;;;1048     SET_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN);
;;;1049   }
;;;1050   
;;;1051   /**
;;;1052     * @brief  Disable Buffer interrupts.
;;;1053     * @note   Any of these Buffer events will generate interrupt :
;;;1054     *         Receive buffer not empty (RXNE)
;;;1055     *         Transmit buffer empty (TXE)
;;;1056     * @rmtoll CR2          ITBUFEN       LL_I2C_DisableIT_BUF
;;;1057     * @param  I2Cx I2C Instance.
;;;1058     * @retval None
;;;1059     */
;;;1060   __STATIC_INLINE void LL_I2C_DisableIT_BUF(I2C_TypeDef *I2Cx)
;;;1061   {
;;;1062     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN);
;;;1063   }
;;;1064   
;;;1065   /**
;;;1066     * @brief  Check if Buffer interrupts are enabled or disabled.
;;;1067     * @rmtoll CR2          ITBUFEN       LL_I2C_IsEnabledIT_BUF
;;;1068     * @param  I2Cx I2C Instance.
;;;1069     * @retval State of bit (1 or 0).
;;;1070     */
;;;1071   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_BUF(I2C_TypeDef *I2Cx)
;;;1072   {
;;;1073     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITBUFEN) == (I2C_CR2_ITBUFEN));
;;;1074   }
;;;1075   
;;;1076   /**
;;;1077     * @brief  Enable Error interrupts.
;;;1078     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1079     *         SMBus feature is supported by the I2Cx Instance.
;;;1080     * @note   Any of these errors will generate interrupt :
;;;1081     *         Bus Error detection (BERR)
;;;1082     *         Arbitration Loss (ARLO)
;;;1083     *         Acknowledge Failure(AF)
;;;1084     *         Overrun/Underrun (OVR)
;;;1085     *         SMBus Timeout detection (TIMEOUT)
;;;1086     *         SMBus PEC error detection (PECERR)
;;;1087     *         SMBus Alert pin event detection (SMBALERT)
;;;1088     * @rmtoll CR2          ITERREN       LL_I2C_EnableIT_ERR
;;;1089     * @param  I2Cx I2C Instance.
;;;1090     * @retval None
;;;1091     */
;;;1092   __STATIC_INLINE void LL_I2C_EnableIT_ERR(I2C_TypeDef *I2Cx)
;;;1093   {
;;;1094     SET_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
;;;1095   }
;;;1096   
;;;1097   /**
;;;1098     * @brief  Disable Error interrupts.
;;;1099     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1100     *         SMBus feature is supported by the I2Cx Instance.
;;;1101     * @note   Any of these errors will generate interrupt :
;;;1102     *         Bus Error detection (BERR)
;;;1103     *         Arbitration Loss (ARLO)
;;;1104     *         Acknowledge Failure(AF)
;;;1105     *         Overrun/Underrun (OVR)
;;;1106     *         SMBus Timeout detection (TIMEOUT)
;;;1107     *         SMBus PEC error detection (PECERR)
;;;1108     *         SMBus Alert pin event detection (SMBALERT)
;;;1109     * @rmtoll CR2          ITERREN       LL_I2C_DisableIT_ERR
;;;1110     * @param  I2Cx I2C Instance.
;;;1111     * @retval None
;;;1112     */
;;;1113   __STATIC_INLINE void LL_I2C_DisableIT_ERR(I2C_TypeDef *I2Cx)
;;;1114   {
;;;1115     CLEAR_BIT(I2Cx->CR2, I2C_CR2_ITERREN);
;;;1116   }
;;;1117   
;;;1118   /**
;;;1119     * @brief  Check if Error interrupts are enabled or disabled.
;;;1120     * @rmtoll CR2          ITERREN       LL_I2C_IsEnabledIT_ERR
;;;1121     * @param  I2Cx I2C Instance.
;;;1122     * @retval State of bit (1 or 0).
;;;1123     */
;;;1124   __STATIC_INLINE uint32_t LL_I2C_IsEnabledIT_ERR(I2C_TypeDef *I2Cx)
;;;1125   {
;;;1126     return (READ_BIT(I2Cx->CR2, I2C_CR2_ITERREN) == (I2C_CR2_ITERREN));
;;;1127   }
;;;1128   
;;;1129   /**
;;;1130     * @}
;;;1131     */
;;;1132   
;;;1133   /** @defgroup I2C_LL_EF_FLAG_management FLAG_management
;;;1134     * @{
;;;1135     */
;;;1136   
;;;1137   /**
;;;1138     * @brief  Indicate the status of Transmit data register empty flag.
;;;1139     * @note   RESET: When next data is written in Transmit data register.
;;;1140     *         SET: When Transmit data register is empty.
;;;1141     * @rmtoll SR1          TXE           LL_I2C_IsActiveFlag_TXE
;;;1142     * @param  I2Cx I2C Instance.
;;;1143     * @retval State of bit (1 or 0).
;;;1144     */
;;;1145   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_TXE(I2C_TypeDef *I2Cx)
;;;1146   {
;;;1147     return (READ_BIT(I2Cx->SR1, I2C_SR1_TXE) == (I2C_SR1_TXE));
;;;1148   }
;;;1149   
;;;1150   /**
;;;1151     * @brief  Indicate the status of Byte Transfer Finished flag.
;;;1152     *         RESET: When Data byte transfer not done.
;;;1153     *         SET: When Data byte transfer succeeded.
;;;1154     * @rmtoll SR1          BTF           LL_I2C_IsActiveFlag_BTF
;;;1155     * @param  I2Cx I2C Instance.
;;;1156     * @retval State of bit (1 or 0).
;;;1157     */
;;;1158   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BTF(I2C_TypeDef *I2Cx)
;;;1159   {
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
;;;1161   }
;;;1162   
;;;1163   /**
;;;1164     * @brief  Indicate the status of Receive data register not empty flag.
;;;1165     * @note   RESET: When Receive data register is read.
;;;1166     *         SET: When the received data is copied in Receive data register.
;;;1167     * @rmtoll SR1          RXNE          LL_I2C_IsActiveFlag_RXNE
;;;1168     * @param  I2Cx I2C Instance.
;;;1169     * @retval State of bit (1 or 0).
;;;1170     */
;;;1171   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_RXNE(I2C_TypeDef *I2Cx)
;;;1172   {
;;;1173     return (READ_BIT(I2Cx->SR1, I2C_SR1_RXNE) == (I2C_SR1_RXNE));
;;;1174   }
;;;1175   
;;;1176   /**
;;;1177     * @brief  Indicate the status of Start Bit (master mode).
;;;1178     * @note   RESET: When No Start condition.
;;;1179     *         SET: When Start condition is generated.
;;;1180     * @rmtoll SR1          SB            LL_I2C_IsActiveFlag_SB
;;;1181     * @param  I2Cx I2C Instance.
;;;1182     * @retval State of bit (1 or 0).
;;;1183     */
;;;1184   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_SB(I2C_TypeDef *I2Cx)
;;;1185   {
;;;1186     return (READ_BIT(I2Cx->SR1, I2C_SR1_SB) == (I2C_SR1_SB));
;;;1187   }
;;;1188   
;;;1189   /**
;;;1190     * @brief  Indicate the status of Address sent (master mode) or Address matched flag (slave mode).
;;;1191     * @note   RESET: Clear default value.
;;;1192     *         SET: When the address is fully sent (master mode) or when the received slave address matched with one of the enabled slave address (slave mode).
;;;1193     * @rmtoll SR1          ADDR          LL_I2C_IsActiveFlag_ADDR
;;;1194     * @param  I2Cx I2C Instance.
;;;1195     * @retval State of bit (1 or 0).
;;;1196     */
;;;1197   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADDR(I2C_TypeDef *I2Cx)
;;;1198   {
;;;1199     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADDR) == (I2C_SR1_ADDR));
;;;1200   }
;;;1201   
;;;1202   /**
;;;1203     * @brief  Indicate the status of 10-bit header sent (master mode).
;;;1204     * @note   RESET: When no ADD10 event occured.
;;;1205     *         SET: When the master has sent the first address byte (header).
;;;1206     * @rmtoll SR1          ADD10         LL_I2C_IsActiveFlag_ADD10
;;;1207     * @param  I2Cx I2C Instance.
;;;1208     * @retval State of bit (1 or 0).
;;;1209     */
;;;1210   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ADD10(I2C_TypeDef *I2Cx)
;;;1211   {
;;;1212     return (READ_BIT(I2Cx->SR1, I2C_SR1_ADD10) == (I2C_SR1_ADD10));
;;;1213   }
;;;1214   
;;;1215   /**
;;;1216     * @brief  Indicate the status of Acknowledge failure flag.
;;;1217     * @note   RESET: No acknowledge failure.
;;;1218     *         SET: When an acknowledge failure is received after a byte transmission.
;;;1219     * @rmtoll SR1          AF            LL_I2C_IsActiveFlag_AF
;;;1220     * @param  I2Cx I2C Instance.
;;;1221     * @retval State of bit (1 or 0).
;;;1222     */
;;;1223   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_AF(I2C_TypeDef *I2Cx)
;;;1224   {
;;;1225     return (READ_BIT(I2Cx->SR1, I2C_SR1_AF) == (I2C_SR1_AF));
;;;1226   }
;;;1227   
;;;1228   /**
;;;1229     * @brief  Indicate the status of Stop detection flag (slave mode).
;;;1230     * @note   RESET: Clear default value.
;;;1231     *         SET: When a Stop condition is detected.
;;;1232     * @rmtoll SR1          STOPF         LL_I2C_IsActiveFlag_STOP
;;;1233     * @param  I2Cx I2C Instance.
;;;1234     * @retval State of bit (1 or 0).
;;;1235     */
;;;1236   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_STOP(I2C_TypeDef *I2Cx)
;;;1237   {
;;;1238     return (READ_BIT(I2Cx->SR1, I2C_SR1_STOPF) == (I2C_SR1_STOPF));
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Indicate the status of Bus error flag.
;;;1243     * @note   RESET: Clear default value.
;;;1244     *         SET: When a misplaced Start or Stop condition is detected.
;;;1245     * @rmtoll SR1          BERR          LL_I2C_IsActiveFlag_BERR
;;;1246     * @param  I2Cx I2C Instance.
;;;1247     * @retval State of bit (1 or 0).
;;;1248     */
;;;1249   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BERR(I2C_TypeDef *I2Cx)
;;;1250   {
;;;1251     return (READ_BIT(I2Cx->SR1, I2C_SR1_BERR) == (I2C_SR1_BERR));
;;;1252   }
;;;1253   
;;;1254   /**
;;;1255     * @brief  Indicate the status of Arbitration lost flag.
;;;1256     * @note   RESET: Clear default value.
;;;1257     *         SET: When arbitration lost.
;;;1258     * @rmtoll SR1          ARLO          LL_I2C_IsActiveFlag_ARLO
;;;1259     * @param  I2Cx I2C Instance.
;;;1260     * @retval State of bit (1 or 0).
;;;1261     */
;;;1262   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_ARLO(I2C_TypeDef *I2Cx)
;;;1263   {
;;;1264     return (READ_BIT(I2Cx->SR1, I2C_SR1_ARLO) == (I2C_SR1_ARLO));
;;;1265   }
;;;1266   
;;;1267   /**
;;;1268     * @brief  Indicate the status of Overrun/Underrun flag.
;;;1269     * @note   RESET: Clear default value.
;;;1270     *         SET: When an overrun/underrun error occurs (Clock Stretching Disabled).
;;;1271     * @rmtoll SR1          OVR           LL_I2C_IsActiveFlag_OVR
;;;1272     * @param  I2Cx I2C Instance.
;;;1273     * @retval State of bit (1 or 0).
;;;1274     */
;;;1275   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_OVR(I2C_TypeDef *I2Cx)
;;;1276   {
;;;1277     return (READ_BIT(I2Cx->SR1, I2C_SR1_OVR) == (I2C_SR1_OVR));
;;;1278   }
;;;1279   
;;;1280   /**
;;;1281     * @brief  Indicate the status of SMBus PEC error flag in reception.
;;;1282     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1283     *         SMBus feature is supported by the I2Cx Instance.
;;;1284     * @rmtoll SR1          PECERR        LL_I2C_IsActiveSMBusFlag_PECERR
;;;1285     * @param  I2Cx I2C Instance.
;;;1286     * @retval State of bit (1 or 0).
;;;1287     */
;;;1288   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_PECERR(I2C_TypeDef *I2Cx)
;;;1289   {
;;;1290     return (READ_BIT(I2Cx->SR1, I2C_SR1_PECERR) == (I2C_SR1_PECERR));
;;;1291   }
;;;1292   
;;;1293   /**
;;;1294     * @brief  Indicate the status of SMBus Timeout detection flag.
;;;1295     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1296     *         SMBus feature is supported by the I2Cx Instance.
;;;1297     * @rmtoll SR1          TIMEOUT       LL_I2C_IsActiveSMBusFlag_TIMEOUT
;;;1298     * @param  I2Cx I2C Instance.
;;;1299     * @retval State of bit (1 or 0).
;;;1300     */
;;;1301   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_TIMEOUT(I2C_TypeDef *I2Cx)
;;;1302   {
;;;1303     return (READ_BIT(I2Cx->SR1, I2C_SR1_TIMEOUT) == (I2C_SR1_TIMEOUT));
;;;1304   }
;;;1305   
;;;1306   /**
;;;1307     * @brief  Indicate the status of SMBus alert flag.
;;;1308     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1309     *         SMBus feature is supported by the I2Cx Instance.
;;;1310     * @rmtoll SR1          SMBALERT      LL_I2C_IsActiveSMBusFlag_ALERT
;;;1311     * @param  I2Cx I2C Instance.
;;;1312     * @retval State of bit (1 or 0).
;;;1313     */
;;;1314   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_ALERT(I2C_TypeDef *I2Cx)
;;;1315   {
;;;1316     return (READ_BIT(I2Cx->SR1, I2C_SR1_SMBALERT) == (I2C_SR1_SMBALERT));
;;;1317   }
;;;1318   
;;;1319   /**
;;;1320     * @brief  Indicate the status of Bus Busy flag.
;;;1321     * @note   RESET: Clear default value.
;;;1322     *         SET: When a Start condition is detected.
;;;1323     * @rmtoll SR2          BUSY          LL_I2C_IsActiveFlag_BUSY
;;;1324     * @param  I2Cx I2C Instance.
;;;1325     * @retval State of bit (1 or 0).
;;;1326     */
;;;1327   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_BUSY(I2C_TypeDef *I2Cx)
;;;1328   {
;;;1329     return (READ_BIT(I2Cx->SR2, I2C_SR2_BUSY) == (I2C_SR2_BUSY));
;;;1330   }
;;;1331   
;;;1332   /**
;;;1333     * @brief  Indicate the status of Dual flag.
;;;1334     * @note   RESET: Received address matched with OAR1.
;;;1335     *         SET: Received address matched with OAR2.
;;;1336     * @rmtoll SR2          DUALF         LL_I2C_IsActiveFlag_DUAL
;;;1337     * @param  I2Cx I2C Instance.
;;;1338     * @retval State of bit (1 or 0).
;;;1339     */
;;;1340   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_DUAL(I2C_TypeDef *I2Cx)
;;;1341   {
;;;1342     return (READ_BIT(I2Cx->SR2, I2C_SR2_DUALF) == (I2C_SR2_DUALF));
;;;1343   }
;;;1344   
;;;1345   /**
;;;1346     * @brief  Indicate the status of SMBus Host address reception (Slave mode).
;;;1347     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1348     *         SMBus feature is supported by the I2Cx Instance.
;;;1349     * @note   RESET: No SMBus Host address
;;;1350     *         SET: SMBus Host address received.
;;;1351     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1352     * @rmtoll SR2          SMBHOST       LL_I2C_IsActiveSMBusFlag_SMBHOST
;;;1353     * @param  I2Cx I2C Instance.
;;;1354     * @retval State of bit (1 or 0).
;;;1355     */
;;;1356   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_SMBHOST(I2C_TypeDef *I2Cx)
;;;1357   {
;;;1358     return (READ_BIT(I2Cx->SR2, I2C_SR2_SMBHOST) == (I2C_SR2_SMBHOST));
;;;1359   }
;;;1360   
;;;1361   /**
;;;1362     * @brief  Indicate the status of SMBus Device default address reception (Slave mode).
;;;1363     * @note   Macro @ref IS_SMBUS_ALL_INSTANCE(I2Cx) can be used to check whether or not
;;;1364     *         SMBus feature is supported by the I2Cx Instance.
;;;1365     * @note   RESET: No SMBus Device default address
;;;1366     *         SET: SMBus Device default address received.
;;;1367     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1368     * @rmtoll SR2          SMBDEFAULT    LL_I2C_IsActiveSMBusFlag_SMBDEFAULT
;;;1369     * @param  I2Cx I2C Instance.
;;;1370     * @retval State of bit (1 or 0).
;;;1371     */
;;;1372   __STATIC_INLINE uint32_t LL_I2C_IsActiveSMBusFlag_SMBDEFAULT(I2C_TypeDef *I2Cx)
;;;1373   {
;;;1374     return (READ_BIT(I2Cx->SR2, I2C_SR2_SMBDEFAULT) == (I2C_SR2_SMBDEFAULT));
;;;1375   }
;;;1376   
;;;1377   /**
;;;1378     * @brief  Indicate the status of General call address reception (Slave mode).
;;;1379     * @note   RESET: No Generall call address
;;;1380     *         SET: General call address received.
;;;1381     * @note   This status is cleared by hardware after a STOP condition or repeated START condition.
;;;1382     * @rmtoll SR2          GENCALL       LL_I2C_IsActiveFlag_GENCALL
;;;1383     * @param  I2Cx I2C Instance.
;;;1384     * @retval State of bit (1 or 0).
;;;1385     */
;;;1386   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_GENCALL(I2C_TypeDef *I2Cx)
;;;1387   {
;;;1388     return (READ_BIT(I2Cx->SR2, I2C_SR2_GENCALL) == (I2C_SR2_GENCALL));
;;;1389   }
;;;1390   
;;;1391   /**
;;;1392     * @brief  Indicate the status of Master/Slave flag.
;;;1393     * @note   RESET: Slave Mode.
;;;1394     *         SET: Master Mode.
;;;1395     * @rmtoll SR2          MSL           LL_I2C_IsActiveFlag_MSL
;;;1396     * @param  I2Cx I2C Instance.
;;;1397     * @retval State of bit (1 or 0).
;;;1398     */
;;;1399   __STATIC_INLINE uint32_t LL_I2C_IsActiveFlag_MSL(I2C_TypeDef *I2Cx)
;;;1400   {
;;;1401     return (READ_BIT(I2Cx->SR2, I2C_SR2_MSL) == (I2C_SR2_MSL));
;;;1402   }
;;;1403   
;;;1404   /**
;;;1405     * @brief  Clear Address Matched flag.
;;;1406     * @note   Clearing this flag is done by a read access to the I2Cx_SR1
;;;1407     *         register followed by a read access to the I2Cx_SR2 register.
;;;1408     * @rmtoll SR1          ADDR          LL_I2C_ClearFlag_ADDR
;;;1409     * @param  I2Cx I2C Instance.
;;;1410     * @retval None
;;;1411     */
;;;1412   __STATIC_INLINE void LL_I2C_ClearFlag_ADDR(I2C_TypeDef *I2Cx)
;;;1413   {
;;;1414     __IO uint32_t tmpreg;
;;;1415     tmpreg = I2Cx->SR1;
        0x0800033e:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08000340:    9100        ..      STR      r1,[sp,#0]
;;;1416     (void) tmpreg;
;;;1417     tmpreg = I2Cx->SR2;
        0x08000342:    6980        .i      LDR      r0,[r0,#0x18]
        0x08000344:    9000        ..      STR      r0,[sp,#0]
;;; .\../Src/stm32f1xx_it.c
;;;366    }
        0x08000346:    bd08        ..      POP      {r3,pc}
    $d
        0x08000348:    40005800    .X.@    DCD    1073764352
    $t
    i.LL_APB1_GRP1_EnableClock
    LL_APB1_GRP1_EnableClock
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;464    {
        0x0800034c:    b508        ..      PUSH     {r3,lr}
;;;465      __IO uint32_t tmpreg;
;;;466      SET_BIT(RCC->APB1ENR, Periphs);
        0x0800034e:    4904        .I      LDR      r1,[pc,#16] ; [0x8000360] = 0x40021000
        0x08000350:    69ca        .i      LDR      r2,[r1,#0x1c]
        0x08000352:    4302        .C      ORRS     r2,r2,r0
        0x08000354:    61ca        .a      STR      r2,[r1,#0x1c]
;;;467      /* Delay after an RCC peripheral clock enabling */
;;;468      tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
        0x08000356:    69c9        .i      LDR      r1,[r1,#0x1c]
        0x08000358:    4001        .@      ANDS     r1,r1,r0
        0x0800035a:    9100        ..      STR      r1,[sp,#0]
;;;469      (void)tmpreg;
;;;470    }
        0x0800035c:    bd08        ..      POP      {r3,pc}
    $d
        0x0800035e:    0000        ..      DCW    0
        0x08000360:    40021000    ...@    DCD    1073876992
    $t
    i.LL_APB2_GRP1_EnableClock
    LL_APB2_GRP1_EnableClock
;;;471    
;;;472    /**
;;;473      * @brief  Check if APB1 peripheral clock is enabled or not
;;;474      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_IsEnabledClock\n
;;;475      *         APB1ENR      CAN1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;476      *         APB1ENR      CAN2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;477      *         APB1ENR      CECEN         LL_APB1_GRP1_IsEnabledClock\n
;;;478      *         APB1ENR      DACEN         LL_APB1_GRP1_IsEnabledClock\n
;;;479      *         APB1ENR      I2C1EN        LL_APB1_GRP1_IsEnabledClock\n
;;;480      *         APB1ENR      I2C2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;481      *         APB1ENR      PWREN         LL_APB1_GRP1_IsEnabledClock\n
;;;482      *         APB1ENR      SPI2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;483      *         APB1ENR      SPI3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;484      *         APB1ENR      TIM12EN       LL_APB1_GRP1_IsEnabledClock\n
;;;485      *         APB1ENR      TIM13EN       LL_APB1_GRP1_IsEnabledClock\n
;;;486      *         APB1ENR      TIM14EN       LL_APB1_GRP1_IsEnabledClock\n
;;;487      *         APB1ENR      TIM2EN        LL_APB1_GRP1_IsEnabledClock\n
;;;488      *         APB1ENR      TIM3EN        LL_APB1_GRP1_IsEnabledClock\n
;;;489      *         APB1ENR      TIM4EN        LL_APB1_GRP1_IsEnabledClock\n
;;;490      *         APB1ENR      TIM5EN        LL_APB1_GRP1_IsEnabledClock\n
;;;491      *         APB1ENR      TIM6EN        LL_APB1_GRP1_IsEnabledClock\n
;;;492      *         APB1ENR      TIM7EN        LL_APB1_GRP1_IsEnabledClock\n
;;;493      *         APB1ENR      UART4EN       LL_APB1_GRP1_IsEnabledClock\n
;;;494      *         APB1ENR      UART5EN       LL_APB1_GRP1_IsEnabledClock\n
;;;495      *         APB1ENR      USART2EN      LL_APB1_GRP1_IsEnabledClock\n
;;;496      *         APB1ENR      USART3EN      LL_APB1_GRP1_IsEnabledClock\n
;;;497      *         APB1ENR      USBEN         LL_APB1_GRP1_IsEnabledClock\n
;;;498      *         APB1ENR      WWDGEN        LL_APB1_GRP1_IsEnabledClock
;;;499      * @param  Periphs This parameter can be a combination of the following values:
;;;500      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;501      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;502      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;503      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;504      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;505      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;506      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;507      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;508      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;509      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;510      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;511      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;512      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;513      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;514      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;515      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;516      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;517      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;518      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;519      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;520      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;521      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;522      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;523      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;524      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;525      *
;;;526      *         (*) value not defined in all devices.
;;;527      * @retval State of Periphs (1 or 0).
;;;528    */
;;;529    __STATIC_INLINE uint32_t LL_APB1_GRP1_IsEnabledClock(uint32_t Periphs)
;;;530    {
;;;531      return (READ_BIT(RCC->APB1ENR, Periphs) == Periphs);
;;;532    }
;;;533    
;;;534    /**
;;;535      * @brief  Disable APB1 peripherals clock.
;;;536      * @rmtoll APB1ENR      BKPEN         LL_APB1_GRP1_DisableClock\n
;;;537      *         APB1ENR      CAN1EN        LL_APB1_GRP1_DisableClock\n
;;;538      *         APB1ENR      CAN2EN        LL_APB1_GRP1_DisableClock\n
;;;539      *         APB1ENR      CECEN         LL_APB1_GRP1_DisableClock\n
;;;540      *         APB1ENR      DACEN         LL_APB1_GRP1_DisableClock\n
;;;541      *         APB1ENR      I2C1EN        LL_APB1_GRP1_DisableClock\n
;;;542      *         APB1ENR      I2C2EN        LL_APB1_GRP1_DisableClock\n
;;;543      *         APB1ENR      PWREN         LL_APB1_GRP1_DisableClock\n
;;;544      *         APB1ENR      SPI2EN        LL_APB1_GRP1_DisableClock\n
;;;545      *         APB1ENR      SPI3EN        LL_APB1_GRP1_DisableClock\n
;;;546      *         APB1ENR      TIM12EN       LL_APB1_GRP1_DisableClock\n
;;;547      *         APB1ENR      TIM13EN       LL_APB1_GRP1_DisableClock\n
;;;548      *         APB1ENR      TIM14EN       LL_APB1_GRP1_DisableClock\n
;;;549      *         APB1ENR      TIM2EN        LL_APB1_GRP1_DisableClock\n
;;;550      *         APB1ENR      TIM3EN        LL_APB1_GRP1_DisableClock\n
;;;551      *         APB1ENR      TIM4EN        LL_APB1_GRP1_DisableClock\n
;;;552      *         APB1ENR      TIM5EN        LL_APB1_GRP1_DisableClock\n
;;;553      *         APB1ENR      TIM6EN        LL_APB1_GRP1_DisableClock\n
;;;554      *         APB1ENR      TIM7EN        LL_APB1_GRP1_DisableClock\n
;;;555      *         APB1ENR      UART4EN       LL_APB1_GRP1_DisableClock\n
;;;556      *         APB1ENR      UART5EN       LL_APB1_GRP1_DisableClock\n
;;;557      *         APB1ENR      USART2EN      LL_APB1_GRP1_DisableClock\n
;;;558      *         APB1ENR      USART3EN      LL_APB1_GRP1_DisableClock\n
;;;559      *         APB1ENR      USBEN         LL_APB1_GRP1_DisableClock\n
;;;560      *         APB1ENR      WWDGEN        LL_APB1_GRP1_DisableClock
;;;561      * @param  Periphs This parameter can be a combination of the following values:
;;;562      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;563      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;564      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;565      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;566      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;567      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;568      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;569      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;570      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;571      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;572      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;573      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;574      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;575      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;576      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;577      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;578      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;579      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;580      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;581      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;582      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;583      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;584      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;585      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;586      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;587      *
;;;588      *         (*) value not defined in all devices.
;;;589      * @retval None
;;;590    */
;;;591    __STATIC_INLINE void LL_APB1_GRP1_DisableClock(uint32_t Periphs)
;;;592    {
;;;593      CLEAR_BIT(RCC->APB1ENR, Periphs);
;;;594    }
;;;595    
;;;596    /**
;;;597      * @brief  Force APB1 peripherals reset.
;;;598      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ForceReset\n
;;;599      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ForceReset\n
;;;600      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ForceReset\n
;;;601      *         APB1RSTR     CECRST        LL_APB1_GRP1_ForceReset\n
;;;602      *         APB1RSTR     DACRST        LL_APB1_GRP1_ForceReset\n
;;;603      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ForceReset\n
;;;604      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ForceReset\n
;;;605      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ForceReset\n
;;;606      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ForceReset\n
;;;607      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ForceReset\n
;;;608      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ForceReset\n
;;;609      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ForceReset\n
;;;610      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ForceReset\n
;;;611      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ForceReset\n
;;;612      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ForceReset\n
;;;613      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ForceReset\n
;;;614      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ForceReset\n
;;;615      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ForceReset\n
;;;616      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ForceReset\n
;;;617      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ForceReset\n
;;;618      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ForceReset\n
;;;619      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ForceReset\n
;;;620      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ForceReset\n
;;;621      *         APB1RSTR     USBRST        LL_APB1_GRP1_ForceReset\n
;;;622      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ForceReset
;;;623      * @param  Periphs This parameter can be a combination of the following values:
;;;624      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;625      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;626      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;627      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;628      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;629      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;630      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;631      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;632      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;633      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;634      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;635      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;636      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;637      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;638      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;639      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;640      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;641      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;642      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;643      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;644      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;645      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;646      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;647      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;648      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;649      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;650      *
;;;651      *         (*) value not defined in all devices.
;;;652      * @retval None
;;;653    */
;;;654    __STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
;;;655    {
;;;656      SET_BIT(RCC->APB1RSTR, Periphs);
;;;657    }
;;;658    
;;;659    /**
;;;660      * @brief  Release APB1 peripherals reset.
;;;661      * @rmtoll APB1RSTR     BKPRST        LL_APB1_GRP1_ReleaseReset\n
;;;662      *         APB1RSTR     CAN1RST       LL_APB1_GRP1_ReleaseReset\n
;;;663      *         APB1RSTR     CAN2RST       LL_APB1_GRP1_ReleaseReset\n
;;;664      *         APB1RSTR     CECRST        LL_APB1_GRP1_ReleaseReset\n
;;;665      *         APB1RSTR     DACRST        LL_APB1_GRP1_ReleaseReset\n
;;;666      *         APB1RSTR     I2C1RST       LL_APB1_GRP1_ReleaseReset\n
;;;667      *         APB1RSTR     I2C2RST       LL_APB1_GRP1_ReleaseReset\n
;;;668      *         APB1RSTR     PWRRST        LL_APB1_GRP1_ReleaseReset\n
;;;669      *         APB1RSTR     SPI2RST       LL_APB1_GRP1_ReleaseReset\n
;;;670      *         APB1RSTR     SPI3RST       LL_APB1_GRP1_ReleaseReset\n
;;;671      *         APB1RSTR     TIM12RST      LL_APB1_GRP1_ReleaseReset\n
;;;672      *         APB1RSTR     TIM13RST      LL_APB1_GRP1_ReleaseReset\n
;;;673      *         APB1RSTR     TIM14RST      LL_APB1_GRP1_ReleaseReset\n
;;;674      *         APB1RSTR     TIM2RST       LL_APB1_GRP1_ReleaseReset\n
;;;675      *         APB1RSTR     TIM3RST       LL_APB1_GRP1_ReleaseReset\n
;;;676      *         APB1RSTR     TIM4RST       LL_APB1_GRP1_ReleaseReset\n
;;;677      *         APB1RSTR     TIM5RST       LL_APB1_GRP1_ReleaseReset\n
;;;678      *         APB1RSTR     TIM6RST       LL_APB1_GRP1_ReleaseReset\n
;;;679      *         APB1RSTR     TIM7RST       LL_APB1_GRP1_ReleaseReset\n
;;;680      *         APB1RSTR     UART4RST      LL_APB1_GRP1_ReleaseReset\n
;;;681      *         APB1RSTR     UART5RST      LL_APB1_GRP1_ReleaseReset\n
;;;682      *         APB1RSTR     USART2RST     LL_APB1_GRP1_ReleaseReset\n
;;;683      *         APB1RSTR     USART3RST     LL_APB1_GRP1_ReleaseReset\n
;;;684      *         APB1RSTR     USBRST        LL_APB1_GRP1_ReleaseReset\n
;;;685      *         APB1RSTR     WWDGRST       LL_APB1_GRP1_ReleaseReset
;;;686      * @param  Periphs This parameter can be a combination of the following values:
;;;687      *         @arg @ref LL_APB1_GRP1_PERIPH_ALL
;;;688      *         @arg @ref LL_APB1_GRP1_PERIPH_BKP
;;;689      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN1 (*)
;;;690      *         @arg @ref LL_APB1_GRP1_PERIPH_CAN2 (*)
;;;691      *         @arg @ref LL_APB1_GRP1_PERIPH_CEC (*)
;;;692      *         @arg @ref LL_APB1_GRP1_PERIPH_DAC1 (*)
;;;693      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C1
;;;694      *         @arg @ref LL_APB1_GRP1_PERIPH_I2C2 (*)
;;;695      *         @arg @ref LL_APB1_GRP1_PERIPH_PWR
;;;696      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI2 (*)
;;;697      *         @arg @ref LL_APB1_GRP1_PERIPH_SPI3 (*)
;;;698      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM12 (*)
;;;699      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM13 (*)
;;;700      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM14 (*)
;;;701      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM2
;;;702      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM3
;;;703      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM4 (*)
;;;704      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM5 (*)
;;;705      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM6 (*)
;;;706      *         @arg @ref LL_APB1_GRP1_PERIPH_TIM7 (*)
;;;707      *         @arg @ref LL_APB1_GRP1_PERIPH_UART4 (*)
;;;708      *         @arg @ref LL_APB1_GRP1_PERIPH_UART5 (*)
;;;709      *         @arg @ref LL_APB1_GRP1_PERIPH_USART2
;;;710      *         @arg @ref LL_APB1_GRP1_PERIPH_USART3 (*)
;;;711      *         @arg @ref LL_APB1_GRP1_PERIPH_USB (*)
;;;712      *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
;;;713      *
;;;714      *         (*) value not defined in all devices.
;;;715      * @retval None
;;;716    */
;;;717    __STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
;;;718    {
;;;719      CLEAR_BIT(RCC->APB1RSTR, Periphs);
;;;720    }
;;;721    
;;;722    /**
;;;723      * @}
;;;724      */
;;;725    
;;;726    /** @defgroup BUS_LL_EF_APB2 APB2
;;;727      * @{
;;;728      */
;;;729    
;;;730    /**
;;;731      * @brief  Enable APB2 peripherals clock.
;;;732      * @rmtoll APB2ENR      ADC1EN        LL_APB2_GRP1_EnableClock\n
;;;733      *         APB2ENR      ADC2EN        LL_APB2_GRP1_EnableClock\n
;;;734      *         APB2ENR      ADC3EN        LL_APB2_GRP1_EnableClock\n
;;;735      *         APB2ENR      AFIOEN        LL_APB2_GRP1_EnableClock\n
;;;736      *         APB2ENR      IOPAEN        LL_APB2_GRP1_EnableClock\n
;;;737      *         APB2ENR      IOPBEN        LL_APB2_GRP1_EnableClock\n
;;;738      *         APB2ENR      IOPCEN        LL_APB2_GRP1_EnableClock\n
;;;739      *         APB2ENR      IOPDEN        LL_APB2_GRP1_EnableClock\n
;;;740      *         APB2ENR      IOPEEN        LL_APB2_GRP1_EnableClock\n
;;;741      *         APB2ENR      IOPFEN        LL_APB2_GRP1_EnableClock\n
;;;742      *         APB2ENR      IOPGEN        LL_APB2_GRP1_EnableClock\n
;;;743      *         APB2ENR      SPI1EN        LL_APB2_GRP1_EnableClock\n
;;;744      *         APB2ENR      TIM10EN       LL_APB2_GRP1_EnableClock\n
;;;745      *         APB2ENR      TIM11EN       LL_APB2_GRP1_EnableClock\n
;;;746      *         APB2ENR      TIM15EN       LL_APB2_GRP1_EnableClock\n
;;;747      *         APB2ENR      TIM16EN       LL_APB2_GRP1_EnableClock\n
;;;748      *         APB2ENR      TIM17EN       LL_APB2_GRP1_EnableClock\n
;;;749      *         APB2ENR      TIM1EN        LL_APB2_GRP1_EnableClock\n
;;;750      *         APB2ENR      TIM8EN        LL_APB2_GRP1_EnableClock\n
;;;751      *         APB2ENR      TIM9EN        LL_APB2_GRP1_EnableClock\n
;;;752      *         APB2ENR      USART1EN      LL_APB2_GRP1_EnableClock
;;;753      * @param  Periphs This parameter can be a combination of the following values:
;;;754      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC1
;;;755      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC2 (*)
;;;756      *         @arg @ref LL_APB2_GRP1_PERIPH_ADC3 (*)
;;;757      *         @arg @ref LL_APB2_GRP1_PERIPH_AFIO
;;;758      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOA
;;;759      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOB
;;;760      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOC
;;;761      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOD
;;;762      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOE (*)
;;;763      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOF (*)
;;;764      *         @arg @ref LL_APB2_GRP1_PERIPH_GPIOG (*)
;;;765      *         @arg @ref LL_APB2_GRP1_PERIPH_SPI1
;;;766      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM10 (*)
;;;767      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM11 (*)
;;;768      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM15 (*)
;;;769      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM16 (*)
;;;770      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17 (*)
;;;771      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM1
;;;772      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM8 (*)
;;;773      *         @arg @ref LL_APB2_GRP1_PERIPH_TIM9 (*)
;;;774      *         @arg @ref LL_APB2_GRP1_PERIPH_USART1
;;;775      *
;;;776      *         (*) value not defined in all devices.
;;;777      * @retval None
;;;778    */
;;;779    __STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
;;;780    {
        0x08000364:    b508        ..      PUSH     {r3,lr}
;;;781      __IO uint32_t tmpreg;
;;;782      SET_BIT(RCC->APB2ENR, Periphs);
        0x08000366:    4904        .I      LDR      r1,[pc,#16] ; [0x8000378] = 0x40021000
        0x08000368:    698a        .i      LDR      r2,[r1,#0x18]
        0x0800036a:    4302        .C      ORRS     r2,r2,r0
        0x0800036c:    618a        .a      STR      r2,[r1,#0x18]
;;;783      /* Delay after an RCC peripheral clock enabling */
;;;784      tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
        0x0800036e:    6989        .i      LDR      r1,[r1,#0x18]
        0x08000370:    4001        .@      ANDS     r1,r1,r0
        0x08000372:    9100        ..      STR      r1,[sp,#0]
;;;785      (void)tmpreg;
;;;786    }
        0x08000374:    bd08        ..      POP      {r3,pc}
    $d
        0x08000376:    0000        ..      DCW    0
        0x08000378:    40021000    ...@    DCD    1073876992
    $t
    i.LL_DMA_SetChannelPriorityLevel
    LL_DMA_SetChannelPriorityLevel
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
        0x0800037c:    4b04        .K      LDR      r3,[pc,#16] ; [0x8000390] = 0x8001f47
        0x0800037e:    4419        .D      ADD      r1,r1,r3
        0x08000380:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x08000384:    5843        CX      LDR      r3,[r0,r1]
        0x08000386:    f4235340    #.@S    BIC      r3,r3,#0x3000
        0x0800038a:    4313        .C      ORRS     r3,r3,r2
        0x0800038c:    5043        CP      STR      r3,[r0,r1]
;;;852                 Priority);
;;;853    }
        0x0800038e:    4770        pG      BX       lr
    $d
        0x08000390:    08001f47    G...    DCD    134225735
    $t
    i.LL_DMA_SetDataTransferDirection
    LL_DMA_SetDataTransferDirection
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (570)
        0x08000394:    b510        ..      PUSH     {r4,lr}
;;;571      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
        0x08000396:    4b05        .K      LDR      r3,[pc,#20] ; [0x80003ac] = 0x8001f47
        0x08000398:    4419        .D      ADD      r1,r1,r3
        0x0800039a:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x0800039e:    5843        CX      LDR      r3,[r0,r1]
        0x080003a0:    f2440410    D...    MOV      r4,#0x4010
        0x080003a4:    43a3        .C      BICS     r3,r3,r4
        0x080003a6:    4313        .C      ORRS     r3,r3,r2
        0x080003a8:    5043        CP      STR      r3,[r0,r1]
;;;572                 DMA_CCR_DIR | DMA_CCR_MEM2MEM, Direction);
;;;573    }
        0x080003aa:    bd10        ..      POP      {r4,pc}
    $d
        0x080003ac:    08001f47    G...    DCD    134225735
    $t
    i.LL_DMA_SetMemoryIncMode
    LL_DMA_SetMemoryIncMode
;;;574    
;;;575    /**
;;;576      * @brief  Get Data transfer direction (read from peripheral or from memory).
;;;577      * @rmtoll CCR          DIR           LL_DMA_GetDataTransferDirection\n
;;;578      *         CCR          MEM2MEM       LL_DMA_GetDataTransferDirection
;;;579      * @param  DMAx DMAx Instance
;;;580      * @param  Channel This parameter can be one of the following values:
;;;581      *         @arg @ref LL_DMA_CHANNEL_1
;;;582      *         @arg @ref LL_DMA_CHANNEL_2
;;;583      *         @arg @ref LL_DMA_CHANNEL_3
;;;584      *         @arg @ref LL_DMA_CHANNEL_4
;;;585      *         @arg @ref LL_DMA_CHANNEL_5
;;;586      *         @arg @ref LL_DMA_CHANNEL_6
;;;587      *         @arg @ref LL_DMA_CHANNEL_7
;;;588      * @retval Returned value can be one of the following values:
;;;589      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;590      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;591      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;592      */
;;;593    __STATIC_INLINE uint32_t LL_DMA_GetDataTransferDirection(DMA_TypeDef *DMAx, uint32_t Channel)
;;;594    {
;;;595      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;596                       DMA_CCR_DIR | DMA_CCR_MEM2MEM));
;;;597    }
;;;598    
;;;599    /**
;;;600      * @brief  Set DMA mode circular or normal.
;;;601      * @note The circular buffer mode cannot be used if the memory-to-memory
;;;602      * data transfer is configured on the selected Channel.
;;;603      * @rmtoll CCR          CIRC          LL_DMA_SetMode
;;;604      * @param  DMAx DMAx Instance
;;;605      * @param  Channel This parameter can be one of the following values:
;;;606      *         @arg @ref LL_DMA_CHANNEL_1
;;;607      *         @arg @ref LL_DMA_CHANNEL_2
;;;608      *         @arg @ref LL_DMA_CHANNEL_3
;;;609      *         @arg @ref LL_DMA_CHANNEL_4
;;;610      *         @arg @ref LL_DMA_CHANNEL_5
;;;611      *         @arg @ref LL_DMA_CHANNEL_6
;;;612      *         @arg @ref LL_DMA_CHANNEL_7
;;;613      * @param  Mode This parameter can be one of the following values:
;;;614      *         @arg @ref LL_DMA_MODE_NORMAL
;;;615      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;616      * @retval None
;;;617      */
;;;618    __STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
;;;619    {
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
;;;621                 Mode);
;;;622    }
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
        0x080003b0:    4b04        .K      LDR      r3,[pc,#16] ; [0x80003c4] = 0x8001f47
        0x080003b2:    4419        .D      ADD      r1,r1,r3
        0x080003b4:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x080003b8:    5843        CX      LDR      r3,[r0,r1]
        0x080003ba:    f0230380    #...    BIC      r3,r3,#0x80
        0x080003be:    4313        .C      ORRS     r3,r3,r2
        0x080003c0:    5043        CP      STR      r3,[r0,r1]
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
        0x080003c2:    4770        pG      BX       lr
    $d
        0x080003c4:    08001f47    G...    DCD    134225735
    $t
    i.LL_DMA_SetMemorySize
    LL_DMA_SetMemorySize
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
;;;759    
;;;760    /**
;;;761      * @brief  Get Peripheral size.
;;;762      * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
;;;763      * @param  DMAx DMAx Instance
;;;764      * @param  Channel This parameter can be one of the following values:
;;;765      *         @arg @ref LL_DMA_CHANNEL_1
;;;766      *         @arg @ref LL_DMA_CHANNEL_2
;;;767      *         @arg @ref LL_DMA_CHANNEL_3
;;;768      *         @arg @ref LL_DMA_CHANNEL_4
;;;769      *         @arg @ref LL_DMA_CHANNEL_5
;;;770      *         @arg @ref LL_DMA_CHANNEL_6
;;;771      *         @arg @ref LL_DMA_CHANNEL_7
;;;772      * @retval Returned value can be one of the following values:
;;;773      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;774      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;775      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;776      */
;;;777    __STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;778    {
;;;779      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;780                       DMA_CCR_PSIZE));
;;;781    }
;;;782    
;;;783    /**
;;;784      * @brief  Set Memory size.
;;;785      * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
;;;786      * @param  DMAx DMAx Instance
;;;787      * @param  Channel This parameter can be one of the following values:
;;;788      *         @arg @ref LL_DMA_CHANNEL_1
;;;789      *         @arg @ref LL_DMA_CHANNEL_2
;;;790      *         @arg @ref LL_DMA_CHANNEL_3
;;;791      *         @arg @ref LL_DMA_CHANNEL_4
;;;792      *         @arg @ref LL_DMA_CHANNEL_5
;;;793      *         @arg @ref LL_DMA_CHANNEL_6
;;;794      *         @arg @ref LL_DMA_CHANNEL_7
;;;795      * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
;;;796      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;797      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;798      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;799      * @retval None
;;;800      */
;;;801    __STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
;;;802    {
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
        0x080003c8:    4b04        .K      LDR      r3,[pc,#16] ; [0x80003dc] = 0x8001f47
        0x080003ca:    4419        .D      ADD      r1,r1,r3
        0x080003cc:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x080003d0:    5843        CX      LDR      r3,[r0,r1]
        0x080003d2:    f4236340    #.@c    BIC      r3,r3,#0xc00
        0x080003d6:    4313        .C      ORRS     r3,r3,r2
        0x080003d8:    5043        CP      STR      r3,[r0,r1]
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
        0x080003da:    4770        pG      BX       lr
    $d
        0x080003dc:    08001f47    G...    DCD    134225735
    $t
    i.LL_DMA_SetMode
    LL_DMA_SetMode
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (620)
        0x080003e0:    4b04        .K      LDR      r3,[pc,#16] ; [0x80003f4] = 0x8001f47
        0x080003e2:    4419        .D      ADD      r1,r1,r3
        0x080003e4:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x080003e8:    5843        CX      LDR      r3,[r0,r1]
        0x080003ea:    f0230320    #. .    BIC      r3,r3,#0x20
        0x080003ee:    4313        .C      ORRS     r3,r3,r2
        0x080003f0:    5043        CP      STR      r3,[r0,r1]
;;;621                 Mode);
;;;622    }
        0x080003f2:    4770        pG      BX       lr
    $d
        0x080003f4:    08001f47    G...    DCD    134225735
    $t
    i.LL_DMA_SetPeriphIncMode
    LL_DMA_SetPeriphIncMode
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
        0x080003f8:    4b04        .K      LDR      r3,[pc,#16] ; [0x800040c] = 0x8001f47
        0x080003fa:    4419        .D      ADD      r1,r1,r3
        0x080003fc:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x08000400:    5843        CX      LDR      r3,[r0,r1]
        0x08000402:    f0230340    #.@.    BIC      r3,r3,#0x40
        0x08000406:    4313        .C      ORRS     r3,r3,r2
        0x08000408:    5043        CP      STR      r3,[r0,r1]
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
        0x0800040a:    4770        pG      BX       lr
    $d
        0x0800040c:    08001f47    G...    DCD    134225735
    $t
    i.LL_DMA_SetPeriphSize
    LL_DMA_SetPeriphSize
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
        0x08000410:    4b04        .K      LDR      r3,[pc,#16] ; [0x8000424] = 0x8001f47
        0x08000412:    4419        .D      ADD      r1,r1,r3
        0x08000414:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x08000418:    5843        CX      LDR      r3,[r0,r1]
        0x0800041a:    f4237340    #.@s    BIC      r3,r3,#0x300
        0x0800041e:    4313        .C      ORRS     r3,r3,r2
        0x08000420:    5043        CP      STR      r3,[r0,r1]
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
        0x08000422:    4770        pG      BX       lr
    $d
        0x08000424:    08001f47    G...    DCD    134225735
    $t
    i.LL_GPIO_Init
    LL_GPIO_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;172    {
        0x08000428:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0800042c:    680a        .h      LDR      r2,[r1,#0]
        0x0800042e:    f3c2250f    ...%    UBFX     r5,r2,#8,#16
        0x08000432:    fa95f2a5    ....    RBIT     r2,r5
        0x08000436:    fab2f282    ....    CLZ      r2,r2
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c (172)
        0x0800043a:    e06b        k.      B        0x8000514 ; LL_GPIO_Init + 236
;;;173      uint32_t pinmask;
;;;174      uint32_t pinpos;
;;;175      uint32_t currentpin;
;;;176    
;;;177      /* Check the parameters */
;;;178      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;179      assert_param(IS_LL_GPIO_PIN(GPIO_InitStruct->Pin));
;;;180    
;;;181      /* ------------------------- Configure the port pins ---------------- */
;;;182      /* Initialize  pinpos on first pin set */
;;;183    
;;;184      pinmask = ((GPIO_InitStruct->Pin) << GPIO_PIN_MASK_POS) >> GPIO_PIN_NB;
;;;185      pinpos = POSITION_VAL(pinmask);
;;;186    
;;;187      /* Configure the port pins */
;;;188      while ((pinmask  >> pinpos) != 0U)
;;;189      {
;;;190        /* skip if bit is not set */
;;;191        if ((pinmask & (1U << pinpos)) != 0U)
        0x0800043c:    2301        .#      MOVS     r3,#1
        0x0800043e:    4093        .@      LSLS     r3,r3,r2
        0x08000440:    422b        +B      TST      r3,r5
        0x08000442:    d066        f.      BEQ      0x8000512 ; LL_GPIO_Init + 234
;;;192        {
;;;193          /* Get current io position */
;;;194          if (pinpos < GPIO_PIN_MASK_POS)
        0x08000444:    2a08        .*      CMP      r2,#8
        0x08000446:    d203        ..      BCS      0x8000450 ; LL_GPIO_Init + 40
;;;195          {
;;;196            currentpin = (0x00000101U << pinpos);
        0x08000448:    f2401301    @...    MOV      r3,#0x101
        0x0800044c:    4093        .@      LSLS     r3,r3,r2
        0x0800044e:    e006        ..      B        0x800045e ; LL_GPIO_Init + 54
;;;197          }
;;;198          else
;;;199          {
;;;200            currentpin = ((0x00010001U << (pinpos - GPIO_PIN_MASK_POS)) | 0x04000000U);
        0x08000450:    f1a20308    ....    SUB      r3,r2,#8
        0x08000454:    f04f1401    O...    MOV      r4,#0x10001
        0x08000458:    409c        .@      LSLS     r4,r4,r3
        0x0800045a:    f0446380    D..c    ORR      r3,r4,#0x4000000
;;;201          }
;;;202    
;;;203          /* Check Pin Mode and Pin Pull parameters */
;;;204          assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
;;;205          assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));
;;;206    
;;;207          /* Pin Mode configuration */
;;;208          LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
        0x0800045e:    684e        Nh      LDR      r6,[r1,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;360      register uint32_t *pReg = (uint32_t *)((uint32_t)(&GPIOx->CRL) + (Pin >> 24));
        0x08000460:    eb006413    ...d    ADD      r4,r0,r3,LSR #24
;;;361      MODIFY_REG(*pReg, ((GPIO_CRL_CNF0 | GPIO_CRL_MODE0) << (POSITION_VAL(Pin) * 4U)), (Mode << (POSITION_VAL(Pin) * 4U)));
        0x08000464:    fa93fca3    ....    RBIT     r12,r3
        0x08000468:    fabcfc8c    ....    CLZ      r12,r12
        0x0800046c:    ea4f088c    O...    LSL      r8,r12,#2
        0x08000470:    f04f0c0f    O...    MOV      r12,#0xf
        0x08000474:    6827        'h      LDR      r7,[r4,#0]
        0x08000476:    fa0cfc08    ....    LSL      r12,r12,r8
        0x0800047a:    ea27070c    '...    BIC      r7,r7,r12
        0x0800047e:    fa93fca3    ....    RBIT     r12,r3
        0x08000482:    fabcfc8c    ....    CLZ      r12,r12
        0x08000486:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x0800048a:    fa06f60c    ....    LSL      r6,r6,r12
        0x0800048e:    4337        7C      ORRS     r7,r7,r6
        0x08000490:    6027        '`      STR      r7,[r4,#0]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;211          LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
        0x08000492:    690e        .i      LDR      r6,[r1,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;583      MODIFY_REG(GPIOx->ODR, (Pin >> GPIO_PIN_MASK_POS), Pull << (POSITION_VAL(Pin >> GPIO_PIN_MASK_POS)));
        0x08000494:    68c7        .h      LDR      r7,[r0,#0xc]
        0x08000496:    ea4f2c13    O..,    LSR      r12,r3,#8
        0x0800049a:    fa9cfcac    ....    RBIT     r12,r12
        0x0800049e:    fabcfc8c    ....    CLZ      r12,r12
        0x080004a2:    ea272713    '..'    BIC      r7,r7,r3,LSR #8
        0x080004a6:    fa06f60c    ....    LSL      r6,r6,r12
        0x080004aa:    4337        7C      ORRS     r7,r7,r6
        0x080004ac:    60c7        .`      STR      r7,[r0,#0xc]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;213          if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
        0x080004ae:    684e        Nh      LDR      r6,[r1,#4]
        0x080004b0:    2e01        ..      CMP      r6,#1
        0x080004b2:    d001        ..      BEQ      0x80004b8 ; LL_GPIO_Init + 144
        0x080004b4:    2e09        ..      CMP      r6,#9
        0x080004b6:    d12c        ,.      BNE      0x8000512 ; LL_GPIO_Init + 234
;;;214          {
;;;215            /* Check speed and Output mode parameters */
;;;216            assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));
;;;217            assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));
;;;218    
;;;219            /* Speed mode configuration */
;;;220            LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
        0x080004b8:    688f        .h      LDR      r7,[r1,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;439      MODIFY_REG(*pReg, (GPIO_CRL_MODE0 << (POSITION_VAL(Pin) * 4U)),
        0x080004ba:    fa93fca3    ....    RBIT     r12,r3
        0x080004be:    fabcfc8c    ....    CLZ      r12,r12
        0x080004c2:    ea4f088c    O...    LSL      r8,r12,#2
        0x080004c6:    f04f0c03    O...    MOV      r12,#3
        0x080004ca:    6826        &h      LDR      r6,[r4,#0]
        0x080004cc:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080004d0:    ea26060c    &...    BIC      r6,r6,r12
        0x080004d4:    fa93fca3    ....    RBIT     r12,r3
        0x080004d8:    fabcfc8c    ....    CLZ      r12,r12
        0x080004dc:    ea4f0c8c    O...    LSL      r12,r12,#2
        0x080004e0:    fa07f70c    ....    LSL      r7,r7,r12
        0x080004e4:    433e        >C      ORRS     r6,r6,r7
        0x080004e6:    6026        &`      STR      r6,[r4,#0]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;223            LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
        0x080004e8:    68cf        .h      LDR      r7,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;513      MODIFY_REG(*pReg, (GPIO_CRL_CNF0_0 << (POSITION_VAL(Pin) * 4U)),
        0x080004ea:    fa93fca3    ....    RBIT     r12,r3
        0x080004ee:    fabcfc8c    ....    CLZ      r12,r12
        0x080004f2:    ea4f088c    O...    LSL      r8,r12,#2
        0x080004f6:    f04f0c04    O...    MOV      r12,#4
        0x080004fa:    fa0cfc08    ....    LSL      r12,r12,r8
        0x080004fe:    fa93f3a3    ....    RBIT     r3,r3
        0x08000502:    fab3f383    ....    CLZ      r3,r3
        0x08000506:    009b        ..      LSLS     r3,r3,#2
        0x08000508:    ea26060c    &...    BIC      r6,r6,r12
        0x0800050c:    409f        .@      LSLS     r7,r7,r3
        0x0800050e:    433e        >C      ORRS     r6,r6,r7
        0x08000510:    6026        &`      STR      r6,[r4,#0]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_gpio.c
;;;226        pinpos++;
        0x08000512:    1c52        R.      ADDS     r2,r2,#1
        0x08000514:    fa35f302    5...    LSRS     r3,r5,r2
        0x08000518:    d190        ..      BNE      0x800043c ; LL_GPIO_Init + 20
;;;227      }
;;;228      return (SUCCESS);
        0x0800051a:    2001        .       MOVS     r0,#1
;;;229    }
        0x0800051c:    e8bd81f0    ....    POP      {r4-r8,pc}
    i.LL_GPIO_IsInputPinSet
    LL_GPIO_IsInputPinSet
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08000520:    6880        .h      LDR      r0,[r0,#8]
        0x08000522:    0a09        ..      LSRS     r1,r1,#8
        0x08000524:    4381        .C      BICS     r1,r1,r0
        0x08000526:    0408        ..      LSLS     r0,r1,#16
        0x08000528:    0c00        ..      LSRS     r0,r0,#16
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h (740)
        0x0800052a:    d001        ..      BEQ      0x8000530 ; LL_GPIO_IsInputPinSet + 16
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x0800052c:    2000        .       MOVS     r0,#0
        0x0800052e:    4770        pG      BX       lr
        0x08000530:    2001        .       MOVS     r0,#1
;;;742    }
        0x08000532:    4770        pG      BX       lr
    i.LL_Init1msTick
    LL_Init1msTick
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;187      LL_InitTick(HCLKFrequency, 1000U);
        0x08000534:    f44f717a    O.zq    MOV      r1,#0x3e8
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_utils.h
;;;237      SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
        0x08000538:    fbb0f1f1    ....    UDIV     r1,r0,r1
        0x0800053c:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x08000540:    1e49        I.      SUBS     r1,r1,#1
        0x08000542:    6141        Aa      STR      r1,[r0,#0x14]
;;;238      SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
        0x08000544:    2100        .!      MOVS     r1,#0
        0x08000546:    6181        .a      STR      r1,[r0,#0x18]
;;;239      SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
        0x08000548:    2105        .!      MOVS     r1,#5
        0x0800054a:    6101        .a      STR      r1,[r0,#0x10]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;188    }
        0x0800054c:    4770        pG      BX       lr
    i.LL_RCC_GetSystemClocksFreq
    LL_RCC_GetSystemClocksFreq
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;206    {
        0x0800054e:    b500        ..      PUSH     {lr}
        0x08000550:    4603        .F      MOV      r3,r0
;;;207      /* Get SYSCLK frequency */
;;;208      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
        0x08000552:    f000fe8d    ....    BL       RCC_GetSystemClockFreq ; 0x8001270
        0x08000556:    6018        .`      STR      r0,[r3,#0]
;;;209    
;;;210      /* HCLK clock frequency */
;;;211      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
        0x08000558:    f000fe60    ..`.    BL       RCC_GetHCLKClockFreq ; 0x800121c
        0x0800055c:    6058        X`      STR      r0,[r3,#4]
;;;212    
;;;213      /* PCLK1 clock frequency */
;;;214      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x0800055e:    f000fe6b    ..k.    BL       RCC_GetPCLK1ClockFreq ; 0x8001238
        0x08000562:    6098        .`      STR      r0,[r3,#8]
;;;215    
;;;216      /* PCLK2 clock frequency */
;;;217      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
        0x08000564:    6858        Xh      LDR      r0,[r3,#4]
        0x08000566:    f000fe75    ..u.    BL       RCC_GetPCLK2ClockFreq ; 0x8001254
        0x0800056a:    60d8        .`      STR      r0,[r3,#0xc]
;;;218    }
        0x0800056c:    bd00        ..      POP      {pc}
        0x0800056e:    0000        ..      MOVS     r0,r0
    i.LL_SetSystemCoreClock
    LL_SetSystemCoreClock
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;261      SystemCoreClock = HCLKFrequency;
        0x08000570:    4901        .I      LDR      r1,[pc,#4] ; [0x8000578] = 0x20000000
        0x08000572:    6008        .`      STR      r0,[r1,#0]
;;;262    }
        0x08000574:    4770        pG      BX       lr
    $d
        0x08000576:    0000        ..      DCW    0
        0x08000578:    20000000    ...     DCD    536870912
    $t
    i.LL_TIM_BDTR_Init
    LL_TIM_BDTR_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;731      MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
        0x0800057c:    7b0a        .{      LDRB     r2,[r1,#0xc]
;;;732      MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
        0x0800057e:    688b        .h      LDR      r3,[r1,#8]
        0x08000580:    431a        .C      ORRS     r2,r2,r3
;;;733      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
        0x08000582:    684b        Kh      LDR      r3,[r1,#4]
        0x08000584:    f4226280    "..b    BIC      r2,r2,#0x400
        0x08000588:    431a        .C      ORRS     r2,r2,r3
;;;734      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
        0x0800058a:    680b        .h      LDR      r3,[r1,#0]
        0x0800058c:    f4226200    "..b    BIC      r2,r2,#0x800
        0x08000590:    431a        .C      ORRS     r2,r2,r3
;;;735      MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
        0x08000592:    89cb        ..      LDRH     r3,[r1,#0xe]
        0x08000594:    f4225280    "..R    BIC      r2,r2,#0x1000
        0x08000598:    431a        .C      ORRS     r2,r2,r3
;;;736      MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
        0x0800059a:    690b        .i      LDR      r3,[r1,#0x10]
        0x0800059c:    f4225200    "..R    BIC      r2,r2,#0x2000
        0x080005a0:    431a        .C      ORRS     r2,r2,r3
;;;737      MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x080005a2:    6949        Ii      LDR      r1,[r1,#0x14]
        0x080005a4:    f4224280    "..B    BIC      r2,r2,#0x4000
        0x080005a8:    430a        .C      ORRS     r2,r2,r1
;;;738      MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
        0x080005aa:    f4224200    "..B    BIC      r2,r2,#0x8000
        0x080005ae:    430a        .C      ORRS     r2,r2,r1
;;;739    
;;;740      /* Set TIMx_BDTR */
;;;741      LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
        0x080005b0:    6442        Bd      STR      r2,[r0,#0x44]
;;;742    
;;;743      return SUCCESS;
        0x080005b2:    2001        .       MOVS     r0,#1
;;;744    }
        0x080005b4:    4770        pG      BX       lr
        0x080005b6:    0000        ..      MOVS     r0,r0
    i.LL_TIM_IC_SetActiveInput
    LL_TIM_IC_SetActiveInput
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2164   {
        0x080005b8:    b510        ..      PUSH     {r4,lr}
        0x080005ba:    2901        .)      CMP      r1,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2164)
        0x080005bc:    d01c        ..      BEQ      0x80005f8 ; LL_TIM_IC_SetActiveInput + 64
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x080005be:    2904        .)      CMP      r1,#4
        0x080005c0:    d01c        ..      BEQ      0x80005fc ; LL_TIM_IC_SetActiveInput + 68
        0x080005c2:    2910        .)      CMP      r1,#0x10
        0x080005c4:    d01c        ..      BEQ      0x8000600 ; LL_TIM_IC_SetActiveInput + 72
        0x080005c6:    2940        @)      CMP      r1,#0x40
        0x080005c8:    d01c        ..      BEQ      0x8000604 ; LL_TIM_IC_SetActiveInput + 76
        0x080005ca:    f5b17f80    ....    CMP      r1,#0x100
        0x080005ce:    d01b        ..      BEQ      0x8000608 ; LL_TIM_IC_SetActiveInput + 80
        0x080005d0:    f5b16f80    ...o    CMP      r1,#0x400
        0x080005d4:    d01a        ..      BEQ      0x800060c ; LL_TIM_IC_SetActiveInput + 84
        0x080005d6:    2106        .!      MOVS     r1,#6
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x080005d8:    4b0d        .K      LDR      r3,[pc,#52] ; [0x8000610] = 0x8001f4e
        0x080005da:    3018        .0      ADDS     r0,r0,#0x18
        0x080005dc:    5c5b        [\      LDRB     r3,[r3,r1]
        0x080005de:    4418        .D      ADD      r0,r0,r3
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x080005e0:    4c0b        .L      LDR      r4,[pc,#44] ; [0x8000610] = 0x8001f4e
        0x080005e2:    6803        .h      LDR      r3,[r0,#0]
        0x080005e4:    340e        .4      ADDS     r4,r4,#0xe
        0x080005e6:    5c61        a\      LDRB     r1,[r4,r1]
        0x080005e8:    2403        .$      MOVS     r4,#3
        0x080005ea:    408c        .@      LSLS     r4,r4,r1
        0x080005ec:    0c12        ..      LSRS     r2,r2,#16
        0x080005ee:    43a3        .C      BICS     r3,r3,r4
        0x080005f0:    408a        .@      LSLS     r2,r2,r1
        0x080005f2:    4313        .C      ORRS     r3,r3,r2
        0x080005f4:    6003        .`      STR      r3,[r0,#0]
;;;2168   }
        0x080005f6:    bd10        ..      POP      {r4,pc}
        0x080005f8:    2100        .!      MOVS     r1,#0
        0x080005fa:    e7ed        ..      B        0x80005d8 ; LL_TIM_IC_SetActiveInput + 32
        0x080005fc:    2101        .!      MOVS     r1,#1
        0x080005fe:    e7eb        ..      B        0x80005d8 ; LL_TIM_IC_SetActiveInput + 32
        0x08000600:    2102        .!      MOVS     r1,#2
        0x08000602:    e7e9        ..      B        0x80005d8 ; LL_TIM_IC_SetActiveInput + 32
        0x08000604:    2103        .!      MOVS     r1,#3
        0x08000606:    e7e7        ..      B        0x80005d8 ; LL_TIM_IC_SetActiveInput + 32
        0x08000608:    2104        .!      MOVS     r1,#4
        0x0800060a:    e7e5        ..      B        0x80005d8 ; LL_TIM_IC_SetActiveInput + 32
        0x0800060c:    2105        .!      MOVS     r1,#5
        0x0800060e:    e7e3        ..      B        0x80005d8 ; LL_TIM_IC_SetActiveInput + 32
    $d
        0x08000610:    08001f4e    N...    DCD    134225742
    $t
    i.LL_TIM_IC_SetFilter
    LL_TIM_IC_SetFilter
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
        0x08000614:    b510        ..      PUSH     {r4,lr}
        0x08000616:    2901        .)      CMP      r1,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2277)
        0x08000618:    d01c        ..      BEQ      0x8000654 ; LL_TIM_IC_SetFilter + 64
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x0800061a:    2904        .)      CMP      r1,#4
        0x0800061c:    d01c        ..      BEQ      0x8000658 ; LL_TIM_IC_SetFilter + 68
        0x0800061e:    2910        .)      CMP      r1,#0x10
        0x08000620:    d01c        ..      BEQ      0x800065c ; LL_TIM_IC_SetFilter + 72
        0x08000622:    2940        @)      CMP      r1,#0x40
        0x08000624:    d01c        ..      BEQ      0x8000660 ; LL_TIM_IC_SetFilter + 76
        0x08000626:    f5b17f80    ....    CMP      r1,#0x100
        0x0800062a:    d01b        ..      BEQ      0x8000664 ; LL_TIM_IC_SetFilter + 80
        0x0800062c:    f5b16f80    ...o    CMP      r1,#0x400
        0x08000630:    d01a        ..      BEQ      0x8000668 ; LL_TIM_IC_SetFilter + 84
        0x08000632:    2106        .!      MOVS     r1,#6
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x08000634:    4b0d        .K      LDR      r3,[pc,#52] ; [0x800066c] = 0x8001f4e
        0x08000636:    3018        .0      ADDS     r0,r0,#0x18
        0x08000638:    5c5b        [\      LDRB     r3,[r3,r1]
        0x0800063a:    4418        .D      ADD      r0,r0,r3
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x0800063c:    4c0b        .L      LDR      r4,[pc,#44] ; [0x800066c] = 0x8001f4e
        0x0800063e:    6803        .h      LDR      r3,[r0,#0]
        0x08000640:    340e        .4      ADDS     r4,r4,#0xe
        0x08000642:    5c61        a\      LDRB     r1,[r4,r1]
        0x08000644:    24f0        .$      MOVS     r4,#0xf0
        0x08000646:    408c        .@      LSLS     r4,r4,r1
        0x08000648:    0c12        ..      LSRS     r2,r2,#16
        0x0800064a:    43a3        .C      BICS     r3,r3,r4
        0x0800064c:    408a        .@      LSLS     r2,r2,r1
        0x0800064e:    4313        .C      ORRS     r3,r3,r2
        0x08000650:    6003        .`      STR      r3,[r0,#0]
;;;2281   }
        0x08000652:    bd10        ..      POP      {r4,pc}
        0x08000654:    2100        .!      MOVS     r1,#0
        0x08000656:    e7ed        ..      B        0x8000634 ; LL_TIM_IC_SetFilter + 32
        0x08000658:    2101        .!      MOVS     r1,#1
        0x0800065a:    e7eb        ..      B        0x8000634 ; LL_TIM_IC_SetFilter + 32
        0x0800065c:    2102        .!      MOVS     r1,#2
        0x0800065e:    e7e9        ..      B        0x8000634 ; LL_TIM_IC_SetFilter + 32
        0x08000660:    2103        .!      MOVS     r1,#3
        0x08000662:    e7e7        ..      B        0x8000634 ; LL_TIM_IC_SetFilter + 32
        0x08000664:    2104        .!      MOVS     r1,#4
        0x08000666:    e7e5        ..      B        0x8000634 ; LL_TIM_IC_SetFilter + 32
        0x08000668:    2105        .!      MOVS     r1,#5
        0x0800066a:    e7e3        ..      B        0x8000634 ; LL_TIM_IC_SetFilter + 32
    $d
        0x0800066c:    08001f4e    N...    DCD    134225742
    $t
    i.LL_TIM_IC_SetPolarity
    LL_TIM_IC_SetPolarity
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
        0x08000670:    b510        ..      PUSH     {r4,lr}
        0x08000672:    2901        .)      CMP      r1,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2341)
        0x08000674:    d016        ..      BEQ      0x80006a4 ; LL_TIM_IC_SetPolarity + 52
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000676:    2904        .)      CMP      r1,#4
        0x08000678:    d016        ..      BEQ      0x80006a8 ; LL_TIM_IC_SetPolarity + 56
        0x0800067a:    2910        .)      CMP      r1,#0x10
        0x0800067c:    d016        ..      BEQ      0x80006ac ; LL_TIM_IC_SetPolarity + 60
        0x0800067e:    2940        @)      CMP      r1,#0x40
        0x08000680:    d016        ..      BEQ      0x80006b0 ; LL_TIM_IC_SetPolarity + 64
        0x08000682:    f5b17f80    ....    CMP      r1,#0x100
        0x08000686:    d015        ..      BEQ      0x80006b4 ; LL_TIM_IC_SetPolarity + 68
        0x08000688:    f5b16f80    ...o    CMP      r1,#0x400
        0x0800068c:    d014        ..      BEQ      0x80006b8 ; LL_TIM_IC_SetPolarity + 72
        0x0800068e:    2106        .!      MOVS     r1,#6
        0x08000690:    6a03        .j      LDR      r3,[r0,#0x20]
        0x08000692:    4c0a        .L      LDR      r4,[pc,#40] ; [0x80006bc] = 0x8001f63
        0x08000694:    5c61        a\      LDRB     r1,[r4,r1]
        0x08000696:    240a        .$      MOVS     r4,#0xa
        0x08000698:    408c        .@      LSLS     r4,r4,r1
        0x0800069a:    43a3        .C      BICS     r3,r3,r4
        0x0800069c:    408a        .@      LSLS     r2,r2,r1
        0x0800069e:    4313        .C      ORRS     r3,r3,r2
        0x080006a0:    6203        .b      STR      r3,[r0,#0x20]
        0x080006a2:    bd10        ..      POP      {r4,pc}
        0x080006a4:    2100        .!      MOVS     r1,#0
        0x080006a6:    e7f3        ..      B        0x8000690 ; LL_TIM_IC_SetPolarity + 32
        0x080006a8:    2101        .!      MOVS     r1,#1
        0x080006aa:    e7f1        ..      B        0x8000690 ; LL_TIM_IC_SetPolarity + 32
        0x080006ac:    2102        .!      MOVS     r1,#2
        0x080006ae:    e7ef        ..      B        0x8000690 ; LL_TIM_IC_SetPolarity + 32
        0x080006b0:    2103        .!      MOVS     r1,#3
        0x080006b2:    e7ed        ..      B        0x8000690 ; LL_TIM_IC_SetPolarity + 32
        0x080006b4:    2104        .!      MOVS     r1,#4
        0x080006b6:    e7eb        ..      B        0x8000690 ; LL_TIM_IC_SetPolarity + 32
        0x080006b8:    2105        .!      MOVS     r1,#5
        0x080006ba:    e7e9        ..      B        0x8000690 ; LL_TIM_IC_SetPolarity + 32
    $d
        0x080006bc:    08001f63    c...    DCD    134225763
    $t
    i.LL_TIM_IC_SetPrescaler
    LL_TIM_IC_SetPrescaler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2214)
        0x080006c0:    b510        ..      PUSH     {r4,lr}
        0x080006c2:    2901        .)      CMP      r1,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2214)
        0x080006c4:    d01c        ..      BEQ      0x8000700 ; LL_TIM_IC_SetPrescaler + 64
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x080006c6:    2904        .)      CMP      r1,#4
        0x080006c8:    d01c        ..      BEQ      0x8000704 ; LL_TIM_IC_SetPrescaler + 68
        0x080006ca:    2910        .)      CMP      r1,#0x10
        0x080006cc:    d01c        ..      BEQ      0x8000708 ; LL_TIM_IC_SetPrescaler + 72
        0x080006ce:    2940        @)      CMP      r1,#0x40
        0x080006d0:    d01c        ..      BEQ      0x800070c ; LL_TIM_IC_SetPrescaler + 76
        0x080006d2:    f5b17f80    ....    CMP      r1,#0x100
        0x080006d6:    d01b        ..      BEQ      0x8000710 ; LL_TIM_IC_SetPrescaler + 80
        0x080006d8:    f5b16f80    ...o    CMP      r1,#0x400
        0x080006dc:    d01a        ..      BEQ      0x8000714 ; LL_TIM_IC_SetPrescaler + 84
        0x080006de:    2106        .!      MOVS     r1,#6
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x080006e0:    4b0d        .K      LDR      r3,[pc,#52] ; [0x8000718] = 0x8001f4e
        0x080006e2:    3018        .0      ADDS     r0,r0,#0x18
        0x080006e4:    5c5b        [\      LDRB     r3,[r3,r1]
        0x080006e6:    4418        .D      ADD      r0,r0,r3
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
        0x080006e8:    4c0b        .L      LDR      r4,[pc,#44] ; [0x8000718] = 0x8001f4e
        0x080006ea:    6803        .h      LDR      r3,[r0,#0]
        0x080006ec:    340e        .4      ADDS     r4,r4,#0xe
        0x080006ee:    5c61        a\      LDRB     r1,[r4,r1]
        0x080006f0:    240c        .$      MOVS     r4,#0xc
        0x080006f2:    408c        .@      LSLS     r4,r4,r1
        0x080006f4:    0c12        ..      LSRS     r2,r2,#16
        0x080006f6:    43a3        .C      BICS     r3,r3,r4
        0x080006f8:    408a        .@      LSLS     r2,r2,r1
        0x080006fa:    4313        .C      ORRS     r3,r3,r2
        0x080006fc:    6003        .`      STR      r3,[r0,#0]
;;;2218   }
        0x080006fe:    bd10        ..      POP      {r4,pc}
        0x08000700:    2100        .!      MOVS     r1,#0
        0x08000702:    e7ed        ..      B        0x80006e0 ; LL_TIM_IC_SetPrescaler + 32
        0x08000704:    2101        .!      MOVS     r1,#1
        0x08000706:    e7eb        ..      B        0x80006e0 ; LL_TIM_IC_SetPrescaler + 32
        0x08000708:    2102        .!      MOVS     r1,#2
        0x0800070a:    e7e9        ..      B        0x80006e0 ; LL_TIM_IC_SetPrescaler + 32
        0x0800070c:    2103        .!      MOVS     r1,#3
        0x0800070e:    e7e7        ..      B        0x80006e0 ; LL_TIM_IC_SetPrescaler + 32
        0x08000710:    2104        .!      MOVS     r1,#4
        0x08000712:    e7e5        ..      B        0x80006e0 ; LL_TIM_IC_SetPrescaler + 32
        0x08000714:    2105        .!      MOVS     r1,#5
        0x08000716:    e7e3        ..      B        0x80006e0 ; LL_TIM_IC_SetPrescaler + 32
    $d
        0x08000718:    08001f4e    N...    DCD    134225742
    $t
    i.LL_TIM_Init
    LL_TIM_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;341    {
        0x0800071c:    b5f0        ..      PUSH     {r4-r7,lr}
;;;342      uint32_t tmpcr1 = 0U;
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_TIM_INSTANCE(TIMx));
;;;346      assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
;;;347      assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
;;;348    
;;;349      tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
        0x0800071e:    6802        .h      LDR      r2,[r0,#0]
;;;350    
;;;351      if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
        0x08000720:    4d15        .M      LDR      r5,[pc,#84] ; [0x8000778] = 0x40012c00
        0x08000722:    4b16        .K      LDR      r3,[pc,#88] ; [0x800077c] = 0x40000400
        0x08000724:    4c16        .L      LDR      r4,[pc,#88] ; [0x8000780] = 0x40000800
        0x08000726:    f04f4680    O..F    MOV      r6,#0x40000000
        0x0800072a:    42a8        .B      CMP      r0,r5
        0x0800072c:    d005        ..      BEQ      0x800073a ; LL_TIM_Init + 30
        0x0800072e:    42b0        .B      CMP      r0,r6
        0x08000730:    d003        ..      BEQ      0x800073a ; LL_TIM_Init + 30
        0x08000732:    4298        .B      CMP      r0,r3
        0x08000734:    d001        ..      BEQ      0x800073a ; LL_TIM_Init + 30
        0x08000736:    42a0        .B      CMP      r0,r4
        0x08000738:    d103        ..      BNE      0x8000742 ; LL_TIM_Init + 38
;;;352      {
;;;353        /* Select the Counter Mode */
;;;354        MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
        0x0800073a:    684f        Oh      LDR      r7,[r1,#4]
        0x0800073c:    f0220270    ".p.    BIC      r2,r2,#0x70
        0x08000740:    433a        :C      ORRS     r2,r2,r7
;;;355      }
;;;356    
;;;357      if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
        0x08000742:    42a8        .B      CMP      r0,r5
        0x08000744:    d005        ..      BEQ      0x8000752 ; LL_TIM_Init + 54
        0x08000746:    42b0        .B      CMP      r0,r6
        0x08000748:    d003        ..      BEQ      0x8000752 ; LL_TIM_Init + 54
        0x0800074a:    4298        .B      CMP      r0,r3
        0x0800074c:    d001        ..      BEQ      0x8000752 ; LL_TIM_Init + 54
        0x0800074e:    42a0        .B      CMP      r0,r4
        0x08000750:    d103        ..      BNE      0x800075a ; LL_TIM_Init + 62
;;;358      {
;;;359        /* Set the clock division */
;;;360        MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
        0x08000752:    68cb        .h      LDR      r3,[r1,#0xc]
        0x08000754:    f4227240    ".@r    BIC      r2,r2,#0x300
        0x08000758:    431a        .C      ORRS     r2,r2,r3
;;;361      }
;;;362    
;;;363      /* Write to TIMx CR1 */
;;;364      LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
        0x0800075a:    6002        .`      STR      r2,[r0,#0]
;;;365    
;;;366      /* Set the Autoreload value */
;;;367      LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
        0x0800075c:    688a        .h      LDR      r2,[r1,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
        0x0800075e:    62c2        .b      STR      r2,[r0,#0x2c]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;370      LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
        0x08000760:    880a        ..      LDRH     r2,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
        0x08000762:    6282        .b      STR      r2,[r0,#0x28]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;372      if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
        0x08000764:    42a8        .B      CMP      r0,r5
        0x08000766:    d101        ..      BNE      0x800076c ; LL_TIM_Init + 80
;;;373      {
;;;374        /* Set the Repetition Counter value */
;;;375        LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
        0x08000768:    7c09        .|      LDRB     r1,[r1,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
        0x0800076a:    6301        .c      STR      r1,[r0,#0x30]
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2645   }
;;;2646   
;;;2647   /**
;;;2648     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2649     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2650     * a timer instance can operate as a slave timer.
;;;2651     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2652     * @param  TIMx Timer instance
;;;2653     * @retval State of bit (1 or 0).
;;;2654     */
;;;2655   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2656   {
;;;2657     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2658   }
;;;2659   
;;;2660   /**
;;;2661     * @brief  Configure the external trigger (ETR) input.
;;;2662     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2663     *       a timer instance provides an external trigger input.
;;;2664     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2665     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2666     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2667     * @param  TIMx Timer instance
;;;2668     * @param  ETRPolarity This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2670     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2671     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2673     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2674     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2675     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2676     * @param  ETRFilter This parameter can be one of the following values:
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2690     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2691     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2692     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2693     * @retval None
;;;2694     */
;;;2695   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2696                                         uint32_t ETRFilter)
;;;2697   {
;;;2698     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2699   }
;;;2700   
;;;2701   /**
;;;2702     * @}
;;;2703     */
;;;2704   
;;;2705   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2706     * @{
;;;2707     */
;;;2708   /**
;;;2709     * @brief  Enable the break function.
;;;2710     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2711     *       a timer instance provides a break input.
;;;2712     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2713     * @param  TIMx Timer instance
;;;2714     * @retval None
;;;2715     */
;;;2716   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2717   {
;;;2718     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2719   }
;;;2720   
;;;2721   /**
;;;2722     * @brief  Disable the break function.
;;;2723     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2724     * @param  TIMx Timer instance
;;;2725     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2726     *       a timer instance provides a break input.
;;;2727     * @retval None
;;;2728     */
;;;2729   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2730   {
;;;2731     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2732   }
;;;2733   
;;;2734   /**
;;;2735     * @brief  Configure the break input.
;;;2736     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2737     *       a timer instance provides a break input.
;;;2738     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2739     * @param  TIMx Timer instance
;;;2740     * @param  BreakPolarity This parameter can be one of the following values:
;;;2741     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2742     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2743     * @retval None
;;;2744     */
;;;2745   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2746   {
;;;2747     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2748   }
;;;2749   
;;;2750   /**
;;;2751     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2752     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2753     *       a timer instance provides a break input.
;;;2754     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2755     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2756     * @param  TIMx Timer instance
;;;2757     * @param  OffStateIdle This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2760     * @param  OffStateRun This parameter can be one of the following values:
;;;2761     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2762     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2763     * @retval None
;;;2764     */
;;;2765   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2766   {
;;;2767     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2768   }
;;;2769   
;;;2770   /**
;;;2771     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2772     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2773     *       a timer instance provides a break input.
;;;2774     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2775     * @param  TIMx Timer instance
;;;2776     * @retval None
;;;2777     */
;;;2778   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2779   {
;;;2780     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2781   }
;;;2782   
;;;2783   /**
;;;2784     * @brief  Disable automatic output (MOE can be set only by software).
;;;2785     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2786     *       a timer instance provides a break input.
;;;2787     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2788     * @param  TIMx Timer instance
;;;2789     * @retval None
;;;2790     */
;;;2791   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2792   {
;;;2793     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2794   }
;;;2795   
;;;2796   /**
;;;2797     * @brief  Indicate whether automatic output is enabled.
;;;2798     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2799     *       a timer instance provides a break input.
;;;2800     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2801     * @param  TIMx Timer instance
;;;2802     * @retval State of bit (1 or 0).
;;;2803     */
;;;2804   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2805   {
;;;2806     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2807   }
;;;2808   
;;;2809   /**
;;;2810     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2811     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2812     *       software and is reset in case of break or break2 event
;;;2813     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2814     *       a timer instance provides a break input.
;;;2815     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2816     * @param  TIMx Timer instance
;;;2817     * @retval None
;;;2818     */
;;;2819   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2820   {
;;;2821     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2822   }
;;;2823   
;;;2824   /**
;;;2825     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2826     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2827     *       software and is reset in case of break or break2 event.
;;;2828     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2829     *       a timer instance provides a break input.
;;;2830     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2831     * @param  TIMx Timer instance
;;;2832     * @retval None
;;;2833     */
;;;2834   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2835   {
;;;2836     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2837   }
;;;2838   
;;;2839   /**
;;;2840     * @brief  Indicates whether outputs are enabled.
;;;2841     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2842     *       a timer instance provides a break input.
;;;2843     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2844     * @param  TIMx Timer instance
;;;2845     * @retval State of bit (1 or 0).
;;;2846     */
;;;2847   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2848   {
;;;2849     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2850   }
;;;2851   
;;;2852   /**
;;;2853     * @}
;;;2854     */
;;;2855   
;;;2856   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2857     * @{
;;;2858     */
;;;2859   /**
;;;2860     * @brief  Configures the timer DMA burst feature.
;;;2861     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2862     *       not a timer instance supports the DMA burst mode.
;;;2863     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2864     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2865     * @param  TIMx Timer instance
;;;2866     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2882     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2883     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2884     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2885     * @param  DMABurstLength This parameter can be one of the following values:
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2901     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2902     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2903     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2904     * @retval None
;;;2905     */
;;;2906   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2907   {
;;;2908     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2909   }
;;;2910   
;;;2911   /**
;;;2912     * @}
;;;2913     */
;;;2914   
;;;2915   
;;;2916   /**
;;;2917     * @}
;;;2918     */
;;;2919   
;;;2920   
;;;2921   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2922     * @{
;;;2923     */
;;;2924   /**
;;;2925     * @brief  Clear the update interrupt flag (UIF).
;;;2926     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2927     * @param  TIMx Timer instance
;;;2928     * @retval None
;;;2929     */
;;;2930   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2931   {
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3204   }
;;;3205   
;;;3206   /**
;;;3207     * @brief  Disable update interrupt (UIE).
;;;3208     * @rmtoll DIER         UIE           LL_TIM_DisableIT_UPDATE
;;;3209     * @param  TIMx Timer instance
;;;3210     * @retval None
;;;3211     */
;;;3212   __STATIC_INLINE void LL_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3213   {
;;;3214     CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3215   }
;;;3216   
;;;3217   /**
;;;3218     * @brief  Indicates whether the update interrupt (UIE) is enabled.
;;;3219     * @rmtoll DIER         UIE           LL_TIM_IsEnabledIT_UPDATE
;;;3220     * @param  TIMx Timer instance
;;;3221     * @retval State of bit (1 or 0).
;;;3222     */
;;;3223   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
;;;3224   {
;;;3225     return (READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE));
;;;3226   }
;;;3227   
;;;3228   /**
;;;3229     * @brief  Enable capture/compare 1 interrupt (CC1IE).
;;;3230     * @rmtoll DIER         CC1IE         LL_TIM_EnableIT_CC1
;;;3231     * @param  TIMx Timer instance
;;;3232     * @retval None
;;;3233     */
;;;3234   __STATIC_INLINE void LL_TIM_EnableIT_CC1(TIM_TypeDef *TIMx)
;;;3235   {
;;;3236     SET_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3237   }
;;;3238   
;;;3239   /**
;;;3240     * @brief  Disable capture/compare 1  interrupt (CC1IE).
;;;3241     * @rmtoll DIER         CC1IE         LL_TIM_DisableIT_CC1
;;;3242     * @param  TIMx Timer instance
;;;3243     * @retval None
;;;3244     */
;;;3245   __STATIC_INLINE void LL_TIM_DisableIT_CC1(TIM_TypeDef *TIMx)
;;;3246   {
;;;3247     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3248   }
;;;3249   
;;;3250   /**
;;;3251     * @brief  Indicates whether the capture/compare 1 interrupt (CC1IE) is enabled.
;;;3252     * @rmtoll DIER         CC1IE         LL_TIM_IsEnabledIT_CC1
;;;3253     * @param  TIMx Timer instance
;;;3254     * @retval State of bit (1 or 0).
;;;3255     */
;;;3256   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx)
;;;3257   {
;;;3258     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1IE) == (TIM_DIER_CC1IE));
;;;3259   }
;;;3260   
;;;3261   /**
;;;3262     * @brief  Enable capture/compare 2 interrupt (CC2IE).
;;;3263     * @rmtoll DIER         CC2IE         LL_TIM_EnableIT_CC2
;;;3264     * @param  TIMx Timer instance
;;;3265     * @retval None
;;;3266     */
;;;3267   __STATIC_INLINE void LL_TIM_EnableIT_CC2(TIM_TypeDef *TIMx)
;;;3268   {
;;;3269     SET_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3270   }
;;;3271   
;;;3272   /**
;;;3273     * @brief  Disable capture/compare 2  interrupt (CC2IE).
;;;3274     * @rmtoll DIER         CC2IE         LL_TIM_DisableIT_CC2
;;;3275     * @param  TIMx Timer instance
;;;3276     * @retval None
;;;3277     */
;;;3278   __STATIC_INLINE void LL_TIM_DisableIT_CC2(TIM_TypeDef *TIMx)
;;;3279   {
;;;3280     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3281   }
;;;3282   
;;;3283   /**
;;;3284     * @brief  Indicates whether the capture/compare 2 interrupt (CC2IE) is enabled.
;;;3285     * @rmtoll DIER         CC2IE         LL_TIM_IsEnabledIT_CC2
;;;3286     * @param  TIMx Timer instance
;;;3287     * @retval State of bit (1 or 0).
;;;3288     */
;;;3289   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx)
;;;3290   {
;;;3291     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2IE) == (TIM_DIER_CC2IE));
;;;3292   }
;;;3293   
;;;3294   /**
;;;3295     * @brief  Enable capture/compare 3 interrupt (CC3IE).
;;;3296     * @rmtoll DIER         CC3IE         LL_TIM_EnableIT_CC3
;;;3297     * @param  TIMx Timer instance
;;;3298     * @retval None
;;;3299     */
;;;3300   __STATIC_INLINE void LL_TIM_EnableIT_CC3(TIM_TypeDef *TIMx)
;;;3301   {
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3303   }
;;;3304   
;;;3305   /**
;;;3306     * @brief  Disable capture/compare 3  interrupt (CC3IE).
;;;3307     * @rmtoll DIER         CC3IE         LL_TIM_DisableIT_CC3
;;;3308     * @param  TIMx Timer instance
;;;3309     * @retval None
;;;3310     */
;;;3311   __STATIC_INLINE void LL_TIM_DisableIT_CC3(TIM_TypeDef *TIMx)
;;;3312   {
;;;3313     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3314   }
;;;3315   
;;;3316   /**
;;;3317     * @brief  Indicates whether the capture/compare 3 interrupt (CC3IE) is enabled.
;;;3318     * @rmtoll DIER         CC3IE         LL_TIM_IsEnabledIT_CC3
;;;3319     * @param  TIMx Timer instance
;;;3320     * @retval State of bit (1 or 0).
;;;3321     */
;;;3322   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx)
;;;3323   {
;;;3324     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3IE) == (TIM_DIER_CC3IE));
;;;3325   }
;;;3326   
;;;3327   /**
;;;3328     * @brief  Enable capture/compare 4 interrupt (CC4IE).
;;;3329     * @rmtoll DIER         CC4IE         LL_TIM_EnableIT_CC4
;;;3330     * @param  TIMx Timer instance
;;;3331     * @retval None
;;;3332     */
;;;3333   __STATIC_INLINE void LL_TIM_EnableIT_CC4(TIM_TypeDef *TIMx)
;;;3334   {
;;;3335     SET_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3336   }
;;;3337   
;;;3338   /**
;;;3339     * @brief  Disable capture/compare 4  interrupt (CC4IE).
;;;3340     * @rmtoll DIER         CC4IE         LL_TIM_DisableIT_CC4
;;;3341     * @param  TIMx Timer instance
;;;3342     * @retval None
;;;3343     */
;;;3344   __STATIC_INLINE void LL_TIM_DisableIT_CC4(TIM_TypeDef *TIMx)
;;;3345   {
;;;3346     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3347   }
;;;3348   
;;;3349   /**
;;;3350     * @brief  Indicates whether the capture/compare 4 interrupt (CC4IE) is enabled.
;;;3351     * @rmtoll DIER         CC4IE         LL_TIM_IsEnabledIT_CC4
;;;3352     * @param  TIMx Timer instance
;;;3353     * @retval State of bit (1 or 0).
;;;3354     */
;;;3355   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx)
;;;3356   {
;;;3357     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4IE) == (TIM_DIER_CC4IE));
;;;3358   }
;;;3359   
;;;3360   /**
;;;3361     * @brief  Enable commutation interrupt (COMIE).
;;;3362     * @rmtoll DIER         COMIE         LL_TIM_EnableIT_COM
;;;3363     * @param  TIMx Timer instance
;;;3364     * @retval None
;;;3365     */
;;;3366   __STATIC_INLINE void LL_TIM_EnableIT_COM(TIM_TypeDef *TIMx)
;;;3367   {
;;;3368     SET_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3369   }
;;;3370   
;;;3371   /**
;;;3372     * @brief  Disable commutation interrupt (COMIE).
;;;3373     * @rmtoll DIER         COMIE         LL_TIM_DisableIT_COM
;;;3374     * @param  TIMx Timer instance
;;;3375     * @retval None
;;;3376     */
;;;3377   __STATIC_INLINE void LL_TIM_DisableIT_COM(TIM_TypeDef *TIMx)
;;;3378   {
;;;3379     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3380   }
;;;3381   
;;;3382   /**
;;;3383     * @brief  Indicates whether the commutation interrupt (COMIE) is enabled.
;;;3384     * @rmtoll DIER         COMIE         LL_TIM_IsEnabledIT_COM
;;;3385     * @param  TIMx Timer instance
;;;3386     * @retval State of bit (1 or 0).
;;;3387     */
;;;3388   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx)
;;;3389   {
;;;3390     return (READ_BIT(TIMx->DIER, TIM_DIER_COMIE) == (TIM_DIER_COMIE));
;;;3391   }
;;;3392   
;;;3393   /**
;;;3394     * @brief  Enable trigger interrupt (TIE).
;;;3395     * @rmtoll DIER         TIE           LL_TIM_EnableIT_TRIG
;;;3396     * @param  TIMx Timer instance
;;;3397     * @retval None
;;;3398     */
;;;3399   __STATIC_INLINE void LL_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx)
;;;3400   {
;;;3401     SET_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3402   }
;;;3403   
;;;3404   /**
;;;3405     * @brief  Disable trigger interrupt (TIE).
;;;3406     * @rmtoll DIER         TIE           LL_TIM_DisableIT_TRIG
;;;3407     * @param  TIMx Timer instance
;;;3408     * @retval None
;;;3409     */
;;;3410   __STATIC_INLINE void LL_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx)
;;;3411   {
;;;3412     CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3413   }
;;;3414   
;;;3415   /**
;;;3416     * @brief  Indicates whether the trigger interrupt (TIE) is enabled.
;;;3417     * @rmtoll DIER         TIE           LL_TIM_IsEnabledIT_TRIG
;;;3418     * @param  TIMx Timer instance
;;;3419     * @retval State of bit (1 or 0).
;;;3420     */
;;;3421   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx)
;;;3422   {
;;;3423     return (READ_BIT(TIMx->DIER, TIM_DIER_TIE) == (TIM_DIER_TIE));
;;;3424   }
;;;3425   
;;;3426   /**
;;;3427     * @brief  Enable break interrupt (BIE).
;;;3428     * @rmtoll DIER         BIE           LL_TIM_EnableIT_BRK
;;;3429     * @param  TIMx Timer instance
;;;3430     * @retval None
;;;3431     */
;;;3432   __STATIC_INLINE void LL_TIM_EnableIT_BRK(TIM_TypeDef *TIMx)
;;;3433   {
;;;3434     SET_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3435   }
;;;3436   
;;;3437   /**
;;;3438     * @brief  Disable break interrupt (BIE).
;;;3439     * @rmtoll DIER         BIE           LL_TIM_DisableIT_BRK
;;;3440     * @param  TIMx Timer instance
;;;3441     * @retval None
;;;3442     */
;;;3443   __STATIC_INLINE void LL_TIM_DisableIT_BRK(TIM_TypeDef *TIMx)
;;;3444   {
;;;3445     CLEAR_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3446   }
;;;3447   
;;;3448   /**
;;;3449     * @brief  Indicates whether the break interrupt (BIE) is enabled.
;;;3450     * @rmtoll DIER         BIE           LL_TIM_IsEnabledIT_BRK
;;;3451     * @param  TIMx Timer instance
;;;3452     * @retval State of bit (1 or 0).
;;;3453     */
;;;3454   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx)
;;;3455   {
;;;3456     return (READ_BIT(TIMx->DIER, TIM_DIER_BIE) == (TIM_DIER_BIE));
;;;3457   }
;;;3458   
;;;3459   /**
;;;3460     * @}
;;;3461     */
;;;3462   
;;;3463   /** @defgroup TIM_LL_EF_DMA_Management DMA-Management
;;;3464     * @{
;;;3465     */
;;;3466   /**
;;;3467     * @brief  Enable update DMA request (UDE).
;;;3468     * @rmtoll DIER         UDE           LL_TIM_EnableDMAReq_UPDATE
;;;3469     * @param  TIMx Timer instance
;;;3470     * @retval None
;;;3471     */
;;;3472   __STATIC_INLINE void LL_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3473   {
;;;3474     SET_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3475   }
;;;3476   
;;;3477   /**
;;;3478     * @brief  Disable update DMA request (UDE).
;;;3479     * @rmtoll DIER         UDE           LL_TIM_DisableDMAReq_UPDATE
;;;3480     * @param  TIMx Timer instance
;;;3481     * @retval None
;;;3482     */
;;;3483   __STATIC_INLINE void LL_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3484   {
;;;3485     CLEAR_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3486   }
;;;3487   
;;;3488   /**
;;;3489     * @brief  Indicates whether the update DMA request  (UDE) is enabled.
;;;3490     * @rmtoll DIER         UDE           LL_TIM_IsEnabledDMAReq_UPDATE
;;;3491     * @param  TIMx Timer instance
;;;3492     * @retval State of bit (1 or 0).
;;;3493     */
;;;3494   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3495   {
;;;3496     return (READ_BIT(TIMx->DIER, TIM_DIER_UDE) == (TIM_DIER_UDE));
;;;3497   }
;;;3498   
;;;3499   /**
;;;3500     * @brief  Enable capture/compare 1 DMA request (CC1DE).
;;;3501     * @rmtoll DIER         CC1DE         LL_TIM_EnableDMAReq_CC1
;;;3502     * @param  TIMx Timer instance
;;;3503     * @retval None
;;;3504     */
;;;3505   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3506   {
;;;3507     SET_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3508   }
;;;3509   
;;;3510   /**
;;;3511     * @brief  Disable capture/compare 1  DMA request (CC1DE).
;;;3512     * @rmtoll DIER         CC1DE         LL_TIM_DisableDMAReq_CC1
;;;3513     * @param  TIMx Timer instance
;;;3514     * @retval None
;;;3515     */
;;;3516   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3517   {
;;;3518     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3519   }
;;;3520   
;;;3521   /**
;;;3522     * @brief  Indicates whether the capture/compare 1 DMA request (CC1DE) is enabled.
;;;3523     * @rmtoll DIER         CC1DE         LL_TIM_IsEnabledDMAReq_CC1
;;;3524     * @param  TIMx Timer instance
;;;3525     * @retval State of bit (1 or 0).
;;;3526     */
;;;3527   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3528   {
;;;3529     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1DE) == (TIM_DIER_CC1DE));
;;;3530   }
;;;3531   
;;;3532   /**
;;;3533     * @brief  Enable capture/compare 2 DMA request (CC2DE).
;;;3534     * @rmtoll DIER         CC2DE         LL_TIM_EnableDMAReq_CC2
;;;3535     * @param  TIMx Timer instance
;;;3536     * @retval None
;;;3537     */
;;;3538   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3539   {
;;;3540     SET_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3541   }
;;;3542   
;;;3543   /**
;;;3544     * @brief  Disable capture/compare 2  DMA request (CC2DE).
;;;3545     * @rmtoll DIER         CC2DE         LL_TIM_DisableDMAReq_CC2
;;;3546     * @param  TIMx Timer instance
;;;3547     * @retval None
;;;3548     */
;;;3549   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3550   {
;;;3551     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3552   }
;;;3553   
;;;3554   /**
;;;3555     * @brief  Indicates whether the capture/compare 2 DMA request (CC2DE) is enabled.
;;;3556     * @rmtoll DIER         CC2DE         LL_TIM_IsEnabledDMAReq_CC2
;;;3557     * @param  TIMx Timer instance
;;;3558     * @retval State of bit (1 or 0).
;;;3559     */
;;;3560   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3561   {
;;;3562     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2DE) == (TIM_DIER_CC2DE));
;;;3563   }
;;;3564   
;;;3565   /**
;;;3566     * @brief  Enable capture/compare 3 DMA request (CC3DE).
;;;3567     * @rmtoll DIER         CC3DE         LL_TIM_EnableDMAReq_CC3
;;;3568     * @param  TIMx Timer instance
;;;3569     * @retval None
;;;3570     */
;;;3571   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3572   {
;;;3573     SET_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3574   }
;;;3575   
;;;3576   /**
;;;3577     * @brief  Disable capture/compare 3  DMA request (CC3DE).
;;;3578     * @rmtoll DIER         CC3DE         LL_TIM_DisableDMAReq_CC3
;;;3579     * @param  TIMx Timer instance
;;;3580     * @retval None
;;;3581     */
;;;3582   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3583   {
;;;3584     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3585   }
;;;3586   
;;;3587   /**
;;;3588     * @brief  Indicates whether the capture/compare 3 DMA request (CC3DE) is enabled.
;;;3589     * @rmtoll DIER         CC3DE         LL_TIM_IsEnabledDMAReq_CC3
;;;3590     * @param  TIMx Timer instance
;;;3591     * @retval State of bit (1 or 0).
;;;3592     */
;;;3593   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3594   {
;;;3595     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3DE) == (TIM_DIER_CC3DE));
;;;3596   }
;;;3597   
;;;3598   /**
;;;3599     * @brief  Enable capture/compare 4 DMA request (CC4DE).
;;;3600     * @rmtoll DIER         CC4DE         LL_TIM_EnableDMAReq_CC4
;;;3601     * @param  TIMx Timer instance
;;;3602     * @retval None
;;;3603     */
;;;3604   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3605   {
;;;3606     SET_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3607   }
;;;3608   
;;;3609   /**
;;;3610     * @brief  Disable capture/compare 4  DMA request (CC4DE).
;;;3611     * @rmtoll DIER         CC4DE         LL_TIM_DisableDMAReq_CC4
;;;3612     * @param  TIMx Timer instance
;;;3613     * @retval None
;;;3614     */
;;;3615   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3616   {
;;;3617     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3618   }
;;;3619   
;;;3620   /**
;;;3621     * @brief  Indicates whether the capture/compare 4 DMA request (CC4DE) is enabled.
;;;3622     * @rmtoll DIER         CC4DE         LL_TIM_IsEnabledDMAReq_CC4
;;;3623     * @param  TIMx Timer instance
;;;3624     * @retval State of bit (1 or 0).
;;;3625     */
;;;3626   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3627   {
;;;3628     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4DE) == (TIM_DIER_CC4DE));
;;;3629   }
;;;3630   
;;;3631   /**
;;;3632     * @brief  Enable commutation DMA request (COMDE).
;;;3633     * @rmtoll DIER         COMDE         LL_TIM_EnableDMAReq_COM
;;;3634     * @param  TIMx Timer instance
;;;3635     * @retval None
;;;3636     */
;;;3637   __STATIC_INLINE void LL_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3638   {
;;;3639     SET_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3640   }
;;;3641   
;;;3642   /**
;;;3643     * @brief  Disable commutation DMA request (COMDE).
;;;3644     * @rmtoll DIER         COMDE         LL_TIM_DisableDMAReq_COM
;;;3645     * @param  TIMx Timer instance
;;;3646     * @retval None
;;;3647     */
;;;3648   __STATIC_INLINE void LL_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3649   {
;;;3650     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3651   }
;;;3652   
;;;3653   /**
;;;3654     * @brief  Indicates whether the commutation DMA request (COMDE) is enabled.
;;;3655     * @rmtoll DIER         COMDE         LL_TIM_IsEnabledDMAReq_COM
;;;3656     * @param  TIMx Timer instance
;;;3657     * @retval State of bit (1 or 0).
;;;3658     */
;;;3659   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx)
;;;3660   {
;;;3661     return (READ_BIT(TIMx->DIER, TIM_DIER_COMDE) == (TIM_DIER_COMDE));
;;;3662   }
;;;3663   
;;;3664   /**
;;;3665     * @brief  Enable trigger interrupt (TDE).
;;;3666     * @rmtoll DIER         TDE           LL_TIM_EnableDMAReq_TRIG
;;;3667     * @param  TIMx Timer instance
;;;3668     * @retval None
;;;3669     */
;;;3670   __STATIC_INLINE void LL_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3671   {
;;;3672     SET_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3673   }
;;;3674   
;;;3675   /**
;;;3676     * @brief  Disable trigger interrupt (TDE).
;;;3677     * @rmtoll DIER         TDE           LL_TIM_DisableDMAReq_TRIG
;;;3678     * @param  TIMx Timer instance
;;;3679     * @retval None
;;;3680     */
;;;3681   __STATIC_INLINE void LL_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3682   {
;;;3683     CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3684   }
;;;3685   
;;;3686   /**
;;;3687     * @brief  Indicates whether the trigger interrupt (TDE) is enabled.
;;;3688     * @rmtoll DIER         TDE           LL_TIM_IsEnabledDMAReq_TRIG
;;;3689     * @param  TIMx Timer instance
;;;3690     * @retval State of bit (1 or 0).
;;;3691     */
;;;3692   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3693   {
;;;3694     return (READ_BIT(TIMx->DIER, TIM_DIER_TDE) == (TIM_DIER_TDE));
;;;3695   }
;;;3696   
;;;3697   /**
;;;3698     * @}
;;;3699     */
;;;3700   
;;;3701   /** @defgroup TIM_LL_EF_EVENT_Management EVENT-Management
;;;3702     * @{
;;;3703     */
;;;3704   /**
;;;3705     * @brief  Generate an update event.
;;;3706     * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
;;;3707     * @param  TIMx Timer instance
;;;3708     * @retval None
;;;3709     */
;;;3710   __STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
;;;3711   {
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x0800076c:    6941        Ai      LDR      r1,[r0,#0x14]
        0x0800076e:    f0410101    A...    ORR      r1,r1,#1
        0x08000772:    6141        Aa      STR      r1,[r0,#0x14]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;382      return SUCCESS;
        0x08000774:    2001        .       MOVS     r0,#1
;;;383    }
        0x08000776:    bdf0        ..      POP      {r4-r7,pc}
    $d
        0x08000778:    40012c00    .,.@    DCD    1073818624
        0x0800077c:    40000400    ...@    DCD    1073742848
        0x08000780:    40000800    ...@    DCD    1073743872
    $t
    i.LL_TIM_OC_DisableFast
    LL_TIM_OC_DisableFast
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000784:    2901        .)      CMP      r1,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1805)
        0x08000786:    d019        ..      BEQ      0x80007bc ; LL_TIM_OC_DisableFast + 56
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x08000788:    2904        .)      CMP      r1,#4
        0x0800078a:    d019        ..      BEQ      0x80007c0 ; LL_TIM_OC_DisableFast + 60
        0x0800078c:    2910        .)      CMP      r1,#0x10
        0x0800078e:    d019        ..      BEQ      0x80007c4 ; LL_TIM_OC_DisableFast + 64
        0x08000790:    2940        @)      CMP      r1,#0x40
        0x08000792:    d019        ..      BEQ      0x80007c8 ; LL_TIM_OC_DisableFast + 68
        0x08000794:    f5b17f80    ....    CMP      r1,#0x100
        0x08000798:    d018        ..      BEQ      0x80007cc ; LL_TIM_OC_DisableFast + 72
        0x0800079a:    f5b16f80    ...o    CMP      r1,#0x400
        0x0800079e:    d017        ..      BEQ      0x80007d0 ; LL_TIM_OC_DisableFast + 76
        0x080007a0:    2106        .!      MOVS     r1,#6
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x080007a2:    4a0c        .J      LDR      r2,[pc,#48] ; [0x80007d4] = 0x8001f4e
        0x080007a4:    3018        .0      ADDS     r0,r0,#0x18
        0x080007a6:    5c52        R\      LDRB     r2,[r2,r1]
        0x080007a8:    4410        .D      ADD      r0,r0,r2
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
        0x080007aa:    4b0a        .K      LDR      r3,[pc,#40] ; [0x80007d4] = 0x8001f4e
        0x080007ac:    6802        .h      LDR      r2,[r0,#0]
        0x080007ae:    1ddb        ..      ADDS     r3,r3,#7
        0x080007b0:    5c5b        [\      LDRB     r3,[r3,r1]
        0x080007b2:    2104        .!      MOVS     r1,#4
        0x080007b4:    4099        .@      LSLS     r1,r1,r3
        0x080007b6:    438a        .C      BICS     r2,r2,r1
        0x080007b8:    6002        .`      STR      r2,[r0,#0]
;;;1809   
;;;1810   }
        0x080007ba:    4770        pG      BX       lr
        0x080007bc:    2100        .!      MOVS     r1,#0
        0x080007be:    e7f0        ..      B        0x80007a2 ; LL_TIM_OC_DisableFast + 30
        0x080007c0:    2101        .!      MOVS     r1,#1
        0x080007c2:    e7ee        ..      B        0x80007a2 ; LL_TIM_OC_DisableFast + 30
        0x080007c4:    2102        .!      MOVS     r1,#2
        0x080007c6:    e7ec        ..      B        0x80007a2 ; LL_TIM_OC_DisableFast + 30
        0x080007c8:    2103        .!      MOVS     r1,#3
        0x080007ca:    e7ea        ..      B        0x80007a2 ; LL_TIM_OC_DisableFast + 30
        0x080007cc:    2104        .!      MOVS     r1,#4
        0x080007ce:    e7e8        ..      B        0x80007a2 ; LL_TIM_OC_DisableFast + 30
        0x080007d0:    2105        .!      MOVS     r1,#5
        0x080007d2:    e7e6        ..      B        0x80007a2 ; LL_TIM_OC_DisableFast + 30
    $d
        0x080007d4:    08001f4e    N...    DCD    134225742
    $t
    i.LL_TIM_OC_EnablePreload
    LL_TIM_OC_EnablePreload
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x080007d8:    2901        .)      CMP      r1,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1849)
        0x080007da:    d019        ..      BEQ      0x8000810 ; LL_TIM_OC_EnablePreload + 56
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
        0x080007dc:    2904        .)      CMP      r1,#4
        0x080007de:    d019        ..      BEQ      0x8000814 ; LL_TIM_OC_EnablePreload + 60
        0x080007e0:    2910        .)      CMP      r1,#0x10
        0x080007e2:    d019        ..      BEQ      0x8000818 ; LL_TIM_OC_EnablePreload + 64
        0x080007e4:    2940        @)      CMP      r1,#0x40
        0x080007e6:    d019        ..      BEQ      0x800081c ; LL_TIM_OC_EnablePreload + 68
        0x080007e8:    f5b17f80    ....    CMP      r1,#0x100
        0x080007ec:    d018        ..      BEQ      0x8000820 ; LL_TIM_OC_EnablePreload + 72
        0x080007ee:    f5b16f80    ...o    CMP      r1,#0x400
        0x080007f2:    d017        ..      BEQ      0x8000824 ; LL_TIM_OC_EnablePreload + 76
        0x080007f4:    2106        .!      MOVS     r1,#6
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
        0x080007f6:    4a0c        .J      LDR      r2,[pc,#48] ; [0x8000828] = 0x8001f4e
        0x080007f8:    3018        .0      ADDS     r0,r0,#0x18
        0x080007fa:    5c52        R\      LDRB     r2,[r2,r1]
        0x080007fc:    4410        .D      ADD      r0,r0,r2
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
        0x080007fe:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8000828] = 0x8001f4e
        0x08000800:    6802        .h      LDR      r2,[r0,#0]
        0x08000802:    1ddb        ..      ADDS     r3,r3,#7
        0x08000804:    5c5b        [\      LDRB     r3,[r3,r1]
        0x08000806:    2108        .!      MOVS     r1,#8
        0x08000808:    4099        .@      LSLS     r1,r1,r3
        0x0800080a:    430a        .C      ORRS     r2,r2,r1
        0x0800080c:    6002        .`      STR      r2,[r0,#0]
;;;1853   }
        0x0800080e:    4770        pG      BX       lr
        0x08000810:    2100        .!      MOVS     r1,#0
        0x08000812:    e7f0        ..      B        0x80007f6 ; LL_TIM_OC_EnablePreload + 30
        0x08000814:    2101        .!      MOVS     r1,#1
        0x08000816:    e7ee        ..      B        0x80007f6 ; LL_TIM_OC_EnablePreload + 30
        0x08000818:    2102        .!      MOVS     r1,#2
        0x0800081a:    e7ec        ..      B        0x80007f6 ; LL_TIM_OC_EnablePreload + 30
        0x0800081c:    2103        .!      MOVS     r1,#3
        0x0800081e:    e7ea        ..      B        0x80007f6 ; LL_TIM_OC_EnablePreload + 30
        0x08000820:    2104        .!      MOVS     r1,#4
        0x08000822:    e7e8        ..      B        0x80007f6 ; LL_TIM_OC_EnablePreload + 30
        0x08000824:    2105        .!      MOVS     r1,#5
        0x08000826:    e7e6        ..      B        0x80007f6 ; LL_TIM_OC_EnablePreload + 30
    $d
        0x08000828:    08001f4e    N...    DCD    134225742
    $t
    i.LL_TIM_OC_Init
    LL_TIM_OC_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;418    {
        0x0800082c:    4603        .F      MOV      r3,r0
        0x0800082e:    2000        .       MOVS     r0,#0
        0x08000830:    2901        .)      CMP      r1,#1
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c (418)
        0x08000832:    d00b        ..      BEQ      0x800084c ; LL_TIM_OC_Init + 32
;;;419      ErrorStatus result = ERROR;
;;;420    
;;;421      switch (Channel)
        0x08000834:    2910        .)      CMP      r1,#0x10
        0x08000836:    d00d        ..      BEQ      0x8000854 ; LL_TIM_OC_Init + 40
        0x08000838:    f5b17f80    ....    CMP      r1,#0x100
        0x0800083c:    d00e        ..      BEQ      0x800085c ; LL_TIM_OC_Init + 48
        0x0800083e:    f5b15f80    ..._    CMP      r1,#0x1000
        0x08000842:    d10f        ..      BNE      0x8000864 ; LL_TIM_OC_Init + 56
        0x08000844:    4611        .F      MOV      r1,r2
        0x08000846:    4618        .F      MOV      r0,r3
        0x08000848:    f000bcbc    ....    B.W      OC4Config ; 0x80011c4
;;;422      {
;;;423        case LL_TIM_CHANNEL_CH1:
;;;424          result = OC1Config(TIMx, TIM_OC_InitStruct);
        0x0800084c:    4611        .F      MOV      r1,r2
        0x0800084e:    4618        .F      MOV      r0,r3
        0x08000850:    f000bc10    ....    B.W      OC1Config ; 0x8001074
;;;425          break;
;;;426        case LL_TIM_CHANNEL_CH2:
;;;427          result = OC2Config(TIMx, TIM_OC_InitStruct);
        0x08000854:    4611        .F      MOV      r1,r2
        0x08000856:    4618        .F      MOV      r0,r3
        0x08000858:    f000bc42    ..B.    B.W      OC2Config ; 0x80010e0
;;;428          break;
;;;429        case LL_TIM_CHANNEL_CH3:
;;;430          result = OC3Config(TIMx, TIM_OC_InitStruct);
        0x0800085c:    4611        .F      MOV      r1,r2
        0x0800085e:    4618        .F      MOV      r0,r3
        0x08000860:    f000bc78    ..x.    B.W      OC3Config ; 0x8001154
;;;431          break;
;;;432        case LL_TIM_CHANNEL_CH4:
;;;433          result = OC4Config(TIMx, TIM_OC_InitStruct);
;;;434          break;
;;;435        default:
;;;436          break;
;;;437      }
;;;438    
;;;439      return result;
;;;440    }
        0x08000864:    4770        pG      BX       lr
        0x08000866:    0000        ..      MOVS     r0,r0
    i.LL_USART_Init
    LL_USART_Init
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;212    {
        0x08000868:    e92d41ff    -..A    PUSH     {r0-r8,lr}
        0x0800086c:    4604        .F      MOV      r4,r0
        0x0800086e:    460e        .F      MOV      r6,r1
;;;213      ErrorStatus status = ERROR;
        0x08000870:    2700        .'      MOVS     r7,#0
;;;214      uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;
        0x08000872:    2500        .%      MOVS     r5,#0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;456      return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
        0x08000874:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000876:    f3c03040    ..@0    UBFX     r0,r0,#13,#1
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;231      if (LL_USART_IsEnabled(USARTx) == 0U)
        0x0800087a:    2800        .(      CMP      r0,#0
        0x0800087c:    d15d        ].      BNE      0x800093a ; LL_USART_Init + 210
;;;232      {
;;;233        /*---------------------------- USART CR1 Configuration -----------------------
;;;234         * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:
;;;235         * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
;;;236         * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
;;;237         * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
;;;238         * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
;;;239         */
;;;240    #if defined(USART_CR1_OVER8)
;;;241        MODIFY_REG(USARTx->CR1,
;;;242                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;243                    USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;244                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;245                    USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));
;;;246    #else
;;;247        MODIFY_REG(USARTx->CR1,
        0x0800087e:    68f1        .h      LDR      r1,[r6,#0xc]
        0x08000880:    6870        ph      LDR      r0,[r6,#4]
        0x08000882:    68e2        .h      LDR      r2,[r4,#0xc]
        0x08000884:    4308        .C      ORRS     r0,r0,r1
        0x08000886:    6931        1i      LDR      r1,[r6,#0x10]
        0x08000888:    f241630c    A..c    MOV      r3,#0x160c
        0x0800088c:    439a        .C      BICS     r2,r2,r3
        0x0800088e:    4311        .C      ORRS     r1,r1,r2
        0x08000890:    4308        .C      ORRS     r0,r0,r1
        0x08000892:    60e0        .`      STR      r0,[r4,#0xc]
;;;248                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;249                    USART_CR1_TE | USART_CR1_RE),
;;;250                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;251                    USART_InitStruct->TransferDirection));
;;;252    #endif /* USART_OverSampling_Feature */
;;;253    
;;;254        /*---------------------------- USART CR2 Configuration -----------------------
;;;255         * Configure USARTx CR2 (Stop bits) with parameters:
;;;256         * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.
;;;257         * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().
;;;258         */
;;;259        LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
        0x08000894:    68b0        .h      LDR      r0,[r6,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;828      MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
        0x08000896:    6921        !i      LDR      r1,[r4,#0x10]
        0x08000898:    f4215140    !.@Q    BIC      r1,r1,#0x3000
        0x0800089c:    4301        .C      ORRS     r1,r1,r0
        0x0800089e:    6121        !a      STR      r1,[r4,#0x10]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;265        LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
        0x080008a0:    6970        pi      LDR      r0,[r6,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;972      MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
        0x080008a2:    6961        ai      LDR      r1,[r4,#0x14]
        0x080008a4:    f4217140    !.@q    BIC      r1,r1,#0x300
        0x080008a8:    4301        .C      ORRS     r1,r1,r0
        0x080008aa:    6161        aa      STR      r1,[r4,#0x14]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;270        LL_RCC_GetSystemClocksFreq(&rcc_clocks);
        0x080008ac:    4668        hF      MOV      r0,sp
        0x080008ae:    f7fffe4e    ..N.    BL       LL_RCC_GetSystemClocksFreq ; 0x800054e
;;;271        if (USARTx == USART1)
        0x080008b2:    4824        $H      LDR      r0,[pc,#144] ; [0x8000944] = 0x40013800
        0x080008b4:    4284        .B      CMP      r4,r0
        0x080008b6:    d101        ..      BNE      0x80008bc ; LL_USART_Init + 84
;;;272        {
;;;273          periphclk = rcc_clocks.PCLK2_Frequency;
        0x080008b8:    9d03        ..      LDR      r5,[sp,#0xc]
        0x080008ba:    e008        ..      B        0x80008ce ; LL_USART_Init + 102
;;;274        }
;;;275        else if (USARTx == USART2)
        0x080008bc:    4822        "H      LDR      r0,[pc,#136] ; [0x8000948] = 0x40004400
        0x080008be:    4284        .B      CMP      r4,r0
        0x080008c0:    d101        ..      BNE      0x80008c6 ; LL_USART_Init + 94
;;;276        {
;;;277          periphclk = rcc_clocks.PCLK1_Frequency;
        0x080008c2:    9d02        ..      LDR      r5,[sp,#8]
        0x080008c4:    e003        ..      B        0x80008ce ; LL_USART_Init + 102
;;;278        }
;;;279    #if defined(USART3)
;;;280        else if (USARTx == USART3)
        0x080008c6:    4821        !H      LDR      r0,[pc,#132] ; [0x800094c] = 0x40004800
        0x080008c8:    4284        .B      CMP      r4,r0
        0x080008ca:    d100        ..      BNE      0x80008ce ; LL_USART_Init + 102
;;;281        {
;;;282          periphclk = rcc_clocks.PCLK1_Frequency;
        0x080008cc:    9d02        ..      LDR      r5,[sp,#8]
;;;283        }
;;;284    #endif /* USART3 */
;;;285    #if defined(UART4)
;;;286        else if (USARTx == UART4)
;;;287        {
;;;288          periphclk = rcc_clocks.PCLK1_Frequency;
;;;289        }
;;;290    #endif /* UART4 */
;;;291    #if defined(UART5)
;;;292        else if (USARTx == UART5)
;;;293        {
;;;294          periphclk = rcc_clocks.PCLK1_Frequency;
;;;295        }
;;;296    #endif /* UART5 */
;;;297        else
;;;298        {
;;;299          /* Nothing to do, as error code is already assigned to ERROR value */
;;;300        }
;;;301    
;;;302        /* Configure the USART Baud Rate :
;;;303           - valid baud rate value (different from 0) is required
;;;304           - Peripheral clock as returned by RCC service, should be valid (different from 0).
;;;305        */
;;;306        if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
        0x080008ce:    b3a5        ..      CBZ      r5,0x800093a ; LL_USART_Init + 210
;;;307            && (USART_InitStruct->BaudRate != 0U))
        0x080008d0:    6830        0h      LDR      r0,[r6,#0]
        0x080008d2:    b390        ..      CBZ      r0,0x800093a ; LL_USART_Init + 210
;;;308        {
;;;309          status = SUCCESS;
        0x080008d4:    2701        .'      MOVS     r7,#1
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1108       USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
        0x080008d6:    eb0501c5    ....    ADD      r1,r5,r5,LSL #3
        0x080008da:    eb011105    ....    ADD      r1,r1,r5,LSL #4
        0x080008de:    0080        ..      LSLS     r0,r0,#2
        0x080008e0:    fbb1f3f0    ....    UDIV     r3,r1,r0
        0x080008e4:    2264        d"      MOVS     r2,#0x64
        0x080008e6:    fbb3f3f2    ....    UDIV     r3,r3,r2
        0x080008ea:    f06f0618    o...    MVN      r6,#0x18
        0x080008ee:    4373        sC      MULS     r3,r6,r3
        0x080008f0:    fbb1f5f0    ....    UDIV     r5,r1,r0
        0x080008f4:    fbb1f6f0    ....    UDIV     r6,r1,r0
        0x080008f8:    eb050583    ....    ADD      r5,r5,r3,LSL #2
        0x080008fc:    2332        2#      MOVS     r3,#0x32
        0x080008fe:    eb031505    ....    ADD      r5,r3,r5,LSL #4
        0x08000902:    fbb5f5f2    ....    UDIV     r5,r5,r2
        0x08000906:    fbb6f6f2    ....    UDIV     r6,r6,r2
        0x0800090a:    f00505f0    ....    AND      r5,r5,#0xf0
        0x0800090e:    eb051506    ....    ADD      r5,r5,r6,LSL #4
        0x08000912:    fbb1f6f0    ....    UDIV     r6,r1,r0
        0x08000916:    fbb1f0f0    ....    UDIV     r0,r1,r0
        0x0800091a:    fbb0f0f2    ....    UDIV     r0,r0,r2
        0x0800091e:    f06f0118    o...    MVN      r1,#0x18
        0x08000922:    4348        HC      MULS     r0,r1,r0
        0x08000924:    eb060080    ....    ADD      r0,r6,r0,LSL #2
        0x08000928:    eb031000    ....    ADD      r0,r3,r0,LSL #4
        0x0800092c:    fbb0f0f2    ....    UDIV     r0,r0,r2
        0x08000930:    f000000f    ....    AND      r0,r0,#0xf
        0x08000934:    4428        (D      ADD      r0,r0,r5
        0x08000936:    b280        ..      UXTH     r0,r0
        0x08000938:    60a0        .`      STR      r0,[r4,#8]
        0x0800093a:    b004        ..      ADD      sp,sp,#0x10
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_usart.c
;;;324      return (status);
        0x0800093c:    4638        8F      MOV      r0,r7
;;;325    }
        0x0800093e:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x08000942:    0000        ..      DCW    0
        0x08000944:    40013800    .8.@    DCD    1073821696
        0x08000948:    40004400    .D.@    DCD    1073759232
        0x0800094c:    40004800    .H.@    DCD    1073760256
    $t
    i.LL_mDelay
    LL_mDelay
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c
;;;201    {
        0x08000950:    b508        ..      PUSH     {r3,lr}
        0x08000952:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x08000956:    690a        .i      LDR      r2,[r1,#0x10]
        0x08000958:    9200        ..      STR      r2,[sp,#0]
        0x0800095a:    1c42        B.      ADDS     r2,r0,#1
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_utils.c (201)
        0x0800095c:    d005        ..      BEQ      0x800096a ; LL_mDelay + 26
;;;202      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
;;;203      /* Add this code to indicate that local variable is not used */
;;;204      ((void)tmp);
;;;205    
;;;206      /* Add a period to guaranty minimum wait */
;;;207      if (Delay < LL_MAX_DELAY)
;;;208      {
;;;209        Delay++;
        0x0800095e:    1c40        @.      ADDS     r0,r0,#1
        0x08000960:    e003        ..      B        0x800096a ; LL_mDelay + 26
        0x08000962:    690a        .i      LDR      r2,[r1,#0x10]
        0x08000964:    03d2        ..      LSLS     r2,r2,#15
        0x08000966:    d500        ..      BPL      0x800096a ; LL_mDelay + 26
        0x08000968:    1e40        @.      SUBS     r0,r0,#1
;;;210      }
;;;211    
;;;212      while (Delay)
        0x0800096a:    2800        .(      CMP      r0,#0
        0x0800096c:    d1f9        ..      BNE      0x8000962 ; LL_mDelay + 18
;;;213      {
;;;214        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
;;;215        {
;;;216          Delay--;
;;;217        }
;;;218      }
;;;219    }
        0x0800096e:    bd08        ..      POP      {r3,pc}
    i.MX_DMA_Init
    MX_DMA_Init
;;; .\../Src/main.c
;;;1278   {
        0x08000970:    b508        ..      PUSH     {r3,lr}
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_bus.h
;;;288      SET_BIT(RCC->AHBENR, Periphs);
        0x08000972:    4812        .H      LDR      r0,[pc,#72] ; [0x80009bc] = 0x40021000
        0x08000974:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08000976:    f0410101    A...    ORR      r1,r1,#1
        0x0800097a:    6141        Aa      STR      r1,[r0,#0x14]
;;;289      /* Delay after an RCC peripheral clock enabling */
;;;290      tmpreg = READ_BIT(RCC->AHBENR, Periphs);
        0x0800097c:    6940        @i      LDR      r0,[r0,#0x14]
        0x0800097e:    f0000001    ....    AND      r0,r0,#1
        0x08000982:    9000        ..      STR      r0,[sp,#0]
;;; .\../Src/main.c
;;;1285     NVIC_SetPriority(DMA1_Channel4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08000984:    f000fb5e    ..^.    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000988:    2200        ."      MOVS     r2,#0
        0x0800098a:    2102        .!      MOVS     r1,#2
        0x0800098c:    f000fb41    ..A.    BL       NVIC_EncodePriority ; 0x8001012
        0x08000990:    4601        .F      MOV      r1,r0
        0x08000992:    200e        .       MOVS     r0,#0xe
        0x08000994:    f000fb5e    ..^.    BL       NVIC_SetPriority ; 0x8001054
;;;1286     NVIC_EnableIRQ(DMA1_Channel4_IRQn);
        0x08000998:    200e        .       MOVS     r0,#0xe
        0x0800099a:    f000fb2f    ../.    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;1287     /* DMA1_Channel7_IRQn interrupt configuration */
;;;1288     NVIC_SetPriority(DMA1_Channel7_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x0800099e:    f000fb51    ..Q.    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x080009a2:    2200        ."      MOVS     r2,#0
        0x080009a4:    2102        .!      MOVS     r1,#2
        0x080009a6:    f000fb34    ..4.    BL       NVIC_EncodePriority ; 0x8001012
        0x080009aa:    4601        .F      MOV      r1,r0
        0x080009ac:    2011        .       MOVS     r0,#0x11
        0x080009ae:    f000fb51    ..Q.    BL       NVIC_SetPriority ; 0x8001054
;;;1289     NVIC_EnableIRQ(DMA1_Channel7_IRQn);
        0x080009b2:    e8bd4008    ...@    POP      {r3,lr}
        0x080009b6:    2011        .       MOVS     r0,#0x11
        0x080009b8:    f000bb20    .. .    B.W      NVIC_EnableIRQ ; 0x8000ffc
    $d
        0x080009bc:    40021000    ...@    DCD    1073876992
    $t
    i.MX_GPIO_Init
    MX_GPIO_Init
;;;1290   
;;;1291   }
;;;1292   
;;;1293   /**
;;;1294     * @brief GPIO Initialization Function
;;;1295     * @param None
;;;1296     * @retval None
;;;1297     */
;;;1298   static void MX_GPIO_Init(void)
;;;1299   {
        0x080009c0:    e92d4ff0    -..O    PUSH     {r4-r11,lr}
        0x080009c4:    b085        ..      SUB      sp,sp,#0x14
;;;1300     LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x080009c6:    2114        .!      MOVS     r1,#0x14
        0x080009c8:    4668        hF      MOV      r0,sp
        0x080009ca:    f7fffbe3    ....    BL       __aeabi_memclr ; 0x8000194
;;;1301   
;;;1302     /* GPIO Ports Clock Enable */
;;;1303     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOC);
        0x080009ce:    2010        .       MOVS     r0,#0x10
        0x080009d0:    f7fffcc8    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1304     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOD);
        0x080009d4:    2020                MOVS     r0,#0x20
        0x080009d6:    f7fffcc5    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1305     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x080009da:    2004        .       MOVS     r0,#4
        0x080009dc:    f7fffcc2    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1306     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x080009e0:    2008        .       MOVS     r0,#8
        0x080009e2:    f7fffcbf    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1307   
;;;1308     /**/
;;;1309     LL_GPIO_ResetOutputPin(GPIOC, LED_Pin|MOTOR_X_DIR_Pin);
        0x080009e6:    4828        (H      LDR      r0,[pc,#160] ; [0x8000a88] = 0x4a000a0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x080009e8:    4f28        (O      LDR      r7,[pc,#160] ; [0x8000a8c] = 0x40011000
        0x080009ea:    f44f4120    O. A    MOV      r1,#0xa000
        0x080009ee:    6179        ya      STR      r1,[r7,#0x14]
;;; .\../Src/main.c
;;;1312     LL_GPIO_ResetOutputPin(GPIOA, MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin);
        0x080009f0:    f2482a82    H..*    MOV      r10,#0x8282
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x080009f4:    f8df8098    ....    LDR      r8,[pc,#152] ; [0x8000a90] = 0x40010800
        0x080009f8:    2182        .!      MOVS     r1,#0x82
        0x080009fa:    f8c81014    ....    STR      r1,[r8,#0x14]
;;; .\../Src/main.c
;;;1315     LL_GPIO_ResetOutputPin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
        0x080009fe:    f2402b02    @..+    MOV      r11,#0x202
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;851      WRITE_REG(GPIOx->BRR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU);
        0x08000a02:    f8df9090    ....    LDR      r9,[pc,#144] ; [0x8000a94] = 0x40010c00
        0x08000a06:    2502        .%      MOVS     r5,#2
        0x08000a08:    f8c95014    ...P    STR      r5,[r9,#0x14]
;;; .\../Src/main.c
;;;1318     GPIO_InitStruct.Pin = LED_Pin|MOTOR_X_DIR_Pin;
        0x08000a0c:    9000        ..      STR      r0,[sp,#0]
;;;1319     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000a0e:    2601        .&      MOVS     r6,#1
        0x08000a10:    9601        ..      STR      r6,[sp,#4]
;;;1320     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08000a12:    9502        ..      STR      r5,[sp,#8]
;;;1321     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000a14:    2400        .$      MOVS     r4,#0
        0x08000a16:    9403        ..      STR      r4,[sp,#0xc]
;;;1322     LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x08000a18:    4669        iF      MOV      r1,sp
        0x08000a1a:    4638        8F      MOV      r0,r7
        0x08000a1c:    f7fffd04    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1323   
;;;1324     /**/
;;;1325     GPIO_InitStruct.Pin = LL_GPIO_PIN_14;
        0x08000a20:    481d        .H      LDR      r0,[pc,#116] ; [0x8000a98] = 0x4400040
        0x08000a22:    9000        ..      STR      r0,[sp,#0]
;;;1326     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08000a24:    9401        ..      STR      r4,[sp,#4]
;;;1327     LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        0x08000a26:    4669        iF      MOV      r1,sp
        0x08000a28:    4638        8F      MOV      r0,r7
        0x08000a2a:    f7fffcfd    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1328   
;;;1329     /**/
;;;1330     GPIO_InitStruct.Pin = LL_GPIO_PIN_0|LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_10 
        0x08000a2e:    481b        .H      LDR      r0,[pc,#108] ; [0x8000a9c] = 0x49c31bd
        0x08000a30:    9000        ..      STR      r0,[sp,#0]
;;;1331                             |LL_GPIO_PIN_11|LL_GPIO_PIN_12|LL_GPIO_PIN_15;
;;;1332     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08000a32:    9401        ..      STR      r4,[sp,#4]
;;;1333     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000a34:    4669        iF      MOV      r1,sp
        0x08000a36:    4640        @F      MOV      r0,r8
        0x08000a38:    f7fffcf6    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1334   
;;;1335     /**/
;;;1336     GPIO_InitStruct.Pin = MOTOR_X_ENABLE_Pin|MOTOR_Z_DIR_Pin;
        0x08000a3c:    f8cda000    ....    STR      r10,[sp,#0]
;;;1337     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000a40:    9601        ..      STR      r6,[sp,#4]
;;;1338     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08000a42:    9502        ..      STR      r5,[sp,#8]
;;;1339     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000a44:    9403        ..      STR      r4,[sp,#0xc]
;;;1340     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000a46:    4669        iF      MOV      r1,sp
        0x08000a48:    4640        @F      MOV      r0,r8
        0x08000a4a:    f7fffced    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1341   
;;;1342     /**/
;;;1343     GPIO_InitStruct.Pin = MOTOR_Z_ENABLE_Pin;
        0x08000a4e:    f8cdb000    ....    STR      r11,[sp,#0]
;;;1344     GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
        0x08000a52:    9601        ..      STR      r6,[sp,#4]
;;;1345     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
        0x08000a54:    9502        ..      STR      r5,[sp,#8]
;;;1346     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000a56:    9403        ..      STR      r4,[sp,#0xc]
;;;1347     LL_GPIO_Init(MOTOR_Z_ENABLE_GPIO_Port, &GPIO_InitStruct);
        0x08000a58:    4669        iF      MOV      r1,sp
        0x08000a5a:    4648        HF      MOV      r0,r9
        0x08000a5c:    f7fffce4    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1348   
;;;1349     /**/
;;;1350     GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_14 
        0x08000a60:    480f        .H      LDR      r0,[pc,#60] ; [0x8000aa0] = 0x4f23cfe
        0x08000a62:    9000        ..      STR      r0,[sp,#0]
;;;1351                             |LL_GPIO_PIN_15|LL_GPIO_PIN_3|LL_GPIO_PIN_4|LL_GPIO_PIN_5 
;;;1352                             |LL_GPIO_PIN_9;
;;;1353     GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
        0x08000a64:    9401        ..      STR      r4,[sp,#4]
;;;1354     LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08000a66:    4669        iF      MOV      r1,sp
        0x08000a68:    4648        HF      MOV      r0,r9
        0x08000a6a:    f7fffcdd    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1355   
;;;1356     /**/
;;;1357     GPIO_InitStruct.Pin = BUTTON_1_Pin|BUTTON_2_Pin;
        0x08000a6e:    480d        .H      LDR      r0,[pc,#52] ; [0x8000aa4] = 0x4030003
        0x08000a70:    9000        ..      STR      r0,[sp,#0]
;;;1358     GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x08000a72:    2008        .       MOVS     r0,#8
        0x08000a74:    9001        ..      STR      r0,[sp,#4]
;;;1359     GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x08000a76:    9604        ..      STR      r6,[sp,#0x10]
;;;1360     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000a78:    4669        iF      MOV      r1,sp
        0x08000a7a:    4640        @F      MOV      r0,r8
        0x08000a7c:    f7fffcd4    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1361   
;;;1362   }
        0x08000a80:    b005        ..      ADD      sp,sp,#0x14
        0x08000a82:    e8bd8ff0    ....    POP      {r4-r11,pc}
    $d
        0x08000a86:    0000        ..      DCW    0
        0x08000a88:    04a000a0    ....    DCD    77594784
        0x08000a8c:    40011000    ...@    DCD    1073811456
        0x08000a90:    40010800    ...@    DCD    1073809408
        0x08000a94:    40010c00    ...@    DCD    1073810432
        0x08000a98:    04400040    @.@.    DCD    71303232
        0x08000a9c:    049c31bd    .1..    DCD    77345213
        0x08000aa0:    04f23cfe    .<..    DCD    82984190
        0x08000aa4:    04030003    ....    DCD    67305475
    $t
    i.MX_I2C2_Init
    MX_I2C2_Init
;;; .\../Src/main.c (937)
        0x08000aa8:    4770        pG      BX       lr
        0x08000aaa:    0000        ..      MOVS     r0,r0
    i.MX_TIM1_Init
    MX_TIM1_Init
;;;938    
;;;939    /**
;;;940      * @brief TIM1 Initialization Function
;;;941      * @param None
;;;942      * @retval None
;;;943      */
;;;944    static void MX_TIM1_Init(void)
;;;945    {
        0x08000aac:    b530        0.      PUSH     {r4,r5,lr}
        0x08000aae:    b093        ..      SUB      sp,sp,#0x4c
;;;946    
;;;947      /* USER CODE BEGIN TIM1_Init 0 */
;;;948    
;;;949      /* USER CODE END TIM1_Init 0 */
;;;950    
;;;951      LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x08000ab0:    2114        .!      MOVS     r1,#0x14
        0x08000ab2:    a80e        ..      ADD      r0,sp,#0x38
        0x08000ab4:    f7fffb6e    ..n.    BL       __aeabi_memclr ; 0x8000194
;;;952      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x08000ab8:    2120         !      MOVS     r1,#0x20
        0x08000aba:    a806        ..      ADD      r0,sp,#0x18
        0x08000abc:    f7fffb6a    ..j.    BL       __aeabi_memclr ; 0x8000194
;;;953      LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};
        0x08000ac0:    2118        .!      MOVS     r1,#0x18
        0x08000ac2:    4668        hF      MOV      r0,sp
        0x08000ac4:    f7fffb66    ..f.    BL       __aeabi_memclr ; 0x8000194
;;;954    
;;;955      /* Peripheral clock enable */
;;;956      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);
        0x08000ac8:    f44f6000    O..`    MOV      r0,#0x800
        0x08000acc:    f7fffc4a    ..J.    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;957    
;;;958      /* TIM1 interrupt Init */
;;;959      NVIC_SetPriority(TIM1_UP_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
        0x08000ad0:    f000fab8    ....    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000ad4:    2200        ."      MOVS     r2,#0
        0x08000ad6:    210f        .!      MOVS     r1,#0xf
        0x08000ad8:    f000fa9b    ....    BL       NVIC_EncodePriority ; 0x8001012
        0x08000adc:    4601        .F      MOV      r1,r0
        0x08000ade:    2019        .       MOVS     r0,#0x19
        0x08000ae0:    f000fab8    ....    BL       NVIC_SetPriority ; 0x8001054
;;;960      NVIC_EnableIRQ(TIM1_UP_IRQn);
        0x08000ae4:    2019        .       MOVS     r0,#0x19
        0x08000ae6:    f000fa89    ....    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;961    
;;;962      /* USER CODE BEGIN TIM1_Init 1 */
;;;963    
;;;964      /* USER CODE END TIM1_Init 1 */
;;;965      TIM_InitStruct.Prescaler = 720;
        0x08000aea:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x08000aee:    f8ad0038    ..8.    STRH     r0,[sp,#0x38]
;;;966      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x08000af2:    2400        .$      MOVS     r4,#0
        0x08000af4:    940f        ..      STR      r4,[sp,#0x3c]
;;;967      TIM_InitStruct.Autoreload = 0;
        0x08000af6:    9410        ..      STR      r4,[sp,#0x40]
;;;968      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08000af8:    9411        ..      STR      r4,[sp,#0x44]
;;;969      TIM_InitStruct.RepetitionCounter = 0;
        0x08000afa:    f88d4048    ..H@    STRB     r4,[sp,#0x48]
;;;970      LL_TIM_Init(TIM1, &TIM_InitStruct);
        0x08000afe:    4d1e        .M      LDR      r5,[pc,#120] ; [0x8000b78] = 0x40012c00
        0x08000b00:    a90e        ..      ADD      r1,sp,#0x38
        0x08000b02:    4628        (F      MOV      r0,r5
        0x08000b04:    f7fffe0a    ....    BL       LL_TIM_Init ; 0x800071c
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
        0x08000b08:    6828        (h      LDR      r0,[r5,#0]
        0x08000b0a:    f0200080     ...    BIC      r0,r0,#0x80
        0x08000b0e:    6028        (`      STR      r0,[r5,#0]
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
        0x08000b10:    68a8        .h      LDR      r0,[r5,#8]
        0x08000b12:    f2440107    D...    MOV      r1,#0x4007
        0x08000b16:    4388        .C      BICS     r0,r0,r1
        0x08000b18:    60a8        .`      STR      r0,[r5,#8]
;;; .\../Src/main.c
;;;973      LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1);
        0x08000b1a:    2101        .!      MOVS     r1,#1
        0x08000b1c:    4628        (F      MOV      r0,r5
        0x08000b1e:    f7fffe5b    ..[.    BL       LL_TIM_OC_EnablePreload ; 0x80007d8
;;;974      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
        0x08000b22:    2060        `       MOVS     r0,#0x60
        0x08000b24:    9006        ..      STR      r0,[sp,#0x18]
;;;975      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08000b26:    9407        ..      STR      r4,[sp,#0x1c]
;;;976      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x08000b28:    9408        ..      STR      r4,[sp,#0x20]
;;;977      TIM_OC_InitStruct.CompareValue = 0;
        0x08000b2a:    9409        ..      STR      r4,[sp,#0x24]
;;;978      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08000b2c:    940a        ..      STR      r4,[sp,#0x28]
;;;979      TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08000b2e:    940b        ..      STR      r4,[sp,#0x2c]
;;;980      TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x08000b30:    940c        ..      STR      r4,[sp,#0x30]
;;;981      TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
        0x08000b32:    940d        ..      STR      r4,[sp,#0x34]
;;;982      LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08000b34:    aa06        ..      ADD      r2,sp,#0x18
        0x08000b36:    2101        .!      MOVS     r1,#1
        0x08000b38:    4628        (F      MOV      r0,r5
        0x08000b3a:    f7fffe77    ..w.    BL       LL_TIM_OC_Init ; 0x800082c
;;;983      LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1);
        0x08000b3e:    2101        .!      MOVS     r1,#1
        0x08000b40:    4628        (F      MOV      r0,r5
        0x08000b42:    f7fffe1f    ....    BL       LL_TIM_OC_DisableFast ; 0x8000784
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
        0x08000b46:    6868        hh      LDR      r0,[r5,#4]
        0x08000b48:    f0200070     .p.    BIC      r0,r0,#0x70
        0x08000b4c:    6068        h`      STR      r0,[r5,#4]
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000b4e:    68a8        .h      LDR      r0,[r5,#8]
        0x08000b50:    f0200080     ...    BIC      r0,r0,#0x80
        0x08000b54:    60a8        .`      STR      r0,[r5,#8]
;;; .\../Src/main.c
;;;986      TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;
        0x08000b56:    9400        ..      STR      r4,[sp,#0]
;;;987      TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;
        0x08000b58:    9401        ..      STR      r4,[sp,#4]
;;;988      TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
        0x08000b5a:    9402        ..      STR      r4,[sp,#8]
;;;989      TIM_BDTRInitStruct.DeadTime = 0;
        0x08000b5c:    f88d400c    ...@    STRB     r4,[sp,#0xc]
;;;990      TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
        0x08000b60:    f8ad400e    ...@    STRH     r4,[sp,#0xe]
;;;991      TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
        0x08000b64:    1468        h.      ASRS     r0,r5,#17
        0x08000b66:    9004        ..      STR      r0,[sp,#0x10]
;;;992      TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
        0x08000b68:    9405        ..      STR      r4,[sp,#0x14]
;;;993      LL_TIM_BDTR_Init(TIM1, &TIM_BDTRInitStruct);
        0x08000b6a:    4669        iF      MOV      r1,sp
        0x08000b6c:    4628        (F      MOV      r0,r5
        0x08000b6e:    f7fffd05    ....    BL       LL_TIM_BDTR_Init ; 0x800057c
;;;994      /* USER CODE BEGIN TIM1_Init 2 */
;;;995    
;;;996      /* USER CODE END TIM1_Init 2 */
;;;997    
;;;998    }
        0x08000b72:    b013        ..      ADD      sp,sp,#0x4c
        0x08000b74:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08000b76:    0000        ..      DCW    0
        0x08000b78:    40012c00    .,.@    DCD    1073818624
    $t
    i.MX_TIM2_Init
    MX_TIM2_Init
;;;999    
;;;1000   /**
;;;1001     * @brief TIM2 Initialization Function
;;;1002     * @param None
;;;1003     * @retval None
;;;1004     */
;;;1005   static void MX_TIM2_Init(void)
;;;1006   {
        0x08000b7c:    b530        0.      PUSH     {r4,r5,lr}
        0x08000b7e:    b08d        ..      SUB      sp,sp,#0x34
;;;1007   
;;;1008     /* USER CODE BEGIN TIM2_Init 0 */
;;;1009   
;;;1010     /* USER CODE END TIM2_Init 0 */
;;;1011   
;;;1012     LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x08000b80:    2114        .!      MOVS     r1,#0x14
        0x08000b82:    a808        ..      ADD      r0,sp,#0x20
        0x08000b84:    f7fffb06    ....    BL       __aeabi_memclr ; 0x8000194
;;;1013     LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x08000b88:    2120         !      MOVS     r1,#0x20
        0x08000b8a:    4668        hF      MOV      r0,sp
        0x08000b8c:    f7fffb02    ....    BL       __aeabi_memclr ; 0x8000194
;;;1014   
;;;1015     /* Peripheral clock enable */
;;;1016     LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM2);
        0x08000b90:    2001        .       MOVS     r0,#1
        0x08000b92:    f7fffbdb    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800034c
;;;1017   
;;;1018     /* TIM2 interrupt Init */
;;;1019     NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),1, 0));
        0x08000b96:    f000fa55    ..U.    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000b9a:    2200        ."      MOVS     r2,#0
        0x08000b9c:    2101        .!      MOVS     r1,#1
        0x08000b9e:    f000fa38    ..8.    BL       NVIC_EncodePriority ; 0x8001012
        0x08000ba2:    4601        .F      MOV      r1,r0
        0x08000ba4:    201c        .       MOVS     r0,#0x1c
        0x08000ba6:    f000fa55    ..U.    BL       NVIC_SetPriority ; 0x8001054
;;;1020     NVIC_EnableIRQ(TIM2_IRQn);
        0x08000baa:    201c        .       MOVS     r0,#0x1c
        0x08000bac:    f000fa26    ..&.    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;1021   
;;;1022     /* USER CODE BEGIN TIM2_Init 1 */
;;;1023   
;;;1024     /* USER CODE END TIM2_Init 1 */
;;;1025     TIM_InitStruct.Prescaler = 720;
        0x08000bb0:    f44f7034    O.4p    MOV      r0,#0x2d0
        0x08000bb4:    f8ad0020    .. .    STRH     r0,[sp,#0x20]
;;;1026     TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x08000bb8:    2500        .%      MOVS     r5,#0
        0x08000bba:    9509        ..      STR      r5,[sp,#0x24]
;;;1027     TIM_InitStruct.Autoreload = 50;
        0x08000bbc:    2032        2       MOVS     r0,#0x32
        0x08000bbe:    900a        ..      STR      r0,[sp,#0x28]
;;;1028     TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08000bc0:    950b        ..      STR      r5,[sp,#0x2c]
;;;1029     LL_TIM_Init(TIM2, &TIM_InitStruct);
        0x08000bc2:    0744        D.      LSLS     r4,r0,#29
        0x08000bc4:    a908        ..      ADD      r1,sp,#0x20
        0x08000bc6:    4620         F      MOV      r0,r4
        0x08000bc8:    f7fffda8    ....    BL       LL_TIM_Init ; 0x800071c
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1198     SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
        0x08000bcc:    6820         h      LDR      r0,[r4,#0]
        0x08000bce:    f0400080    @...    ORR      r0,r0,#0x80
        0x08000bd2:    6020         `      STR      r0,[r4,#0]
;;;1199   }
;;;1200   
;;;1201   /**
;;;1202     * @brief  Disable auto-reload (ARR) preload.
;;;1203     * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
;;;1204     * @param  TIMx Timer instance
;;;1205     * @retval None
;;;1206     */
;;;1207   __STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
;;;1208   {
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
        0x08000bd4:    68a0        .h      LDR      r0,[r4,#8]
        0x08000bd6:    f2440107    D...    MOV      r1,#0x4007
        0x08000bda:    4388        .C      BICS     r0,r0,r1
        0x08000bdc:    60a0        .`      STR      r0,[r4,#8]
;;; .\../Src/main.c
;;;1032     LL_TIM_OC_EnablePreload(TIM2, LL_TIM_CHANNEL_CH1);
        0x08000bde:    2101        .!      MOVS     r1,#1
        0x08000be0:    4620         F      MOV      r0,r4
        0x08000be2:    f7fffdf9    ....    BL       LL_TIM_OC_EnablePreload ; 0x80007d8
;;;1033     TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x08000be6:    2070        p       MOVS     r0,#0x70
        0x08000be8:    9000        ..      STR      r0,[sp,#0]
;;;1034     TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08000bea:    9501        ..      STR      r5,[sp,#4]
;;;1035     TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x08000bec:    9502        ..      STR      r5,[sp,#8]
;;;1036     TIM_OC_InitStruct.CompareValue = 48;
        0x08000bee:    2030        0       MOVS     r0,#0x30
        0x08000bf0:    9003        ..      STR      r0,[sp,#0xc]
;;;1037     TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08000bf2:    9504        ..      STR      r5,[sp,#0x10]
;;;1038     LL_TIM_OC_Init(TIM2, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08000bf4:    466a        jF      MOV      r2,sp
        0x08000bf6:    2101        .!      MOVS     r1,#1
        0x08000bf8:    4620         F      MOV      r0,r4
        0x08000bfa:    f7fffe17    ....    BL       LL_TIM_OC_Init ; 0x800082c
;;;1039     LL_TIM_OC_DisableFast(TIM2, LL_TIM_CHANNEL_CH1);
        0x08000bfe:    2101        .!      MOVS     r1,#1
        0x08000c00:    4620         F      MOV      r0,r4
        0x08000c02:    f7fffdbf    ....    BL       LL_TIM_OC_DisableFast ; 0x8000784
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
        0x08000c06:    6860        `h      LDR      r0,[r4,#4]
        0x08000c08:    f0200070     .p.    BIC      r0,r0,#0x70
        0x08000c0c:    f0400020    @. .    ORR      r0,r0,#0x20
        0x08000c10:    6060        ``      STR      r0,[r4,#4]
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000c12:    68a0        .h      LDR      r0,[r4,#8]
        0x08000c14:    f0400080    @...    ORR      r0,r0,#0x80
        0x08000c18:    60a0        .`      STR      r0,[r4,#8]
;;; .\../Src/main.c
;;;1046   }
        0x08000c1a:    b00d        ..      ADD      sp,sp,#0x34
        0x08000c1c:    bd30        0.      POP      {r4,r5,pc}
        0x08000c1e:    0000        ..      MOVS     r0,r0
    i.MX_TIM3_Init
    MX_TIM3_Init
;;;1047   
;;;1048   /**
;;;1049     * @brief TIM3 Initialization Function
;;;1050     * @param None
;;;1051     * @retval None
;;;1052     */
;;;1053   static void MX_TIM3_Init(void)
;;;1054   {
        0x08000c20:    b570        p.      PUSH     {r4-r6,lr}
        0x08000c22:    b092        ..      SUB      sp,sp,#0x48
;;;1055   
;;;1056     /* USER CODE BEGIN TIM3_Init 0 */
;;;1057   
;;;1058     /* USER CODE END TIM3_Init 0 */
;;;1059   
;;;1060     LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x08000c24:    2114        .!      MOVS     r1,#0x14
        0x08000c26:    a80d        ..      ADD      r0,sp,#0x34
        0x08000c28:    f7fffab4    ....    BL       __aeabi_memclr ; 0x8000194
;;;1061     LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
        0x08000c2c:    2120         !      MOVS     r1,#0x20
        0x08000c2e:    a805        ..      ADD      r0,sp,#0x14
        0x08000c30:    f7fffab0    ....    BL       __aeabi_memclr ; 0x8000194
;;;1062   
;;;1063     LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x08000c34:    2114        .!      MOVS     r1,#0x14
        0x08000c36:    4668        hF      MOV      r0,sp
        0x08000c38:    f7fffaac    ....    BL       __aeabi_memclr ; 0x8000194
;;;1064   
;;;1065     /* Peripheral clock enable */
;;;1066     LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM3);
        0x08000c3c:    2002        .       MOVS     r0,#2
        0x08000c3e:    f7fffb85    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800034c
;;;1067   
;;;1068     /* TIM3 interrupt Init */
;;;1069     NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08000c42:    f000f9ff    ....    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000c46:    2200        ."      MOVS     r2,#0
        0x08000c48:    4611        .F      MOV      r1,r2
        0x08000c4a:    f000f9e2    ....    BL       NVIC_EncodePriority ; 0x8001012
        0x08000c4e:    4601        .F      MOV      r1,r0
        0x08000c50:    201d        .       MOVS     r0,#0x1d
        0x08000c52:    f000f9ff    ....    BL       NVIC_SetPriority ; 0x8001054
;;;1070     NVIC_EnableIRQ(TIM3_IRQn);
        0x08000c56:    201d        .       MOVS     r0,#0x1d
        0x08000c58:    f000f9d0    ....    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;1071   
;;;1072     /* USER CODE BEGIN TIM3_Init 1 */
;;;1073     NVIC_SetPriority(TIM3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),1, 0));
        0x08000c5c:    f000f9f2    ....    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000c60:    2200        ."      MOVS     r2,#0
        0x08000c62:    2101        .!      MOVS     r1,#1
        0x08000c64:    f000f9d5    ....    BL       NVIC_EncodePriority ; 0x8001012
        0x08000c68:    4601        .F      MOV      r1,r0
        0x08000c6a:    201d        .       MOVS     r0,#0x1d
        0x08000c6c:    f000f9f2    ....    BL       NVIC_SetPriority ; 0x8001054
;;;1074     NVIC_EnableIRQ(TIM3_IRQn);
        0x08000c70:    201d        .       MOVS     r0,#0x1d
        0x08000c72:    f000f9c3    ....    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;1075   
;;;1076     /* USER CODE END TIM3_Init 1 */
;;;1077     TIM_InitStruct.Prescaler = 0;
        0x08000c76:    2500        .%      MOVS     r5,#0
        0x08000c78:    f8ad5034    ..4P    STRH     r5,[sp,#0x34]
;;;1078     TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x08000c7c:    950e        ..      STR      r5,[sp,#0x38]
;;;1079     TIM_InitStruct.Autoreload = min_pulse;
        0x08000c7e:    f24020d5    @..     MOV      r0,#0x2d5
        0x08000c82:    900f        ..      STR      r0,[sp,#0x3c]
;;;1080     TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08000c84:    9510        ..      STR      r5,[sp,#0x40]
;;;1081     LL_TIM_Init(TIM3, &TIM_InitStruct);
        0x08000c86:    4c38        8L      LDR      r4,[pc,#224] ; [0x8000d68] = 0x40000400
        0x08000c88:    a90d        ..      ADD      r1,sp,#0x34
        0x08000c8a:    4620         F      MOV      r0,r4
        0x08000c8c:    f7fffd46    ..F.    BL       LL_TIM_Init ; 0x800071c
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1198     SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
        0x08000c90:    6820         h      LDR      r0,[r4,#0]
        0x08000c92:    f0400080    @...    ORR      r0,r0,#0x80
        0x08000c96:    6020         `      STR      r0,[r4,#0]
;;;1199   }
;;;1200   
;;;1201   /**
;;;1202     * @brief  Disable auto-reload (ARR) preload.
;;;1203     * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
;;;1204     * @param  TIMx Timer instance
;;;1205     * @retval None
;;;1206     */
;;;1207   __STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
;;;1208   {
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
        0x08000c98:    68a0        .h      LDR      r0,[r4,#8]
        0x08000c9a:    f2440107    D...    MOV      r1,#0x4007
        0x08000c9e:    4388        .C      BICS     r0,r0,r1
        0x08000ca0:    60a0        .`      STR      r0,[r4,#8]
;;; .\../Src/main.c
;;;1084     LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH1);
        0x08000ca2:    2101        .!      MOVS     r1,#1
        0x08000ca4:    4620         F      MOV      r0,r4
        0x08000ca6:    f7fffd97    ....    BL       LL_TIM_OC_EnablePreload ; 0x80007d8
;;;1085     TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM2;
        0x08000caa:    2070        p       MOVS     r0,#0x70
        0x08000cac:    9005        ..      STR      r0,[sp,#0x14]
;;;1086     TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08000cae:    9506        ..      STR      r5,[sp,#0x18]
;;;1087     TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x08000cb0:    9507        ..      STR      r5,[sp,#0x1c]
;;;1088     TIM_OC_InitStruct.CompareValue = 1;
        0x08000cb2:    2001        .       MOVS     r0,#1
        0x08000cb4:    9008        ..      STR      r0,[sp,#0x20]
;;;1089     TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
        0x08000cb6:    9509        ..      STR      r5,[sp,#0x24]
;;;1090     LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
        0x08000cb8:    aa05        ..      ADD      r2,sp,#0x14
        0x08000cba:    2101        .!      MOVS     r1,#1
        0x08000cbc:    4620         F      MOV      r0,r4
        0x08000cbe:    f7fffdb5    ....    BL       LL_TIM_OC_Init ; 0x800082c
;;;1091     LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH1);
        0x08000cc2:    2101        .!      MOVS     r1,#1
        0x08000cc4:    4620         F      MOV      r0,r4
        0x08000cc6:    f7fffd5d    ..].    BL       LL_TIM_OC_DisableFast ; 0x8000784
;;;1092     LL_TIM_OC_EnablePreload(TIM3, LL_TIM_CHANNEL_CH3);
        0x08000cca:    15a6        ..      ASRS     r6,r4,#22
        0x08000ccc:    4631        1F      MOV      r1,r6
        0x08000cce:    4620         F      MOV      r0,r4
        0x08000cd0:    f7fffd82    ....    BL       LL_TIM_OC_EnablePreload ; 0x80007d8
;;;1093     TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
        0x08000cd4:    9506        ..      STR      r5,[sp,#0x18]
;;;1094     TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
        0x08000cd6:    9507        ..      STR      r5,[sp,#0x1c]
;;;1095     LL_TIM_OC_Init(TIM3, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
        0x08000cd8:    aa05        ..      ADD      r2,sp,#0x14
        0x08000cda:    4631        1F      MOV      r1,r6
        0x08000cdc:    4620         F      MOV      r0,r4
        0x08000cde:    f7fffda5    ....    BL       LL_TIM_OC_Init ; 0x800082c
;;;1096     LL_TIM_OC_DisableFast(TIM3, LL_TIM_CHANNEL_CH3);
        0x08000ce2:    4631        1F      MOV      r1,r6
        0x08000ce4:    4620         F      MOV      r0,r4
        0x08000ce6:    f7fffd4d    ..M.    BL       LL_TIM_OC_DisableFast ; 0x8000784
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1130     MODIFY_REG(TIMx->CR1, TIM_CR1_OPM, OnePulseMode);
        0x08000cea:    6820         h      LDR      r0,[r4,#0]
        0x08000cec:    f0400008    @...    ORR      r0,r0,#8
        0x08000cf0:    6020         `      STR      r0,[r4,#0]
;;;1131   }
;;;1132   
;;;1133   /**
;;;1134     * @brief  Get actual one pulse mode.
;;;1135     * @rmtoll CR1          OPM           LL_TIM_GetOnePulseMode
;;;1136     * @param  TIMx Timer instance
;;;1137     * @retval Returned value can be one of the following values:
;;;1138     *         @arg @ref LL_TIM_ONEPULSEMODE_SINGLE
;;;1139     *         @arg @ref LL_TIM_ONEPULSEMODE_REPETITIVE
;;;1140     */
;;;1141   __STATIC_INLINE uint32_t LL_TIM_GetOnePulseMode(TIM_TypeDef *TIMx)
;;;1142   {
;;;1143     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_OPM));
;;;1144   }
;;;1145   
;;;1146   /**
;;;1147     * @brief  Set the timer counter counting mode.
;;;1148     * @note Macro @ref IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to
;;;1149     *       check whether or not the counter mode selection feature is supported
;;;1150     *       by a timer instance.
;;;1151     * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
;;;1152     *       requires a timer reset to avoid unexpected direction
;;;1153     *       due to DIR bit readonly in center aligned mode.
;;;1154     * @rmtoll CR1          DIR           LL_TIM_SetCounterMode\n
;;;1155     *         CR1          CMS           LL_TIM_SetCounterMode
;;;1156     * @param  TIMx Timer instance
;;;1157     * @param  CounterMode This parameter can be one of the following values:
;;;1158     *         @arg @ref LL_TIM_COUNTERMODE_UP
;;;1159     *         @arg @ref LL_TIM_COUNTERMODE_DOWN
;;;1160     *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP
;;;1161     *         @arg @ref LL_TIM_COUNTERMODE_CENTER_DOWN
;;;1162     *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
;;;1163     * @retval None
;;;1164     */
;;;1165   __STATIC_INLINE void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
;;;1166   {
;;;1167     MODIFY_REG(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS, CounterMode);
;;;1168   }
;;;1169   
;;;1170   /**
;;;1171     * @brief  Get actual counter mode.
;;;1172     * @note Macro @ref IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx) can be used to
;;;1173     *       check whether or not the counter mode selection feature is supported
;;;1174     *       by a timer instance.
;;;1175     * @rmtoll CR1          DIR           LL_TIM_GetCounterMode\n
;;;1176     *         CR1          CMS           LL_TIM_GetCounterMode
;;;1177     * @param  TIMx Timer instance
;;;1178     * @retval Returned value can be one of the following values:
;;;1179     *         @arg @ref LL_TIM_COUNTERMODE_UP
;;;1180     *         @arg @ref LL_TIM_COUNTERMODE_DOWN
;;;1181     *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP
;;;1182     *         @arg @ref LL_TIM_COUNTERMODE_CENTER_DOWN
;;;1183     *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
;;;1184     */
;;;1185   __STATIC_INLINE uint32_t LL_TIM_GetCounterMode(TIM_TypeDef *TIMx)
;;;1186   {
;;;1187     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS));
;;;1188   }
;;;1189   
;;;1190   /**
;;;1191     * @brief  Enable auto-reload (ARR) preload.
;;;1192     * @rmtoll CR1          ARPE          LL_TIM_EnableARRPreload
;;;1193     * @param  TIMx Timer instance
;;;1194     * @retval None
;;;1195     */
;;;1196   __STATIC_INLINE void LL_TIM_EnableARRPreload(TIM_TypeDef *TIMx)
;;;1197   {
;;;1198     SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
;;;1199   }
;;;1200   
;;;1201   /**
;;;1202     * @brief  Disable auto-reload (ARR) preload.
;;;1203     * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
;;;1204     * @param  TIMx Timer instance
;;;1205     * @retval None
;;;1206     */
;;;1207   __STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
;;;1208   {
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
;;;2550   }
;;;2551   
;;;2552   /**
;;;2553     * @}
;;;2554     */
;;;2555   
;;;2556   /** @defgroup TIM_LL_EF_Timer_Synchronization Timer synchronisation configuration
;;;2557     * @{
;;;2558     */
;;;2559   /**
;;;2560     * @brief  Set the trigger output (TRGO) used for timer synchronization .
;;;2561     * @note Macro @ref IS_TIM_MASTER_INSTANCE(TIMx) can be used to check
;;;2562     *       whether or not a timer instance can operate as a master timer.
;;;2563     * @rmtoll CR2          MMS           LL_TIM_SetTriggerOutput
;;;2564     * @param  TIMx Timer instance
;;;2565     * @param  TimerSynchronization This parameter can be one of the following values:
;;;2566     *         @arg @ref LL_TIM_TRGO_RESET
;;;2567     *         @arg @ref LL_TIM_TRGO_ENABLE
;;;2568     *         @arg @ref LL_TIM_TRGO_UPDATE
;;;2569     *         @arg @ref LL_TIM_TRGO_CC1IF
;;;2570     *         @arg @ref LL_TIM_TRGO_OC1REF
;;;2571     *         @arg @ref LL_TIM_TRGO_OC2REF
;;;2572     *         @arg @ref LL_TIM_TRGO_OC3REF
;;;2573     *         @arg @ref LL_TIM_TRGO_OC4REF
;;;2574     * @retval None
;;;2575     */
;;;2576   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
;;;2577   {
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x08000cf2:    68a0        .h      LDR      r0,[r4,#8]
        0x08000cf4:    f0200070     .p.    BIC      r0,r0,#0x70
        0x08000cf8:    f0400010    @...    ORR      r0,r0,#0x10
        0x08000cfc:    60a0        .`      STR      r0,[r4,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2596)
        0x08000cfe:    68a0        .h      LDR      r0,[r4,#8]
        0x08000d00:    f0200007     ...    BIC      r0,r0,#7
        0x08000d04:    f0400006    @...    ORR      r0,r0,#6
        0x08000d08:    60a0        .`      STR      r0,[r4,#8]
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2645   }
;;;2646   
;;;2647   /**
;;;2648     * @brief Indicates whether the Master/Slave mode is enabled.
;;;2649     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2650     * a timer instance can operate as a slave timer.
;;;2651     * @rmtoll SMCR         MSM           LL_TIM_IsEnabledMasterSlaveMode
;;;2652     * @param  TIMx Timer instance
;;;2653     * @retval State of bit (1 or 0).
;;;2654     */
;;;2655   __STATIC_INLINE uint32_t LL_TIM_IsEnabledMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2656   {
;;;2657     return (READ_BIT(TIMx->SMCR, TIM_SMCR_MSM) == (TIM_SMCR_MSM));
;;;2658   }
;;;2659   
;;;2660   /**
;;;2661     * @brief  Configure the external trigger (ETR) input.
;;;2662     * @note Macro @ref IS_TIM_ETR_INSTANCE(TIMx) can be used to check whether or not
;;;2663     *       a timer instance provides an external trigger input.
;;;2664     * @rmtoll SMCR         ETP           LL_TIM_ConfigETR\n
;;;2665     *         SMCR         ETPS          LL_TIM_ConfigETR\n
;;;2666     *         SMCR         ETF           LL_TIM_ConfigETR
;;;2667     * @param  TIMx Timer instance
;;;2668     * @param  ETRPolarity This parameter can be one of the following values:
;;;2669     *         @arg @ref LL_TIM_ETR_POLARITY_NONINVERTED
;;;2670     *         @arg @ref LL_TIM_ETR_POLARITY_INVERTED
;;;2671     * @param  ETRPrescaler This parameter can be one of the following values:
;;;2672     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV1
;;;2673     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV2
;;;2674     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV4
;;;2675     *         @arg @ref LL_TIM_ETR_PRESCALER_DIV8
;;;2676     * @param  ETRFilter This parameter can be one of the following values:
;;;2677     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1
;;;2678     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N2
;;;2679     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N4
;;;2680     *         @arg @ref LL_TIM_ETR_FILTER_FDIV1_N8
;;;2681     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N6
;;;2682     *         @arg @ref LL_TIM_ETR_FILTER_FDIV2_N8
;;;2683     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N6
;;;2684     *         @arg @ref LL_TIM_ETR_FILTER_FDIV4_N8
;;;2685     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N6
;;;2686     *         @arg @ref LL_TIM_ETR_FILTER_FDIV8_N8
;;;2687     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N5
;;;2688     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N6
;;;2689     *         @arg @ref LL_TIM_ETR_FILTER_FDIV16_N8
;;;2690     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N5
;;;2691     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N6
;;;2692     *         @arg @ref LL_TIM_ETR_FILTER_FDIV32_N8
;;;2693     * @retval None
;;;2694     */
;;;2695   __STATIC_INLINE void LL_TIM_ConfigETR(TIM_TypeDef *TIMx, uint32_t ETRPolarity, uint32_t ETRPrescaler,
;;;2696                                         uint32_t ETRFilter)
;;;2697   {
;;;2698     MODIFY_REG(TIMx->SMCR, TIM_SMCR_ETP | TIM_SMCR_ETPS | TIM_SMCR_ETF, ETRPolarity | ETRPrescaler | ETRFilter);
;;;2699   }
;;;2700   
;;;2701   /**
;;;2702     * @}
;;;2703     */
;;;2704   
;;;2705   /** @defgroup TIM_LL_EF_Break_Function Break function configuration
;;;2706     * @{
;;;2707     */
;;;2708   /**
;;;2709     * @brief  Enable the break function.
;;;2710     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2711     *       a timer instance provides a break input.
;;;2712     * @rmtoll BDTR         BKE           LL_TIM_EnableBRK
;;;2713     * @param  TIMx Timer instance
;;;2714     * @retval None
;;;2715     */
;;;2716   __STATIC_INLINE void LL_TIM_EnableBRK(TIM_TypeDef *TIMx)
;;;2717   {
;;;2718     SET_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2719   }
;;;2720   
;;;2721   /**
;;;2722     * @brief  Disable the break function.
;;;2723     * @rmtoll BDTR         BKE           LL_TIM_DisableBRK
;;;2724     * @param  TIMx Timer instance
;;;2725     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2726     *       a timer instance provides a break input.
;;;2727     * @retval None
;;;2728     */
;;;2729   __STATIC_INLINE void LL_TIM_DisableBRK(TIM_TypeDef *TIMx)
;;;2730   {
;;;2731     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_BKE);
;;;2732   }
;;;2733   
;;;2734   /**
;;;2735     * @brief  Configure the break input.
;;;2736     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2737     *       a timer instance provides a break input.
;;;2738     * @rmtoll BDTR         BKP           LL_TIM_ConfigBRK
;;;2739     * @param  TIMx Timer instance
;;;2740     * @param  BreakPolarity This parameter can be one of the following values:
;;;2741     *         @arg @ref LL_TIM_BREAK_POLARITY_LOW
;;;2742     *         @arg @ref LL_TIM_BREAK_POLARITY_HIGH
;;;2743     * @retval None
;;;2744     */
;;;2745   __STATIC_INLINE void LL_TIM_ConfigBRK(TIM_TypeDef *TIMx, uint32_t BreakPolarity)
;;;2746   {
;;;2747     MODIFY_REG(TIMx->BDTR, TIM_BDTR_BKP, BreakPolarity);
;;;2748   }
;;;2749   
;;;2750   /**
;;;2751     * @brief  Select the outputs off state (enabled v.s. disabled) in Idle and Run modes.
;;;2752     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2753     *       a timer instance provides a break input.
;;;2754     * @rmtoll BDTR         OSSI          LL_TIM_SetOffStates\n
;;;2755     *         BDTR         OSSR          LL_TIM_SetOffStates
;;;2756     * @param  TIMx Timer instance
;;;2757     * @param  OffStateIdle This parameter can be one of the following values:
;;;2758     *         @arg @ref LL_TIM_OSSI_DISABLE
;;;2759     *         @arg @ref LL_TIM_OSSI_ENABLE
;;;2760     * @param  OffStateRun This parameter can be one of the following values:
;;;2761     *         @arg @ref LL_TIM_OSSR_DISABLE
;;;2762     *         @arg @ref LL_TIM_OSSR_ENABLE
;;;2763     * @retval None
;;;2764     */
;;;2765   __STATIC_INLINE void LL_TIM_SetOffStates(TIM_TypeDef *TIMx, uint32_t OffStateIdle, uint32_t OffStateRun)
;;;2766   {
;;;2767     MODIFY_REG(TIMx->BDTR, TIM_BDTR_OSSI | TIM_BDTR_OSSR, OffStateIdle | OffStateRun);
;;;2768   }
;;;2769   
;;;2770   /**
;;;2771     * @brief  Enable automatic output (MOE can be set by software or automatically when a break input is active).
;;;2772     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2773     *       a timer instance provides a break input.
;;;2774     * @rmtoll BDTR         AOE           LL_TIM_EnableAutomaticOutput
;;;2775     * @param  TIMx Timer instance
;;;2776     * @retval None
;;;2777     */
;;;2778   __STATIC_INLINE void LL_TIM_EnableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2779   {
;;;2780     SET_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2781   }
;;;2782   
;;;2783   /**
;;;2784     * @brief  Disable automatic output (MOE can be set only by software).
;;;2785     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2786     *       a timer instance provides a break input.
;;;2787     * @rmtoll BDTR         AOE           LL_TIM_DisableAutomaticOutput
;;;2788     * @param  TIMx Timer instance
;;;2789     * @retval None
;;;2790     */
;;;2791   __STATIC_INLINE void LL_TIM_DisableAutomaticOutput(TIM_TypeDef *TIMx)
;;;2792   {
;;;2793     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_AOE);
;;;2794   }
;;;2795   
;;;2796   /**
;;;2797     * @brief  Indicate whether automatic output is enabled.
;;;2798     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2799     *       a timer instance provides a break input.
;;;2800     * @rmtoll BDTR         AOE           LL_TIM_IsEnabledAutomaticOutput
;;;2801     * @param  TIMx Timer instance
;;;2802     * @retval State of bit (1 or 0).
;;;2803     */
;;;2804   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAutomaticOutput(TIM_TypeDef *TIMx)
;;;2805   {
;;;2806     return (READ_BIT(TIMx->BDTR, TIM_BDTR_AOE) == (TIM_BDTR_AOE));
;;;2807   }
;;;2808   
;;;2809   /**
;;;2810     * @brief  Enable the outputs (set the MOE bit in TIMx_BDTR register).
;;;2811     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2812     *       software and is reset in case of break or break2 event
;;;2813     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2814     *       a timer instance provides a break input.
;;;2815     * @rmtoll BDTR         MOE           LL_TIM_EnableAllOutputs
;;;2816     * @param  TIMx Timer instance
;;;2817     * @retval None
;;;2818     */
;;;2819   __STATIC_INLINE void LL_TIM_EnableAllOutputs(TIM_TypeDef *TIMx)
;;;2820   {
;;;2821     SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2822   }
;;;2823   
;;;2824   /**
;;;2825     * @brief  Disable the outputs (reset the MOE bit in TIMx_BDTR register).
;;;2826     * @note The MOE bit in TIMx_BDTR register allows to enable /disable the outputs by
;;;2827     *       software and is reset in case of break or break2 event.
;;;2828     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2829     *       a timer instance provides a break input.
;;;2830     * @rmtoll BDTR         MOE           LL_TIM_DisableAllOutputs
;;;2831     * @param  TIMx Timer instance
;;;2832     * @retval None
;;;2833     */
;;;2834   __STATIC_INLINE void LL_TIM_DisableAllOutputs(TIM_TypeDef *TIMx)
;;;2835   {
;;;2836     CLEAR_BIT(TIMx->BDTR, TIM_BDTR_MOE);
;;;2837   }
;;;2838   
;;;2839   /**
;;;2840     * @brief  Indicates whether outputs are enabled.
;;;2841     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;2842     *       a timer instance provides a break input.
;;;2843     * @rmtoll BDTR         MOE           LL_TIM_IsEnabledAllOutputs
;;;2844     * @param  TIMx Timer instance
;;;2845     * @retval State of bit (1 or 0).
;;;2846     */
;;;2847   __STATIC_INLINE uint32_t LL_TIM_IsEnabledAllOutputs(TIM_TypeDef *TIMx)
;;;2848   {
;;;2849     return (READ_BIT(TIMx->BDTR, TIM_BDTR_MOE) == (TIM_BDTR_MOE));
;;;2850   }
;;;2851   
;;;2852   /**
;;;2853     * @}
;;;2854     */
;;;2855   
;;;2856   /** @defgroup TIM_LL_EF_DMA_Burst_Mode DMA burst mode configuration
;;;2857     * @{
;;;2858     */
;;;2859   /**
;;;2860     * @brief  Configures the timer DMA burst feature.
;;;2861     * @note Macro @ref IS_TIM_DMABURST_INSTANCE(TIMx) can be used to check whether or
;;;2862     *       not a timer instance supports the DMA burst mode.
;;;2863     * @rmtoll DCR          DBL           LL_TIM_ConfigDMABurst\n
;;;2864     *         DCR          DBA           LL_TIM_ConfigDMABurst
;;;2865     * @param  TIMx Timer instance
;;;2866     * @param  DMABurstBaseAddress This parameter can be one of the following values:
;;;2867     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR1
;;;2868     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CR2
;;;2869     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SMCR
;;;2870     *         @arg @ref LL_TIM_DMABURST_BASEADDR_DIER
;;;2871     *         @arg @ref LL_TIM_DMABURST_BASEADDR_SR
;;;2872     *         @arg @ref LL_TIM_DMABURST_BASEADDR_EGR
;;;2873     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR1
;;;2874     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCMR2
;;;2875     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCER
;;;2876     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CNT
;;;2877     *         @arg @ref LL_TIM_DMABURST_BASEADDR_PSC
;;;2878     *         @arg @ref LL_TIM_DMABURST_BASEADDR_ARR
;;;2879     *         @arg @ref LL_TIM_DMABURST_BASEADDR_RCR
;;;2880     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR1
;;;2881     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR2
;;;2882     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR3
;;;2883     *         @arg @ref LL_TIM_DMABURST_BASEADDR_CCR4
;;;2884     *         @arg @ref LL_TIM_DMABURST_BASEADDR_BDTR
;;;2885     * @param  DMABurstLength This parameter can be one of the following values:
;;;2886     *         @arg @ref LL_TIM_DMABURST_LENGTH_1TRANSFER
;;;2887     *         @arg @ref LL_TIM_DMABURST_LENGTH_2TRANSFERS
;;;2888     *         @arg @ref LL_TIM_DMABURST_LENGTH_3TRANSFERS
;;;2889     *         @arg @ref LL_TIM_DMABURST_LENGTH_4TRANSFERS
;;;2890     *         @arg @ref LL_TIM_DMABURST_LENGTH_5TRANSFERS
;;;2891     *         @arg @ref LL_TIM_DMABURST_LENGTH_6TRANSFERS
;;;2892     *         @arg @ref LL_TIM_DMABURST_LENGTH_7TRANSFERS
;;;2893     *         @arg @ref LL_TIM_DMABURST_LENGTH_8TRANSFERS
;;;2894     *         @arg @ref LL_TIM_DMABURST_LENGTH_9TRANSFERS
;;;2895     *         @arg @ref LL_TIM_DMABURST_LENGTH_10TRANSFERS
;;;2896     *         @arg @ref LL_TIM_DMABURST_LENGTH_11TRANSFERS
;;;2897     *         @arg @ref LL_TIM_DMABURST_LENGTH_12TRANSFERS
;;;2898     *         @arg @ref LL_TIM_DMABURST_LENGTH_13TRANSFERS
;;;2899     *         @arg @ref LL_TIM_DMABURST_LENGTH_14TRANSFERS
;;;2900     *         @arg @ref LL_TIM_DMABURST_LENGTH_15TRANSFERS
;;;2901     *         @arg @ref LL_TIM_DMABURST_LENGTH_16TRANSFERS
;;;2902     *         @arg @ref LL_TIM_DMABURST_LENGTH_17TRANSFERS
;;;2903     *         @arg @ref LL_TIM_DMABURST_LENGTH_18TRANSFERS
;;;2904     * @retval None
;;;2905     */
;;;2906   __STATIC_INLINE void LL_TIM_ConfigDMABurst(TIM_TypeDef *TIMx, uint32_t DMABurstBaseAddress, uint32_t DMABurstLength)
;;;2907   {
;;;2908     MODIFY_REG(TIMx->DCR, TIM_DCR_DBL | TIM_DCR_DBA, DMABurstBaseAddress | DMABurstLength);
;;;2909   }
;;;2910   
;;;2911   /**
;;;2912     * @}
;;;2913     */
;;;2914   
;;;2915   
;;;2916   /**
;;;2917     * @}
;;;2918     */
;;;2919   
;;;2920   
;;;2921   /** @defgroup TIM_LL_EF_FLAG_Management FLAG-Management
;;;2922     * @{
;;;2923     */
;;;2924   /**
;;;2925     * @brief  Clear the update interrupt flag (UIF).
;;;2926     * @rmtoll SR           UIF           LL_TIM_ClearFlag_UPDATE
;;;2927     * @param  TIMx Timer instance
;;;2928     * @retval None
;;;2929     */
;;;2930   __STATIC_INLINE void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2931   {
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3204   }
;;;3205   
;;;3206   /**
;;;3207     * @brief  Disable update interrupt (UIE).
;;;3208     * @rmtoll DIER         UIE           LL_TIM_DisableIT_UPDATE
;;;3209     * @param  TIMx Timer instance
;;;3210     * @retval None
;;;3211     */
;;;3212   __STATIC_INLINE void LL_TIM_DisableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3213   {
;;;3214     CLEAR_BIT(TIMx->DIER, TIM_DIER_UIE);
;;;3215   }
;;;3216   
;;;3217   /**
;;;3218     * @brief  Indicates whether the update interrupt (UIE) is enabled.
;;;3219     * @rmtoll DIER         UIE           LL_TIM_IsEnabledIT_UPDATE
;;;3220     * @param  TIMx Timer instance
;;;3221     * @retval State of bit (1 or 0).
;;;3222     */
;;;3223   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_UPDATE(TIM_TypeDef *TIMx)
;;;3224   {
;;;3225     return (READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE));
;;;3226   }
;;;3227   
;;;3228   /**
;;;3229     * @brief  Enable capture/compare 1 interrupt (CC1IE).
;;;3230     * @rmtoll DIER         CC1IE         LL_TIM_EnableIT_CC1
;;;3231     * @param  TIMx Timer instance
;;;3232     * @retval None
;;;3233     */
;;;3234   __STATIC_INLINE void LL_TIM_EnableIT_CC1(TIM_TypeDef *TIMx)
;;;3235   {
;;;3236     SET_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3237   }
;;;3238   
;;;3239   /**
;;;3240     * @brief  Disable capture/compare 1  interrupt (CC1IE).
;;;3241     * @rmtoll DIER         CC1IE         LL_TIM_DisableIT_CC1
;;;3242     * @param  TIMx Timer instance
;;;3243     * @retval None
;;;3244     */
;;;3245   __STATIC_INLINE void LL_TIM_DisableIT_CC1(TIM_TypeDef *TIMx)
;;;3246   {
;;;3247     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1IE);
;;;3248   }
;;;3249   
;;;3250   /**
;;;3251     * @brief  Indicates whether the capture/compare 1 interrupt (CC1IE) is enabled.
;;;3252     * @rmtoll DIER         CC1IE         LL_TIM_IsEnabledIT_CC1
;;;3253     * @param  TIMx Timer instance
;;;3254     * @retval State of bit (1 or 0).
;;;3255     */
;;;3256   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC1(TIM_TypeDef *TIMx)
;;;3257   {
;;;3258     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1IE) == (TIM_DIER_CC1IE));
;;;3259   }
;;;3260   
;;;3261   /**
;;;3262     * @brief  Enable capture/compare 2 interrupt (CC2IE).
;;;3263     * @rmtoll DIER         CC2IE         LL_TIM_EnableIT_CC2
;;;3264     * @param  TIMx Timer instance
;;;3265     * @retval None
;;;3266     */
;;;3267   __STATIC_INLINE void LL_TIM_EnableIT_CC2(TIM_TypeDef *TIMx)
;;;3268   {
;;;3269     SET_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3270   }
;;;3271   
;;;3272   /**
;;;3273     * @brief  Disable capture/compare 2  interrupt (CC2IE).
;;;3274     * @rmtoll DIER         CC2IE         LL_TIM_DisableIT_CC2
;;;3275     * @param  TIMx Timer instance
;;;3276     * @retval None
;;;3277     */
;;;3278   __STATIC_INLINE void LL_TIM_DisableIT_CC2(TIM_TypeDef *TIMx)
;;;3279   {
;;;3280     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2IE);
;;;3281   }
;;;3282   
;;;3283   /**
;;;3284     * @brief  Indicates whether the capture/compare 2 interrupt (CC2IE) is enabled.
;;;3285     * @rmtoll DIER         CC2IE         LL_TIM_IsEnabledIT_CC2
;;;3286     * @param  TIMx Timer instance
;;;3287     * @retval State of bit (1 or 0).
;;;3288     */
;;;3289   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC2(TIM_TypeDef *TIMx)
;;;3290   {
;;;3291     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2IE) == (TIM_DIER_CC2IE));
;;;3292   }
;;;3293   
;;;3294   /**
;;;3295     * @brief  Enable capture/compare 3 interrupt (CC3IE).
;;;3296     * @rmtoll DIER         CC3IE         LL_TIM_EnableIT_CC3
;;;3297     * @param  TIMx Timer instance
;;;3298     * @retval None
;;;3299     */
;;;3300   __STATIC_INLINE void LL_TIM_EnableIT_CC3(TIM_TypeDef *TIMx)
;;;3301   {
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3303   }
;;;3304   
;;;3305   /**
;;;3306     * @brief  Disable capture/compare 3  interrupt (CC3IE).
;;;3307     * @rmtoll DIER         CC3IE         LL_TIM_DisableIT_CC3
;;;3308     * @param  TIMx Timer instance
;;;3309     * @retval None
;;;3310     */
;;;3311   __STATIC_INLINE void LL_TIM_DisableIT_CC3(TIM_TypeDef *TIMx)
;;;3312   {
;;;3313     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3IE);
;;;3314   }
;;;3315   
;;;3316   /**
;;;3317     * @brief  Indicates whether the capture/compare 3 interrupt (CC3IE) is enabled.
;;;3318     * @rmtoll DIER         CC3IE         LL_TIM_IsEnabledIT_CC3
;;;3319     * @param  TIMx Timer instance
;;;3320     * @retval State of bit (1 or 0).
;;;3321     */
;;;3322   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC3(TIM_TypeDef *TIMx)
;;;3323   {
;;;3324     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3IE) == (TIM_DIER_CC3IE));
;;;3325   }
;;;3326   
;;;3327   /**
;;;3328     * @brief  Enable capture/compare 4 interrupt (CC4IE).
;;;3329     * @rmtoll DIER         CC4IE         LL_TIM_EnableIT_CC4
;;;3330     * @param  TIMx Timer instance
;;;3331     * @retval None
;;;3332     */
;;;3333   __STATIC_INLINE void LL_TIM_EnableIT_CC4(TIM_TypeDef *TIMx)
;;;3334   {
;;;3335     SET_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3336   }
;;;3337   
;;;3338   /**
;;;3339     * @brief  Disable capture/compare 4  interrupt (CC4IE).
;;;3340     * @rmtoll DIER         CC4IE         LL_TIM_DisableIT_CC4
;;;3341     * @param  TIMx Timer instance
;;;3342     * @retval None
;;;3343     */
;;;3344   __STATIC_INLINE void LL_TIM_DisableIT_CC4(TIM_TypeDef *TIMx)
;;;3345   {
;;;3346     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4IE);
;;;3347   }
;;;3348   
;;;3349   /**
;;;3350     * @brief  Indicates whether the capture/compare 4 interrupt (CC4IE) is enabled.
;;;3351     * @rmtoll DIER         CC4IE         LL_TIM_IsEnabledIT_CC4
;;;3352     * @param  TIMx Timer instance
;;;3353     * @retval State of bit (1 or 0).
;;;3354     */
;;;3355   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_CC4(TIM_TypeDef *TIMx)
;;;3356   {
;;;3357     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4IE) == (TIM_DIER_CC4IE));
;;;3358   }
;;;3359   
;;;3360   /**
;;;3361     * @brief  Enable commutation interrupt (COMIE).
;;;3362     * @rmtoll DIER         COMIE         LL_TIM_EnableIT_COM
;;;3363     * @param  TIMx Timer instance
;;;3364     * @retval None
;;;3365     */
;;;3366   __STATIC_INLINE void LL_TIM_EnableIT_COM(TIM_TypeDef *TIMx)
;;;3367   {
;;;3368     SET_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3369   }
;;;3370   
;;;3371   /**
;;;3372     * @brief  Disable commutation interrupt (COMIE).
;;;3373     * @rmtoll DIER         COMIE         LL_TIM_DisableIT_COM
;;;3374     * @param  TIMx Timer instance
;;;3375     * @retval None
;;;3376     */
;;;3377   __STATIC_INLINE void LL_TIM_DisableIT_COM(TIM_TypeDef *TIMx)
;;;3378   {
;;;3379     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMIE);
;;;3380   }
;;;3381   
;;;3382   /**
;;;3383     * @brief  Indicates whether the commutation interrupt (COMIE) is enabled.
;;;3384     * @rmtoll DIER         COMIE         LL_TIM_IsEnabledIT_COM
;;;3385     * @param  TIMx Timer instance
;;;3386     * @retval State of bit (1 or 0).
;;;3387     */
;;;3388   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_COM(TIM_TypeDef *TIMx)
;;;3389   {
;;;3390     return (READ_BIT(TIMx->DIER, TIM_DIER_COMIE) == (TIM_DIER_COMIE));
;;;3391   }
;;;3392   
;;;3393   /**
;;;3394     * @brief  Enable trigger interrupt (TIE).
;;;3395     * @rmtoll DIER         TIE           LL_TIM_EnableIT_TRIG
;;;3396     * @param  TIMx Timer instance
;;;3397     * @retval None
;;;3398     */
;;;3399   __STATIC_INLINE void LL_TIM_EnableIT_TRIG(TIM_TypeDef *TIMx)
;;;3400   {
;;;3401     SET_BIT(TIMx->DIER, TIM_DIER_TIE);
;;;3402   }
;;;3403   
;;;3404   /**
;;;3405     * @brief  Disable trigger interrupt (TIE).
;;;3406     * @rmtoll DIER         TIE           LL_TIM_DisableIT_TRIG
;;;3407     * @param  TIMx Timer instance
;;;3408     * @retval None
;;;3409     */
;;;3410   __STATIC_INLINE void LL_TIM_DisableIT_TRIG(TIM_TypeDef *TIMx)
;;;3411   {
;;;3412     CLEAR_BIT(TIMx->DIER, TIM_DIER_TIE);
        0x08000d0a:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000d0c:    f0200040     .@.    BIC      r0,r0,#0x40
        0x08000d10:    60e0        .`      STR      r0,[r4,#0xc]
;;;3413   }
;;;3414   
;;;3415   /**
;;;3416     * @brief  Indicates whether the trigger interrupt (TIE) is enabled.
;;;3417     * @rmtoll DIER         TIE           LL_TIM_IsEnabledIT_TRIG
;;;3418     * @param  TIMx Timer instance
;;;3419     * @retval State of bit (1 or 0).
;;;3420     */
;;;3421   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_TRIG(TIM_TypeDef *TIMx)
;;;3422   {
;;;3423     return (READ_BIT(TIMx->DIER, TIM_DIER_TIE) == (TIM_DIER_TIE));
;;;3424   }
;;;3425   
;;;3426   /**
;;;3427     * @brief  Enable break interrupt (BIE).
;;;3428     * @rmtoll DIER         BIE           LL_TIM_EnableIT_BRK
;;;3429     * @param  TIMx Timer instance
;;;3430     * @retval None
;;;3431     */
;;;3432   __STATIC_INLINE void LL_TIM_EnableIT_BRK(TIM_TypeDef *TIMx)
;;;3433   {
;;;3434     SET_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3435   }
;;;3436   
;;;3437   /**
;;;3438     * @brief  Disable break interrupt (BIE).
;;;3439     * @rmtoll DIER         BIE           LL_TIM_DisableIT_BRK
;;;3440     * @param  TIMx Timer instance
;;;3441     * @retval None
;;;3442     */
;;;3443   __STATIC_INLINE void LL_TIM_DisableIT_BRK(TIM_TypeDef *TIMx)
;;;3444   {
;;;3445     CLEAR_BIT(TIMx->DIER, TIM_DIER_BIE);
;;;3446   }
;;;3447   
;;;3448   /**
;;;3449     * @brief  Indicates whether the break interrupt (BIE) is enabled.
;;;3450     * @rmtoll DIER         BIE           LL_TIM_IsEnabledIT_BRK
;;;3451     * @param  TIMx Timer instance
;;;3452     * @retval State of bit (1 or 0).
;;;3453     */
;;;3454   __STATIC_INLINE uint32_t LL_TIM_IsEnabledIT_BRK(TIM_TypeDef *TIMx)
;;;3455   {
;;;3456     return (READ_BIT(TIMx->DIER, TIM_DIER_BIE) == (TIM_DIER_BIE));
;;;3457   }
;;;3458   
;;;3459   /**
;;;3460     * @}
;;;3461     */
;;;3462   
;;;3463   /** @defgroup TIM_LL_EF_DMA_Management DMA-Management
;;;3464     * @{
;;;3465     */
;;;3466   /**
;;;3467     * @brief  Enable update DMA request (UDE).
;;;3468     * @rmtoll DIER         UDE           LL_TIM_EnableDMAReq_UPDATE
;;;3469     * @param  TIMx Timer instance
;;;3470     * @retval None
;;;3471     */
;;;3472   __STATIC_INLINE void LL_TIM_EnableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3473   {
;;;3474     SET_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3475   }
;;;3476   
;;;3477   /**
;;;3478     * @brief  Disable update DMA request (UDE).
;;;3479     * @rmtoll DIER         UDE           LL_TIM_DisableDMAReq_UPDATE
;;;3480     * @param  TIMx Timer instance
;;;3481     * @retval None
;;;3482     */
;;;3483   __STATIC_INLINE void LL_TIM_DisableDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3484   {
;;;3485     CLEAR_BIT(TIMx->DIER, TIM_DIER_UDE);
;;;3486   }
;;;3487   
;;;3488   /**
;;;3489     * @brief  Indicates whether the update DMA request  (UDE) is enabled.
;;;3490     * @rmtoll DIER         UDE           LL_TIM_IsEnabledDMAReq_UPDATE
;;;3491     * @param  TIMx Timer instance
;;;3492     * @retval State of bit (1 or 0).
;;;3493     */
;;;3494   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_UPDATE(TIM_TypeDef *TIMx)
;;;3495   {
;;;3496     return (READ_BIT(TIMx->DIER, TIM_DIER_UDE) == (TIM_DIER_UDE));
;;;3497   }
;;;3498   
;;;3499   /**
;;;3500     * @brief  Enable capture/compare 1 DMA request (CC1DE).
;;;3501     * @rmtoll DIER         CC1DE         LL_TIM_EnableDMAReq_CC1
;;;3502     * @param  TIMx Timer instance
;;;3503     * @retval None
;;;3504     */
;;;3505   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3506   {
;;;3507     SET_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3508   }
;;;3509   
;;;3510   /**
;;;3511     * @brief  Disable capture/compare 1  DMA request (CC1DE).
;;;3512     * @rmtoll DIER         CC1DE         LL_TIM_DisableDMAReq_CC1
;;;3513     * @param  TIMx Timer instance
;;;3514     * @retval None
;;;3515     */
;;;3516   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3517   {
;;;3518     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC1DE);
;;;3519   }
;;;3520   
;;;3521   /**
;;;3522     * @brief  Indicates whether the capture/compare 1 DMA request (CC1DE) is enabled.
;;;3523     * @rmtoll DIER         CC1DE         LL_TIM_IsEnabledDMAReq_CC1
;;;3524     * @param  TIMx Timer instance
;;;3525     * @retval State of bit (1 or 0).
;;;3526     */
;;;3527   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC1(TIM_TypeDef *TIMx)
;;;3528   {
;;;3529     return (READ_BIT(TIMx->DIER, TIM_DIER_CC1DE) == (TIM_DIER_CC1DE));
;;;3530   }
;;;3531   
;;;3532   /**
;;;3533     * @brief  Enable capture/compare 2 DMA request (CC2DE).
;;;3534     * @rmtoll DIER         CC2DE         LL_TIM_EnableDMAReq_CC2
;;;3535     * @param  TIMx Timer instance
;;;3536     * @retval None
;;;3537     */
;;;3538   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3539   {
;;;3540     SET_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3541   }
;;;3542   
;;;3543   /**
;;;3544     * @brief  Disable capture/compare 2  DMA request (CC2DE).
;;;3545     * @rmtoll DIER         CC2DE         LL_TIM_DisableDMAReq_CC2
;;;3546     * @param  TIMx Timer instance
;;;3547     * @retval None
;;;3548     */
;;;3549   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3550   {
;;;3551     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC2DE);
;;;3552   }
;;;3553   
;;;3554   /**
;;;3555     * @brief  Indicates whether the capture/compare 2 DMA request (CC2DE) is enabled.
;;;3556     * @rmtoll DIER         CC2DE         LL_TIM_IsEnabledDMAReq_CC2
;;;3557     * @param  TIMx Timer instance
;;;3558     * @retval State of bit (1 or 0).
;;;3559     */
;;;3560   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC2(TIM_TypeDef *TIMx)
;;;3561   {
;;;3562     return (READ_BIT(TIMx->DIER, TIM_DIER_CC2DE) == (TIM_DIER_CC2DE));
;;;3563   }
;;;3564   
;;;3565   /**
;;;3566     * @brief  Enable capture/compare 3 DMA request (CC3DE).
;;;3567     * @rmtoll DIER         CC3DE         LL_TIM_EnableDMAReq_CC3
;;;3568     * @param  TIMx Timer instance
;;;3569     * @retval None
;;;3570     */
;;;3571   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3572   {
;;;3573     SET_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3574   }
;;;3575   
;;;3576   /**
;;;3577     * @brief  Disable capture/compare 3  DMA request (CC3DE).
;;;3578     * @rmtoll DIER         CC3DE         LL_TIM_DisableDMAReq_CC3
;;;3579     * @param  TIMx Timer instance
;;;3580     * @retval None
;;;3581     */
;;;3582   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3583   {
;;;3584     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC3DE);
;;;3585   }
;;;3586   
;;;3587   /**
;;;3588     * @brief  Indicates whether the capture/compare 3 DMA request (CC3DE) is enabled.
;;;3589     * @rmtoll DIER         CC3DE         LL_TIM_IsEnabledDMAReq_CC3
;;;3590     * @param  TIMx Timer instance
;;;3591     * @retval State of bit (1 or 0).
;;;3592     */
;;;3593   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC3(TIM_TypeDef *TIMx)
;;;3594   {
;;;3595     return (READ_BIT(TIMx->DIER, TIM_DIER_CC3DE) == (TIM_DIER_CC3DE));
;;;3596   }
;;;3597   
;;;3598   /**
;;;3599     * @brief  Enable capture/compare 4 DMA request (CC4DE).
;;;3600     * @rmtoll DIER         CC4DE         LL_TIM_EnableDMAReq_CC4
;;;3601     * @param  TIMx Timer instance
;;;3602     * @retval None
;;;3603     */
;;;3604   __STATIC_INLINE void LL_TIM_EnableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3605   {
;;;3606     SET_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3607   }
;;;3608   
;;;3609   /**
;;;3610     * @brief  Disable capture/compare 4  DMA request (CC4DE).
;;;3611     * @rmtoll DIER         CC4DE         LL_TIM_DisableDMAReq_CC4
;;;3612     * @param  TIMx Timer instance
;;;3613     * @retval None
;;;3614     */
;;;3615   __STATIC_INLINE void LL_TIM_DisableDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3616   {
;;;3617     CLEAR_BIT(TIMx->DIER, TIM_DIER_CC4DE);
;;;3618   }
;;;3619   
;;;3620   /**
;;;3621     * @brief  Indicates whether the capture/compare 4 DMA request (CC4DE) is enabled.
;;;3622     * @rmtoll DIER         CC4DE         LL_TIM_IsEnabledDMAReq_CC4
;;;3623     * @param  TIMx Timer instance
;;;3624     * @retval State of bit (1 or 0).
;;;3625     */
;;;3626   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_CC4(TIM_TypeDef *TIMx)
;;;3627   {
;;;3628     return (READ_BIT(TIMx->DIER, TIM_DIER_CC4DE) == (TIM_DIER_CC4DE));
;;;3629   }
;;;3630   
;;;3631   /**
;;;3632     * @brief  Enable commutation DMA request (COMDE).
;;;3633     * @rmtoll DIER         COMDE         LL_TIM_EnableDMAReq_COM
;;;3634     * @param  TIMx Timer instance
;;;3635     * @retval None
;;;3636     */
;;;3637   __STATIC_INLINE void LL_TIM_EnableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3638   {
;;;3639     SET_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3640   }
;;;3641   
;;;3642   /**
;;;3643     * @brief  Disable commutation DMA request (COMDE).
;;;3644     * @rmtoll DIER         COMDE         LL_TIM_DisableDMAReq_COM
;;;3645     * @param  TIMx Timer instance
;;;3646     * @retval None
;;;3647     */
;;;3648   __STATIC_INLINE void LL_TIM_DisableDMAReq_COM(TIM_TypeDef *TIMx)
;;;3649   {
;;;3650     CLEAR_BIT(TIMx->DIER, TIM_DIER_COMDE);
;;;3651   }
;;;3652   
;;;3653   /**
;;;3654     * @brief  Indicates whether the commutation DMA request (COMDE) is enabled.
;;;3655     * @rmtoll DIER         COMDE         LL_TIM_IsEnabledDMAReq_COM
;;;3656     * @param  TIMx Timer instance
;;;3657     * @retval State of bit (1 or 0).
;;;3658     */
;;;3659   __STATIC_INLINE uint32_t LL_TIM_IsEnabledDMAReq_COM(TIM_TypeDef *TIMx)
;;;3660   {
;;;3661     return (READ_BIT(TIMx->DIER, TIM_DIER_COMDE) == (TIM_DIER_COMDE));
;;;3662   }
;;;3663   
;;;3664   /**
;;;3665     * @brief  Enable trigger interrupt (TDE).
;;;3666     * @rmtoll DIER         TDE           LL_TIM_EnableDMAReq_TRIG
;;;3667     * @param  TIMx Timer instance
;;;3668     * @retval None
;;;3669     */
;;;3670   __STATIC_INLINE void LL_TIM_EnableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3671   {
;;;3672     SET_BIT(TIMx->DIER, TIM_DIER_TDE);
;;;3673   }
;;;3674   
;;;3675   /**
;;;3676     * @brief  Disable trigger interrupt (TDE).
;;;3677     * @rmtoll DIER         TDE           LL_TIM_DisableDMAReq_TRIG
;;;3678     * @param  TIMx Timer instance
;;;3679     * @retval None
;;;3680     */
;;;3681   __STATIC_INLINE void LL_TIM_DisableDMAReq_TRIG(TIM_TypeDef *TIMx)
;;;3682   {
;;;3683     CLEAR_BIT(TIMx->DIER, TIM_DIER_TDE);
        0x08000d12:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000d14:    f4204080     ..@    BIC      r0,r0,#0x4000
        0x08000d18:    60e0        .`      STR      r0,[r4,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2578)
        0x08000d1a:    6860        `h      LDR      r0,[r4,#4]
        0x08000d1c:    f0200070     .p.    BIC      r0,r0,#0x70
        0x08000d20:    6060        ``      STR      r0,[r4,#4]
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
;;;2632   }
;;;2633   
;;;2634   /**
;;;2635     * @brief  Disable the Master/Slave mode.
;;;2636     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2637     *       a timer instance can operate as a slave timer.
;;;2638     * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
;;;2639     * @param  TIMx Timer instance
;;;2640     * @retval None
;;;2641     */
;;;2642   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2643   {
;;;2644     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000d22:    68a0        .h      LDR      r0,[r4,#8]
        0x08000d24:    f0200080     ...    BIC      r0,r0,#0x80
        0x08000d28:    60a0        .`      STR      r0,[r4,#8]
;;; .\../Src/main.c
;;;1107     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08000d2a:    2004        .       MOVS     r0,#4
        0x08000d2c:    f7fffb1a    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1108     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x08000d30:    2008        .       MOVS     r0,#8
        0x08000d32:    f7fffb17    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1109     /**TIM3 GPIO Configuration  
;;;1110     PA6   ------> TIM3_CH1
;;;1111     PB0   ------> TIM3_CH3 
;;;1112     */
;;;1113     GPIO_InitStruct.Pin = MOTOR_X_STEP_Pin;
        0x08000d36:    f2440040    D.@.    MOV      r0,#0x4040
        0x08000d3a:    9000        ..      STR      r0,[sp,#0]
;;;1114     GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x08000d3c:    2409        .$      MOVS     r4,#9
        0x08000d3e:    9401        ..      STR      r4,[sp,#4]
;;;1115     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x08000d40:    2603        .&      MOVS     r6,#3
        0x08000d42:    9602        ..      STR      r6,[sp,#8]
;;;1116     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000d44:    9503        ..      STR      r5,[sp,#0xc]
;;;1117     LL_GPIO_Init(MOTOR_X_STEP_GPIO_Port, &GPIO_InitStruct);
        0x08000d46:    4669        iF      MOV      r1,sp
        0x08000d48:    4808        .H      LDR      r0,[pc,#32] ; [0x8000d6c] = 0x40010800
        0x08000d4a:    f7fffb6d    ..m.    BL       LL_GPIO_Init ; 0x8000428
;;;1118   
;;;1119     GPIO_InitStruct.Pin = MOTOR_Z_STEP_Pin;
        0x08000d4e:    f2401001    @...    MOV      r0,#0x101
        0x08000d52:    9000        ..      STR      r0,[sp,#0]
;;;1120     GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x08000d54:    9401        ..      STR      r4,[sp,#4]
;;;1121     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x08000d56:    9602        ..      STR      r6,[sp,#8]
;;;1122     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000d58:    9503        ..      STR      r5,[sp,#0xc]
;;;1123     LL_GPIO_Init(MOTOR_Z_STEP_GPIO_Port, &GPIO_InitStruct);
        0x08000d5a:    4669        iF      MOV      r1,sp
        0x08000d5c:    4804        .H      LDR      r0,[pc,#16] ; [0x8000d70] = 0x40010c00
        0x08000d5e:    f7fffb63    ..c.    BL       LL_GPIO_Init ; 0x8000428
;;;1124   
;;;1125   }
        0x08000d62:    b012        ..      ADD      sp,sp,#0x48
        0x08000d64:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000d66:    0000        ..      DCW    0
        0x08000d68:    40000400    ...@    DCD    1073742848
        0x08000d6c:    40010800    ...@    DCD    1073809408
        0x08000d70:    40010c00    ...@    DCD    1073810432
    $t
    i.MX_TIM4_Init
    MX_TIM4_Init
;;;1126   
;;;1127   /**
;;;1128     * @brief TIM4 Initialization Function
;;;1129     * @param None
;;;1130     * @retval None
;;;1131     */
;;;1132   static void MX_TIM4_Init(void)
;;;1133   {
        0x08000d74:    b570        p.      PUSH     {r4-r6,lr}
        0x08000d76:    b08a        ..      SUB      sp,sp,#0x28
;;;1134   
;;;1135     /* USER CODE BEGIN TIM4_Init 0 */
;;;1136   
;;;1137     /* USER CODE END TIM4_Init 0 */
;;;1138   
;;;1139     LL_TIM_InitTypeDef TIM_InitStruct = {0};
        0x08000d78:    2114        .!      MOVS     r1,#0x14
        0x08000d7a:    a805        ..      ADD      r0,sp,#0x14
        0x08000d7c:    f7fffa0a    ....    BL       __aeabi_memclr ; 0x8000194
;;;1140   
;;;1141     LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x08000d80:    2114        .!      MOVS     r1,#0x14
        0x08000d82:    4668        hF      MOV      r0,sp
        0x08000d84:    f7fffa06    ....    BL       __aeabi_memclr ; 0x8000194
;;;1142   
;;;1143     /* Peripheral clock enable */
;;;1144     LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM4);
        0x08000d88:    2004        .       MOVS     r0,#4
        0x08000d8a:    f7fffadf    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800034c
;;;1145     
;;;1146     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
        0x08000d8e:    2008        .       MOVS     r0,#8
        0x08000d90:    f7fffae8    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1147     /**TIM4 GPIO Configuration  
;;;1148     PB6   ------> TIM4_CH1
;;;1149     PB7   ------> TIM4_CH2
;;;1150     PB8   ------> TIM4_CH3 
;;;1151     */
;;;1152     GPIO_InitStruct.Pin = ENC_A_Pin|ENC_B_Pin|ENC_ZERO_Pin;
        0x08000d94:    483b        ;H      LDR      r0,[pc,#236] ; [0x8000e84] = 0x401c0c1
        0x08000d96:    9000        ..      STR      r0,[sp,#0]
;;;1153     GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
        0x08000d98:    2408        .$      MOVS     r4,#8
        0x08000d9a:    9401        ..      STR      r4,[sp,#4]
;;;1154     GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
        0x08000d9c:    2001        .       MOVS     r0,#1
        0x08000d9e:    9004        ..      STR      r0,[sp,#0x10]
;;;1155     LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
        0x08000da0:    4669        iF      MOV      r1,sp
        0x08000da2:    4839        9H      LDR      r0,[pc,#228] ; [0x8000e88] = 0x40010c00
        0x08000da4:    f7fffb40    ..@.    BL       LL_GPIO_Init ; 0x8000428
;;;1156   
;;;1157     /* TIM4 interrupt Init */
;;;1158     NVIC_SetPriority(TIM4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
        0x08000da8:    f000f94c    ..L.    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000dac:    2200        ."      MOVS     r2,#0
        0x08000dae:    4611        .F      MOV      r1,r2
        0x08000db0:    f000f92f    ../.    BL       NVIC_EncodePriority ; 0x8001012
        0x08000db4:    4601        .F      MOV      r1,r0
        0x08000db6:    201e        .       MOVS     r0,#0x1e
        0x08000db8:    f000f94c    ..L.    BL       NVIC_SetPriority ; 0x8001054
;;;1159     NVIC_EnableIRQ(TIM4_IRQn);
        0x08000dbc:    201e        .       MOVS     r0,#0x1e
        0x08000dbe:    f000f91d    ....    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;1160   
;;;1161     /* USER CODE BEGIN TIM4_Init 1 */
;;;1162   
;;;1163     /* USER CODE END TIM4_Init 1 */
;;;1164     TIM_InitStruct.Prescaler = 0;
        0x08000dc2:    2000        .       MOVS     r0,#0
        0x08000dc4:    f8ad0014    ....    STRH     r0,[sp,#0x14]
;;;1165     TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
        0x08000dc8:    9006        ..      STR      r0,[sp,#0x18]
;;;1166     TIM_InitStruct.Autoreload = 8;
        0x08000dca:    9407        ..      STR      r4,[sp,#0x1c]
;;;1167     TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
        0x08000dcc:    9008        ..      STR      r0,[sp,#0x20]
;;;1168     LL_TIM_Init(TIM4, &TIM_InitStruct);
        0x08000dce:    4c2f        /L      LDR      r4,[pc,#188] ; [0x8000e8c] = 0x40000800
        0x08000dd0:    a905        ..      ADD      r1,sp,#0x14
        0x08000dd2:    4620         F      MOV      r0,r4
        0x08000dd4:    f7fffca2    ....    BL       LL_TIM_Init ; 0x800071c
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1209     CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
        0x08000dd8:    6820         h      LDR      r0,[r4,#0]
        0x08000dda:    f0200080     ...    BIC      r0,r0,#0x80
        0x08000dde:    6020         `      STR      r0,[r4,#0]
;;;1210   }
;;;1211   
;;;1212   /**
;;;1213     * @brief  Indicates whether auto-reload (ARR) preload is enabled.
;;;1214     * @rmtoll CR1          ARPE          LL_TIM_IsEnabledARRPreload
;;;1215     * @param  TIMx Timer instance
;;;1216     * @retval State of bit (1 or 0).
;;;1217     */
;;;1218   __STATIC_INLINE uint32_t LL_TIM_IsEnabledARRPreload(TIM_TypeDef *TIMx)
;;;1219   {
;;;1220     return (READ_BIT(TIMx->CR1, TIM_CR1_ARPE) == (TIM_CR1_ARPE));
;;;1221   }
;;;1222   
;;;1223   /**
;;;1224     * @brief  Set the division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1225     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1226     *       whether or not the clock division feature is supported by the timer
;;;1227     *       instance.
;;;1228     * @rmtoll CR1          CKD           LL_TIM_SetClockDivision
;;;1229     * @param  TIMx Timer instance
;;;1230     * @param  ClockDivision This parameter can be one of the following values:
;;;1231     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1232     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1233     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1234     * @retval None
;;;1235     */
;;;1236   __STATIC_INLINE void LL_TIM_SetClockDivision(TIM_TypeDef *TIMx, uint32_t ClockDivision)
;;;1237   {
;;;1238     MODIFY_REG(TIMx->CR1, TIM_CR1_CKD, ClockDivision);
;;;1239   }
;;;1240   
;;;1241   /**
;;;1242     * @brief  Get the actual division ratio between the timer clock  and the sampling clock used by the dead-time generators (when supported) and the digital filters.
;;;1243     * @note Macro @ref IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx) can be used to check
;;;1244     *       whether or not the clock division feature is supported by the timer
;;;1245     *       instance.
;;;1246     * @rmtoll CR1          CKD           LL_TIM_GetClockDivision
;;;1247     * @param  TIMx Timer instance
;;;1248     * @retval Returned value can be one of the following values:
;;;1249     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV1
;;;1250     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV2
;;;1251     *         @arg @ref LL_TIM_CLOCKDIVISION_DIV4
;;;1252     */
;;;1253   __STATIC_INLINE uint32_t LL_TIM_GetClockDivision(TIM_TypeDef *TIMx)
;;;1254   {
;;;1255     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_CKD));
;;;1256   }
;;;1257   
;;;1258   /**
;;;1259     * @brief  Set the counter value.
;;;1260     * @rmtoll CNT          CNT           LL_TIM_SetCounter
;;;1261     * @param  TIMx Timer instance
;;;1262     * @param  Counter Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1263     * @retval None
;;;1264     */
;;;1265   __STATIC_INLINE void LL_TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t Counter)
;;;1266   {
;;;1267     WRITE_REG(TIMx->CNT, Counter);
;;;1268   }
;;;1269   
;;;1270   /**
;;;1271     * @brief  Get the counter value.
;;;1272     * @rmtoll CNT          CNT           LL_TIM_GetCounter
;;;1273     * @param  TIMx Timer instance
;;;1274     * @retval Counter value (between Min_Data=0 and Max_Data=0xFFFF)
;;;1275     */
;;;1276   __STATIC_INLINE uint32_t LL_TIM_GetCounter(TIM_TypeDef *TIMx)
;;;1277   {
;;;1278     return (uint32_t)(READ_REG(TIMx->CNT));
;;;1279   }
;;;1280   
;;;1281   /**
;;;1282     * @brief  Get the current direction of the counter
;;;1283     * @rmtoll CR1          DIR           LL_TIM_GetDirection
;;;1284     * @param  TIMx Timer instance
;;;1285     * @retval Returned value can be one of the following values:
;;;1286     *         @arg @ref LL_TIM_COUNTERDIRECTION_UP
;;;1287     *         @arg @ref LL_TIM_COUNTERDIRECTION_DOWN
;;;1288     */
;;;1289   __STATIC_INLINE uint32_t LL_TIM_GetDirection(TIM_TypeDef *TIMx)
;;;1290   {
;;;1291     return (uint32_t)(READ_BIT(TIMx->CR1, TIM_CR1_DIR));
;;;1292   }
;;;1293   
;;;1294   /**
;;;1295     * @brief  Set the prescaler value.
;;;1296     * @note The counter clock frequency CK_CNT is equal to fCK_PSC / (PSC[15:0] + 1).
;;;1297     * @note The prescaler can be changed on the fly as this control register is buffered. The new
;;;1298     *       prescaler ratio is taken into account at the next update event.
;;;1299     * @note Helper macro @ref __LL_TIM_CALC_PSC can be used to calculate the Prescaler parameter
;;;1300     * @rmtoll PSC          PSC           LL_TIM_SetPrescaler
;;;1301     * @param  TIMx Timer instance
;;;1302     * @param  Prescaler between Min_Data=0 and Max_Data=65535
;;;1303     * @retval None
;;;1304     */
;;;1305   __STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
;;;1306   {
;;;1307     WRITE_REG(TIMx->PSC, Prescaler);
;;;1308   }
;;;1309   
;;;1310   /**
;;;1311     * @brief  Get the prescaler value.
;;;1312     * @rmtoll PSC          PSC           LL_TIM_GetPrescaler
;;;1313     * @param  TIMx Timer instance
;;;1314     * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
;;;1315     */
;;;1316   __STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
;;;1317   {
;;;1318     return (uint32_t)(READ_REG(TIMx->PSC));
;;;1319   }
;;;1320   
;;;1321   /**
;;;1322     * @brief  Set the auto-reload value.
;;;1323     * @note The counter is blocked while the auto-reload value is null.
;;;1324     * @note Helper macro @ref __LL_TIM_CALC_ARR can be used to calculate the AutoReload parameter
;;;1325     * @rmtoll ARR          ARR           LL_TIM_SetAutoReload
;;;1326     * @param  TIMx Timer instance
;;;1327     * @param  AutoReload between Min_Data=0 and Max_Data=65535
;;;1328     * @retval None
;;;1329     */
;;;1330   __STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
;;;1331   {
;;;1332     WRITE_REG(TIMx->ARR, AutoReload);
;;;1333   }
;;;1334   
;;;1335   /**
;;;1336     * @brief  Get the auto-reload value.
;;;1337     * @rmtoll ARR          ARR           LL_TIM_GetAutoReload
;;;1338     * @param  TIMx Timer instance
;;;1339     * @retval Auto-reload value
;;;1340     */
;;;1341   __STATIC_INLINE uint32_t LL_TIM_GetAutoReload(TIM_TypeDef *TIMx)
;;;1342   {
;;;1343     return (uint32_t)(READ_REG(TIMx->ARR));
;;;1344   }
;;;1345   
;;;1346   /**
;;;1347     * @brief  Set the repetition counter value.
;;;1348     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1349     *       whether or not a timer instance supports a repetition counter.
;;;1350     * @rmtoll RCR          REP           LL_TIM_SetRepetitionCounter
;;;1351     * @param  TIMx Timer instance
;;;1352     * @param  RepetitionCounter between Min_Data=0 and Max_Data=255
;;;1353     * @retval None
;;;1354     */
;;;1355   __STATIC_INLINE void LL_TIM_SetRepetitionCounter(TIM_TypeDef *TIMx, uint32_t RepetitionCounter)
;;;1356   {
;;;1357     WRITE_REG(TIMx->RCR, RepetitionCounter);
;;;1358   }
;;;1359   
;;;1360   /**
;;;1361     * @brief  Get the repetition counter value.
;;;1362     * @note Macro @ref IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx) can be used to check
;;;1363     *       whether or not a timer instance supports a repetition counter.
;;;1364     * @rmtoll RCR          REP           LL_TIM_GetRepetitionCounter
;;;1365     * @param  TIMx Timer instance
;;;1366     * @retval Repetition counter value
;;;1367     */
;;;1368   __STATIC_INLINE uint32_t LL_TIM_GetRepetitionCounter(TIM_TypeDef *TIMx)
;;;1369   {
;;;1370     return (uint32_t)(READ_REG(TIMx->RCR));
;;;1371   }
;;;1372   
;;;1373   /**
;;;1374     * @}
;;;1375     */
;;;1376   
;;;1377   /** @defgroup TIM_LL_EF_Capture_Compare Capture Compare configuration
;;;1378     * @{
;;;1379     */
;;;1380   /**
;;;1381     * @brief  Enable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1382     * @note CCxE, CCxNE and OCxM bits are preloaded, after having been written,
;;;1383     *       they are updated only when a commutation event (COM) occurs.
;;;1384     * @note Only on channels that have a complementary output.
;;;1385     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1386     *       whether or not a timer instance is able to generate a commutation event.
;;;1387     * @rmtoll CR2          CCPC          LL_TIM_CC_EnablePreload
;;;1388     * @param  TIMx Timer instance
;;;1389     * @retval None
;;;1390     */
;;;1391   __STATIC_INLINE void LL_TIM_CC_EnablePreload(TIM_TypeDef *TIMx)
;;;1392   {
;;;1393     SET_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1394   }
;;;1395   
;;;1396   /**
;;;1397     * @brief  Disable  the capture/compare control bits (CCxE, CCxNE and OCxM) preload.
;;;1398     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1399     *       whether or not a timer instance is able to generate a commutation event.
;;;1400     * @rmtoll CR2          CCPC          LL_TIM_CC_DisablePreload
;;;1401     * @param  TIMx Timer instance
;;;1402     * @retval None
;;;1403     */
;;;1404   __STATIC_INLINE void LL_TIM_CC_DisablePreload(TIM_TypeDef *TIMx)
;;;1405   {
;;;1406     CLEAR_BIT(TIMx->CR2, TIM_CR2_CCPC);
;;;1407   }
;;;1408   
;;;1409   /**
;;;1410     * @brief  Set the updated source of the capture/compare control bits (CCxE, CCxNE and OCxM).
;;;1411     * @note Macro @ref IS_TIM_COMMUTATION_EVENT_INSTANCE(TIMx) can be used to check
;;;1412     *       whether or not a timer instance is able to generate a commutation event.
;;;1413     * @rmtoll CR2          CCUS          LL_TIM_CC_SetUpdate
;;;1414     * @param  TIMx Timer instance
;;;1415     * @param  CCUpdateSource This parameter can be one of the following values:
;;;1416     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_ONLY
;;;1417     *         @arg @ref LL_TIM_CCUPDATESOURCE_COMG_AND_TRGI
;;;1418     * @retval None
;;;1419     */
;;;1420   __STATIC_INLINE void LL_TIM_CC_SetUpdate(TIM_TypeDef *TIMx, uint32_t CCUpdateSource)
;;;1421   {
;;;1422     MODIFY_REG(TIMx->CR2, TIM_CR2_CCUS, CCUpdateSource);
;;;1423   }
;;;1424   
;;;1425   /**
;;;1426     * @brief  Set the trigger of the capture/compare DMA request.
;;;1427     * @rmtoll CR2          CCDS          LL_TIM_CC_SetDMAReqTrigger
;;;1428     * @param  TIMx Timer instance
;;;1429     * @param  DMAReqTrigger This parameter can be one of the following values:
;;;1430     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1431     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1432     * @retval None
;;;1433     */
;;;1434   __STATIC_INLINE void LL_TIM_CC_SetDMAReqTrigger(TIM_TypeDef *TIMx, uint32_t DMAReqTrigger)
;;;1435   {
;;;1436     MODIFY_REG(TIMx->CR2, TIM_CR2_CCDS, DMAReqTrigger);
;;;1437   }
;;;1438   
;;;1439   /**
;;;1440     * @brief  Get actual trigger of the capture/compare DMA request.
;;;1441     * @rmtoll CR2          CCDS          LL_TIM_CC_GetDMAReqTrigger
;;;1442     * @param  TIMx Timer instance
;;;1443     * @retval Returned value can be one of the following values:
;;;1444     *         @arg @ref LL_TIM_CCDMAREQUEST_CC
;;;1445     *         @arg @ref LL_TIM_CCDMAREQUEST_UPDATE
;;;1446     */
;;;1447   __STATIC_INLINE uint32_t LL_TIM_CC_GetDMAReqTrigger(TIM_TypeDef *TIMx)
;;;1448   {
;;;1449     return (uint32_t)(READ_BIT(TIMx->CR2, TIM_CR2_CCDS));
;;;1450   }
;;;1451   
;;;1452   /**
;;;1453     * @brief  Set the lock level to freeze the
;;;1454     *         configuration of several capture/compare parameters.
;;;1455     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1456     *       the lock mechanism is supported by a timer instance.
;;;1457     * @rmtoll BDTR         LOCK          LL_TIM_CC_SetLockLevel
;;;1458     * @param  TIMx Timer instance
;;;1459     * @param  LockLevel This parameter can be one of the following values:
;;;1460     *         @arg @ref LL_TIM_LOCKLEVEL_OFF
;;;1461     *         @arg @ref LL_TIM_LOCKLEVEL_1
;;;1462     *         @arg @ref LL_TIM_LOCKLEVEL_2
;;;1463     *         @arg @ref LL_TIM_LOCKLEVEL_3
;;;1464     * @retval None
;;;1465     */
;;;1466   __STATIC_INLINE void LL_TIM_CC_SetLockLevel(TIM_TypeDef *TIMx, uint32_t LockLevel)
;;;1467   {
;;;1468     MODIFY_REG(TIMx->BDTR, TIM_BDTR_LOCK, LockLevel);
;;;1469   }
;;;1470   
;;;1471   /**
;;;1472     * @brief  Enable capture/compare channels.
;;;1473     * @rmtoll CCER         CC1E          LL_TIM_CC_EnableChannel\n
;;;1474     *         CCER         CC1NE         LL_TIM_CC_EnableChannel\n
;;;1475     *         CCER         CC2E          LL_TIM_CC_EnableChannel\n
;;;1476     *         CCER         CC2NE         LL_TIM_CC_EnableChannel\n
;;;1477     *         CCER         CC3E          LL_TIM_CC_EnableChannel\n
;;;1478     *         CCER         CC3NE         LL_TIM_CC_EnableChannel\n
;;;1479     *         CCER         CC4E          LL_TIM_CC_EnableChannel
;;;1480     * @param  TIMx Timer instance
;;;1481     * @param  Channels This parameter can be a combination of the following values:
;;;1482     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1483     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1484     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1485     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1486     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1487     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1488     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1489     * @retval None
;;;1490     */
;;;1491   __STATIC_INLINE void LL_TIM_CC_EnableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1492   {
;;;1493     SET_BIT(TIMx->CCER, Channels);
;;;1494   }
;;;1495   
;;;1496   /**
;;;1497     * @brief  Disable capture/compare channels.
;;;1498     * @rmtoll CCER         CC1E          LL_TIM_CC_DisableChannel\n
;;;1499     *         CCER         CC1NE         LL_TIM_CC_DisableChannel\n
;;;1500     *         CCER         CC2E          LL_TIM_CC_DisableChannel\n
;;;1501     *         CCER         CC2NE         LL_TIM_CC_DisableChannel\n
;;;1502     *         CCER         CC3E          LL_TIM_CC_DisableChannel\n
;;;1503     *         CCER         CC3NE         LL_TIM_CC_DisableChannel\n
;;;1504     *         CCER         CC4E          LL_TIM_CC_DisableChannel
;;;1505     * @param  TIMx Timer instance
;;;1506     * @param  Channels This parameter can be a combination of the following values:
;;;1507     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1508     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1509     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1510     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1511     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1512     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1513     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1514     * @retval None
;;;1515     */
;;;1516   __STATIC_INLINE void LL_TIM_CC_DisableChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1517   {
;;;1518     CLEAR_BIT(TIMx->CCER, Channels);
;;;1519   }
;;;1520   
;;;1521   /**
;;;1522     * @brief  Indicate whether channel(s) is(are) enabled.
;;;1523     * @rmtoll CCER         CC1E          LL_TIM_CC_IsEnabledChannel\n
;;;1524     *         CCER         CC1NE         LL_TIM_CC_IsEnabledChannel\n
;;;1525     *         CCER         CC2E          LL_TIM_CC_IsEnabledChannel\n
;;;1526     *         CCER         CC2NE         LL_TIM_CC_IsEnabledChannel\n
;;;1527     *         CCER         CC3E          LL_TIM_CC_IsEnabledChannel\n
;;;1528     *         CCER         CC3NE         LL_TIM_CC_IsEnabledChannel\n
;;;1529     *         CCER         CC4E          LL_TIM_CC_IsEnabledChannel
;;;1530     * @param  TIMx Timer instance
;;;1531     * @param  Channels This parameter can be a combination of the following values:
;;;1532     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1533     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1534     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1535     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1536     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1537     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1538     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1539     * @retval State of bit (1 or 0).
;;;1540     */
;;;1541   __STATIC_INLINE uint32_t LL_TIM_CC_IsEnabledChannel(TIM_TypeDef *TIMx, uint32_t Channels)
;;;1542   {
;;;1543     return (READ_BIT(TIMx->CCER, Channels) == (Channels));
;;;1544   }
;;;1545   
;;;1546   /**
;;;1547     * @}
;;;1548     */
;;;1549   
;;;1550   /** @defgroup TIM_LL_EF_Output_Channel Output channel configuration
;;;1551     * @{
;;;1552     */
;;;1553   /**
;;;1554     * @brief  Configure an output channel.
;;;1555     * @rmtoll CCMR1        CC1S          LL_TIM_OC_ConfigOutput\n
;;;1556     *         CCMR1        CC2S          LL_TIM_OC_ConfigOutput\n
;;;1557     *         CCMR2        CC3S          LL_TIM_OC_ConfigOutput\n
;;;1558     *         CCMR2        CC4S          LL_TIM_OC_ConfigOutput\n
;;;1559     *         CCER         CC1P          LL_TIM_OC_ConfigOutput\n
;;;1560     *         CCER         CC2P          LL_TIM_OC_ConfigOutput\n
;;;1561     *         CCER         CC3P          LL_TIM_OC_ConfigOutput\n
;;;1562     *         CCER         CC4P          LL_TIM_OC_ConfigOutput\n
;;;1563     *         CR2          OIS1          LL_TIM_OC_ConfigOutput\n
;;;1564     *         CR2          OIS2          LL_TIM_OC_ConfigOutput\n
;;;1565     *         CR2          OIS3          LL_TIM_OC_ConfigOutput\n
;;;1566     *         CR2          OIS4          LL_TIM_OC_ConfigOutput
;;;1567     * @param  TIMx Timer instance
;;;1568     * @param  Channel This parameter can be one of the following values:
;;;1569     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1570     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1571     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1572     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1573     * @param  Configuration This parameter must be a combination of all the following values:
;;;1574     *         @arg @ref LL_TIM_OCPOLARITY_HIGH or @ref LL_TIM_OCPOLARITY_LOW
;;;1575     *         @arg @ref LL_TIM_OCIDLESTATE_LOW or @ref LL_TIM_OCIDLESTATE_HIGH
;;;1576     * @retval None
;;;1577     */
;;;1578   __STATIC_INLINE void LL_TIM_OC_ConfigOutput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;1579   {
;;;1580     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1581     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1582     CLEAR_BIT(*pReg, (TIM_CCMR1_CC1S << SHIFT_TAB_OCxx[iChannel]));
;;;1583     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),
;;;1584                (Configuration & TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]);
;;;1585     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),
;;;1586                (Configuration & TIM_CR2_OIS1) << SHIFT_TAB_OISx[iChannel]);
;;;1587   }
;;;1588   
;;;1589   /**
;;;1590     * @brief  Define the behavior of the output reference signal OCxREF from which
;;;1591     *         OCx and OCxN (when relevant) are derived.
;;;1592     * @rmtoll CCMR1        OC1M          LL_TIM_OC_SetMode\n
;;;1593     *         CCMR1        OC2M          LL_TIM_OC_SetMode\n
;;;1594     *         CCMR2        OC3M          LL_TIM_OC_SetMode\n
;;;1595     *         CCMR2        OC4M          LL_TIM_OC_SetMode
;;;1596     * @param  TIMx Timer instance
;;;1597     * @param  Channel This parameter can be one of the following values:
;;;1598     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1599     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1600     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1601     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1602     * @param  Mode This parameter can be one of the following values:
;;;1603     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1604     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1605     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1606     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1607     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1608     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1609     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1610     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1611     * @retval None
;;;1612     */
;;;1613   __STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
;;;1614   {
;;;1615     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1616     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1617     MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
;;;1618   }
;;;1619   
;;;1620   /**
;;;1621     * @brief  Get the output compare mode of an output channel.
;;;1622     * @rmtoll CCMR1        OC1M          LL_TIM_OC_GetMode\n
;;;1623     *         CCMR1        OC2M          LL_TIM_OC_GetMode\n
;;;1624     *         CCMR2        OC3M          LL_TIM_OC_GetMode\n
;;;1625     *         CCMR2        OC4M          LL_TIM_OC_GetMode
;;;1626     * @param  TIMx Timer instance
;;;1627     * @param  Channel This parameter can be one of the following values:
;;;1628     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1629     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1630     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1631     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1632     * @retval Returned value can be one of the following values:
;;;1633     *         @arg @ref LL_TIM_OCMODE_FROZEN
;;;1634     *         @arg @ref LL_TIM_OCMODE_ACTIVE
;;;1635     *         @arg @ref LL_TIM_OCMODE_INACTIVE
;;;1636     *         @arg @ref LL_TIM_OCMODE_TOGGLE
;;;1637     *         @arg @ref LL_TIM_OCMODE_FORCED_INACTIVE
;;;1638     *         @arg @ref LL_TIM_OCMODE_FORCED_ACTIVE
;;;1639     *         @arg @ref LL_TIM_OCMODE_PWM1
;;;1640     *         @arg @ref LL_TIM_OCMODE_PWM2
;;;1641     */
;;;1642   __STATIC_INLINE uint32_t LL_TIM_OC_GetMode(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1643   {
;;;1644     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1645     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1646     return (READ_BIT(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel])) >> SHIFT_TAB_OCxx[iChannel]);
;;;1647   }
;;;1648   
;;;1649   /**
;;;1650     * @brief  Set the polarity of an output channel.
;;;1651     * @rmtoll CCER         CC1P          LL_TIM_OC_SetPolarity\n
;;;1652     *         CCER         CC1NP         LL_TIM_OC_SetPolarity\n
;;;1653     *         CCER         CC2P          LL_TIM_OC_SetPolarity\n
;;;1654     *         CCER         CC2NP         LL_TIM_OC_SetPolarity\n
;;;1655     *         CCER         CC3P          LL_TIM_OC_SetPolarity\n
;;;1656     *         CCER         CC3NP         LL_TIM_OC_SetPolarity\n
;;;1657     *         CCER         CC4P          LL_TIM_OC_SetPolarity
;;;1658     * @param  TIMx Timer instance
;;;1659     * @param  Channel This parameter can be one of the following values:
;;;1660     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1661     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1662     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1663     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1664     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1665     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1666     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1667     * @param  Polarity This parameter can be one of the following values:
;;;1668     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1669     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1670     * @retval None
;;;1671     */
;;;1672   __STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
;;;1673   {
;;;1674     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1675     MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
;;;1676   }
;;;1677   
;;;1678   /**
;;;1679     * @brief  Get the polarity of an output channel.
;;;1680     * @rmtoll CCER         CC1P          LL_TIM_OC_GetPolarity\n
;;;1681     *         CCER         CC1NP         LL_TIM_OC_GetPolarity\n
;;;1682     *         CCER         CC2P          LL_TIM_OC_GetPolarity\n
;;;1683     *         CCER         CC2NP         LL_TIM_OC_GetPolarity\n
;;;1684     *         CCER         CC3P          LL_TIM_OC_GetPolarity\n
;;;1685     *         CCER         CC3NP         LL_TIM_OC_GetPolarity\n
;;;1686     *         CCER         CC4P          LL_TIM_OC_GetPolarity
;;;1687     * @param  TIMx Timer instance
;;;1688     * @param  Channel This parameter can be one of the following values:
;;;1689     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1690     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1691     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1692     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1693     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1694     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1695     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1696     * @retval Returned value can be one of the following values:
;;;1697     *         @arg @ref LL_TIM_OCPOLARITY_HIGH
;;;1698     *         @arg @ref LL_TIM_OCPOLARITY_LOW
;;;1699     */
;;;1700   __STATIC_INLINE uint32_t LL_TIM_OC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1701   {
;;;1702     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1703     return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
;;;1704   }
;;;1705   
;;;1706   /**
;;;1707     * @brief  Set the IDLE state of an output channel
;;;1708     * @note This function is significant only for the timer instances
;;;1709     *       supporting the break feature. Macro @ref IS_TIM_BREAK_INSTANCE(TIMx)
;;;1710     *       can be used to check whether or not a timer instance provides
;;;1711     *       a break input.
;;;1712     * @rmtoll CR2         OIS1          LL_TIM_OC_SetIdleState\n
;;;1713     *         CR2         OIS1N         LL_TIM_OC_SetIdleState\n
;;;1714     *         CR2         OIS2          LL_TIM_OC_SetIdleState\n
;;;1715     *         CR2         OIS2N         LL_TIM_OC_SetIdleState\n
;;;1716     *         CR2         OIS3          LL_TIM_OC_SetIdleState\n
;;;1717     *         CR2         OIS3N         LL_TIM_OC_SetIdleState\n
;;;1718     *         CR2         OIS4          LL_TIM_OC_SetIdleState
;;;1719     * @param  TIMx Timer instance
;;;1720     * @param  Channel This parameter can be one of the following values:
;;;1721     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1722     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1723     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1724     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1725     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1726     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1727     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1728     * @param  IdleState This parameter can be one of the following values:
;;;1729     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1730     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1731     * @retval None
;;;1732     */
;;;1733   __STATIC_INLINE void LL_TIM_OC_SetIdleState(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t IdleState)
;;;1734   {
;;;1735     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1736     MODIFY_REG(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel]),  IdleState << SHIFT_TAB_OISx[iChannel]);
;;;1737   }
;;;1738   
;;;1739   /**
;;;1740     * @brief  Get the IDLE state of an output channel
;;;1741     * @rmtoll CR2         OIS1          LL_TIM_OC_GetIdleState\n
;;;1742     *         CR2         OIS1N         LL_TIM_OC_GetIdleState\n
;;;1743     *         CR2         OIS2          LL_TIM_OC_GetIdleState\n
;;;1744     *         CR2         OIS2N         LL_TIM_OC_GetIdleState\n
;;;1745     *         CR2         OIS3          LL_TIM_OC_GetIdleState\n
;;;1746     *         CR2         OIS3N         LL_TIM_OC_GetIdleState\n
;;;1747     *         CR2         OIS4          LL_TIM_OC_GetIdleState
;;;1748     * @param  TIMx Timer instance
;;;1749     * @param  Channel This parameter can be one of the following values:
;;;1750     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1751     *         @arg @ref LL_TIM_CHANNEL_CH1N
;;;1752     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1753     *         @arg @ref LL_TIM_CHANNEL_CH2N
;;;1754     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1755     *         @arg @ref LL_TIM_CHANNEL_CH3N
;;;1756     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1757     * @retval Returned value can be one of the following values:
;;;1758     *         @arg @ref LL_TIM_OCIDLESTATE_LOW
;;;1759     *         @arg @ref LL_TIM_OCIDLESTATE_HIGH
;;;1760     */
;;;1761   __STATIC_INLINE uint32_t LL_TIM_OC_GetIdleState(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1762   {
;;;1763     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1764     return (READ_BIT(TIMx->CR2, (TIM_CR2_OIS1 << SHIFT_TAB_OISx[iChannel])) >> SHIFT_TAB_OISx[iChannel]);
;;;1765   }
;;;1766   
;;;1767   /**
;;;1768     * @brief  Enable fast mode for the output channel.
;;;1769     * @note Acts only if the channel is configured in PWM1 or PWM2 mode.
;;;1770     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_EnableFast\n
;;;1771     *         CCMR1        OC2FE          LL_TIM_OC_EnableFast\n
;;;1772     *         CCMR2        OC3FE          LL_TIM_OC_EnableFast\n
;;;1773     *         CCMR2        OC4FE          LL_TIM_OC_EnableFast
;;;1774     * @param  TIMx Timer instance
;;;1775     * @param  Channel This parameter can be one of the following values:
;;;1776     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1777     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1778     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1779     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1780     * @retval None
;;;1781     */
;;;1782   __STATIC_INLINE void LL_TIM_OC_EnableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1783   {
;;;1784     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1785     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1786     SET_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1787   
;;;1788   }
;;;1789   
;;;1790   /**
;;;1791     * @brief  Disable fast mode for the output channel.
;;;1792     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_DisableFast\n
;;;1793     *         CCMR1        OC2FE          LL_TIM_OC_DisableFast\n
;;;1794     *         CCMR2        OC3FE          LL_TIM_OC_DisableFast\n
;;;1795     *         CCMR2        OC4FE          LL_TIM_OC_DisableFast
;;;1796     * @param  TIMx Timer instance
;;;1797     * @param  Channel This parameter can be one of the following values:
;;;1798     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1799     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1800     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1801     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1802     * @retval None
;;;1803     */
;;;1804   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1805   {
;;;1806     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1807     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1808     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
;;;1809   
;;;1810   }
;;;1811   
;;;1812   /**
;;;1813     * @brief  Indicates whether fast mode is enabled for the output channel.
;;;1814     * @rmtoll CCMR1        OC1FE          LL_TIM_OC_IsEnabledFast\n
;;;1815     *         CCMR1        OC2FE          LL_TIM_OC_IsEnabledFast\n
;;;1816     *         CCMR2        OC3FE          LL_TIM_OC_IsEnabledFast\n
;;;1817     *         CCMR2        OC4FE          LL_TIM_OC_IsEnabledFast\n
;;;1818     * @param  TIMx Timer instance
;;;1819     * @param  Channel This parameter can be one of the following values:
;;;1820     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1821     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1822     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1823     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1824     * @retval State of bit (1 or 0).
;;;1825     */
;;;1826   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledFast(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1827   {
;;;1828     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1829     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1830     register uint32_t bitfield = TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel];
;;;1831     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1832   }
;;;1833   
;;;1834   /**
;;;1835     * @brief  Enable compare register (TIMx_CCRx) preload for the output channel.
;;;1836     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_EnablePreload\n
;;;1837     *         CCMR1        OC2PE          LL_TIM_OC_EnablePreload\n
;;;1838     *         CCMR2        OC3PE          LL_TIM_OC_EnablePreload\n
;;;1839     *         CCMR2        OC4PE          LL_TIM_OC_EnablePreload
;;;1840     * @param  TIMx Timer instance
;;;1841     * @param  Channel This parameter can be one of the following values:
;;;1842     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1843     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1844     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1845     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1846     * @retval None
;;;1847     */
;;;1848   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1849   {
;;;1850     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1851     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1852     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1853   }
;;;1854   
;;;1855   /**
;;;1856     * @brief  Disable compare register (TIMx_CCRx) preload for the output channel.
;;;1857     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_DisablePreload\n
;;;1858     *         CCMR1        OC2PE          LL_TIM_OC_DisablePreload\n
;;;1859     *         CCMR2        OC3PE          LL_TIM_OC_DisablePreload\n
;;;1860     *         CCMR2        OC4PE          LL_TIM_OC_DisablePreload
;;;1861     * @param  TIMx Timer instance
;;;1862     * @param  Channel This parameter can be one of the following values:
;;;1863     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1864     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1865     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1866     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1867     * @retval None
;;;1868     */
;;;1869   __STATIC_INLINE void LL_TIM_OC_DisablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1870   {
;;;1871     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1872     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1873     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
;;;1874   }
;;;1875   
;;;1876   /**
;;;1877     * @brief  Indicates whether compare register (TIMx_CCRx) preload is enabled for the output channel.
;;;1878     * @rmtoll CCMR1        OC1PE          LL_TIM_OC_IsEnabledPreload\n
;;;1879     *         CCMR1        OC2PE          LL_TIM_OC_IsEnabledPreload\n
;;;1880     *         CCMR2        OC3PE          LL_TIM_OC_IsEnabledPreload\n
;;;1881     *         CCMR2        OC4PE          LL_TIM_OC_IsEnabledPreload\n
;;;1882     * @param  TIMx Timer instance
;;;1883     * @param  Channel This parameter can be one of the following values:
;;;1884     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1885     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1886     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1887     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1888     * @retval State of bit (1 or 0).
;;;1889     */
;;;1890   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledPreload(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1891   {
;;;1892     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1893     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1894     register uint32_t bitfield = TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel];
;;;1895     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1896   }
;;;1897   
;;;1898   /**
;;;1899     * @brief  Enable clearing the output channel on an external event.
;;;1900     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1901     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1902     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1903     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_EnableClear\n
;;;1904     *         CCMR1        OC2CE          LL_TIM_OC_EnableClear\n
;;;1905     *         CCMR2        OC3CE          LL_TIM_OC_EnableClear\n
;;;1906     *         CCMR2        OC4CE          LL_TIM_OC_EnableClear
;;;1907     * @param  TIMx Timer instance
;;;1908     * @param  Channel This parameter can be one of the following values:
;;;1909     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1910     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1911     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1912     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1913     * @retval None
;;;1914     */
;;;1915   __STATIC_INLINE void LL_TIM_OC_EnableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1916   {
;;;1917     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1918     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1919     SET_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1920   }
;;;1921   
;;;1922   /**
;;;1923     * @brief  Disable clearing the output channel on an external event.
;;;1924     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1925     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1926     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_DisableClear\n
;;;1927     *         CCMR1        OC2CE          LL_TIM_OC_DisableClear\n
;;;1928     *         CCMR2        OC3CE          LL_TIM_OC_DisableClear\n
;;;1929     *         CCMR2        OC4CE          LL_TIM_OC_DisableClear
;;;1930     * @param  TIMx Timer instance
;;;1931     * @param  Channel This parameter can be one of the following values:
;;;1932     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1933     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1934     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1935     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1936     * @retval None
;;;1937     */
;;;1938   __STATIC_INLINE void LL_TIM_OC_DisableClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1939   {
;;;1940     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1941     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1942     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel]));
;;;1943   }
;;;1944   
;;;1945   /**
;;;1946     * @brief  Indicates clearing the output channel on an external event is enabled for the output channel.
;;;1947     * @note This function enables clearing the output channel on an external event.
;;;1948     * @note This function can only be used in Output compare and PWM modes. It does not work in Forced mode.
;;;1949     * @note Macro @ref IS_TIM_OCXREF_CLEAR_INSTANCE(TIMx) can be used to check whether
;;;1950     *       or not a timer instance can clear the OCxREF signal on an external event.
;;;1951     * @rmtoll CCMR1        OC1CE          LL_TIM_OC_IsEnabledClear\n
;;;1952     *         CCMR1        OC2CE          LL_TIM_OC_IsEnabledClear\n
;;;1953     *         CCMR2        OC3CE          LL_TIM_OC_IsEnabledClear\n
;;;1954     *         CCMR2        OC4CE          LL_TIM_OC_IsEnabledClear\n
;;;1955     * @param  TIMx Timer instance
;;;1956     * @param  Channel This parameter can be one of the following values:
;;;1957     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;1958     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;1959     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;1960     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;1961     * @retval State of bit (1 or 0).
;;;1962     */
;;;1963   __STATIC_INLINE uint32_t LL_TIM_OC_IsEnabledClear(TIM_TypeDef *TIMx, uint32_t Channel)
;;;1964   {
;;;1965     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;1966     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;1967     register uint32_t bitfield = TIM_CCMR1_OC1CE << SHIFT_TAB_OCxx[iChannel];
;;;1968     return (READ_BIT(*pReg, bitfield) == bitfield);
;;;1969   }
;;;1970   
;;;1971   /**
;;;1972     * @brief  Set the dead-time delay (delay inserted between the rising edge of the OCxREF signal and the rising edge if the Ocx and OCxN signals).
;;;1973     * @note Macro @ref IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
;;;1974     *       dead-time insertion feature is supported by a timer instance.
;;;1975     * @note Helper macro @ref __LL_TIM_CALC_DEADTIME can be used to calculate the DeadTime parameter
;;;1976     * @rmtoll BDTR         DTG           LL_TIM_OC_SetDeadTime
;;;1977     * @param  TIMx Timer instance
;;;1978     * @param  DeadTime between Min_Data=0 and Max_Data=255
;;;1979     * @retval None
;;;1980     */
;;;1981   __STATIC_INLINE void LL_TIM_OC_SetDeadTime(TIM_TypeDef *TIMx, uint32_t DeadTime)
;;;1982   {
;;;1983     MODIFY_REG(TIMx->BDTR, TIM_BDTR_DTG, DeadTime);
;;;1984   }
;;;1985   
;;;1986   /**
;;;1987     * @brief  Set compare value for output channel 1 (TIMx_CCR1).
;;;1988     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;1989     *       output channel 1 is supported by a timer instance.
;;;1990     * @rmtoll CCR1         CCR1          LL_TIM_OC_SetCompareCH1
;;;1991     * @param  TIMx Timer instance
;;;1992     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;1993     * @retval None
;;;1994     */
;;;1995   __STATIC_INLINE void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;1996   {
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
;;;1998   }
;;;1999   
;;;2000   /**
;;;2001     * @brief  Set compare value for output channel 2 (TIMx_CCR2).
;;;2002     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2003     *       output channel 2 is supported by a timer instance.
;;;2004     * @rmtoll CCR2         CCR2          LL_TIM_OC_SetCompareCH2
;;;2005     * @param  TIMx Timer instance
;;;2006     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2007     * @retval None
;;;2008     */
;;;2009   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2010   {
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2012   }
;;;2013   
;;;2014   /**
;;;2015     * @brief  Set compare value for output channel 3 (TIMx_CCR3).
;;;2016     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2017     *       output channel is supported by a timer instance.
;;;2018     * @rmtoll CCR3         CCR3          LL_TIM_OC_SetCompareCH3
;;;2019     * @param  TIMx Timer instance
;;;2020     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2021     * @retval None
;;;2022     */
;;;2023   __STATIC_INLINE void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2024   {
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
;;;2026   }
;;;2027   
;;;2028   /**
;;;2029     * @brief  Set compare value for output channel 4 (TIMx_CCR4).
;;;2030     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2031     *       output channel 4 is supported by a timer instance.
;;;2032     * @rmtoll CCR4         CCR4          LL_TIM_OC_SetCompareCH4
;;;2033     * @param  TIMx Timer instance
;;;2034     * @param  CompareValue between Min_Data=0 and Max_Data=65535
;;;2035     * @retval None
;;;2036     */
;;;2037   __STATIC_INLINE void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *TIMx, uint32_t CompareValue)
;;;2038   {
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
;;;2040   }
;;;2041   
;;;2042   /**
;;;2043     * @brief  Get compare value (TIMx_CCR1) set for  output channel 1.
;;;2044     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2045     *       output channel 1 is supported by a timer instance.
;;;2046     * @rmtoll CCR1         CCR1          LL_TIM_OC_GetCompareCH1
;;;2047     * @param  TIMx Timer instance
;;;2048     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2049     */
;;;2050   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH1(TIM_TypeDef *TIMx)
;;;2051   {
;;;2052     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2053   }
;;;2054   
;;;2055   /**
;;;2056     * @brief  Get compare value (TIMx_CCR2) set for  output channel 2.
;;;2057     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2058     *       output channel 2 is supported by a timer instance.
;;;2059     * @rmtoll CCR2         CCR2          LL_TIM_OC_GetCompareCH2
;;;2060     * @param  TIMx Timer instance
;;;2061     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2062     */
;;;2063   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH2(TIM_TypeDef *TIMx)
;;;2064   {
;;;2065     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2066   }
;;;2067   
;;;2068   /**
;;;2069     * @brief  Get compare value (TIMx_CCR3) set for  output channel 3.
;;;2070     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2071     *       output channel 3 is supported by a timer instance.
;;;2072     * @rmtoll CCR3         CCR3          LL_TIM_OC_GetCompareCH3
;;;2073     * @param  TIMx Timer instance
;;;2074     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2075     */
;;;2076   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH3(TIM_TypeDef *TIMx)
;;;2077   {
;;;2078     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2079   }
;;;2080   
;;;2081   /**
;;;2082     * @brief  Get compare value (TIMx_CCR4) set for  output channel 4.
;;;2083     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2084     *       output channel 4 is supported by a timer instance.
;;;2085     * @rmtoll CCR4         CCR4          LL_TIM_OC_GetCompareCH4
;;;2086     * @param  TIMx Timer instance
;;;2087     * @retval CompareValue (between Min_Data=0 and Max_Data=65535)
;;;2088     */
;;;2089   __STATIC_INLINE uint32_t LL_TIM_OC_GetCompareCH4(TIM_TypeDef *TIMx)
;;;2090   {
;;;2091     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2092   }
;;;2093   
;;;2094   /**
;;;2095     * @}
;;;2096     */
;;;2097   
;;;2098   /** @defgroup TIM_LL_EF_Input_Channel Input channel configuration
;;;2099     * @{
;;;2100     */
;;;2101   /**
;;;2102     * @brief  Configure input channel.
;;;2103     * @rmtoll CCMR1        CC1S          LL_TIM_IC_Config\n
;;;2104     *         CCMR1        IC1PSC        LL_TIM_IC_Config\n
;;;2105     *         CCMR1        IC1F          LL_TIM_IC_Config\n
;;;2106     *         CCMR1        CC2S          LL_TIM_IC_Config\n
;;;2107     *         CCMR1        IC2PSC        LL_TIM_IC_Config\n
;;;2108     *         CCMR1        IC2F          LL_TIM_IC_Config\n
;;;2109     *         CCMR2        CC3S          LL_TIM_IC_Config\n
;;;2110     *         CCMR2        IC3PSC        LL_TIM_IC_Config\n
;;;2111     *         CCMR2        IC3F          LL_TIM_IC_Config\n
;;;2112     *         CCMR2        CC4S          LL_TIM_IC_Config\n
;;;2113     *         CCMR2        IC4PSC        LL_TIM_IC_Config\n
;;;2114     *         CCMR2        IC4F          LL_TIM_IC_Config\n
;;;2115     *         CCER         CC1P          LL_TIM_IC_Config\n
;;;2116     *         CCER         CC1NP         LL_TIM_IC_Config\n
;;;2117     *         CCER         CC2P          LL_TIM_IC_Config\n
;;;2118     *         CCER         CC2NP         LL_TIM_IC_Config\n
;;;2119     *         CCER         CC3P          LL_TIM_IC_Config\n
;;;2120     *         CCER         CC3NP         LL_TIM_IC_Config\n
;;;2121     *         CCER         CC4P          LL_TIM_IC_Config\n
;;;2122     * @param  TIMx Timer instance
;;;2123     * @param  Channel This parameter can be one of the following values:
;;;2124     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2125     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2126     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2127     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2128     * @param  Configuration This parameter must be a combination of all the following values:
;;;2129     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI or @ref LL_TIM_ACTIVEINPUT_INDIRECTTI or @ref LL_TIM_ACTIVEINPUT_TRC
;;;2130     *         @arg @ref LL_TIM_ICPSC_DIV1 or ... or @ref LL_TIM_ICPSC_DIV8
;;;2131     *         @arg @ref LL_TIM_IC_FILTER_FDIV1 or ... or @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2132     *         @arg @ref LL_TIM_IC_POLARITY_RISING or @ref LL_TIM_IC_POLARITY_FALLING
;;;2133     * @retval None
;;;2134     */
;;;2135   __STATIC_INLINE void LL_TIM_IC_Config(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Configuration)
;;;2136   {
;;;2137     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2138     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2139     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]),
;;;2140                ((Configuration >> 16U) & (TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC | TIM_CCMR1_CC1S))  << SHIFT_TAB_ICxx[iChannel]);
;;;2141     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2142                (Configuration & (TIM_CCER_CC1NP | TIM_CCER_CC1P)) << SHIFT_TAB_CCxP[iChannel]);
;;;2143   }
;;;2144   
;;;2145   /**
;;;2146     * @brief  Set the active input.
;;;2147     * @rmtoll CCMR1        CC1S          LL_TIM_IC_SetActiveInput\n
;;;2148     *         CCMR1        CC2S          LL_TIM_IC_SetActiveInput\n
;;;2149     *         CCMR2        CC3S          LL_TIM_IC_SetActiveInput\n
;;;2150     *         CCMR2        CC4S          LL_TIM_IC_SetActiveInput
;;;2151     * @param  TIMx Timer instance
;;;2152     * @param  Channel This parameter can be one of the following values:
;;;2153     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2154     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2155     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2156     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2157     * @param  ICActiveInput This parameter can be one of the following values:
;;;2158     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2159     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2160     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2161     * @retval None
;;;2162     */
;;;2163   __STATIC_INLINE void LL_TIM_IC_SetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICActiveInput)
;;;2164   {
;;;2165     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2166     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2167     MODIFY_REG(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel]), (ICActiveInput >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2168   }
;;;2169   
;;;2170   /**
;;;2171     * @brief  Get the current active input.
;;;2172     * @rmtoll CCMR1        CC1S          LL_TIM_IC_GetActiveInput\n
;;;2173     *         CCMR1        CC2S          LL_TIM_IC_GetActiveInput\n
;;;2174     *         CCMR2        CC3S          LL_TIM_IC_GetActiveInput\n
;;;2175     *         CCMR2        CC4S          LL_TIM_IC_GetActiveInput
;;;2176     * @param  TIMx Timer instance
;;;2177     * @param  Channel This parameter can be one of the following values:
;;;2178     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2179     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2180     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2181     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2182     * @retval Returned value can be one of the following values:
;;;2183     *         @arg @ref LL_TIM_ACTIVEINPUT_DIRECTTI
;;;2184     *         @arg @ref LL_TIM_ACTIVEINPUT_INDIRECTTI
;;;2185     *         @arg @ref LL_TIM_ACTIVEINPUT_TRC
;;;2186     */
;;;2187   __STATIC_INLINE uint32_t LL_TIM_IC_GetActiveInput(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2188   {
;;;2189     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2190     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2191     return ((READ_BIT(*pReg, ((TIM_CCMR1_CC1S) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2192   }
;;;2193   
;;;2194   /**
;;;2195     * @brief  Set the prescaler of input channel.
;;;2196     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_SetPrescaler\n
;;;2197     *         CCMR1        IC2PSC        LL_TIM_IC_SetPrescaler\n
;;;2198     *         CCMR2        IC3PSC        LL_TIM_IC_SetPrescaler\n
;;;2199     *         CCMR2        IC4PSC        LL_TIM_IC_SetPrescaler
;;;2200     * @param  TIMx Timer instance
;;;2201     * @param  Channel This parameter can be one of the following values:
;;;2202     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2203     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2204     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2205     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2206     * @param  ICPrescaler This parameter can be one of the following values:
;;;2207     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2208     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2209     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2210     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2211     * @retval None
;;;2212     */
;;;2213   __STATIC_INLINE void LL_TIM_IC_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPrescaler)
;;;2214   {
;;;2215     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2216     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2217     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel]), (ICPrescaler >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2218   }
;;;2219   
;;;2220   /**
;;;2221     * @brief  Get the current prescaler value acting on an  input channel.
;;;2222     * @rmtoll CCMR1        IC1PSC        LL_TIM_IC_GetPrescaler\n
;;;2223     *         CCMR1        IC2PSC        LL_TIM_IC_GetPrescaler\n
;;;2224     *         CCMR2        IC3PSC        LL_TIM_IC_GetPrescaler\n
;;;2225     *         CCMR2        IC4PSC        LL_TIM_IC_GetPrescaler
;;;2226     * @param  TIMx Timer instance
;;;2227     * @param  Channel This parameter can be one of the following values:
;;;2228     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2229     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2230     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2231     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2232     * @retval Returned value can be one of the following values:
;;;2233     *         @arg @ref LL_TIM_ICPSC_DIV1
;;;2234     *         @arg @ref LL_TIM_ICPSC_DIV2
;;;2235     *         @arg @ref LL_TIM_ICPSC_DIV4
;;;2236     *         @arg @ref LL_TIM_ICPSC_DIV8
;;;2237     */
;;;2238   __STATIC_INLINE uint32_t LL_TIM_IC_GetPrescaler(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2239   {
;;;2240     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2241     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2242     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1PSC) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2243   }
;;;2244   
;;;2245   /**
;;;2246     * @brief  Set the input filter duration.
;;;2247     * @rmtoll CCMR1        IC1F          LL_TIM_IC_SetFilter\n
;;;2248     *         CCMR1        IC2F          LL_TIM_IC_SetFilter\n
;;;2249     *         CCMR2        IC3F          LL_TIM_IC_SetFilter\n
;;;2250     *         CCMR2        IC4F          LL_TIM_IC_SetFilter
;;;2251     * @param  TIMx Timer instance
;;;2252     * @param  Channel This parameter can be one of the following values:
;;;2253     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2254     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2255     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2256     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2257     * @param  ICFilter This parameter can be one of the following values:
;;;2258     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2259     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2260     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2261     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2262     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2263     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2264     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2265     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2266     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2267     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2268     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2269     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2270     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2271     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2272     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2273     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2274     * @retval None
;;;2275     */
;;;2276   __STATIC_INLINE void LL_TIM_IC_SetFilter(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICFilter)
;;;2277   {
;;;2278     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2279     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2280     MODIFY_REG(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel]), (ICFilter >> 16U) << SHIFT_TAB_ICxx[iChannel]);
;;;2281   }
;;;2282   
;;;2283   /**
;;;2284     * @brief  Get the input filter duration.
;;;2285     * @rmtoll CCMR1        IC1F          LL_TIM_IC_GetFilter\n
;;;2286     *         CCMR1        IC2F          LL_TIM_IC_GetFilter\n
;;;2287     *         CCMR2        IC3F          LL_TIM_IC_GetFilter\n
;;;2288     *         CCMR2        IC4F          LL_TIM_IC_GetFilter
;;;2289     * @param  TIMx Timer instance
;;;2290     * @param  Channel This parameter can be one of the following values:
;;;2291     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2292     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2293     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2294     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2295     * @retval Returned value can be one of the following values:
;;;2296     *         @arg @ref LL_TIM_IC_FILTER_FDIV1
;;;2297     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N2
;;;2298     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N4
;;;2299     *         @arg @ref LL_TIM_IC_FILTER_FDIV1_N8
;;;2300     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N6
;;;2301     *         @arg @ref LL_TIM_IC_FILTER_FDIV2_N8
;;;2302     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N6
;;;2303     *         @arg @ref LL_TIM_IC_FILTER_FDIV4_N8
;;;2304     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N6
;;;2305     *         @arg @ref LL_TIM_IC_FILTER_FDIV8_N8
;;;2306     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N5
;;;2307     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N6
;;;2308     *         @arg @ref LL_TIM_IC_FILTER_FDIV16_N8
;;;2309     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N5
;;;2310     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N6
;;;2311     *         @arg @ref LL_TIM_IC_FILTER_FDIV32_N8
;;;2312     */
;;;2313   __STATIC_INLINE uint32_t LL_TIM_IC_GetFilter(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2314   {
;;;2315     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2316     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
;;;2317     return ((READ_BIT(*pReg, ((TIM_CCMR1_IC1F) << SHIFT_TAB_ICxx[iChannel])) >> SHIFT_TAB_ICxx[iChannel]) << 16U);
;;;2318   }
;;;2319   
;;;2320   /**
;;;2321     * @brief  Set the input channel polarity.
;;;2322     * @rmtoll CCER         CC1P          LL_TIM_IC_SetPolarity\n
;;;2323     *         CCER         CC1NP         LL_TIM_IC_SetPolarity\n
;;;2324     *         CCER         CC2P          LL_TIM_IC_SetPolarity\n
;;;2325     *         CCER         CC2NP         LL_TIM_IC_SetPolarity\n
;;;2326     *         CCER         CC3P          LL_TIM_IC_SetPolarity\n
;;;2327     *         CCER         CC3NP         LL_TIM_IC_SetPolarity\n
;;;2328     *         CCER         CC4P          LL_TIM_IC_SetPolarity\n
;;;2329     * @param  TIMx Timer instance
;;;2330     * @param  Channel This parameter can be one of the following values:
;;;2331     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2332     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2333     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2334     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2335     * @param  ICPolarity This parameter can be one of the following values:
;;;2336     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2337     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2338     * @retval None
;;;2339     */
;;;2340   __STATIC_INLINE void LL_TIM_IC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ICPolarity)
;;;2341   {
;;;2342     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2343     MODIFY_REG(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel]),
;;;2344                ICPolarity << SHIFT_TAB_CCxP[iChannel]);
;;;2345   }
;;;2346   
;;;2347   /**
;;;2348     * @brief  Get the current input channel polarity.
;;;2349     * @rmtoll CCER         CC1P          LL_TIM_IC_GetPolarity\n
;;;2350     *         CCER         CC1NP         LL_TIM_IC_GetPolarity\n
;;;2351     *         CCER         CC2P          LL_TIM_IC_GetPolarity\n
;;;2352     *         CCER         CC2NP         LL_TIM_IC_GetPolarity\n
;;;2353     *         CCER         CC3P          LL_TIM_IC_GetPolarity\n
;;;2354     *         CCER         CC3NP         LL_TIM_IC_GetPolarity\n
;;;2355     *         CCER         CC4P          LL_TIM_IC_GetPolarity\n
;;;2356     * @param  TIMx Timer instance
;;;2357     * @param  Channel This parameter can be one of the following values:
;;;2358     *         @arg @ref LL_TIM_CHANNEL_CH1
;;;2359     *         @arg @ref LL_TIM_CHANNEL_CH2
;;;2360     *         @arg @ref LL_TIM_CHANNEL_CH3
;;;2361     *         @arg @ref LL_TIM_CHANNEL_CH4
;;;2362     * @retval Returned value can be one of the following values:
;;;2363     *         @arg @ref LL_TIM_IC_POLARITY_RISING
;;;2364     *         @arg @ref LL_TIM_IC_POLARITY_FALLING
;;;2365     */
;;;2366   __STATIC_INLINE uint32_t LL_TIM_IC_GetPolarity(TIM_TypeDef *TIMx, uint32_t Channel)
;;;2367   {
;;;2368     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
;;;2369     return (READ_BIT(TIMx->CCER, ((TIM_CCER_CC1NP | TIM_CCER_CC1P) << SHIFT_TAB_CCxP[iChannel])) >>
;;;2370             SHIFT_TAB_CCxP[iChannel]);
;;;2371   }
;;;2372   
;;;2373   /**
;;;2374     * @brief  Connect the TIMx_CH1, CH2 and CH3 pins  to the TI1 input (XOR combination).
;;;2375     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2376     *       a timer instance provides an XOR input.
;;;2377     * @rmtoll CR2          TI1S          LL_TIM_IC_EnableXORCombination
;;;2378     * @param  TIMx Timer instance
;;;2379     * @retval None
;;;2380     */
;;;2381   __STATIC_INLINE void LL_TIM_IC_EnableXORCombination(TIM_TypeDef *TIMx)
;;;2382   {
;;;2383     SET_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2384   }
;;;2385   
;;;2386   /**
;;;2387     * @brief  Disconnect the TIMx_CH1, CH2 and CH3 pins  from the TI1 input.
;;;2388     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2389     *       a timer instance provides an XOR input.
;;;2390     * @rmtoll CR2          TI1S          LL_TIM_IC_DisableXORCombination
;;;2391     * @param  TIMx Timer instance
;;;2392     * @retval None
;;;2393     */
;;;2394   __STATIC_INLINE void LL_TIM_IC_DisableXORCombination(TIM_TypeDef *TIMx)
;;;2395   {
;;;2396     CLEAR_BIT(TIMx->CR2, TIM_CR2_TI1S);
;;;2397   }
;;;2398   
;;;2399   /**
;;;2400     * @brief  Indicates whether the TIMx_CH1, CH2 and CH3 pins are connectected to the TI1 input.
;;;2401     * @note Macro @ref IS_TIM_XOR_INSTANCE(TIMx) can be used to check whether or not
;;;2402     * a timer instance provides an XOR input.
;;;2403     * @rmtoll CR2          TI1S          LL_TIM_IC_IsEnabledXORCombination
;;;2404     * @param  TIMx Timer instance
;;;2405     * @retval State of bit (1 or 0).
;;;2406     */
;;;2407   __STATIC_INLINE uint32_t LL_TIM_IC_IsEnabledXORCombination(TIM_TypeDef *TIMx)
;;;2408   {
;;;2409     return (READ_BIT(TIMx->CR2, TIM_CR2_TI1S) == (TIM_CR2_TI1S));
;;;2410   }
;;;2411   
;;;2412   /**
;;;2413     * @brief  Get captured value for input channel 1.
;;;2414     * @note Macro @ref IS_TIM_CC1_INSTANCE(TIMx) can be used to check whether or not
;;;2415     *       input channel 1 is supported by a timer instance.
;;;2416     * @rmtoll CCR1         CCR1          LL_TIM_IC_GetCaptureCH1
;;;2417     * @param  TIMx Timer instance
;;;2418     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2419     */
;;;2420   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH1(TIM_TypeDef *TIMx)
;;;2421   {
;;;2422     return (uint32_t)(READ_REG(TIMx->CCR1));
;;;2423   }
;;;2424   
;;;2425   /**
;;;2426     * @brief  Get captured value for input channel 2.
;;;2427     * @note Macro @ref IS_TIM_CC2_INSTANCE(TIMx) can be used to check whether or not
;;;2428     *       input channel 2 is supported by a timer instance.
;;;2429     * @rmtoll CCR2         CCR2          LL_TIM_IC_GetCaptureCH2
;;;2430     * @param  TIMx Timer instance
;;;2431     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2432     */
;;;2433   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH2(TIM_TypeDef *TIMx)
;;;2434   {
;;;2435     return (uint32_t)(READ_REG(TIMx->CCR2));
;;;2436   }
;;;2437   
;;;2438   /**
;;;2439     * @brief  Get captured value for input channel 3.
;;;2440     * @note Macro @ref IS_TIM_CC3_INSTANCE(TIMx) can be used to check whether or not
;;;2441     *       input channel 3 is supported by a timer instance.
;;;2442     * @rmtoll CCR3         CCR3          LL_TIM_IC_GetCaptureCH3
;;;2443     * @param  TIMx Timer instance
;;;2444     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2445     */
;;;2446   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH3(TIM_TypeDef *TIMx)
;;;2447   {
;;;2448     return (uint32_t)(READ_REG(TIMx->CCR3));
;;;2449   }
;;;2450   
;;;2451   /**
;;;2452     * @brief  Get captured value for input channel 4.
;;;2453     * @note Macro @ref IS_TIM_CC4_INSTANCE(TIMx) can be used to check whether or not
;;;2454     *       input channel 4 is supported by a timer instance.
;;;2455     * @rmtoll CCR4         CCR4          LL_TIM_IC_GetCaptureCH4
;;;2456     * @param  TIMx Timer instance
;;;2457     * @retval CapturedValue (between Min_Data=0 and Max_Data=65535)
;;;2458     */
;;;2459   __STATIC_INLINE uint32_t LL_TIM_IC_GetCaptureCH4(TIM_TypeDef *TIMx)
;;;2460   {
;;;2461     return (uint32_t)(READ_REG(TIMx->CCR4));
;;;2462   }
;;;2463   
;;;2464   /**
;;;2465     * @}
;;;2466     */
;;;2467   
;;;2468   /** @defgroup TIM_LL_EF_Clock_Selection Counter clock selection
;;;2469     * @{
;;;2470     */
;;;2471   /**
;;;2472     * @brief  Enable external clock mode 2.
;;;2473     * @note When external clock mode 2 is enabled the counter is clocked by any active edge on the ETRF signal.
;;;2474     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2475     *       whether or not a timer instance supports external clock mode2.
;;;2476     * @rmtoll SMCR         ECE           LL_TIM_EnableExternalClock
;;;2477     * @param  TIMx Timer instance
;;;2478     * @retval None
;;;2479     */
;;;2480   __STATIC_INLINE void LL_TIM_EnableExternalClock(TIM_TypeDef *TIMx)
;;;2481   {
;;;2482     SET_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2483   }
;;;2484   
;;;2485   /**
;;;2486     * @brief  Disable external clock mode 2.
;;;2487     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2488     *       whether or not a timer instance supports external clock mode2.
;;;2489     * @rmtoll SMCR         ECE           LL_TIM_DisableExternalClock
;;;2490     * @param  TIMx Timer instance
;;;2491     * @retval None
;;;2492     */
;;;2493   __STATIC_INLINE void LL_TIM_DisableExternalClock(TIM_TypeDef *TIMx)
;;;2494   {
;;;2495     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_ECE);
;;;2496   }
;;;2497   
;;;2498   /**
;;;2499     * @brief  Indicate whether external clock mode 2 is enabled.
;;;2500     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2501     *       whether or not a timer instance supports external clock mode2.
;;;2502     * @rmtoll SMCR         ECE           LL_TIM_IsEnabledExternalClock
;;;2503     * @param  TIMx Timer instance
;;;2504     * @retval State of bit (1 or 0).
;;;2505     */
;;;2506   __STATIC_INLINE uint32_t LL_TIM_IsEnabledExternalClock(TIM_TypeDef *TIMx)
;;;2507   {
;;;2508     return (READ_BIT(TIMx->SMCR, TIM_SMCR_ECE) == (TIM_SMCR_ECE));
;;;2509   }
;;;2510   
;;;2511   /**
;;;2512     * @brief  Set the clock source of the counter clock.
;;;2513     * @note when selected clock source is external clock mode 1, the timer input
;;;2514     *       the external clock is applied is selected by calling the @ref LL_TIM_SetTriggerInput()
;;;2515     *       function. This timer input must be configured by calling
;;;2516     *       the @ref LL_TIM_IC_Config() function.
;;;2517     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(TIMx) can be used to check
;;;2518     *       whether or not a timer instance supports external clock mode1.
;;;2519     * @note Macro @ref IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(TIMx) can be used to check
;;;2520     *       whether or not a timer instance supports external clock mode2.
;;;2521     * @rmtoll SMCR         SMS           LL_TIM_SetClockSource\n
;;;2522     *         SMCR         ECE           LL_TIM_SetClockSource
;;;2523     * @param  TIMx Timer instance
;;;2524     * @param  ClockSource This parameter can be one of the following values:
;;;2525     *         @arg @ref LL_TIM_CLOCKSOURCE_INTERNAL
;;;2526     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
;;;2527     *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
;;;2528     * @retval None
;;;2529     */
;;;2530   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
;;;2531   {
;;;2532     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
;;;2533   }
;;;2534   
;;;2535   /**
;;;2536     * @brief  Set the encoder interface mode.
;;;2537     * @note Macro @ref IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx) can be used to check
;;;2538     *       whether or not a timer instance supports the encoder mode.
;;;2539     * @rmtoll SMCR         SMS           LL_TIM_SetEncoderMode
;;;2540     * @param  TIMx Timer instance
;;;2541     * @param  EncoderMode This parameter can be one of the following values:
;;;2542     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI1
;;;2543     *         @arg @ref LL_TIM_ENCODERMODE_X2_TI2
;;;2544     *         @arg @ref LL_TIM_ENCODERMODE_X4_TI12
;;;2545     * @retval None
;;;2546     */
;;;2547   __STATIC_INLINE void LL_TIM_SetEncoderMode(TIM_TypeDef *TIMx, uint32_t EncoderMode)
;;;2548   {
;;;2549     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, EncoderMode);
        0x08000de0:    68a0        .h      LDR      r0,[r4,#8]
        0x08000de2:    f0200007     ...    BIC      r0,r0,#7
        0x08000de6:    f0400001    @...    ORR      r0,r0,#1
        0x08000dea:    60a0        .`      STR      r0,[r4,#8]
;;; .\../Src/main.c
;;;1171     LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08000dec:    13a5        ..      ASRS     r5,r4,#14
        0x08000dee:    462a        *F      MOV      r2,r5
        0x08000df0:    2101        .!      MOVS     r1,#1
        0x08000df2:    4620         F      MOV      r0,r4
        0x08000df4:    f7fffbe0    ....    BL       LL_TIM_IC_SetActiveInput ; 0x80005b8
;;;1172     LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_ICPSC_DIV1);
        0x08000df8:    2200        ."      MOVS     r2,#0
        0x08000dfa:    2101        .!      MOVS     r1,#1
        0x08000dfc:    4620         F      MOV      r0,r4
        0x08000dfe:    f7fffc5f    .._.    BL       LL_TIM_IC_SetPrescaler ; 0x80006c0
;;;1173     LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_FILTER_FDIV32_N8);
        0x08000e02:    f44f0670    O.p.    MOV      r6,#0xf00000
        0x08000e06:    4632        2F      MOV      r2,r6
        0x08000e08:    2101        .!      MOVS     r1,#1
        0x08000e0a:    4620         F      MOV      r0,r4
        0x08000e0c:    f7fffc02    ....    BL       LL_TIM_IC_SetFilter ; 0x8000614
;;;1174     LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH1, LL_TIM_IC_POLARITY_RISING);
        0x08000e10:    2200        ."      MOVS     r2,#0
        0x08000e12:    2101        .!      MOVS     r1,#1
        0x08000e14:    4620         F      MOV      r0,r4
        0x08000e16:    f7fffc2b    ..+.    BL       LL_TIM_IC_SetPolarity ; 0x8000670
;;;1175     LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08000e1a:    462a        *F      MOV      r2,r5
        0x08000e1c:    2110        .!      MOVS     r1,#0x10
        0x08000e1e:    4620         F      MOV      r0,r4
        0x08000e20:    f7fffbca    ....    BL       LL_TIM_IC_SetActiveInput ; 0x80005b8
;;;1176     LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_ICPSC_DIV1);
        0x08000e24:    2200        ."      MOVS     r2,#0
        0x08000e26:    2110        .!      MOVS     r1,#0x10
        0x08000e28:    4620         F      MOV      r0,r4
        0x08000e2a:    f7fffc49    ..I.    BL       LL_TIM_IC_SetPrescaler ; 0x80006c0
;;;1177     LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_FILTER_FDIV32_N8);
        0x08000e2e:    4632        2F      MOV      r2,r6
        0x08000e30:    2110        .!      MOVS     r1,#0x10
        0x08000e32:    4620         F      MOV      r0,r4
        0x08000e34:    f7fffbee    ....    BL       LL_TIM_IC_SetFilter ; 0x8000614
;;;1178     LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH2, LL_TIM_IC_POLARITY_RISING);
        0x08000e38:    2200        ."      MOVS     r2,#0
        0x08000e3a:    2110        .!      MOVS     r1,#0x10
        0x08000e3c:    4620         F      MOV      r0,r4
        0x08000e3e:    f7fffc17    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000670
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2578     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
        0x08000e42:    6860        `h      LDR      r0,[r4,#4]
        0x08000e44:    f0200070     .p.    BIC      r0,r0,#0x70
        0x08000e48:    f0400020    @. .    ORR      r0,r0,#0x20
        0x08000e4c:    6060        ``      STR      r0,[r4,#4]
;;;2579   }
;;;2580   
;;;2581   /**
;;;2582     * @brief  Set the synchronization mode of a slave timer.
;;;2583     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2584     *       a timer instance can operate as a slave timer.
;;;2585     * @rmtoll SMCR         SMS           LL_TIM_SetSlaveMode
;;;2586     * @param  TIMx Timer instance
;;;2587     * @param  SlaveMode This parameter can be one of the following values:
;;;2588     *         @arg @ref LL_TIM_SLAVEMODE_DISABLED
;;;2589     *         @arg @ref LL_TIM_SLAVEMODE_RESET
;;;2590     *         @arg @ref LL_TIM_SLAVEMODE_GATED
;;;2591     *         @arg @ref LL_TIM_SLAVEMODE_TRIGGER
;;;2592     * @retval None
;;;2593     */
;;;2594   __STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
;;;2595   {
;;;2596     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
;;;2597   }
;;;2598   
;;;2599   /**
;;;2600     * @brief  Set the selects the trigger input to be used to synchronize the counter.
;;;2601     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2602     *       a timer instance can operate as a slave timer.
;;;2603     * @rmtoll SMCR         TS            LL_TIM_SetTriggerInput
;;;2604     * @param  TIMx Timer instance
;;;2605     * @param  TriggerInput This parameter can be one of the following values:
;;;2606     *         @arg @ref LL_TIM_TS_ITR0
;;;2607     *         @arg @ref LL_TIM_TS_ITR1
;;;2608     *         @arg @ref LL_TIM_TS_ITR2
;;;2609     *         @arg @ref LL_TIM_TS_ITR3
;;;2610     *         @arg @ref LL_TIM_TS_TI1F_ED
;;;2611     *         @arg @ref LL_TIM_TS_TI1FP1
;;;2612     *         @arg @ref LL_TIM_TS_TI2FP2
;;;2613     *         @arg @ref LL_TIM_TS_ETRF
;;;2614     * @retval None
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
;;;2619   }
;;;2620   
;;;2621   /**
;;;2622     * @brief  Enable the Master/Slave mode.
;;;2623     * @note Macro @ref IS_TIM_SLAVE_INSTANCE(TIMx) can be used to check whether or not
;;;2624     *       a timer instance can operate as a slave timer.
;;;2625     * @rmtoll SMCR         MSM           LL_TIM_EnableMasterSlaveMode
;;;2626     * @param  TIMx Timer instance
;;;2627     * @retval None
;;;2628     */
;;;2629   __STATIC_INLINE void LL_TIM_EnableMasterSlaveMode(TIM_TypeDef *TIMx)
;;;2630   {
;;;2631     SET_BIT(TIMx->SMCR, TIM_SMCR_MSM);
        0x08000e4e:    68a0        .h      LDR      r0,[r4,#8]
        0x08000e50:    f0400080    @...    ORR      r0,r0,#0x80
        0x08000e54:    60a0        .`      STR      r0,[r4,#8]
;;; .\../Src/main.c
;;;1181     LL_TIM_IC_SetActiveInput(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ACTIVEINPUT_DIRECTTI);
        0x08000e56:    462a        *F      MOV      r2,r5
        0x08000e58:    15a5        ..      ASRS     r5,r4,#22
        0x08000e5a:    4629        )F      MOV      r1,r5
        0x08000e5c:    4620         F      MOV      r0,r4
        0x08000e5e:    f7fffbab    ....    BL       LL_TIM_IC_SetActiveInput ; 0x80005b8
;;;1182     LL_TIM_IC_SetPrescaler(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_ICPSC_DIV1);
        0x08000e62:    2200        ."      MOVS     r2,#0
        0x08000e64:    4629        )F      MOV      r1,r5
        0x08000e66:    4620         F      MOV      r0,r4
        0x08000e68:    f7fffc2a    ..*.    BL       LL_TIM_IC_SetPrescaler ; 0x80006c0
;;;1183     LL_TIM_IC_SetFilter(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_FILTER_FDIV32_N8);
        0x08000e6c:    4632        2F      MOV      r2,r6
        0x08000e6e:    4629        )F      MOV      r1,r5
        0x08000e70:    4620         F      MOV      r0,r4
        0x08000e72:    f7fffbcf    ....    BL       LL_TIM_IC_SetFilter ; 0x8000614
;;;1184     LL_TIM_IC_SetPolarity(TIM4, LL_TIM_CHANNEL_CH3, LL_TIM_IC_POLARITY_RISING);
        0x08000e76:    2200        ."      MOVS     r2,#0
        0x08000e78:    4629        )F      MOV      r1,r5
        0x08000e7a:    4620         F      MOV      r0,r4
        0x08000e7c:    f7fffbf8    ....    BL       LL_TIM_IC_SetPolarity ; 0x8000670
;;;1185     /* USER CODE BEGIN TIM4_Init 2 */
;;;1186   
;;;1187     /* USER CODE END TIM4_Init 2 */
;;;1188   
;;;1189   }
        0x08000e80:    b00a        ..      ADD      sp,sp,#0x28
        0x08000e82:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08000e84:    0401c0c1    ....    DCD    67223745
        0x08000e88:    40010c00    ...@    DCD    1073810432
        0x08000e8c:    40000800    ...@    DCD    1073743872
    $t
    i.MX_USART2_UART_Init
    MX_USART2_UART_Init
;;;1190   
;;;1191   /**
;;;1192     * @brief USART2 Initialization Function
;;;1193     * @param None
;;;1194     * @retval None
;;;1195     */
;;;1196   static void MX_USART2_UART_Init(void)
;;;1197   {
        0x08000e90:    b5f0        ..      PUSH     {r4-r7,lr}
        0x08000e92:    b08b        ..      SUB      sp,sp,#0x2c
;;;1198   
;;;1199     /* USER CODE BEGIN USART2_Init 0 */
;;;1200     pBufferReadyForReception = aRXBufferA;
        0x08000e94:    4d54        TM      LDR      r5,[pc,#336] ; [0x8000fe8] = 0x20000038
        0x08000e96:    4853        SH      LDR      r0,[pc,#332] ; [0x8000fe4] = 0x20000538
        0x08000e98:    6168        ha      STR      r0,[r5,#0x14]
;;;1201     pBufferReadyForUser      = aRXBufferB;
        0x08000e9a:    300c        .0      ADDS     r0,r0,#0xc
        0x08000e9c:    6128        (a      STR      r0,[r5,#0x10]
;;;1202     uwNbReceivedChars = 0;
        0x08000e9e:    2600        .&      MOVS     r6,#0
        0x08000ea0:    60ee        .`      STR      r6,[r5,#0xc]
;;;1203     ubUART2ReceptionComplete = 0;
        0x08000ea2:    702e        .p      STRB     r6,[r5,#0]
;;;1204     /* USER CODE END USART2_Init 0 */
;;;1205   
;;;1206     LL_USART_InitTypeDef USART_InitStruct = {0};
        0x08000ea4:    2118        .!      MOVS     r1,#0x18
        0x08000ea6:    a805        ..      ADD      r0,sp,#0x14
        0x08000ea8:    f7fff974    ..t.    BL       __aeabi_memclr ; 0x8000194
;;;1207   
;;;1208     LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
        0x08000eac:    2114        .!      MOVS     r1,#0x14
        0x08000eae:    4668        hF      MOV      r0,sp
        0x08000eb0:    f7fff970    ..p.    BL       __aeabi_memclr ; 0x8000194
;;;1209   
;;;1210     /* Peripheral clock enable */
;;;1211     LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);
        0x08000eb4:    f44f3000    O..0    MOV      r0,#0x20000
        0x08000eb8:    f7fffa48    ..H.    BL       LL_APB1_GRP1_EnableClock ; 0x800034c
;;;1212     
;;;1213     LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
        0x08000ebc:    2004        .       MOVS     r0,#4
        0x08000ebe:    f7fffa51    ..Q.    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;1214     /**USART2 GPIO Configuration  
;;;1215     PA2   ------> USART2_TX
;;;1216     PA3   ------> USART2_RX 
;;;1217     */
;;;1218     GPIO_InitStruct.Pin = LL_GPIO_PIN_2;
        0x08000ec2:    f2404004    @..@    MOV      r0,#0x404
        0x08000ec6:    9000        ..      STR      r0,[sp,#0]
;;;1219     GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
        0x08000ec8:    2009        .       MOVS     r0,#9
        0x08000eca:    9001        ..      STR      r0,[sp,#4]
;;;1220     GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
        0x08000ecc:    2003        .       MOVS     r0,#3
        0x08000ece:    9002        ..      STR      r0,[sp,#8]
;;;1221     GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
        0x08000ed0:    9603        ..      STR      r6,[sp,#0xc]
;;;1222     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000ed2:    4c46        FL      LDR      r4,[pc,#280] ; [0x8000fec] = 0x40010800
        0x08000ed4:    4669        iF      MOV      r1,sp
        0x08000ed6:    4620         F      MOV      r0,r4
        0x08000ed8:    f7fffaa6    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1223   
;;;1224     GPIO_InitStruct.Pin = LL_GPIO_PIN_3;
        0x08000edc:    f6400108    @...    MOV      r1,#0x808
        0x08000ee0:    9100        ..      STR      r1,[sp,#0]
;;;1225     GPIO_InitStruct.Mode = LL_GPIO_MODE_FLOATING;
        0x08000ee2:    2104        .!      MOVS     r1,#4
        0x08000ee4:    9101        ..      STR      r1,[sp,#4]
;;;1226     LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
        0x08000ee6:    4669        iF      MOV      r1,sp
        0x08000ee8:    4620         F      MOV      r0,r4
        0x08000eea:    f7fffa9d    ....    BL       LL_GPIO_Init ; 0x8000428
;;;1227   
;;;1228     /* USART2 DMA Init */
;;;1229     
;;;1230     /* USART2_TX Init */
;;;1231     LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_7, LL_DMA_DIRECTION_MEMORY_TO_PERIPH);
        0x08000eee:    4f40        @O      LDR      r7,[pc,#256] ; [0x8000ff0] = 0x40020000
        0x08000ef0:    2210        ."      MOVS     r2,#0x10
        0x08000ef2:    2107        .!      MOVS     r1,#7
        0x08000ef4:    4638        8F      MOV      r0,r7
        0x08000ef6:    f7fffa4d    ..M.    BL       LL_DMA_SetDataTransferDirection ; 0x8000394
;;;1232   
;;;1233     LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_7, LL_DMA_PRIORITY_LOW);
        0x08000efa:    2200        ."      MOVS     r2,#0
        0x08000efc:    2107        .!      MOVS     r1,#7
        0x08000efe:    4638        8F      MOV      r0,r7
        0x08000f00:    f7fffa3c    ..<.    BL       LL_DMA_SetChannelPriorityLevel ; 0x800037c
;;;1234   
;;;1235     LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_7, LL_DMA_MODE_NORMAL);
        0x08000f04:    2200        ."      MOVS     r2,#0
        0x08000f06:    2107        .!      MOVS     r1,#7
        0x08000f08:    4638        8F      MOV      r0,r7
        0x08000f0a:    f7fffa69    ..i.    BL       LL_DMA_SetMode ; 0x80003e0
;;;1236   
;;;1237     LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_7, LL_DMA_PERIPH_NOINCREMENT);
        0x08000f0e:    2200        ."      MOVS     r2,#0
        0x08000f10:    2107        .!      MOVS     r1,#7
        0x08000f12:    4638        8F      MOV      r0,r7
        0x08000f14:    f7fffa70    ..p.    BL       LL_DMA_SetPeriphIncMode ; 0x80003f8
;;;1238   
;;;1239     LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_7, LL_DMA_MEMORY_INCREMENT);
        0x08000f18:    2280        ."      MOVS     r2,#0x80
        0x08000f1a:    2107        .!      MOVS     r1,#7
        0x08000f1c:    4638        8F      MOV      r0,r7
        0x08000f1e:    f7fffa47    ..G.    BL       LL_DMA_SetMemoryIncMode ; 0x80003b0
;;;1240   
;;;1241     LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_7, LL_DMA_PDATAALIGN_BYTE);
        0x08000f22:    2200        ."      MOVS     r2,#0
        0x08000f24:    2107        .!      MOVS     r1,#7
        0x08000f26:    4638        8F      MOV      r0,r7
        0x08000f28:    f7fffa72    ..r.    BL       LL_DMA_SetPeriphSize ; 0x8000410
;;;1242   
;;;1243     LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_7, LL_DMA_MDATAALIGN_BYTE);
        0x08000f2c:    2200        ."      MOVS     r2,#0
        0x08000f2e:    2107        .!      MOVS     r1,#7
        0x08000f30:    4638        8F      MOV      r0,r7
        0x08000f32:    f7fffa49    ..I.    BL       LL_DMA_SetMemorySize ; 0x80003c8
;;;1244   
;;;1245     /* USART2 interrupt Init */
;;;1246     NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),2, 0));
        0x08000f36:    f000f885    ....    BL       NVIC_GetPriorityGrouping ; 0x8001044
        0x08000f3a:    2200        ."      MOVS     r2,#0
        0x08000f3c:    2102        .!      MOVS     r1,#2
        0x08000f3e:    f000f868    ..h.    BL       NVIC_EncodePriority ; 0x8001012
        0x08000f42:    4601        .F      MOV      r1,r0
        0x08000f44:    2026        &       MOVS     r0,#0x26
        0x08000f46:    f000f885    ....    BL       NVIC_SetPriority ; 0x8001054
;;;1247     NVIC_EnableIRQ(USART2_IRQn);
        0x08000f4a:    2026        &       MOVS     r0,#0x26
        0x08000f4c:    f000f856    ..V.    BL       NVIC_EnableIRQ ; 0x8000ffc
;;;1248   
;;;1249     /* USER CODE BEGIN USART2_Init 1 */
;;;1250   
;;;1251     LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_7,
        0x08000f50:    4928        (I      LDR      r1,[pc,#160] ; [0x8000ff4] = 0x8001f6a
        0x08000f52:    4c29        )L      LDR      r4,[pc,#164] ; [0x8000ff8] = 0x40004400
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2451     return ((uint32_t) &(USARTx->DR));
        0x08000f54:    1d22        ".      ADDS     r2,r4,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;595      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
        0x08000f56:    f1a10323    ..#.    SUB      r3,r1,#0x23
        0x08000f5a:    1dd8        ..      ADDS     r0,r3,#7
        0x08000f5c:    799b        .y      LDRB     r3,[r3,#6]
        0x08000f5e:    58fb        .X      LDR      r3,[r7,r3]
        0x08000f60:    f2440710    D...    MOV      r7,#0x4010
        0x08000f64:    403b        ;@      ANDS     r3,r3,r7
;;;596                       DMA_CCR_DIR | DMA_CCR_MEM2MEM));
;;;597    }
;;;598    
;;;599    /**
;;;600      * @brief  Set DMA mode circular or normal.
;;;601      * @note The circular buffer mode cannot be used if the memory-to-memory
;;;602      * data transfer is configured on the selected Channel.
;;;603      * @rmtoll CCR          CIRC          LL_DMA_SetMode
;;;604      * @param  DMAx DMAx Instance
;;;605      * @param  Channel This parameter can be one of the following values:
;;;606      *         @arg @ref LL_DMA_CHANNEL_1
;;;607      *         @arg @ref LL_DMA_CHANNEL_2
;;;608      *         @arg @ref LL_DMA_CHANNEL_3
;;;609      *         @arg @ref LL_DMA_CHANNEL_4
;;;610      *         @arg @ref LL_DMA_CHANNEL_5
;;;611      *         @arg @ref LL_DMA_CHANNEL_6
;;;612      *         @arg @ref LL_DMA_CHANNEL_7
;;;613      * @param  Mode This parameter can be one of the following values:
;;;614      *         @arg @ref LL_DMA_MODE_NORMAL
;;;615      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;616      * @retval None
;;;617      */
;;;618    __STATIC_INLINE void LL_DMA_SetMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Mode)
;;;619    {
;;;620      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_CIRC,
;;;621                 Mode);
;;;622    }
;;;623    
;;;624    /**
;;;625      * @brief  Get DMA mode circular or normal.
;;;626      * @rmtoll CCR          CIRC          LL_DMA_GetMode
;;;627      * @param  DMAx DMAx Instance
;;;628      * @param  Channel This parameter can be one of the following values:
;;;629      *         @arg @ref LL_DMA_CHANNEL_1
;;;630      *         @arg @ref LL_DMA_CHANNEL_2
;;;631      *         @arg @ref LL_DMA_CHANNEL_3
;;;632      *         @arg @ref LL_DMA_CHANNEL_4
;;;633      *         @arg @ref LL_DMA_CHANNEL_5
;;;634      *         @arg @ref LL_DMA_CHANNEL_6
;;;635      *         @arg @ref LL_DMA_CHANNEL_7
;;;636      * @retval Returned value can be one of the following values:
;;;637      *         @arg @ref LL_DMA_MODE_NORMAL
;;;638      *         @arg @ref LL_DMA_MODE_CIRCULAR
;;;639      */
;;;640    __STATIC_INLINE uint32_t LL_DMA_GetMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;641    {
;;;642      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;643                       DMA_CCR_CIRC));
;;;644    }
;;;645    
;;;646    /**
;;;647      * @brief  Set Peripheral increment mode.
;;;648      * @rmtoll CCR          PINC          LL_DMA_SetPeriphIncMode
;;;649      * @param  DMAx DMAx Instance
;;;650      * @param  Channel This parameter can be one of the following values:
;;;651      *         @arg @ref LL_DMA_CHANNEL_1
;;;652      *         @arg @ref LL_DMA_CHANNEL_2
;;;653      *         @arg @ref LL_DMA_CHANNEL_3
;;;654      *         @arg @ref LL_DMA_CHANNEL_4
;;;655      *         @arg @ref LL_DMA_CHANNEL_5
;;;656      *         @arg @ref LL_DMA_CHANNEL_6
;;;657      *         @arg @ref LL_DMA_CHANNEL_7
;;;658      * @param  PeriphOrM2MSrcIncMode This parameter can be one of the following values:
;;;659      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;660      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;661      * @retval None
;;;662      */
;;;663    __STATIC_INLINE void LL_DMA_SetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcIncMode)
;;;664    {
;;;665      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PINC,
;;;666                 PeriphOrM2MSrcIncMode);
;;;667    }
;;;668    
;;;669    /**
;;;670      * @brief  Get Peripheral increment mode.
;;;671      * @rmtoll CCR          PINC          LL_DMA_GetPeriphIncMode
;;;672      * @param  DMAx DMAx Instance
;;;673      * @param  Channel This parameter can be one of the following values:
;;;674      *         @arg @ref LL_DMA_CHANNEL_1
;;;675      *         @arg @ref LL_DMA_CHANNEL_2
;;;676      *         @arg @ref LL_DMA_CHANNEL_3
;;;677      *         @arg @ref LL_DMA_CHANNEL_4
;;;678      *         @arg @ref LL_DMA_CHANNEL_5
;;;679      *         @arg @ref LL_DMA_CHANNEL_6
;;;680      *         @arg @ref LL_DMA_CHANNEL_7
;;;681      * @retval Returned value can be one of the following values:
;;;682      *         @arg @ref LL_DMA_PERIPH_INCREMENT
;;;683      *         @arg @ref LL_DMA_PERIPH_NOINCREMENT
;;;684      */
;;;685    __STATIC_INLINE uint32_t LL_DMA_GetPeriphIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;686    {
;;;687      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;688                       DMA_CCR_PINC));
;;;689    }
;;;690    
;;;691    /**
;;;692      * @brief  Set Memory increment mode.
;;;693      * @rmtoll CCR          MINC          LL_DMA_SetMemoryIncMode
;;;694      * @param  DMAx DMAx Instance
;;;695      * @param  Channel This parameter can be one of the following values:
;;;696      *         @arg @ref LL_DMA_CHANNEL_1
;;;697      *         @arg @ref LL_DMA_CHANNEL_2
;;;698      *         @arg @ref LL_DMA_CHANNEL_3
;;;699      *         @arg @ref LL_DMA_CHANNEL_4
;;;700      *         @arg @ref LL_DMA_CHANNEL_5
;;;701      *         @arg @ref LL_DMA_CHANNEL_6
;;;702      *         @arg @ref LL_DMA_CHANNEL_7
;;;703      * @param  MemoryOrM2MDstIncMode This parameter can be one of the following values:
;;;704      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;705      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;706      * @retval None
;;;707      */
;;;708    __STATIC_INLINE void LL_DMA_SetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstIncMode)
;;;709    {
;;;710      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MINC,
;;;711                 MemoryOrM2MDstIncMode);
;;;712    }
;;;713    
;;;714    /**
;;;715      * @brief  Get Memory increment mode.
;;;716      * @rmtoll CCR          MINC          LL_DMA_GetMemoryIncMode
;;;717      * @param  DMAx DMAx Instance
;;;718      * @param  Channel This parameter can be one of the following values:
;;;719      *         @arg @ref LL_DMA_CHANNEL_1
;;;720      *         @arg @ref LL_DMA_CHANNEL_2
;;;721      *         @arg @ref LL_DMA_CHANNEL_3
;;;722      *         @arg @ref LL_DMA_CHANNEL_4
;;;723      *         @arg @ref LL_DMA_CHANNEL_5
;;;724      *         @arg @ref LL_DMA_CHANNEL_6
;;;725      *         @arg @ref LL_DMA_CHANNEL_7
;;;726      * @retval Returned value can be one of the following values:
;;;727      *         @arg @ref LL_DMA_MEMORY_INCREMENT
;;;728      *         @arg @ref LL_DMA_MEMORY_NOINCREMENT
;;;729      */
;;;730    __STATIC_INLINE uint32_t LL_DMA_GetMemoryIncMode(DMA_TypeDef *DMAx, uint32_t Channel)
;;;731    {
;;;732      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;733                       DMA_CCR_MINC));
;;;734    }
;;;735    
;;;736    /**
;;;737      * @brief  Set Peripheral size.
;;;738      * @rmtoll CCR          PSIZE         LL_DMA_SetPeriphSize
;;;739      * @param  DMAx DMAx Instance
;;;740      * @param  Channel This parameter can be one of the following values:
;;;741      *         @arg @ref LL_DMA_CHANNEL_1
;;;742      *         @arg @ref LL_DMA_CHANNEL_2
;;;743      *         @arg @ref LL_DMA_CHANNEL_3
;;;744      *         @arg @ref LL_DMA_CHANNEL_4
;;;745      *         @arg @ref LL_DMA_CHANNEL_5
;;;746      *         @arg @ref LL_DMA_CHANNEL_6
;;;747      *         @arg @ref LL_DMA_CHANNEL_7
;;;748      * @param  PeriphOrM2MSrcDataSize This parameter can be one of the following values:
;;;749      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;750      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;751      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;752      * @retval None
;;;753      */
;;;754    __STATIC_INLINE void LL_DMA_SetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t PeriphOrM2MSrcDataSize)
;;;755    {
;;;756      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PSIZE,
;;;757                 PeriphOrM2MSrcDataSize);
;;;758    }
;;;759    
;;;760    /**
;;;761      * @brief  Get Peripheral size.
;;;762      * @rmtoll CCR          PSIZE         LL_DMA_GetPeriphSize
;;;763      * @param  DMAx DMAx Instance
;;;764      * @param  Channel This parameter can be one of the following values:
;;;765      *         @arg @ref LL_DMA_CHANNEL_1
;;;766      *         @arg @ref LL_DMA_CHANNEL_2
;;;767      *         @arg @ref LL_DMA_CHANNEL_3
;;;768      *         @arg @ref LL_DMA_CHANNEL_4
;;;769      *         @arg @ref LL_DMA_CHANNEL_5
;;;770      *         @arg @ref LL_DMA_CHANNEL_6
;;;771      *         @arg @ref LL_DMA_CHANNEL_7
;;;772      * @retval Returned value can be one of the following values:
;;;773      *         @arg @ref LL_DMA_PDATAALIGN_BYTE
;;;774      *         @arg @ref LL_DMA_PDATAALIGN_HALFWORD
;;;775      *         @arg @ref LL_DMA_PDATAALIGN_WORD
;;;776      */
;;;777    __STATIC_INLINE uint32_t LL_DMA_GetPeriphSize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;778    {
;;;779      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;780                       DMA_CCR_PSIZE));
;;;781    }
;;;782    
;;;783    /**
;;;784      * @brief  Set Memory size.
;;;785      * @rmtoll CCR          MSIZE         LL_DMA_SetMemorySize
;;;786      * @param  DMAx DMAx Instance
;;;787      * @param  Channel This parameter can be one of the following values:
;;;788      *         @arg @ref LL_DMA_CHANNEL_1
;;;789      *         @arg @ref LL_DMA_CHANNEL_2
;;;790      *         @arg @ref LL_DMA_CHANNEL_3
;;;791      *         @arg @ref LL_DMA_CHANNEL_4
;;;792      *         @arg @ref LL_DMA_CHANNEL_5
;;;793      *         @arg @ref LL_DMA_CHANNEL_6
;;;794      *         @arg @ref LL_DMA_CHANNEL_7
;;;795      * @param  MemoryOrM2MDstDataSize This parameter can be one of the following values:
;;;796      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;797      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;798      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;799      * @retval None
;;;800      */
;;;801    __STATIC_INLINE void LL_DMA_SetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t MemoryOrM2MDstDataSize)
;;;802    {
;;;803      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_MSIZE,
;;;804                 MemoryOrM2MDstDataSize);
;;;805    }
;;;806    
;;;807    /**
;;;808      * @brief  Get Memory size.
;;;809      * @rmtoll CCR          MSIZE         LL_DMA_GetMemorySize
;;;810      * @param  DMAx DMAx Instance
;;;811      * @param  Channel This parameter can be one of the following values:
;;;812      *         @arg @ref LL_DMA_CHANNEL_1
;;;813      *         @arg @ref LL_DMA_CHANNEL_2
;;;814      *         @arg @ref LL_DMA_CHANNEL_3
;;;815      *         @arg @ref LL_DMA_CHANNEL_4
;;;816      *         @arg @ref LL_DMA_CHANNEL_5
;;;817      *         @arg @ref LL_DMA_CHANNEL_6
;;;818      *         @arg @ref LL_DMA_CHANNEL_7
;;;819      * @retval Returned value can be one of the following values:
;;;820      *         @arg @ref LL_DMA_MDATAALIGN_BYTE
;;;821      *         @arg @ref LL_DMA_MDATAALIGN_HALFWORD
;;;822      *         @arg @ref LL_DMA_MDATAALIGN_WORD
;;;823      */
;;;824    __STATIC_INLINE uint32_t LL_DMA_GetMemorySize(DMA_TypeDef *DMAx, uint32_t Channel)
;;;825    {
;;;826      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;827                       DMA_CCR_MSIZE));
;;;828    }
;;;829    
;;;830    /**
;;;831      * @brief  Set Channel priority level.
;;;832      * @rmtoll CCR          PL            LL_DMA_SetChannelPriorityLevel
;;;833      * @param  DMAx DMAx Instance
;;;834      * @param  Channel This parameter can be one of the following values:
;;;835      *         @arg @ref LL_DMA_CHANNEL_1
;;;836      *         @arg @ref LL_DMA_CHANNEL_2
;;;837      *         @arg @ref LL_DMA_CHANNEL_3
;;;838      *         @arg @ref LL_DMA_CHANNEL_4
;;;839      *         @arg @ref LL_DMA_CHANNEL_5
;;;840      *         @arg @ref LL_DMA_CHANNEL_6
;;;841      *         @arg @ref LL_DMA_CHANNEL_7
;;;842      * @param  Priority This parameter can be one of the following values:
;;;843      *         @arg @ref LL_DMA_PRIORITY_LOW
;;;844      *         @arg @ref LL_DMA_PRIORITY_MEDIUM
;;;845      *         @arg @ref LL_DMA_PRIORITY_HIGH
;;;846      *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
;;;847      * @retval None
;;;848      */
;;;849    __STATIC_INLINE void LL_DMA_SetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t Priority)
;;;850    {
;;;851      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_PL,
;;;852                 Priority);
;;;853    }
;;;854    
;;;855    /**
;;;856      * @brief  Get Channel priority level.
;;;857      * @rmtoll CCR          PL            LL_DMA_GetChannelPriorityLevel
;;;858      * @param  DMAx DMAx Instance
;;;859      * @param  Channel This parameter can be one of the following values:
;;;860      *         @arg @ref LL_DMA_CHANNEL_1
;;;861      *         @arg @ref LL_DMA_CHANNEL_2
;;;862      *         @arg @ref LL_DMA_CHANNEL_3
;;;863      *         @arg @ref LL_DMA_CHANNEL_4
;;;864      *         @arg @ref LL_DMA_CHANNEL_5
;;;865      *         @arg @ref LL_DMA_CHANNEL_6
;;;866      *         @arg @ref LL_DMA_CHANNEL_7
;;;867      * @retval Returned value can be one of the following values:
;;;868      *         @arg @ref LL_DMA_PRIORITY_LOW
;;;869      *         @arg @ref LL_DMA_PRIORITY_MEDIUM
;;;870      *         @arg @ref LL_DMA_PRIORITY_HIGH
;;;871      *         @arg @ref LL_DMA_PRIORITY_VERYHIGH
;;;872      */
;;;873    __STATIC_INLINE uint32_t LL_DMA_GetChannelPriorityLevel(DMA_TypeDef *DMAx, uint32_t Channel)
;;;874    {
;;;875      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR,
;;;876                       DMA_CCR_PL));
;;;877    }
;;;878    
;;;879    /**
;;;880      * @brief  Set Number of data to transfer.
;;;881      * @note   This action has no effect if
;;;882      *         channel is enabled.
;;;883      * @rmtoll CNDTR        NDT           LL_DMA_SetDataLength
;;;884      * @param  DMAx DMAx Instance
;;;885      * @param  Channel This parameter can be one of the following values:
;;;886      *         @arg @ref LL_DMA_CHANNEL_1
;;;887      *         @arg @ref LL_DMA_CHANNEL_2
;;;888      *         @arg @ref LL_DMA_CHANNEL_3
;;;889      *         @arg @ref LL_DMA_CHANNEL_4
;;;890      *         @arg @ref LL_DMA_CHANNEL_5
;;;891      *         @arg @ref LL_DMA_CHANNEL_6
;;;892      *         @arg @ref LL_DMA_CHANNEL_7
;;;893      * @param  NbData Between Min_Data = 0 and Max_Data = 0x0000FFFF
;;;894      * @retval None
;;;895      */
;;;896    __STATIC_INLINE void LL_DMA_SetDataLength(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t NbData)
;;;897    {
;;;898      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
;;;899                 DMA_CNDTR_NDT, NbData);
;;;900    }
;;;901    
;;;902    /**
;;;903      * @brief  Get Number of data to transfer.
;;;904      * @note   Once the channel is enabled, the return value indicate the
;;;905      *         remaining bytes to be transmitted.
;;;906      * @rmtoll CNDTR        NDT           LL_DMA_GetDataLength
;;;907      * @param  DMAx DMAx Instance
;;;908      * @param  Channel This parameter can be one of the following values:
;;;909      *         @arg @ref LL_DMA_CHANNEL_1
;;;910      *         @arg @ref LL_DMA_CHANNEL_2
;;;911      *         @arg @ref LL_DMA_CHANNEL_3
;;;912      *         @arg @ref LL_DMA_CHANNEL_4
;;;913      *         @arg @ref LL_DMA_CHANNEL_5
;;;914      *         @arg @ref LL_DMA_CHANNEL_6
;;;915      *         @arg @ref LL_DMA_CHANNEL_7
;;;916      * @retval Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;917      */
;;;918    __STATIC_INLINE uint32_t LL_DMA_GetDataLength(DMA_TypeDef *DMAx, uint32_t Channel)
;;;919    {
;;;920      return (READ_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
;;;921                       DMA_CNDTR_NDT));
;;;922    }
;;;923    
;;;924    /**
;;;925      * @brief  Configure the Source and Destination addresses.
;;;926      * @note   This API must not be called when the DMA channel is enabled.
;;;927      * @note   Each IP using DMA provides an API to get directly the register adress (LL_PPP_DMA_GetRegAddr).
;;;928      * @rmtoll CPAR         PA            LL_DMA_ConfigAddresses\n
;;;929      *         CMAR         MA            LL_DMA_ConfigAddresses
;;;930      * @param  DMAx DMAx Instance
;;;931      * @param  Channel This parameter can be one of the following values:
;;;932      *         @arg @ref LL_DMA_CHANNEL_1
;;;933      *         @arg @ref LL_DMA_CHANNEL_2
;;;934      *         @arg @ref LL_DMA_CHANNEL_3
;;;935      *         @arg @ref LL_DMA_CHANNEL_4
;;;936      *         @arg @ref LL_DMA_CHANNEL_5
;;;937      *         @arg @ref LL_DMA_CHANNEL_6
;;;938      *         @arg @ref LL_DMA_CHANNEL_7
;;;939      * @param  SrcAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;940      * @param  DstAddress Between Min_Data = 0 and Max_Data = 0xFFFFFFFF
;;;941      * @param  Direction This parameter can be one of the following values:
;;;942      *         @arg @ref LL_DMA_DIRECTION_PERIPH_TO_MEMORY
;;;943      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_PERIPH
;;;944      *         @arg @ref LL_DMA_DIRECTION_MEMORY_TO_MEMORY
;;;945      * @retval None
;;;946      */
;;;947    __STATIC_INLINE void LL_DMA_ConfigAddresses(DMA_TypeDef *DMAx, uint32_t Channel, uint32_t SrcAddress,
;;;948                                                uint32_t DstAddress, uint32_t Direction)
;;;949    {
;;;950      /* Direction Memory to Periph */
;;;951      if (Direction == LL_DMA_DIRECTION_MEMORY_TO_PERIPH)
;;;952      {
;;;953        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
        0x08000f66:    4f22        "O      LDR      r7,[pc,#136] ; [0x8000ff0] = 0x40020000
        0x08000f68:    370c        .7      ADDS     r7,r7,#0xc
;;;954        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
        0x08000f6a:    f1a70c04    ....    SUB      r12,r7,#4
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h (951)
        0x08000f6e:    2b10        .+      CMP      r3,#0x10
        0x08000f70:    d02f        /.      BEQ      0x8000fd2 ; MX_USART2_UART_Init + 322
;;;952      {
;;;953        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
;;;954        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
;;;955      }
;;;956      /* Direction Periph to Memory and Memory to Memory */
;;;957      else
;;;958      {
;;;959        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, SrcAddress);
        0x08000f72:    f1a10323    ..#.    SUB      r3,r1,#0x23
        0x08000f76:    799b        .y      LDRB     r3,[r3,#6]
        0x08000f78:    f843100c    C...    STR      r1,[r3,r12]
;;;960        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, DstAddress);
        0x08000f7c:    f8101c01    ....    LDRB     r1,[r0,#-1]
        0x08000f80:    51ca        .Q      STR      r2,[r1,r7]
;;; .\../Src/main.c
;;;1255     LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_7, ubNbDataToTransmit);
        0x08000f82:    7869        ix      LDRB     r1,[r5,#1]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;898      MODIFY_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CNDTR,
        0x08000f84:    4a1b        .J      LDR      r2,[pc,#108] ; [0x8000ff4] = 0x8001f6a
        0x08000f86:    3a23        #:      SUBS     r2,r2,#0x23
        0x08000f88:    7993        .y      LDRB     r3,[r2,#6]
        0x08000f8a:    4a19        .J      LDR      r2,[pc,#100] ; [0x8000ff0] = 0x40020000
        0x08000f8c:    1d12        ..      ADDS     r2,r2,#4
        0x08000f8e:    589b        .X      LDR      r3,[r3,r2]
        0x08000f90:    f8100c01    ....    LDRB     r0,[r0,#-1]
        0x08000f94:    f36f030f    o...    BFC      r3,#0,#16
        0x08000f98:    430b        .C      ORRS     r3,r3,r1
        0x08000f9a:    5083        .P      STR      r3,[r0,r2]
;;; .\../Src/main.c
;;;1259     USART_InitStruct.BaudRate = 115200;
        0x08000f9c:    f44f30e1    O..0    MOV      r0,#0x1c200
        0x08000fa0:    9005        ..      STR      r0,[sp,#0x14]
;;;1260     USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
        0x08000fa2:    9606        ..      STR      r6,[sp,#0x18]
;;;1261     USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
        0x08000fa4:    9607        ..      STR      r6,[sp,#0x1c]
;;;1262     USART_InitStruct.Parity = LL_USART_PARITY_NONE;
        0x08000fa6:    9608        ..      STR      r6,[sp,#0x20]
;;;1263     USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
        0x08000fa8:    200c        .       MOVS     r0,#0xc
        0x08000faa:    9009        ..      STR      r0,[sp,#0x24]
;;;1264     USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
        0x08000fac:    960a        ..      STR      r6,[sp,#0x28]
;;;1265     LL_USART_Init(USART2, &USART_InitStruct);
        0x08000fae:    a905        ..      ADD      r1,sp,#0x14
        0x08000fb0:    4620         F      MOV      r0,r4
        0x08000fb2:    f7fffc59    ..Y.    BL       LL_USART_Init ; 0x8000868
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1549     CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
        0x08000fb6:    6920         i      LDR      r0,[r4,#0x10]
        0x08000fb8:    f4204090     ..@    BIC      r0,r0,#0x4800
        0x08000fbc:    6120         a      STR      r0,[r4,#0x10]
;;;1550     CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
        0x08000fbe:    6960        `i      LDR      r0,[r4,#0x14]
        0x08000fc0:    f020002a     .*.    BIC      r0,r0,#0x2a
        0x08000fc4:    6160        `a      STR      r0,[r4,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h (431)
        0x08000fc6:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08000fc8:    f4405000    @..P    ORR      r0,r0,#0x2000
        0x08000fcc:    60e0        .`      STR      r0,[r4,#0xc]
;;; .\../Src/main.c
;;;1272   }
        0x08000fce:    b00b        ..      ADD      sp,sp,#0x2c
        0x08000fd0:    bdf0        ..      POP      {r4-r7,pc}
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;953        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CMAR, SrcAddress);
        0x08000fd2:    4b08        .K      LDR      r3,[pc,#32] ; [0x8000ff4] = 0x8001f6a
        0x08000fd4:    3b23        #;      SUBS     r3,r3,#0x23
        0x08000fd6:    799b        .y      LDRB     r3,[r3,#6]
        0x08000fd8:    51d9        .Q      STR      r1,[r3,r7]
;;;954        WRITE_REG(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CPAR, DstAddress);
        0x08000fda:    f8101c01    ....    LDRB     r1,[r0,#-1]
        0x08000fde:    f841200c    A..     STR      r2,[r1,r12]
        0x08000fe2:    e7ce        ..      B        0x8000f82 ; MX_USART2_UART_Init + 242
    $d
        0x08000fe4:    20000538    8..     DCD    536872248
        0x08000fe8:    20000038    8..     DCD    536870968
        0x08000fec:    40010800    ...@    DCD    1073809408
        0x08000ff0:    40020000    ...@    DCD    1073872896
        0x08000ff4:    08001f6a    j...    DCD    134225770
        0x08000ff8:    40004400    .D.@    DCD    1073759232
    $t
    i.NVIC_EnableIRQ
    NVIC_EnableIRQ
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08000ffc:    f000021f    ....    AND      r2,r0,#0x1f
        0x08001000:    2101        .!      MOVS     r1,#1
        0x08001002:    4091        .@      LSLS     r1,r1,r2
        0x08001004:    0940        @.      LSRS     r0,r0,#5
        0x08001006:    0080        ..      LSLS     r0,r0,#2
        0x08001008:    f10020e0    ...     ADD      r0,r0,#0xe000e000
        0x0800100c:    f8c01100    ....    STR      r1,[r0,#0x100]
;;;1455   }
        0x08001010:    4770        pG      BX       lr
    i.NVIC_EncodePriority
    NVIC_EncodePriority
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
;;;1526     if ((int32_t)(IRQn) < 0)
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1533     }
;;;1534   }
;;;1535   
;;;1536   
;;;1537   /**
;;;1538     \brief   Get Interrupt Priority
;;;1539     \details Reads the priority of an interrupt.
;;;1540              The interrupt number can be positive to specify an external (device specific) interrupt,
;;;1541              or negative to specify an internal (core) interrupt.
;;;1542     \param [in]   IRQn  Interrupt number.
;;;1543     \return             Interrupt Priority.
;;;1544                         Value is aligned automatically to the implemented priority bits of the microcontroller.
;;;1545    */
;;;1546   __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
;;;1547   {
;;;1548   
;;;1549     if ((int32_t)(IRQn) < 0)
;;;1550     {
;;;1551       return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
;;;1552     }
;;;1553     else
;;;1554     {
;;;1555       return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
;;;1556     }
;;;1557   }
;;;1558   
;;;1559   
;;;1560   /**
;;;1561     \brief   Encode Priority
;;;1562     \details Encodes the priority for an interrupt with the given priority group,
;;;1563              preemptive priority value, and subpriority value.
;;;1564              In case of a conflict between priority grouping and available
;;;1565              priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
;;;1566     \param [in]     PriorityGroup  Used priority group.
;;;1567     \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
;;;1568     \param [in]       SubPriority  Subpriority value (starting from 0).
;;;1569     \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
;;;1570    */
;;;1571   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
;;;1572   {
        0x08001012:    b530        0.      PUSH     {r4,r5,lr}
        0x08001014:    f0000307    ....    AND      r3,r0,#7
        0x08001018:    f1c30407    ....    RSB      r4,r3,#7
        0x0800101c:    2c04        .,      CMP      r4,#4
        0x0800101e:    d900        ..      BLS      0x8001022 ; NVIC_EncodePriority + 16
;;;1573     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
;;;1574     uint32_t PreemptPriorityBits;
;;;1575     uint32_t SubPriorityBits;
;;;1576   
;;;1577     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
        0x08001020:    2404        .$      MOVS     r4,#4
;;;1578     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
        0x08001022:    1d18        ..      ADDS     r0,r3,#4
        0x08001024:    2807        .(      CMP      r0,#7
        0x08001026:    d201        ..      BCS      0x800102c ; NVIC_EncodePriority + 26
        0x08001028:    2300        .#      MOVS     r3,#0
        0x0800102a:    e000        ..      B        0x800102e ; NVIC_EncodePriority + 28
        0x0800102c:    1edb        ..      SUBS     r3,r3,#3
;;;1579   
;;;1580     return (
        0x0800102e:    2501        .%      MOVS     r5,#1
        0x08001030:    fa05f004    ....    LSL      r0,r5,r4
        0x08001034:    1e40        @.      SUBS     r0,r0,#1
        0x08001036:    4008        .@      ANDS     r0,r0,r1
        0x08001038:    4098        .@      LSLS     r0,r0,r3
        0x0800103a:    409d        .@      LSLS     r5,r5,r3
        0x0800103c:    1e6d        m.      SUBS     r5,r5,#1
        0x0800103e:    4015        .@      ANDS     r5,r5,r2
        0x08001040:    4328        (C      ORRS     r0,r0,r5
;;;1581              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1582              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1583            );
;;;1584   }
        0x08001042:    bd30        0.      POP      {r4,r5,pc}
    i.NVIC_GetPriorityGrouping
    NVIC_GetPriorityGrouping
;;; ../Drivers/CMSIS/Include/core_cm3.h (1443)
        0x08001044:    4802        .H      LDR      r0,[pc,#8] ; [0x8001050] = 0xe000ed0c
        0x08001046:    6800        .h      LDR      r0,[r0,#0]
        0x08001048:    f3c02002    ...     UBFX     r0,r0,#8,#3
;;;1444   }
        0x0800104c:    4770        pG      BX       lr
    $d
        0x0800104e:    0000        ..      DCW    0
        0x08001050:    e000ed0c    ....    DCD    3758157068
    $t
    i.NVIC_SetPriority
    NVIC_SetPriority
;;;1445   
;;;1446   
;;;1447   /**
;;;1448     \brief   Enable External Interrupt
;;;1449     \details Enables a device-specific interrupt in the NVIC interrupt controller.
;;;1450     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
;;;1453   {
;;;1454     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1455   }
;;;1456   
;;;1457   
;;;1458   /**
;;;1459     \brief   Disable External Interrupt
;;;1460     \details Disables a device-specific interrupt in the NVIC interrupt controller.
;;;1461     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1462    */
;;;1463   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
;;;1464   {
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1466   }
;;;1467   
;;;1468   
;;;1469   /**
;;;1470     \brief   Get Pending Interrupt
;;;1471     \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
;;;1472     \param [in]      IRQn  Interrupt number.
;;;1473     \return             0  Interrupt status is not pending.
;;;1474     \return             1  Interrupt status is pending.
;;;1475    */
;;;1476   __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
;;;1477   {
;;;1478     return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1479   }
;;;1480   
;;;1481   
;;;1482   /**
;;;1483     \brief   Set Pending Interrupt
;;;1484     \details Sets the pending bit of an external interrupt.
;;;1485     \param [in]      IRQn  Interrupt number. Value cannot be negative.
;;;1486    */
;;;1487   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
;;;1488   {
;;;1489     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1490   }
;;;1491   
;;;1492   
;;;1493   /**
;;;1494     \brief   Clear Pending Interrupt
;;;1495     \details Clears the pending bit of an external interrupt.
;;;1496     \param [in]      IRQn  External interrupt number. Value cannot be negative.
;;;1497    */
;;;1498   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
;;;1499   {
;;;1500     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
;;;1501   }
;;;1502   
;;;1503   
;;;1504   /**
;;;1505     \brief   Get Active Interrupt
;;;1506     \details Reads the active register in NVIC and returns the active bit.
;;;1507     \param [in]      IRQn  Interrupt number.
;;;1508     \return             0  Interrupt status is not active.
;;;1509     \return             1  Interrupt status is active.
;;;1510    */
;;;1511   __STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
;;;1512   {
;;;1513     return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
;;;1514   }
;;;1515   
;;;1516   
;;;1517   /**
;;;1518     \brief   Set Interrupt Priority
;;;1519     \details Sets the priority of an interrupt.
;;;1520     \note    The priority cannot be set for every core interrupt.
;;;1521     \param [in]      IRQn  Interrupt number.
;;;1522     \param [in]  priority  Priority to set.
;;;1523    */
;;;1524   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
;;;1525   {
;;;1526     if ((int32_t)(IRQn) < 0)
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x08001054:    0709        ..      LSLS     r1,r1,#28
        0x08001056:    0e09        ..      LSRS     r1,r1,#24
        0x08001058:    2800        .(      CMP      r0,#0
;;; ../Drivers/CMSIS/Include/core_cm3.h (1525)
        0x0800105a:    da06        ..      BGE      0x800106a ; NVIC_SetPriority + 22
;;;1526     if ((int32_t)(IRQn) < 0)
;;;1527     {
;;;1528       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x0800105c:    f000000f    ....    AND      r0,r0,#0xf
        0x08001060:    f10020e0    ...     ADD      r0,r0,#0xe000e000
        0x08001064:    f8801d14    ....    STRB     r1,[r0,#0xd14]
        0x08001068:    4770        pG      BX       lr
;;;1529     }
;;;1530     else
;;;1531     {
;;;1532       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
        0x0800106a:    f10020e0    ...     ADD      r0,r0,#0xe000e000
        0x0800106e:    f8801400    ....    STRB     r1,[r0,#0x400]
;;;1533     }
;;;1534   }
        0x08001072:    4770        pG      BX       lr
    i.OC1Config
    OC1Config
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;766    {
        0x08001074:    b530        0.      PUSH     {r4,r5,lr}
;;;767      uint32_t tmpccmr1 = 0U;
;;;768      uint32_t tmpccer = 0U;
;;;769      uint32_t tmpcr2 = 0U;
;;;770    
;;;771      /* Check the parameters */
;;;772      assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;773      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;774      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;775      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;776      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;777      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;778    
;;;779      /* Disable the Channel 1: Reset the CC1E Bit */
;;;780      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
        0x08001076:    6a02        .j      LDR      r2,[r0,#0x20]
        0x08001078:    f0220201    "...    BIC      r2,r2,#1
        0x0800107c:    6202        .b      STR      r2,[r0,#0x20]
;;;781    
;;;782      /* Get the TIMx CCER register value */
;;;783      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x0800107e:    6a02        .j      LDR      r2,[r0,#0x20]
;;;784    
;;;785      /* Get the TIMx CR2 register value */
;;;786      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001080:    6843        Ch      LDR      r3,[r0,#4]
;;;787    
;;;788      /* Get the TIMx CCMR1 register value */
;;;789      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x08001082:    6984        .i      LDR      r4,[r0,#0x18]
;;;790    
;;;791      /* Reset Capture/Compare selection Bits */
;;;792      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
        0x08001084:    f0240403    $...    BIC      r4,r4,#3
;;;793    
;;;794      /* Set the Output Compare Mode */
;;;795      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
        0x08001088:    680d        .h      LDR      r5,[r1,#0]
        0x0800108a:    f0240470    $.p.    BIC      r4,r4,#0x70
        0x0800108e:    432c        ,C      ORRS     r4,r4,r5
;;;796    
;;;797      /* Set the Output Compare Polarity */
;;;798      MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
        0x08001090:    690d        .i      LDR      r5,[r1,#0x10]
        0x08001092:    f0220202    "...    BIC      r2,r2,#2
        0x08001096:    432a        *C      ORRS     r2,r2,r5
;;;799    
;;;800      /* Set the Output State */
;;;801      MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
        0x08001098:    684d        Mh      LDR      r5,[r1,#4]
        0x0800109a:    f0220201    "...    BIC      r2,r2,#1
        0x0800109e:    432a        *C      ORRS     r2,r2,r5
;;;802    
;;;803      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x080010a0:    4d0e        .M      LDR      r5,[pc,#56] ; [0x80010dc] = 0x40012c00
        0x080010a2:    42a8        .B      CMP      r0,r5
        0x080010a4:    d112        ..      BNE      0x80010cc ; OC1Config + 88
;;;804      {
;;;805        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;806        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;807    
;;;808        /* Set the complementary output Polarity */
;;;809        MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
        0x080010a6:    694d        Mi      LDR      r5,[r1,#0x14]
        0x080010a8:    f0220208    "...    BIC      r2,r2,#8
        0x080010ac:    ea420285    B...    ORR      r2,r2,r5,LSL #2
;;;810    
;;;811        /* Set the complementary output State */
;;;812        MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
        0x080010b0:    688d        .h      LDR      r5,[r1,#8]
        0x080010b2:    f0220204    "...    BIC      r2,r2,#4
        0x080010b6:    ea420285    B...    ORR      r2,r2,r5,LSL #2
;;;813    
;;;814        /* Set the Output Idle state */
;;;815        MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
        0x080010ba:    698d        .i      LDR      r5,[r1,#0x18]
        0x080010bc:    f4237380    #..s    BIC      r3,r3,#0x100
        0x080010c0:    432b        +C      ORRS     r3,r3,r5
;;;816    
;;;817        /* Set the complementary output Idle state */
;;;818        MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
        0x080010c2:    69cd        .i      LDR      r5,[r1,#0x1c]
        0x080010c4:    f4237300    #..s    BIC      r3,r3,#0x200
        0x080010c8:    ea430345    C.E.    ORR      r3,r3,r5,LSL #1
;;;819      }
;;;820    
;;;821      /* Write to TIMx CR2 */
;;;822      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x080010cc:    6043        C`      STR      r3,[r0,#4]
;;;823    
;;;824      /* Write to TIMx CCMR1 */
;;;825      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x080010ce:    6184        .a      STR      r4,[r0,#0x18]
;;;826    
;;;827      /* Set the Capture Compare Register value */
;;;828      LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
        0x080010d0:    68c9        .h      LDR      r1,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1997     WRITE_REG(TIMx->CCR1, CompareValue);
        0x080010d2:    6341        Ac      STR      r1,[r0,#0x34]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;831      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x080010d4:    6202        .b      STR      r2,[r0,#0x20]
;;;832    
;;;833      return SUCCESS;
        0x080010d6:    2001        .       MOVS     r0,#1
;;;834    }
        0x080010d8:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080010da:    0000        ..      DCW    0
        0x080010dc:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC2Config
    OC2Config
;;;835    
;;;836    /**
;;;837      * @brief  Configure the TIMx output channel 2.
;;;838      * @param  TIMx Timer Instance
;;;839      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
;;;840      * @retval An ErrorStatus enumeration value:
;;;841      *          - SUCCESS: TIMx registers are de-initialized
;;;842      *          - ERROR: not applicable
;;;843      */
;;;844    static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;845    {
        0x080010e0:    b530        0.      PUSH     {r4,r5,lr}
;;;846      uint32_t tmpccmr1 = 0U;
;;;847      uint32_t tmpccer = 0U;
;;;848      uint32_t tmpcr2 = 0U;
;;;849    
;;;850      /* Check the parameters */
;;;851      assert_param(IS_TIM_CC2_INSTANCE(TIMx));
;;;852      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;853      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;854      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;855      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;856      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;857    
;;;858      /* Disable the Channel 2: Reset the CC2E Bit */
;;;859      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
        0x080010e2:    6a02        .j      LDR      r2,[r0,#0x20]
        0x080010e4:    f0220210    "...    BIC      r2,r2,#0x10
        0x080010e8:    6202        .b      STR      r2,[r0,#0x20]
;;;860    
;;;861      /* Get the TIMx CCER register value */
;;;862      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x080010ea:    6a02        .j      LDR      r2,[r0,#0x20]
;;;863    
;;;864      /* Get the TIMx CR2 register value */
;;;865      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x080010ec:    6843        Ch      LDR      r3,[r0,#4]
;;;866    
;;;867      /* Get the TIMx CCMR1 register value */
;;;868      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
        0x080010ee:    6984        .i      LDR      r4,[r0,#0x18]
;;;869    
;;;870      /* Reset Capture/Compare selection Bits */
;;;871      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
        0x080010f0:    f4247440    $.@t    BIC      r4,r4,#0x300
;;;872    
;;;873      /* Select the Output Compare Mode */
;;;874      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
        0x080010f4:    680d        .h      LDR      r5,[r1,#0]
        0x080010f6:    f42444e0    $..D    BIC      r4,r4,#0x7000
        0x080010fa:    ea442405    D..$    ORR      r4,r4,r5,LSL #8
;;;875    
;;;876      /* Set the Output Compare Polarity */
;;;877      MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
        0x080010fe:    690d        .i      LDR      r5,[r1,#0x10]
        0x08001100:    f0220220    ". .    BIC      r2,r2,#0x20
        0x08001104:    ea421205    B...    ORR      r2,r2,r5,LSL #4
;;;878    
;;;879      /* Set the Output State */
;;;880      MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
        0x08001108:    684d        Mh      LDR      r5,[r1,#4]
        0x0800110a:    f0220210    "...    BIC      r2,r2,#0x10
        0x0800110e:    ea421205    B...    ORR      r2,r2,r5,LSL #4
;;;881    
;;;882      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001112:    4d0f        .M      LDR      r5,[pc,#60] ; [0x8001150] = 0x40012c00
        0x08001114:    42a8        .B      CMP      r0,r5
        0x08001116:    d113        ..      BNE      0x8001140 ; OC2Config + 96
;;;883      {
;;;884        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;885        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;886    
;;;887        /* Set the complementary output Polarity */
;;;888        MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
        0x08001118:    694d        Mi      LDR      r5,[r1,#0x14]
        0x0800111a:    f0220280    "...    BIC      r2,r2,#0x80
        0x0800111e:    ea421285    B...    ORR      r2,r2,r5,LSL #6
;;;889    
;;;890        /* Set the complementary output State */
;;;891        MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
        0x08001122:    688d        .h      LDR      r5,[r1,#8]
        0x08001124:    f0220240    ".@.    BIC      r2,r2,#0x40
        0x08001128:    ea421285    B...    ORR      r2,r2,r5,LSL #6
;;;892    
;;;893        /* Set the Output Idle state */
;;;894        MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
        0x0800112c:    698d        .i      LDR      r5,[r1,#0x18]
        0x0800112e:    f4236380    #..c    BIC      r3,r3,#0x400
        0x08001132:    ea430385    C...    ORR      r3,r3,r5,LSL #2
;;;895    
;;;896        /* Set the complementary output Idle state */
;;;897        MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
        0x08001136:    69cd        .i      LDR      r5,[r1,#0x1c]
        0x08001138:    f4236300    #..c    BIC      r3,r3,#0x800
        0x0800113c:    ea4303c5    C...    ORR      r3,r3,r5,LSL #3
;;;898      }
;;;899    
;;;900      /* Write to TIMx CR2 */
;;;901      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001140:    6043        C`      STR      r3,[r0,#4]
;;;902    
;;;903      /* Write to TIMx CCMR1 */
;;;904      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
        0x08001142:    6184        .a      STR      r4,[r0,#0x18]
;;;905    
;;;906      /* Set the Capture Compare Register value */
;;;907      LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
        0x08001144:    68c9        .h      LDR      r1,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2011     WRITE_REG(TIMx->CCR2, CompareValue);
        0x08001146:    6381        .c      STR      r1,[r0,#0x38]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;910      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x08001148:    6202        .b      STR      r2,[r0,#0x20]
;;;911    
;;;912      return SUCCESS;
        0x0800114a:    2001        .       MOVS     r0,#1
;;;913    }
        0x0800114c:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x0800114e:    0000        ..      DCW    0
        0x08001150:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC3Config
    OC3Config
;;;914    
;;;915    /**
;;;916      * @brief  Configure the TIMx output channel 3.
;;;917      * @param  TIMx Timer Instance
;;;918      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
;;;919      * @retval An ErrorStatus enumeration value:
;;;920      *          - SUCCESS: TIMx registers are de-initialized
;;;921      *          - ERROR: not applicable
;;;922      */
;;;923    static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;924    {
        0x08001154:    b530        0.      PUSH     {r4,r5,lr}
;;;925      uint32_t tmpccmr2 = 0U;
;;;926      uint32_t tmpccer = 0U;
;;;927      uint32_t tmpcr2 = 0U;
;;;928    
;;;929      /* Check the parameters */
;;;930      assert_param(IS_TIM_CC3_INSTANCE(TIMx));
;;;931      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;932      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;933      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;934      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;935      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;936    
;;;937      /* Disable the Channel 3: Reset the CC3E Bit */
;;;938      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
        0x08001156:    6a02        .j      LDR      r2,[r0,#0x20]
        0x08001158:    f4227280    "..r    BIC      r2,r2,#0x100
        0x0800115c:    6202        .b      STR      r2,[r0,#0x20]
;;;939    
;;;940      /* Get the TIMx CCER register value */
;;;941      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
        0x0800115e:    6a02        .j      LDR      r2,[r0,#0x20]
;;;942    
;;;943      /* Get the TIMx CR2 register value */
;;;944      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
        0x08001160:    6843        Ch      LDR      r3,[r0,#4]
;;;945    
;;;946      /* Get the TIMx CCMR2 register value */
;;;947      tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x08001162:    69c4        .i      LDR      r4,[r0,#0x1c]
;;;948    
;;;949      /* Reset Capture/Compare selection Bits */
;;;950      CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
        0x08001164:    f0240403    $...    BIC      r4,r4,#3
;;;951    
;;;952      /* Select the Output Compare Mode */
;;;953      MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
        0x08001168:    680d        .h      LDR      r5,[r1,#0]
        0x0800116a:    f0240470    $.p.    BIC      r4,r4,#0x70
        0x0800116e:    432c        ,C      ORRS     r4,r4,r5
;;;954    
;;;955      /* Set the Output Compare Polarity */
;;;956      MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
        0x08001170:    690d        .i      LDR      r5,[r1,#0x10]
        0x08001172:    f4227200    "..r    BIC      r2,r2,#0x200
        0x08001176:    ea422205    B.."    ORR      r2,r2,r5,LSL #8
;;;957    
;;;958      /* Set the Output State */
;;;959      MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
        0x0800117a:    684d        Mh      LDR      r5,[r1,#4]
        0x0800117c:    f4227280    "..r    BIC      r2,r2,#0x100
        0x08001180:    ea422205    B.."    ORR      r2,r2,r5,LSL #8
;;;960    
;;;961      if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x08001184:    4d0e        .M      LDR      r5,[pc,#56] ; [0x80011c0] = 0x40012c00
        0x08001186:    42a8        .B      CMP      r0,r5
        0x08001188:    d113        ..      BNE      0x80011b2 ; OC3Config + 94
;;;962      {
;;;963        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;964        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;965    
;;;966        /* Set the complementary output Polarity */
;;;967        MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
        0x0800118a:    694d        Mi      LDR      r5,[r1,#0x14]
        0x0800118c:    f4226200    "..b    BIC      r2,r2,#0x800
        0x08001190:    ea422285    B.."    ORR      r2,r2,r5,LSL #10
;;;968    
;;;969        /* Set the complementary output State */
;;;970        MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
        0x08001194:    688d        .h      LDR      r5,[r1,#8]
        0x08001196:    f4226280    "..b    BIC      r2,r2,#0x400
        0x0800119a:    ea422285    B.."    ORR      r2,r2,r5,LSL #10
;;;971    
;;;972        /* Set the Output Idle state */
;;;973        MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
        0x0800119e:    698d        .i      LDR      r5,[r1,#0x18]
        0x080011a0:    f4235380    #..S    BIC      r3,r3,#0x1000
        0x080011a4:    ea431305    C...    ORR      r3,r3,r5,LSL #4
;;;974    
;;;975        /* Set the complementary output Idle state */
;;;976        MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
        0x080011a8:    69cd        .i      LDR      r5,[r1,#0x1c]
        0x080011aa:    f4235300    #..S    BIC      r3,r3,#0x2000
        0x080011ae:    ea431345    C.E.    ORR      r3,r3,r5,LSL #5
;;;977      }
;;;978    
;;;979      /* Write to TIMx CR2 */
;;;980      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x080011b2:    6043        C`      STR      r3,[r0,#4]
;;;981    
;;;982      /* Write to TIMx CCMR2 */
;;;983      LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x080011b4:    61c4        .a      STR      r4,[r0,#0x1c]
;;;984    
;;;985      /* Set the Capture Compare Register value */
;;;986      LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
        0x080011b6:    68c9        .h      LDR      r1,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2025     WRITE_REG(TIMx->CCR3, CompareValue);
        0x080011b8:    63c1        .c      STR      r1,[r0,#0x3c]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;989      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x080011ba:    6202        .b      STR      r2,[r0,#0x20]
;;;990    
;;;991      return SUCCESS;
        0x080011bc:    2001        .       MOVS     r0,#1
;;;992    }
        0x080011be:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080011c0:    40012c00    .,.@    DCD    1073818624
    $t
    i.OC4Config
    OC4Config
;;;993    
;;;994    /**
;;;995      * @brief  Configure the TIMx output channel 4.
;;;996      * @param  TIMx Timer Instance
;;;997      * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
;;;998      * @retval An ErrorStatus enumeration value:
;;;999      *          - SUCCESS: TIMx registers are de-initialized
;;;1000     *          - ERROR: not applicable
;;;1001     */
;;;1002   static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
;;;1003   {
        0x080011c4:    b530        0.      PUSH     {r4,r5,lr}
;;;1004     uint32_t tmpccmr2 = 0U;
;;;1005     uint32_t tmpccer = 0U;
;;;1006     uint32_t tmpcr2 = 0U;
;;;1007   
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;1010     assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;1011     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;1012     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;1013     assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;1014     assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;1015   
;;;1016     /* Disable the Channel 4: Reset the CC4E Bit */
;;;1017     CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
        0x080011c6:    6a02        .j      LDR      r2,[r0,#0x20]
        0x080011c8:    f4225280    "..R    BIC      r2,r2,#0x1000
        0x080011cc:    6202        .b      STR      r2,[r0,#0x20]
;;;1018   
;;;1019     /* Get the TIMx CCER register value */
;;;1020     tmpccer = LL_TIM_ReadReg(TIMx, CCER);
        0x080011ce:    6a04        .j      LDR      r4,[r0,#0x20]
;;;1021   
;;;1022     /* Get the TIMx CR2 register value */
;;;1023     tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
        0x080011d0:    6842        Bh      LDR      r2,[r0,#4]
;;;1024   
;;;1025     /* Get the TIMx CCMR2 register value */
;;;1026     tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
        0x080011d2:    69c3        .i      LDR      r3,[r0,#0x1c]
;;;1027   
;;;1028     /* Reset Capture/Compare selection Bits */
;;;1029     CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
        0x080011d4:    f4237340    #.@s    BIC      r3,r3,#0x300
;;;1030   
;;;1031     /* Select the Output Compare Mode */
;;;1032     MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
        0x080011d8:    680d        .h      LDR      r5,[r1,#0]
        0x080011da:    f42343e0    #..C    BIC      r3,r3,#0x7000
        0x080011de:    ea432305    C..#    ORR      r3,r3,r5,LSL #8
;;;1033   
;;;1034     /* Set the Output Compare Polarity */
;;;1035     MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
        0x080011e2:    690d        .i      LDR      r5,[r1,#0x10]
        0x080011e4:    f4245400    $..T    BIC      r4,r4,#0x2000
        0x080011e8:    ea443405    D..4    ORR      r4,r4,r5,LSL #12
;;;1036   
;;;1037     /* Set the Output State */
;;;1038     MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
        0x080011ec:    684d        Mh      LDR      r5,[r1,#4]
        0x080011ee:    f4245480    $..T    BIC      r4,r4,#0x1000
        0x080011f2:    ea443405    D..4    ORR      r4,r4,r5,LSL #12
;;;1039   
;;;1040     if (IS_TIM_BREAK_INSTANCE(TIMx))
        0x080011f6:    4d07        .M      LDR      r5,[pc,#28] ; [0x8001214] = 0x40012c00
        0x080011f8:    42a8        .B      CMP      r0,r5
        0x080011fa:    d104        ..      BNE      0x8001206 ; OC4Config + 66
;;;1041     {
;;;1042       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;1043       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;1044   
;;;1045       /* Set the Output Idle state */
;;;1046       MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
        0x080011fc:    698d        .i      LDR      r5,[r1,#0x18]
        0x080011fe:    f4224280    "..B    BIC      r2,r2,#0x4000
        0x08001202:    ea421285    B...    ORR      r2,r2,r5,LSL #6
;;;1047     }
;;;1048   
;;;1049     /* Write to TIMx CR2 */
;;;1050     LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
        0x08001206:    6042        B`      STR      r2,[r0,#4]
;;;1051   
;;;1052     /* Write to TIMx CCMR2 */
;;;1053     LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
        0x08001208:    61c3        .a      STR      r3,[r0,#0x1c]
;;;1054   
;;;1055     /* Set the Capture Compare Register value */
;;;1056     LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
        0x0800120a:    68c9        .h      LDR      r1,[r1,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2039     WRITE_REG(TIMx->CCR4, CompareValue);
        0x0800120c:    6401        .d      STR      r1,[r0,#0x40]
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_tim.c
;;;1059     LL_TIM_WriteReg(TIMx, CCER, tmpccer);
        0x0800120e:    6204        .b      STR      r4,[r0,#0x20]
;;;1060   
;;;1061     return SUCCESS;
        0x08001210:    2001        .       MOVS     r0,#1
;;;1062   }
        0x08001212:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001214:    40012c00    .,.@    DCD    1073818624
    $t
    i.PendSV_Handler
    PendSV_Handler
;;; .\../Src/stm32f1xx_it.c
;;;146    }
        0x08001218:    4770        pG      BX       lr
        0x0800121a:    0000        ..      MOVS     r0,r0
    i.RCC_GetHCLKClockFreq
    RCC_GetHCLKClockFreq
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1116     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
        0x0800121c:    4904        .I      LDR      r1,[pc,#16] ; [0x8001230] = 0x40021000
        0x0800121e:    6849        Ih      LDR      r1,[r1,#4]
        0x08001220:    f00101f0    ....    AND      r1,r1,#0xf0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;390      return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
        0x08001224:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001234] = 0x8001f28
        0x08001226:    0909        ..      LSRS     r1,r1,#4
        0x08001228:    5c51        Q\      LDRB     r1,[r2,r1]
        0x0800122a:    40c8        .@      LSRS     r0,r0,r1
;;;391    }
        0x0800122c:    4770        pG      BX       lr
    $d
        0x0800122e:    0000        ..      DCW    0
        0x08001230:    40021000    ...@    DCD    1073876992
        0x08001234:    08001f28    (...    DCD    134225704
    $t
    i.RCC_GetPCLK1ClockFreq
    RCC_GetPCLK1ClockFreq
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1131     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
        0x08001238:    4904        .I      LDR      r1,[pc,#16] ; [0x800124c] = 0x40021000
        0x0800123a:    6849        Ih      LDR      r1,[r1,#4]
        0x0800123c:    f40161e0    ...a    AND      r1,r1,#0x700
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;401      return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
        0x08001240:    4a03        .J      LDR      r2,[pc,#12] ; [0x8001250] = 0x8001f38
        0x08001242:    eb022111    ...!    ADD      r1,r2,r1,LSR #8
        0x08001246:    7809        .x      LDRB     r1,[r1,#0]
        0x08001248:    40c8        .@      LSRS     r0,r0,r1
;;;402    }
        0x0800124a:    4770        pG      BX       lr
    $d
        0x0800124c:    40021000    ...@    DCD    1073876992
        0x08001250:    08001f38    8...    DCD    134225720
    $t
    i.RCC_GetPCLK2ClockFreq
    RCC_GetPCLK2ClockFreq
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1146     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
        0x08001254:    4904        .I      LDR      r1,[pc,#16] ; [0x8001268] = 0x40021000
        0x08001256:    6849        Ih      LDR      r1,[r1,#4]
        0x08001258:    f4015160    ..`Q    AND      r1,r1,#0x3800
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;412      return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
        0x0800125c:    4a03        .J      LDR      r2,[pc,#12] ; [0x800126c] = 0x8001f38
        0x0800125e:    eb0221d1    ...!    ADD      r1,r2,r1,LSR #11
        0x08001262:    7809        .x      LDRB     r1,[r1,#0]
        0x08001264:    40c8        .@      LSRS     r0,r0,r1
;;;413    }
        0x08001266:    4770        pG      BX       lr
    $d
        0x08001268:    40021000    ...@    DCD    1073876992
        0x0800126c:    08001f38    8...    DCD    134225720
    $t
    i.RCC_GetSystemClockFreq
    RCC_GetSystemClockFreq
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001270:    4806        .H      LDR      r0,[pc,#24] ; [0x800128c] = 0x40021000
        0x08001272:    6840        @h      LDR      r0,[r0,#4]
        0x08001274:    f000010c    ....    AND      r1,r0,#0xc
        0x08001278:    4805        .H      LDR      r0,[pc,#20] ; [0x8001290] = 0x7a1200
        0x0800127a:    2900        .)      CMP      r1,#0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;356    {
        0x0800127c:    d005        ..      BEQ      0x800128a ; RCC_GetSystemClockFreq + 26
;;;357      uint32_t frequency = 0U;
;;;358    
;;;359      /* Get SYSCLK source -------------------------------------------------------*/
;;;360      switch (LL_RCC_GetSysClkSource())
        0x0800127e:    2904        .)      CMP      r1,#4
        0x08001280:    d003        ..      BEQ      0x800128a ; RCC_GetSystemClockFreq + 26
        0x08001282:    2908        .)      CMP      r1,#8
        0x08001284:    d101        ..      BNE      0x800128a ; RCC_GetSystemClockFreq + 26
;;;361      {
;;;362        case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
;;;363          frequency = HSI_VALUE;
;;;364          break;
;;;365    
;;;366        case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;367          frequency = HSE_VALUE;
;;;368          break;
;;;369    
;;;370        case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;371          frequency = RCC_PLL_GetFreqDomain_SYS();
        0x08001286:    f000b805    ....    B.W      RCC_PLL_GetFreqDomain_SYS ; 0x8001294
;;;372          break;
;;;373    
;;;374        default:
;;;375          frequency = HSI_VALUE;
;;;376          break;
;;;377      }
;;;378    
;;;379      return frequency;
;;;380    }
        0x0800128a:    4770        pG      BX       lr
    $d
        0x0800128c:    40021000    ...@    DCD    1073876992
        0x08001290:    007a1200    ..z.    DCD    8000000
    $t
    i.RCC_PLL_GetFreqDomain_SYS
    RCC_PLL_GetFreqDomain_SYS
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1543     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLSRC));
        0x08001294:    4a0c        .J      LDR      r2,[pc,#48] ; [0x80012c8] = 0x40021000
        0x08001296:    6850        Ph      LDR      r0,[r2,#4]
        0x08001298:    f4003080    ...0    AND      r0,r0,#0x10000
        0x0800129c:    490b        .I      LDR      r1,[pc,#44] ; [0x80012cc] = 0x3d0900
        0x0800129e:    2800        .(      CMP      r0,#0
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;420    {
        0x080012a0:    d009        ..      BEQ      0x80012b6 ; RCC_PLL_GetFreqDomain_SYS + 34
;;;421      uint32_t pllinputfreq = 0U, pllsource = 0U;
;;;422    
;;;423      /* PLL_VCO = (HSE_VALUE, HSI_VALUE or PLL2 / PLL Predivider) * PLL Multiplicator */
;;;424    
;;;425      /* Get PLL source */
;;;426      pllsource = LL_RCC_PLL_GetMainSource();
;;;427    
;;;428      switch (pllsource)
        0x080012a2:    f5b03f80    ...?    CMP      r0,#0x10000
        0x080012a6:    d106        ..      BNE      0x80012b6 ; RCC_PLL_GetFreqDomain_SYS + 34
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1605     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos);
        0x080012a8:    6850        Ph      LDR      r0,[r2,#4]
        0x080012aa:    f3c04040    ..@@    UBFX     r0,r0,#17,#1
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;435          pllinputfreq = HSE_VALUE / (LL_RCC_PLL_GetPrediv() + 1U);
        0x080012ae:    1c40        @.      ADDS     r0,r0,#1
        0x080012b0:    0049        I.      LSLS     r1,r1,#1
        0x080012b2:    fbb1f1f0    ....    UDIV     r1,r1,r0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1572     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PLLMULL));
        0x080012b6:    6850        Ph      LDR      r0,[r2,#4]
        0x080012b8:    f4001070    ..p.    AND      r0,r0,#0x3c0000
;;; .\../Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_ll_rcc.c
;;;448      return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator());
        0x080012bc:    2202        ."      MOVS     r2,#2
        0x080012be:    eb024090    ...@    ADD      r0,r2,r0,LSR #18
        0x080012c2:    4348        HC      MULS     r0,r1,r0
;;;449    }
        0x080012c4:    4770        pG      BX       lr
    $d
        0x080012c6:    0000        ..      DCW    0
        0x080012c8:    40021000    ...@    DCD    1073876992
        0x080012cc:    003d0900    ..=.    DCD    4000000
    $t
    i.SVC_Handler
    SVC_Handler
;;; .\../Src/stm32f1xx_it.c
;;;133    }
        0x080012d0:    4770        pG      BX       lr
        0x080012d2:    0000        ..      MOVS     r0,r0
    i.SysTick_Handler
    SysTick_Handler
;;;134    
;;;135    /**
;;;136      * @brief This function handles Pendable request for system service.
;;;137      */
;;;138    void PendSV_Handler(void)
;;;139    {
;;;140      /* USER CODE BEGIN PendSV_IRQn 0 */
;;;141    
;;;142      /* USER CODE END PendSV_IRQn 0 */
;;;143      /* USER CODE BEGIN PendSV_IRQn 1 */
;;;144    
;;;145      /* USER CODE END PendSV_IRQn 1 */
;;;146    }
;;;147    
;;;148    /**
;;;149      * @brief This function handles System tick timer.
;;;150      */
;;;151    void SysTick_Handler(void)
;;;152    {
;;;153      /* USER CODE BEGIN SysTick_IRQn 0 */
;;;154    
;;;155      /* USER CODE END SysTick_IRQn 0 */
;;;156      
;;;157      /* USER CODE BEGIN SysTick_IRQn 1 */
;;;158    
;;;159    /*
;;;160    #if  defined ( _SIMU )
;;;161    
;;;162    //simulate spindle
;;;163    	if(++tacho_cnt == 1800 ) {
;;;164    		tacho_debug = 1;
;;;165    		tacho_cnt = 0;
;;;166    		TIM4_IRQHandler();
;;;167    	}
;;;168    	if(++TIM4->CNT > TIM4->ARR) {
;;;169    		TIM4->CNT = 0; // overflow emulation
;;;170    		encoder = true;
;;;171    		TIM4_IRQHandler();
;;;172    	}
;;;173    #endif
;;;174    */
;;;175    //      if(auto_mode_delay > 0)
;;;176    //              auto_mode_delay--;
;;;177    	for(int a = 0; a<BT_TOTAL;a++){
        0x080012d4:    2000        .       MOVS     r0,#0
        0x080012d6:    4b05        .K      LDR      r3,[pc,#20] ; [0x80012ec] = 0x200004e4
        0x080012d8:    eb031240    ..@.    ADD      r2,r3,r0,LSL #5
        0x080012dc:    6911        .i      LDR      r1,[r2,#0x10]
        0x080012de:    b109        ..      CBZ      r1,0x80012e4 ; SysTick_Handler + 16
        0x080012e0:    1c49        I.      ADDS     r1,r1,#1
        0x080012e2:    6111        .a      STR      r1,[r2,#0x10]
;;; .\../Src/stm32f1xx_it.c (177)
        0x080012e4:    1c40        @.      ADDS     r0,r0,#1
        0x080012e6:    2801        .(      CMP      r0,#1
        0x080012e8:    dbf6        ..      BLT      0x80012d8 ; SysTick_Handler + 4
;;;178    		if( bt[a].buttons_mstick > 0 )
;;;179    			bt[a].buttons_mstick++;
;;;180    	}
;;;181      /* USER CODE END SysTick_IRQn 1 */
;;;182    }
        0x080012ea:    4770        pG      BX       lr
    $d
        0x080012ec:    200004e4    ...     DCD    536872164
    $t
    i.SystemClock_Config
    SystemClock_Config
;;; .\../Src/main.c
;;;825    {
        0x080012f0:    b510        ..      PUSH     {r4,lr}
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_system.h
;;;488      MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
        0x080012f2:    4827        'H      LDR      r0,[pc,#156] ; [0x8001390] = 0x40022000
        0x080012f4:    6801        .h      LDR      r1,[r0,#0]
        0x080012f6:    f0210107    !...    BIC      r1,r1,#7
        0x080012fa:    f0410102    A...    ORR      r1,r1,#2
        0x080012fe:    6001        .`      STR      r1,[r0,#0]
;;;489    }
;;;490    
;;;491    /**
;;;492      * @brief  Get FLASH Latency
;;;493      * @rmtoll FLASH_ACR    LATENCY       LL_FLASH_GetLatency
;;;494      * @retval Returned value can be one of the following values:
;;;495      *         @arg @ref LL_FLASH_LATENCY_0
;;;496      *         @arg @ref LL_FLASH_LATENCY_1
;;;497      *         @arg @ref LL_FLASH_LATENCY_2
;;;498      */
;;;499    __STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
;;;500    {
;;;501      return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
        0x08001300:    6800        .h      LDR      r0,[r0,#0]
        0x08001302:    f0000007    ....    AND      r0,r0,#7
;;; .\../Src/main.c
;;;828       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
        0x08001306:    2802        .(      CMP      r0,#2
;;; .\../Src/main.c (825)
        0x08001308:    d001        ..      BEQ      0x800130e ; SystemClock_Config + 30
;;;826      LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
;;;827    
;;;828       if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
;;;829      {
;;;830        Error_Handler();  
        0x0800130a:    f7feffc0    ....    BL       Error_Handler ; 0x800028e
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;792      SET_BIT(RCC->CR, RCC_CR_HSEON);
        0x0800130e:    4821        !H      LDR      r0,[pc,#132] ; [0x8001394] = 0x40021000
        0x08001310:    6801        .h      LDR      r1,[r0,#0]
        0x08001312:    f4413180    A..1    ORR      r1,r1,#0x10000
        0x08001316:    6001        .`      STR      r1,[r0,#0]
;;;793    }
;;;794    
;;;795    /**
;;;796      * @brief  Disable HSE crystal oscillator (HSE ON)
;;;797      * @rmtoll CR           HSEON         LL_RCC_HSE_Disable
;;;798      * @retval None
;;;799      */
;;;800    __STATIC_INLINE void LL_RCC_HSE_Disable(void)
;;;801    {
;;;802      CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
;;;803    }
;;;804    
;;;805    /**
;;;806      * @brief  Check if HSE oscillator Ready
;;;807      * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
;;;808      * @retval State of bit (1 or 0).
;;;809      */
;;;810    __STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
;;;811    {
;;;812      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
        0x08001318:    6801        .h      LDR      r1,[r0,#0]
        0x0800131a:    f3c14140    ..@A    UBFX     r1,r1,#17,#1
;;; .\../Src/main.c
;;;835      while(LL_RCC_HSE_IsReady() != 1)
        0x0800131e:    2900        .)      CMP      r1,#0
        0x08001320:    d0fa        ..      BEQ      0x8001318 ; SystemClock_Config + 40
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1495     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
        0x08001322:    6841        Ah      LDR      r1,[r0,#4]
        0x08001324:    f421117c    !.|.    BIC      r1,r1,#0x3f0000
        0x08001328:    f44111e8    A...    ORR      r1,r1,#0x1d0000
        0x0800132c:    6041        A`      STR      r1,[r0,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h (1405)
        0x0800132e:    6801        .h      LDR      r1,[r0,#0]
        0x08001330:    f0417180    A..q    ORR      r1,r1,#0x1000000
        0x08001334:    6001        .`      STR      r1,[r0,#0]
;;;1406   }
;;;1407   
;;;1408   /**
;;;1409     * @brief  Disable PLL
;;;1410     * @note Cannot be disabled if the PLL clock is used as the system clock
;;;1411     * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
;;;1412     * @retval None
;;;1413     */
;;;1414   __STATIC_INLINE void LL_RCC_PLL_Disable(void)
;;;1415   {
;;;1416     CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
;;;1417   }
;;;1418   
;;;1419   /**
;;;1420     * @brief  Check if PLL Ready
;;;1421     * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
;;;1422     * @retval State of bit (1 or 0).
;;;1423     */
;;;1424   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
;;;1425   {
;;;1426     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
        0x08001336:    6801        .h      LDR      r1,[r0,#0]
        0x08001338:    f3c16140    ..@a    UBFX     r1,r1,#25,#1
;;; .\../Src/main.c
;;;843      while(LL_RCC_PLL_IsReady() != 1)
        0x0800133c:    2900        .)      CMP      r1,#0
        0x0800133e:    d0fa        ..      BEQ      0x8001336 ; SystemClock_Config + 70
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h
;;;1065     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
        0x08001340:    6841        Ah      LDR      r1,[r0,#4]
        0x08001342:    f02101f0    !...    BIC      r1,r1,#0xf0
        0x08001346:    6041        A`      STR      r1,[r0,#4]
;;;1066   }
;;;1067   
;;;1068   /**
;;;1069     * @brief  Set APB1 prescaler
;;;1070     * @rmtoll CFGR         PPRE1         LL_RCC_SetAPB1Prescaler
;;;1071     * @param  Prescaler This parameter can be one of the following values:
;;;1072     *         @arg @ref LL_RCC_APB1_DIV_1
;;;1073     *         @arg @ref LL_RCC_APB1_DIV_2
;;;1074     *         @arg @ref LL_RCC_APB1_DIV_4
;;;1075     *         @arg @ref LL_RCC_APB1_DIV_8
;;;1076     *         @arg @ref LL_RCC_APB1_DIV_16
;;;1077     * @retval None
;;;1078     */
;;;1079   __STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
;;;1080   {
;;;1081     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
        0x08001348:    6841        Ah      LDR      r1,[r0,#4]
        0x0800134a:    f42161e0    !..a    BIC      r1,r1,#0x700
        0x0800134e:    f4416180    A..a    ORR      r1,r1,#0x400
        0x08001352:    6041        A`      STR      r1,[r0,#4]
;;;1082   }
;;;1083   
;;;1084   /**
;;;1085     * @brief  Set APB2 prescaler
;;;1086     * @rmtoll CFGR         PPRE2         LL_RCC_SetAPB2Prescaler
;;;1087     * @param  Prescaler This parameter can be one of the following values:
;;;1088     *         @arg @ref LL_RCC_APB2_DIV_1
;;;1089     *         @arg @ref LL_RCC_APB2_DIV_2
;;;1090     *         @arg @ref LL_RCC_APB2_DIV_4
;;;1091     *         @arg @ref LL_RCC_APB2_DIV_8
;;;1092     *         @arg @ref LL_RCC_APB2_DIV_16
;;;1093     * @retval None
;;;1094     */
;;;1095   __STATIC_INLINE void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
;;;1096   {
;;;1097     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
        0x08001354:    6841        Ah      LDR      r1,[r0,#4]
        0x08001356:    f4215160    !.`Q    BIC      r1,r1,#0x3800
        0x0800135a:    6041        A`      STR      r1,[r0,#4]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_rcc.h (1032)
        0x0800135c:    6841        Ah      LDR      r1,[r0,#4]
        0x0800135e:    f0210103    !...    BIC      r1,r1,#3
        0x08001362:    f0410102    A...    ORR      r1,r1,#2
        0x08001366:    6041        A`      STR      r1,[r0,#4]
;;;1033   }
;;;1034   
;;;1035   /**
;;;1036     * @brief  Get the system clock source
;;;1037     * @rmtoll CFGR         SWS           LL_RCC_GetSysClkSource
;;;1038     * @retval Returned value can be one of the following values:
;;;1039     *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI
;;;1040     *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
;;;1041     *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL
;;;1042     */
;;;1043   __STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
;;;1044   {
;;;1045     return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
        0x08001368:    6841        Ah      LDR      r1,[r0,#4]
        0x0800136a:    f001010c    ....    AND      r1,r1,#0xc
;;; .\../Src/main.c
;;;853      while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
        0x0800136e:    2908        .)      CMP      r1,#8
        0x08001370:    d1fa        ..      BNE      0x8001368 ; SystemClock_Config + 120
;;;854      {
;;;855      
;;;856      }
;;;857      LL_Init1msTick(72000000);
        0x08001372:    4c09        .L      LDR      r4,[pc,#36] ; [0x8001398] = 0x44aa200
        0x08001374:    4620         F      MOV      r0,r4
        0x08001376:    f7fff8dd    ....    BL       LL_Init1msTick ; 0x8000534
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;264        SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
        0x0800137a:    f04f21e0    O..!    MOV      r1,#0xe000e000
        0x0800137e:    690a        .i      LDR      r2,[r1,#0x10]
        0x08001380:    f0420204    B...    ORR      r2,r2,#4
        0x08001384:    610a        .a      STR      r2,[r1,#0x10]
;;; .\../Src/main.c
;;;859      LL_SetSystemCoreClock(72000000);
        0x08001386:    4620         F      MOV      r0,r4
        0x08001388:    e8bd4010    ...@    POP      {r4,lr}
        0x0800138c:    f7ffb8f0    ....    B        LL_SetSystemCoreClock ; 0x8000570
    $d
        0x08001390:    40022000    . .@    DCD    1073881088
        0x08001394:    40021000    ...@    DCD    1073876992
        0x08001398:    044aa200    ..J.    DCD    72000000
    $t
    i.SystemInit
    SystemInit
;;; .\../Src/system_stm32f1xx.c
;;;179      RCC->CR |= 0x00000001U;
        0x0800139c:    480d        .H      LDR      r0,[pc,#52] ; [0x80013d4] = 0x40021000
        0x0800139e:    6801        .h      LDR      r1,[r0,#0]
        0x080013a0:    f0410101    A...    ORR      r1,r1,#1
        0x080013a4:    6001        .`      STR      r1,[r0,#0]
;;;180    
;;;181      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;182    #if !defined(STM32F105xC) && !defined(STM32F107xC)
;;;183      RCC->CFGR &= 0xF8FF0000U;
        0x080013a6:    6841        Ah      LDR      r1,[r0,#4]
        0x080013a8:    4a0b        .J      LDR      r2,[pc,#44] ; [0x80013d8] = 0xf8ff0000
        0x080013aa:    4011        .@      ANDS     r1,r1,r2
        0x080013ac:    6041        A`      STR      r1,[r0,#4]
;;;184    #else
;;;185      RCC->CFGR &= 0xF0FF0000U;
;;;186    #endif /* STM32F105xC */   
;;;187      
;;;188      /* Reset HSEON, CSSON and PLLON bits */
;;;189      RCC->CR &= 0xFEF6FFFFU;
        0x080013ae:    6801        .h      LDR      r1,[r0,#0]
        0x080013b0:    4a0a        .J      LDR      r2,[pc,#40] ; [0x80013dc] = 0xfef6ffff
        0x080013b2:    4011        .@      ANDS     r1,r1,r2
        0x080013b4:    6001        .`      STR      r1,[r0,#0]
;;;190    
;;;191      /* Reset HSEBYP bit */
;;;192      RCC->CR &= 0xFFFBFFFFU;
        0x080013b6:    6801        .h      LDR      r1,[r0,#0]
        0x080013b8:    f4212180    !..!    BIC      r1,r1,#0x40000
        0x080013bc:    6001        .`      STR      r1,[r0,#0]
;;;193    
;;;194      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;195      RCC->CFGR &= 0xFF80FFFFU;
        0x080013be:    6841        Ah      LDR      r1,[r0,#4]
        0x080013c0:    f42101fe    !...    BIC      r1,r1,#0x7f0000
        0x080013c4:    6041        A`      STR      r1,[r0,#4]
;;;196    
;;;197    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;198      /* Reset PLL2ON and PLL3ON bits */
;;;199      RCC->CR &= 0xEBFFFFFFU;
;;;200    
;;;201      /* Disable all interrupts and clear pending bits  */
;;;202      RCC->CIR = 0x00FF0000U;
;;;203    
;;;204      /* Reset CFGR2 register */
;;;205      RCC->CFGR2 = 0x00000000U;
;;;206    #elif defined(STM32F100xB) || defined(STM32F100xE)
;;;207      /* Disable all interrupts and clear pending bits  */
;;;208      RCC->CIR = 0x009F0000U;
;;;209    
;;;210      /* Reset CFGR2 register */
;;;211      RCC->CFGR2 = 0x00000000U;      
;;;212    #else
;;;213      /* Disable all interrupts and clear pending bits  */
;;;214      RCC->CIR = 0x009F0000U;
        0x080013c6:    f44f011f    O...    MOV      r1,#0x9f0000
        0x080013ca:    6081        .`      STR      r1,[r0,#8]
;;;215    #endif /* STM32F105xC */
;;;216        
;;;217    #if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
;;;218      #ifdef DATA_IN_ExtSRAM
;;;219        SystemInit_ExtMemCtl(); 
;;;220      #endif /* DATA_IN_ExtSRAM */
;;;221    #endif 
;;;222    
;;;223    #ifdef VECT_TAB_SRAM
;;;224      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;225    #else
;;;226      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
        0x080013cc:    4904        .I      LDR      r1,[pc,#16] ; [0x80013e0] = 0xe000ed08
        0x080013ce:    03c0        ..      LSLS     r0,r0,#15
        0x080013d0:    6008        .`      STR      r0,[r1,#0]
;;;227    #endif 
;;;228    }
        0x080013d2:    4770        pG      BX       lr
    $d
        0x080013d4:    40021000    ...@    DCD    1073876992
        0x080013d8:    f8ff0000    ....    DCD    4177461248
        0x080013dc:    fef6ffff    ....    DCD    4277600255
        0x080013e0:    e000ed08    ....    DCD    3758157064
    $t
    i.TIM1_UP_IRQHandler
    TIM1_UP_IRQHandler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
        0x080013e4:    4804        .H      LDR      r0,[pc,#16] ; [0x80013f8] = 0x40012c00
        0x080013e6:    6901        .i      LDR      r1,[r0,#0x10]
        0x080013e8:    f3c10100    ....    UBFX     r1,r1,#0,#1
        0x080013ec:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c
;;;233    {
        0x080013ee:    d002        ..      BEQ      0x80013f6 ; TIM1_UP_IRQHandler + 18
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x080013f0:    f06f0101    o...    MVN      r1,#1
        0x080013f4:    6101        .a      STR      r1,[r0,#0x10]
;;; .\../Src/stm32f1xx_it.c
;;;245    }
        0x080013f6:    4770        pG      BX       lr
    $d
        0x080013f8:    40012c00    .,.@    DCD    1073818624
    $t
    i.TIM2_IRQHandler
    TIM2_IRQHandler
;;;246    
;;;247    /**
;;;248      * @brief This function handles TIM2 global interrupt.
;;;249      */
;;;250    void TIM2_IRQHandler(void)
;;;251    {
        0x080013fc:    b570        p.      PUSH     {r4-r6,lr}
        0x080013fe:    480c        .H      LDR      r0,[pc,#48] ; [0x8001430] = 0x40000408
        0x08001400:    6800        .h      LDR      r0,[r0,#0]
        0x08001402:    f04f4480    O..D    MOV      r4,#0x40000000
        0x08001406:    2816        .(      CMP      r0,#0x16
;;; .\../Src/stm32f1xx_it.c (251)
        0x08001408:    d109        ..      BNE      0x800141e ; TIM2_IRQHandler + 34
;;;252      /* USER CODE BEGIN TIM2_IRQn 0 */
;;;253    // prescaler=((((speed=72000000)/((period=20000)/(1/hz=1)))+0,5)-1)
;;;254    //	if ( async_z == 1) {
;;;255    	if(TIM3->SMCR == 0x16) { // TIM3 connected to TIM2 as SLAVE
;;;256    //	if ( state.async_z == 1) {
;;;257    //		state.f_encoder = encoder;
;;;258    //		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
;;;259    //		LED_GPIO_Port->BSRR = LED_Pin;   // led off
;;;260    //		LED_GPIO_Port->BRR = LED_Pin;
;;;261    //    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
;;;262    //    LL_GPIO_TogglePin( LED_GPIO_Port, LED_Pin);
;;;263    
;;;264    		state.function(&state);
        0x0800140a:    4d0a        .M      LDR      r5,[pc,#40] ; [0x8001434] = 0x20000060
        0x0800140c:    4628        (F      MOV      r0,r5
        0x0800140e:    6829        )h      LDR      r1,[r5,#0]
        0x08001410:    4788        .G      BLX      r1
;;;265    
;;;266    		TIM2->ARR = state.z_period;
        0x08001412:    7b28        ({      LDRB     r0,[r5,#0xc]
        0x08001414:    62e0        .b      STR      r0,[r4,#0x2c]
;;;267    		TIM2->EGR |= TIM_EGR_UG;
        0x08001416:    6960        `i      LDR      r0,[r4,#0x14]
        0x08001418:    f0400001    @...    ORR      r0,r0,#1
        0x0800141c:    6160        `a      STR      r0,[r4,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
        0x0800141e:    6920         i      LDR      r0,[r4,#0x10]
        0x08001420:    f3c00000    ....    UBFX     r0,r0,#0,#1
;;; .\../Src/stm32f1xx_it.c
;;;276      if(LL_TIM_IsActiveFlag_UPDATE(TIM2) == 1)
        0x08001424:    2800        .(      CMP      r0,#0
        0x08001426:    d002        ..      BEQ      0x800142e ; TIM2_IRQHandler + 50
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2932     WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
        0x08001428:    f06f0001    o...    MVN      r0,#1
        0x0800142c:    6120         a      STR      r0,[r4,#0x10]
;;; .\../Src/stm32f1xx_it.c
;;;282    }
        0x0800142e:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x08001430:    40000408    ...@    DCD    1073742856
        0x08001434:    20000060    `..     DCD    536871008
    $t
    i.TIM3_IRQHandler
    TIM3_IRQHandler
;;;283    
;;;284    /**
;;;285      * @brief This function handles TIM3 global interrupt.
;;;286      */
;;;287    void TIM3_IRQHandler(void)
;;;288    {
        0x08001438:    b570        p.      PUSH     {r4-r6,lr}
        0x0800143a:    4811        .H      LDR      r0,[pc,#68] ; [0x8001480] = 0x40000408
        0x0800143c:    6800        .h      LDR      r0,[r0,#0]
        0x0800143e:    2400        .$      MOVS     r4,#0
        0x08001440:    2816        .(      CMP      r0,#0x16
;;; .\../Src/stm32f1xx_it.c (288)
        0x08001442:    d118        ..      BNE      0x8001476 ; TIM3_IRQHandler + 62
;;; ../Inc/fsm.h
;;;97     	TIM3->CCER = 0;	//	LL_TIM_CC_DisableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x08001444:    480e        .H      LDR      r0,[pc,#56] ; [0x8001480] = 0x40000408
        0x08001446:    3018        .0      ADDS     r0,r0,#0x18
        0x08001448:    6004        .`      STR      r4,[r0,#0]
;;;98     	s->e2 = s->err;
        0x0800144a:    4b0e        .K      LDR      r3,[pc,#56] ; [0x8001484] = 0x20000060
        0x0800144c:    6c58        Xl      LDR      r0,[r3,#0x44]
        0x0800144e:    6498        .d      STR      r0,[r3,#0x48]
;;;99     	if (s->e2 > -s->dx)	{ 
        0x08001450:    6a9a        .j      LDR      r2,[r3,#0x28]
;;; ../Inc/fsm.h (98)
        0x08001452:    4619        .F      MOV      r1,r3
;;;99     	if (s->e2 > -s->dx)	{ 
        0x08001454:    4255        UB      RSBS     r5,r2,#0
;;;100    		s->err -= s->dz; 
;;;101    		t3ccer[TIM_CCER_CC1E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x08001456:    2601        .&      MOVS     r6,#1
;;; ../Inc/fsm.h (100)
        0x08001458:    6ac9        .j      LDR      r1,[r1,#0x2c]
;;; ../Inc/fsm.h (99)
        0x0800145a:    42a8        .B      CMP      r0,r5
        0x0800145c:    dd03        ..      BLE      0x8001466 ; TIM3_IRQHandler + 46
;;;100    		s->err -= s->dz; 
        0x0800145e:    1a45        E.      SUBS     r5,r0,r1
        0x08001460:    645d        ]d      STR      r5,[r3,#0x44]
;;;101    		t3ccer[TIM_CCER_CC1E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x08001462:    4d09        .M      LDR      r5,[pc,#36] ; [0x8001488] = 0x42008400
        0x08001464:    602e        .`      STR      r6,[r5,#0]
;;;102    	}
;;;103    	if (s->e2 < s->dz)	{ 
        0x08001466:    4288        .B      CMP      r0,r1
        0x08001468:    da05        ..      BGE      0x8001476 ; TIM3_IRQHandler + 62
;;;104    		s->err += s->dx;
        0x0800146a:    6c58        Xl      LDR      r0,[r3,#0x44]
        0x0800146c:    4410        .D      ADD      r0,r0,r2
        0x0800146e:    6458        Xd      STR      r0,[r3,#0x44]
;;;105    		t3ccer[TIM_CCER_CC3E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3); 
        0x08001470:    4805        .H      LDR      r0,[pc,#20] ; [0x8001488] = 0x42008400
        0x08001472:    3020         0      ADDS     r0,r0,#0x20
        0x08001474:    6006        .`      STR      r6,[r0,#0]
;;; .\../Src/stm32f1xx_it.c
;;;293    	TIM3->SR = 0;
        0x08001476:    4802        .H      LDR      r0,[pc,#8] ; [0x8001480] = 0x40000408
        0x08001478:    3008        .0      ADDS     r0,r0,#8
        0x0800147a:    6004        .`      STR      r4,[r0,#0]
;;;294    	
;;;295      /* USER CODE END TIM3_IRQn 0 */
;;;296      /* USER CODE BEGIN TIM3_IRQn 1 */
;;;297    
;;;298      /* USER CODE END TIM3_IRQn 1 */
;;;299    }
        0x0800147c:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0800147e:    0000        ..      DCW    0
        0x08001480:    40000408    ...@    DCD    1073742856
        0x08001484:    20000060    `..     DCD    536871008
        0x08001488:    42008400    ...B    DCD    1107330048
    $t
    i.TIM4_IRQHandler
    TIM4_IRQHandler
;;;300    
;;;301    /**
;;;302      * @brief This function handles TIM4 global interrupt.
;;;303      */
;;;304    void TIM4_IRQHandler(void)
;;;305    {
        0x0800148c:    b510        ..      PUSH     {r4,lr}
        0x0800148e:    490a        .I      LDR      r1,[pc,#40] ; [0x80014b8] = 0x20000060
        0x08001490:    7c08        .|      LDRB     r0,[r1,#0x10]
        0x08001492:    2801        .(      CMP      r0,#1
;;; .\../Src/stm32f1xx_it.c (305)
        0x08001494:    d10c        ..      BNE      0x80014b0 ; TIM4_IRQHandler + 36
;;;306      /* USER CODE BEGIN TIM4_IRQn 0 */
;;;307    //	_Bool dir = t4cr1[TIM_CR1_DIR_Pos];
;;;308    //	if(t4sr[TIM_SR_CC3IF_Pos]){
;;;309    //		do_fsm_wait_tacho(&state);
;;;310    //	}
;;;311    	if (state.sync == true) {
;;;312    		state.spindle_dir = t4cr1[TIM_CR1_DIR_Pos];
        0x08001496:    4a09        .J      LDR      r2,[pc,#36] ; [0x80014bc] = 0x42010000
        0x08001498:    6910        .i      LDR      r0,[r2,#0x10]
        0x0800149a:    b100        ..      CBZ      r0,0x800149e ; TIM4_IRQHandler + 18
        0x0800149c:    2001        .       MOVS     r0,#1
        0x0800149e:    73c8        .s      STRB     r0,[r1,#0xf]
;;;313    //		state.f_encoder = encoder;
;;;314    		state.f_tacho = t4sr[TIM_SR_CC3IF_Pos];
        0x080014a0:    f8d2020c    ....    LDR      r0,[r2,#0x20c]
        0x080014a4:    b100        ..      CBZ      r0,0x80014a8 ; TIM4_IRQHandler + 28
        0x080014a6:    2001        .       MOVS     r0,#1
        0x080014a8:    7388        .s      STRB     r0,[r1,#0xe]
;;;315    		state.function(&state);
        0x080014aa:    6809        .h      LDR      r1,[r1,#0]
        0x080014ac:    4802        .H      LDR      r0,[pc,#8] ; [0x80014b8] = 0x20000060
        0x080014ae:    4788        .G      BLX      r1
;;;316    	}
;;;317    //	TIM4->SR &= ~TIM_SR_UIF; //   . 
;;;318    
;;;319      /* USER CODE END TIM4_IRQn 0 */
;;;320      /* USER CODE BEGIN TIM4_IRQn 1 */
;;;321      /* Check whether update interrupt is pending */
;;;322    //	if(LL_TIM_IsActiveFlag_CC2OVR(TIM4) == 1){
;;;323    //		TIM4->SR = 0;
;;;324    //	}
;;;325    	TIM4->SR = 0;
        0x080014b0:    4903        .I      LDR      r1,[pc,#12] ; [0x80014c0] = 0x40000810
        0x080014b2:    2000        .       MOVS     r0,#0
        0x080014b4:    6008        .`      STR      r0,[r1,#0]
;;;326    /*
;;;327    	if(LL_TIM_IsActiveFlag_CC2(TIM4) == 1)
;;;328        LL_TIM_ClearFlag_CC2(TIM4);
;;;329    	if(LL_TIM_IsActiveFlag_CC3(TIM4) == 1)
;;;330        LL_TIM_ClearFlag_CC3(TIM4);
;;;331    	if(LL_TIM_IsActiveFlag_UPDATE(TIM4) == 1)
;;;332      {
;;;333        LL_TIM_ClearFlag_UPDATE(TIM4); //Clear the update interrupt flag
;;;334      }
;;;335    */
;;;336      /* USER CODE END TIM4_IRQn 1 */
;;;337    }
        0x080014b6:    bd10        ..      POP      {r4,pc}
    $d
        0x080014b8:    20000060    `..     DCD    536871008
        0x080014bc:    42010000    ...B    DCD    1107361792
        0x080014c0:    40000810    ...@    DCD    1073743888
    $t
    i.Transfer_Complete_Callback
    Transfer_Complete_Callback
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1160     return (READ_BIT(I2Cx->SR1, I2C_SR1_BTF) == (I2C_SR1_BTF));
        0x080014c4:    480b        .H      LDR      r0,[pc,#44] ; [0x80014f4] = 0x40005800
        0x080014c6:    6941        Ai      LDR      r1,[r0,#0x14]
        0x080014c8:    f3c10180    ....    UBFX     r1,r1,#2,#1
;;; .\..\Src\i2c_interface.c
;;;331    	while(!LL_I2C_IsActiveFlag_BTF(I2C2))
        0x080014cc:    2900        .)      CMP      r1,#0
        0x080014ce:    d0fa        ..      BEQ      0x80014c6 ; Transfer_Complete_Callback + 2
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_i2c.h
;;;1596     SET_BIT(I2Cx->CR1, I2C_CR1_STOP);
        0x080014d0:    6801        .h      LDR      r1,[r0,#0]
        0x080014d2:    f4417100    A..q    ORR      r1,r1,#0x200
        0x080014d6:    6001        .`      STR      r1,[r0,#0]
;;; .\..\Src\i2c_interface.c
;;;335      LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
        0x080014d8:    4a07        .J      LDR      r2,[pc,#28] ; [0x80014f8] = 0x40020000
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;491      CLEAR_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x080014da:    4808        .H      LDR      r0,[pc,#32] ; [0x80014fc] = 0x8001f40
        0x080014dc:    1d01        ..      ADDS     r1,r0,#4
        0x080014de:    78c0        .x      LDRB     r0,[r0,#3]
        0x080014e0:    5810        .X      LDR      r0,[r2,r0]
        0x080014e2:    f8111c01    ....    LDRB     r1,[r1,#-1]
        0x080014e6:    f0200001     ...    BIC      r0,r0,#1
        0x080014ea:    5050        PP      STR      r0,[r2,r1]
;;; .\..\Src\i2c_interface.c
;;;337      ubTransferComplete = 1;
        0x080014ec:    4904        .I      LDR      r1,[pc,#16] ; [0x8001500] = 0x20000004
        0x080014ee:    2001        .       MOVS     r0,#1
        0x080014f0:    7008        .p      STRB     r0,[r1,#0]
;;;338    }
        0x080014f2:    4770        pG      BX       lr
    $d
        0x080014f4:    40005800    .X.@    DCD    1073764352
        0x080014f8:    40020000    ...@    DCD    1073872896
        0x080014fc:    08001f40    @...    DCD    134225728
        0x08001500:    20000004    ...     DCD    536870916
    $t
    i.Transfer_Error_Callback
    Transfer_Error_Callback
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1465     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
        0x08001504:    4902        .I      LDR      r1,[pc,#8] ; [0x8001510] = 0xe000e180
        0x08001506:    f44f4080    O..@    MOV      r0,#0x4000
        0x0800150a:    6008        .`      STR      r0,[r1,#0]
;;; .\..\Src\i2c_interface.c
;;;351      while(1){};
        0x0800150c:    e7fe        ..      B        0x800150c ; Transfer_Error_Callback + 8
    $d
        0x0800150e:    0000        ..      DCW    0
        0x08001510:    e000e180    ....    DCD    3758154112
    $t
    i.USART2_IRQHandler
    USART2_IRQHandler
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;1859     return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
        0x08001514:    4806        .H      LDR      r0,[pc,#24] ; [0x8001530] = 0x40004400
        0x08001516:    6801        .h      LDR      r1,[r0,#0]
        0x08001518:    f3c11140    ..@.    UBFX     r1,r1,#5,#1
        0x0800151c:    2900        .)      CMP      r1,#0
;;; .\../Src/stm32f1xx_it.c
;;;388    {
        0x0800151e:    d006        ..      BEQ      0x800152e ; USART2_IRQHandler + 26
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2294     return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
        0x08001520:    68c0        .h      LDR      r0,[r0,#0xc]
        0x08001522:    f3c01040    ..@.    UBFX     r0,r0,#5,#1
;;; .\../Src/stm32f1xx_it.c
;;;390      if(LL_USART_IsActiveFlag_RXNE(USART2) && LL_USART_IsEnabledIT_RXNE(USART2))
        0x08001526:    2800        .(      CMP      r0,#0
        0x08001528:    d001        ..      BEQ      0x800152e ; USART2_IRQHandler + 26
;;;391      {
;;;392        /* RXNE flag will be cleared by reading of DR register (done in call) */
;;;393        /* Call function in charge of handling Character reception */
;;;394        USART_CharReception_Callback();
        0x0800152a:    f000b803    ....    B.W      USART_CharReception_Callback ; 0x8001534
;;;395      }
;;;396      /* USER CODE END USART2_IRQn 0 */
;;;397      /* USER CODE BEGIN USART2_IRQn 1 */
;;;398    
;;;399      /* USER CODE END USART2_IRQn 1 */
;;;400    }
        0x0800152e:    4770        pG      BX       lr
    $d
        0x08001530:    40004400    .D.@    DCD    1073759232
    $t
    i.USART_CharReception_Callback
    USART_CharReception_Callback
;;; .\../Src/main.c
;;;324    {
        0x08001534:    b510        ..      PUSH     {r4,lr}
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2470     return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
        0x08001536:    480b        .H      LDR      r0,[pc,#44] ; [0x8001564] = 0x40004400
        0x08001538:    6840        @h      LDR      r0,[r0,#4]
        0x0800153a:    b2c0        ..      UXTB     r0,r0
;;; .\../Src/main.c
;;;330    		ubUART2ReceptionComplete = 1;
        0x0800153c:    490a        .I      LDR      r1,[pc,#40] ; [0x8001568] = 0x20000038
;;; .\../Src/main.c (328)
        0x0800153e:    280a        .(      CMP      r0,#0xa
        0x08001540:    694b        Ki      LDR      r3,[r1,#0x14]
;;; .\../Src/main.c (324)
        0x08001542:    d006        ..      BEQ      0x8001552 ; USART_CharReception_Callback + 30
;;;325    	uint8_t *ptemp;
;;;326      /* Read Received character. RXNE flag is cleared by reading of DR register */
;;;327    	uint8_t symbol = LL_USART_ReceiveData8(USART2);
;;;328    	if(symbol == '\n' || symbol == '\r'){
        0x08001544:    280d        .(      CMP      r0,#0xd
        0x08001546:    d004        ..      BEQ      0x8001552 ; USART_CharReception_Callback + 30
;;;329        /* Set Buffer swap indication */
;;;330    		ubUART2ReceptionComplete = 1;
;;;331    
;;;332        /* Swap buffers for next bytes to be received */
;;;333        ptemp = pBufferReadyForUser;
;;;334        pBufferReadyForUser = pBufferReadyForReception;
;;;335        pBufferReadyForReception = ptemp;
;;;336        uwNbReceivedChars = 0;
;;;337    	} else {
;;;338    		pBufferReadyForReception[uwNbReceivedChars++] = symbol;
        0x08001548:    68ca        .h      LDR      r2,[r1,#0xc]
        0x0800154a:    1c54        T.      ADDS     r4,r2,#1
        0x0800154c:    60cc        .`      STR      r4,[r1,#0xc]
        0x0800154e:    5498        .T      STRB     r0,[r3,r2]
;;;339    	}
;;;340    }
        0x08001550:    bd10        ..      POP      {r4,pc}
;;; .\../Src/main.c (330)
        0x08001552:    2001        .       MOVS     r0,#1
        0x08001554:    7008        .p      STRB     r0,[r1,#0]
;;;331    
;;;332        /* Swap buffers for next bytes to be received */
;;;333        ptemp = pBufferReadyForUser;
        0x08001556:    6908        .i      LDR      r0,[r1,#0x10]
;;;334        pBufferReadyForUser = pBufferReadyForReception;
        0x08001558:    610b        .a      STR      r3,[r1,#0x10]
;;;335        pBufferReadyForReception = ptemp;
        0x0800155a:    6148        Ha      STR      r0,[r1,#0x14]
;;;336        uwNbReceivedChars = 0;
        0x0800155c:    2000        .       MOVS     r0,#0
        0x0800155e:    60c8        .`      STR      r0,[r1,#0xc]
;;;337    	} else {
;;;338    		pBufferReadyForReception[uwNbReceivedChars++] = symbol;
;;;339    	}
;;;340    }
        0x08001560:    bd10        ..      POP      {r4,pc}
    $d
        0x08001562:    0000        ..      DCW    0
        0x08001564:    40004400    .D.@    DCD    1073759232
        0x08001568:    20000038    8..     DCD    536870968
    $t
    i.__scatterload_copy
    __scatterload_copy
        0x0800156c:    e002        ..      B        0x8001574 ; __scatterload_copy + 8
        0x0800156e:    c808        ..      LDM      r0!,{r3}
        0x08001570:    1f12        ..      SUBS     r2,r2,#4
        0x08001572:    c108        ..      STM      r1!,{r3}
        0x08001574:    2a00        .*      CMP      r2,#0
        0x08001576:    d1fa        ..      BNE      0x800156e ; __scatterload_copy + 2
        0x08001578:    4770        pG      BX       lr
    i.__scatterload_null
    __scatterload_null
        0x0800157a:    4770        pG      BX       lr
    i.__scatterload_zeroinit
    __scatterload_zeroinit
        0x0800157c:    2000        .       MOVS     r0,#0
        0x0800157e:    e001        ..      B        0x8001584 ; __scatterload_zeroinit + 8
        0x08001580:    c101        ..      STM      r1!,{r0}
        0x08001582:    1f12        ..      SUBS     r2,r2,#4
        0x08001584:    2a00        .*      CMP      r2,#0
        0x08001586:    d1fb        ..      BNE      0x8001580 ; __scatterload_zeroinit + 4
        0x08001588:    4770        pG      BX       lr
        0x0800158a:    0000        ..      MOVS     r0,r0
    i.do_fsm_menu
    do_fsm_menu
;;; .\..\Src\fsm.c
;;;69     {
        0x0800158c:    e92d41f0    -..A    PUSH     {r4-r8,lr}
;;;70     	uint8_t level = Thread_Info[Menu_Step].level;
        0x08001590:    4e23        #N      LDR      r6,[pc,#140] ; [0x8001620] = 0x200004e0
        0x08001592:    4b22        "K      LDR      r3,[pc,#136] ; [0x800161c] = 0x200000c0
        0x08001594:    7831        1x      LDRB     r1,[r6,#0]
        0x08001596:    eb031141    ..A.    ADD      r1,r3,r1,LSL #5
;;;71     #ifdef _SIMU
;;;72     	buttons_flag_set = long_press_start_Msk;
        0x0800159a:    4a22        "J      LDR      r2,[pc,#136] ; [0x8001624] = 0x200005dc
        0x0800159c:    2501        .%      MOVS     r5,#1
        0x0800159e:    6015        .`      STR      r5,[r2,#0]
;;;73     #endif	
;;;74     	switch(buttons_flag_set) {
;;;75     	case single_click_Msk3: {
;;;76     		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;77     		menu_changed = 1;
;;;78     		break;
;;;79     	}
;;;80     	case single_click_Msk2: {
;;;81     		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;82     		menu_changed = 1;
;;;83     		break;
;;;84     	}
;;;85     	case single_click_Msk: {
;;;86     		if(z_axis.end_pos != 0) {
;;;87     			// first pass of thread cut was complete, so just use single click
;;;88     			//	to switch between modes to process all other cuts
;;;89     
;;;90     //			z_move(feed_direction, z_axis.end_pos, s->main_feed_direction == feed_direction ? true : false, true);
;;;91     			if(demo)
;;;92     				z_move(feed_direction, z_axis.end_pos, false, true); //test case, always async
;;;93     			else
;;;94     				z_move(feed_direction, z_axis.end_pos, s->main_feed_direction == feed_direction ? true : false, true);
;;;95     //			z_move(feed_direction, 400*2, false, true);
;;;96     		} else { // controller in initial state, scroll menu
;;;97     			s->function = do_fsm_menu_lps;
;;;98     			for (int a = Menu_Step+1; a<Menu_size; a++) {
;;;99     				if(Thread_Info[a].level == level) {
;;;100    					Menu_Step = a;
;;;101    					menu_changed = 1;
;;;102    					break;
;;;103    				}
;;;104    			}
;;;105    			if(menu_changed != 1) {
;;;106    				for (int a = 0; a<Menu_Step; a++) {
;;;107    					if(Thread_Info[a].level == level) {
;;;108    						Menu_Step = a;
;;;109    						menu_changed = 1;
;;;110    						break;
;;;111    					}
;;;112    				}
;;;113    			}
;;;114    		}
;;;115    		break;
;;;116    	}
;;;117    	case double_click_Msk: {
;;;118    		feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;119    		menu_changed = 1;
;;;120    		break;
;;;121    	}
;;;122    	case (long_press_start_Msk | long_press_start_Msk2): { // two buttons long pressed same time
;;;123    		// todo check if it work
;;;124    		break;
;;;125    	}
;;;126    	case long_press_start_Msk: {
;;;127    		if(s->function == do_fsm_menu_lps){
        0x080015a0:    6800        .h      LDR      r0,[r0,#0]
        0x080015a2:    4a21        !J      LDR      r2,[pc,#132] ; [0x8001628] = 0x8001649
        0x080015a4:    4290        .B      CMP      r0,r2
        0x080015a6:    d131        1.      BNE      0x800160c ; do_fsm_menu + 128
;;;128    			if(Thread_Info[Menu_Step].Q824 != 0) { // long press detected, start new thread from current position
        0x080015a8:    680a        .h      LDR      r2,[r1,#0]
        0x080015aa:    b31a        ..      CBZ      r2,0x80015f4 ; do_fsm_menu + 104
;;;129    
;;;130    				z_axis.Q824set = Thread_Info[Menu_Step].Q824;
        0x080015ac:    4c1f        .L      LDR      r4,[pc,#124] ; [0x800162c] = 0x20000508
        0x080015ae:    60e2        .`      STR      r2,[r4,#0xc]
;;;131    				const uint64_t upl = (uint64_t)3600 << 48; //calculate some constants for prolong mode
;;;132    				z_axis.prolong_addSteps = upl / (fixedptud)z_axis.Q824set;
        0x080015b0:    2300        .#      MOVS     r3,#0
        0x080015b2:    4618        .F      MOV      r0,r3
        0x080015b4:    f04f6161    O.aa    MOV      r1,#0xe100000
        0x080015b8:    f7fefdb4    ....    BL       __aeabi_uldivmod ; 0x8000124
        0x080015bc:    e9c40106    ....    STRD     r0,r1,[r4,#0x18]
;;;133    				// 200*step_divider*z_feed_screw(mm)*len(mm) = desired length in steps, in my case its 200*2*1*x
;;;134    
;;;135    				
;;;136    				MOTOR_X_Enable();
        0x080015c0:    491b        .I      LDR      r1,[pc,#108] ; [0x8001630] = 0x40010810
        0x080015c2:    f2402002    @..     MOV      r0,#0x202
        0x080015c6:    6008        .`      STR      r0,[r1,#0]
;;;137    				MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x080015c8:    491a        .I      LDR      r1,[pc,#104] ; [0x8001634] = 0x40010c10
        0x080015ca:    6008        .`      STR      r0,[r1,#0]
;;;138    //				LL_mDelay(2);
;;;139    				if(demo){
        0x080015cc:    481a        .H      LDR      r0,[pc,#104] ; [0x8001638] = 0x2000000b
        0x080015ce:    7800        .x      LDRB     r0,[r0,#0]
        0x080015d0:    b138        8.      CBZ      r0,0x80015e2 ; do_fsm_menu + 86
;;;140    					G01(steps_x,steps_z,0);
        0x080015d2:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x080015d6:    2200        ."      MOVS     r2,#0
        0x080015d8:    f44f7196    O..q    MOV      r1,#0x12c
        0x080015dc:    2001        .       MOVS     r0,#1
        0x080015de:    f7febe57    ..W.    B        G01 ; 0x8000290
;;;141    //					z_move(feed_direction, steps, false, true); //test case, move async 10mm
;;;142    //					z_move(feed_direction, 31, false, true); //test case, move async 10mm
;;;143    				}
;;;144    				else
;;;145    					z_move(feed_direction, 0, true, true);
        0x080015e2:    4816        .H      LDR      r0,[pc,#88] ; [0x800163c] = 0x200000bc
        0x080015e4:    2301        .#      MOVS     r3,#1
        0x080015e6:    461a        .F      MOV      r2,r3
        0x080015e8:    7800        .x      LDRB     r0,[r0,#0]
        0x080015ea:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x080015ee:    2100        .!      MOVS     r1,#0
        0x080015f0:    f000bc54    ..T.    B.W      z_move ; 0x8001e9c
;;;146    
;;;147    				//do_fsm_move_start
;;;148    			} else { // goto submenu
;;;149    				for (int a = 0; a<Menu_size; a++) {
        0x080015f4:    2000        .       MOVS     r0,#0
        0x080015f6:    4a12        .J      LDR      r2,[pc,#72] ; [0x8001640] = 0x8002011
        0x080015f8:    e00b        ..      B        0x8001612 ; do_fsm_menu + 134
;;;150    					if(Thread_Info[a].level == Thread_Info[Menu_Step].submenu) {
        0x080015fa:    eb031440    ..@.    ADD      r4,r3,r0,LSL #5
        0x080015fe:    790f        .y      LDRB     r7,[r1,#4]
        0x08001600:    7c64        d|      LDRB     r4,[r4,#0x11]
        0x08001602:    42bc        .B      CMP      r4,r7
        0x08001604:    d104        ..      BNE      0x8001610 ; do_fsm_menu + 132
;;;151    						Menu_Step = a;
        0x08001606:    7030        0p      STRB     r0,[r6,#0]
;;;152    						menu_changed = 1;
        0x08001608:    480e        .H      LDR      r0,[pc,#56] ; [0x8001644] = 0x2000003c
        0x0800160a:    6005        .`      STR      r5,[r0,#0]
;;;153    						break;
;;;154    					}
;;;155    				}
;;;156    			}
;;;157    		} 
;;;158    /* todo prolong
;;;159    		else if(s->function == do_fsm_main_cut_back){
;;;160    			s->function = do_fsm_main_cut_back_prolong; // go to 48 mode to add threads until long_press end
;;;161    		}
;;;162    */
;;;163    		break;
;;;164    	}
;;;165    	case long_press_end_Msk: {
;;;166    		if(s->function == do_fsm_move)
;;;167    			s->function = do_long_press_end_callback;
;;;168    		break;
;;;169    	}
;;;170    	}
;;;171    }
        0x0800160c:    e8bd81f0    ....    POP      {r4-r8,pc}
        0x08001610:    1c40        @.      ADDS     r0,r0,#1
        0x08001612:    7814        .x      LDRB     r4,[r2,#0]
        0x08001614:    42a0        .B      CMP      r0,r4
        0x08001616:    dbf0        ..      BLT      0x80015fa ; do_fsm_menu + 110
        0x08001618:    e7f8        ..      B        0x800160c ; do_fsm_menu + 128
    $d
        0x0800161a:    0000        ..      DCW    0
        0x0800161c:    200000c0    ...     DCD    536871104
        0x08001620:    200004e0    ...     DCD    536872160
        0x08001624:    200005dc    ...     DCD    536872412
        0x08001628:    08001649    I...    DCD    134223433
        0x0800162c:    20000508    ...     DCD    536872200
        0x08001630:    40010810    ...@    DCD    1073809424
        0x08001634:    40010c10    ...@    DCD    1073810448
        0x08001638:    2000000b    ...     DCD    536870923
        0x0800163c:    200000bc    ...     DCD    536871100
        0x08001640:    08002011    . ..    DCD    134225937
        0x08001644:    2000003c    <..     DCD    536870972
    $t
    i.do_fsm_menu_lps
    do_fsm_menu_lps
;;;172    
;;;173    void do_fsm_menu_lps(state_t* s)
;;;174    {
;;;175    }
        0x08001648:    4770        pG      BX       lr
        0x0800164a:    0000        ..      MOVS     r0,r0
    i.do_fsm_move
    do_fsm_move
;;;176    
;;;177    /*
;;;178    void do_fsm_main_cut_back_prolong(state_t* s)   // reverse movement: main part with prolong activated. todo split it with 46 mode?
;;;179    {
;;;180    	MOTOR_Z_SetPulse();
;;;181    	--z_axis.current_pos;
;;;182    	if(z_axis.current_pos == z_axis.ramp_step) { // we reach end of main path and have long_pressed key, so just add additional thread full turn to shift initial start point
;;;183    		z_axis.prolong_fract += z_axis.prolong_addSteps; // fract part from prev step
;;;184    		uint32_t prolong_fixpart = z_axis.prolong_fract >> 24;
;;;185    		z_axis.current_pos += prolong_fixpart; // add fixed part
;;;186    		z_axis.end_pos += prolong_fixpart;
;;;187    		z_axis.prolong_fract &= FIXEDPT_FMASK; // leave fract part to accumulate with next dividing cycle
;;;188    		// when long_press end, get back to 46 mode to proceed
;;;189    	}
;;;190    }
;;;191    */
;;;192    
;;;193    void do_fsm_wait_sclick(state_t* s)
;;;194    {
;;;195    }
;;;196    
;;;197    void z_move(uint32_t direction, uint32_t length, bool sync, bool autostart){
;;;198    	MOTOR_X_Enable();
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
;;;200    
;;;201    	if(direction == feed_direction_left) {
;;;202    		feed_direction = feed_direction_left;
;;;203    		MOTOR_Z_Reverse();
;;;204    		MOTOR_X_Reverse();
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
;;;207    		MOTOR_Z_Forward();
;;;208    		MOTOR_X_Forward();
;;;209    	}
;;;210    	LL_mDelay(2);
;;;211    
;;;212    	state.sync = sync;
;;;213    	if(sync){
;;;214    		state.main_feed_direction = feed_direction;
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
;;;218    	z_axis.end_pos = length;
;;;219    	if(z_axis.end_pos > 0){
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
;;;228    }
;;;229    
;;;230    //---------------------------------------------------------------------------------------------
;;;231    void do_fsm_move_start(state_t* s){
;;;232    	if(s->sync && !s->f_tacho){
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
;;;234    		// enable and wait tacho event on spindle encoder
;;;235    		LL_TIM_CC_EnableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;236    		return;
;;;237    	}
;;;238    
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
;;;240    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;241    		if(s->sync && s->f_tacho) {
;;;242    			s->function = do_fsm_ramp_up;
;;;243    			s->async_z = 0;
;;;244    			s->syncbase = TIM4; 									// sync with spindle
;;;245    
;;;246    			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR3); 				//trigger by spindle encoder timer TIM4(sync mode)
;;;247    
;;;248    // disable TACHO events, we dont need'em until next start			
;;;249    			LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
;;;260    			LL_TIM_GenerateEvent_UPDATE(TIM3);
;;;261    //			LL_TIM_EnableCounter(TIM3);
;;;262    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;263    //			LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;264    
;;;265    //			TIM3->SR = 0;
;;;266    //			LL_TIM_EnableCounter(TIM3);
;;;267    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;268    //			LL_TIM_SetTriggerInput(TIM3, LL_TIM_TS_ITR1); 				//trigger by TIM2(async mode)
;;;269    
;;;270    			
;;;271    //			LL_TIM_EnableCounter(TIM2); /* Enable counter */
;;;272    
;;;273    //			MOTOR_Z_AllowPulse();
;;;274    //			MOTOR_X_AllowPulse();
;;;275    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_TRIGGER);
;;;276    
;;;277    			TIM2->ARR = 10;
;;;278    //			LL_TIM_GenerateEvent_UPDATE(TIM2); // start first step on motor
;;;279    			LL_TIM_EnableCounter(TIM2);
;;;280    
;;;281    
;;;282    //			TIM2->ARR = 1;
;;;283    //			LL_TIM_EnableCounter(TIM2);
;;;284    
;;;285    //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
;;;286    //			TIM3->SR = 0;
;;;287    //			LL_TIM_EnableCounter(TIM3);
;;;288    //			LL_TIM_GenerateEvent_TRIG(TIM2); // start first step on motor
;;;289    	//		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3);
;;;290    //			s->syncbase->ARR = 1; 					// start stepper motor ramp up procedure immediately after tacho event
;;;291    			s->async_z = 1;
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
        0x0800164c:    b570        p.      PUSH     {r4-r6,lr}
        0x0800164e:    4604        .F      MOV      r4,r0
        0x08001650:    4d0e        .M      LDR      r5,[pc,#56] ; [0x800168c] = 0x20000508
        0x08001652:    f8951028    ..(.    LDRB     r1,[r5,#0x28]
        0x08001656:    6868        hh      LDR      r0,[r5,#4]
        0x08001658:    1a41        A.      SUBS     r1,r0,r1
        0x0800165a:    6828        (h      LDR      r0,[r5,#0]
        0x0800165c:    1c40        @.      ADDS     r0,r0,#1
        0x0800165e:    6028        (`      STR      r0,[r5,#0]
        0x08001660:    4281        .B      CMP      r1,r0
;;; .\..\Src\fsm.c (310)
        0x08001662:    d304        ..      BCC      0x800166e ; do_fsm_move + 34
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
        0x08001664:    4620         F      MOV      r0,r4
        0x08001666:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x0800166a:    f000bbbd    ....    B.W      z_axis_move2 ; 0x8001de8
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
        0x0800166e:    4620         F      MOV      r0,r4
        0x08001670:    f000fbd4    ....    BL       z_axis_ramp_down2 ; 0x8001e1c
        0x08001674:    b130        0.      CBZ      r0,0x8001684 ; do_fsm_move + 56
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
        0x08001676:    e9d50100    ....    LDRD     r0,r1,[r5,#0]
        0x0800167a:    4281        .B      CMP      r1,r0
        0x0800167c:    d000        ..      BEQ      0x8001680 ; do_fsm_move + 52
;;;318    				z_axis.end_pos = z_axis.current_pos;
        0x0800167e:    6068        h`      STR      r0,[r5,#4]
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
        0x08001680:    4803        .H      LDR      r0,[pc,#12] ; [0x8001690] = 0x80016c5
        0x08001682:    6020         `      STR      r0,[r4,#0]
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
        0x08001684:    4803        .H      LDR      r0,[pc,#12] ; [0x8001694] = 0x80017d9
        0x08001686:    6020         `      STR      r0,[r4,#0]
;;;323    	}
;;;324    }
        0x08001688:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x0800168a:    0000        ..      DCW    0
        0x0800168c:    20000508    ...     DCD    536872200
        0x08001690:    080016c5    ....    DCD    134223557
        0x08001694:    080017d9    ....    DCD    134223833
    $t
    i.do_fsm_move_async
    do_fsm_move_async
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
;;;340    //	if(s->spindle_dir)	
;;;341    	z_axis.current_pos++;
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
;;;346    			z_axis.end_pos = z_axis.current_pos;
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
;;;349    	}
;;;350    }
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    static inline _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
;;;436    		if( rs2 < z_axis.end_pos) {
;;;437    			s->z_period = slew_speed_period;
;;;438    			s->function = do_fsm_move_async;
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
;;;442    			s->function = do_fsm_ramp_down_async;
;;;443    			z_axis.ramp_step--;
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
;;;448    	}
;;;449    }
;;;450    
;;;451    void do_fsm_move_async(state_t* s)
;;;452    {
;;;453    	
;;;454    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;455    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;456    //	uint32_t a = z_axis.end_pos;
;;;457    //	uint32_t b = z_axis.ramp_step;
;;;458    //	uint32_t cp = ++z_axis.current_pos;
;;;459    //	uint32_t pre = a - b - 1;
;;;460    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
        0x08001698:    4a08        .J      LDR      r2,[pc,#32] ; [0x80016bc] = 0x20000508
        0x0800169a:    f8923028    ..(0    LDRB     r3,[r2,#0x28]
        0x0800169e:    6851        Qh      LDR      r1,[r2,#4]
        0x080016a0:    1acb        ..      SUBS     r3,r1,r3
        0x080016a2:    1e5b        [.      SUBS     r3,r3,#1
        0x080016a4:    6811        .h      LDR      r1,[r2,#0]
        0x080016a6:    1c49        I.      ADDS     r1,r1,#1
        0x080016a8:    6011        .`      STR      r1,[r2,#0]
        0x080016aa:    4299        .B      CMP      r1,r3
;;; .\..\Src\fsm.c (452)
        0x080016ac:    d202        ..      BCS      0x80016b4 ; do_fsm_move_async + 28
;;;453    	
;;;454    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;455    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;456    //	uint32_t a = z_axis.end_pos;
;;;457    //	uint32_t b = z_axis.ramp_step;
;;;458    //	uint32_t cp = ++z_axis.current_pos;
;;;459    //	uint32_t pre = a - b - 1;
;;;460    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
;;;461    	if( ++z_axis.current_pos < pre ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;462    		s->z_period = slew_speed_period;
        0x080016ae:    2132        2!      MOVS     r1,#0x32
        0x080016b0:    7301        .s      STRB     r1,[r0,#0xc]
        0x080016b2:    4770        pG      BX       lr
;;;463    	} else {
;;;464    		s->function = do_fsm_ramp_down_async;
        0x080016b4:    4902        .I      LDR      r1,[pc,#8] ; [0x80016c0] = 0x8001809
        0x080016b6:    6001        .`      STR      r1,[r0,#0]
;;;465    	}
;;;466    }
        0x080016b8:    4770        pG      BX       lr
    $d
        0x080016ba:    0000        ..      DCW    0
        0x080016bc:    20000508    ...     DCD    536872200
        0x080016c0:    08001809    ....    DCD    134223881
    $t
    i.do_fsm_move_end
    do_fsm_move_end
;;; .\..\Src\fsm.c (352)
        0x080016c4:    b510        ..      PUSH     {r4,lr}
        0x080016c6:    4604        .F      MOV      r4,r0
        0x080016c8:    2000        .       MOVS     r0,#0
        0x080016ca:    6060        ``      STR      r0,[r4,#4]
        0x080016cc:    4915        .I      LDR      r1,[pc,#84] ; [0x8001724] = 0x40000400
        0x080016ce:    688a        .h      LDR      r2,[r1,#8]
        0x080016d0:    f0220207    "...    BIC      r2,r2,#7
        0x080016d4:    608a        .`      STR      r2,[r1,#8]
        0x080016d6:    7c21        !|      LDRB     r1,[r4,#0x10]
        0x080016d8:    2900        .)      CMP      r1,#0
;;; .\..\Src\fsm.c (352)
        0x080016da:    d007        ..      BEQ      0x80016ec ; do_fsm_move_end + 40
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
        0x080016dc:    4912        .I      LDR      r1,[pc,#72] ; [0x8001728] = 0x42010180
        0x080016de:    6008        .`      STR      r0,[r1,#0]
        0x080016e0:    4912        .I      LDR      r1,[pc,#72] ; [0x800172c] = 0x40000800
        0x080016e2:    6a0a        .j      LDR      r2,[r1,#0x20]
        0x080016e4:    f4227280    "..r    BIC      r2,r2,#0x100
        0x080016e8:    620a        .b      STR      r2,[r1,#0x20]
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
        0x080016ea:    e005        ..      B        0x80016f8 ; do_fsm_move_end + 52
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1038     CLEAR_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x080016ec:    f04f4180    O..A    MOV      r1,#0x40000000
        0x080016f0:    680a        .h      LDR      r2,[r1,#0]
        0x080016f2:    f0220201    "...    BIC      r2,r2,#1
        0x080016f6:    600a        .`      STR      r2,[r1,#0]
;;; .\..\Src\fsm.c
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
        0x080016f8:    6160        `a      STR      r0,[r4,#0x14]
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
        0x080016fa:    2002        .       MOVS     r0,#2
        0x080016fc:    f7fff928    ..(.    BL       LL_mDelay ; 0x8000950
;;;368      MOTOR_Z_Disable();
        0x08001700:    490b        .I      LDR      r1,[pc,#44] ; [0x8001730] = 0x40010c14
        0x08001702:    f2402002    @..     MOV      r0,#0x202
        0x08001706:    6008        .`      STR      r0,[r1,#0]
;;;369      MOTOR_X_Disable();
        0x08001708:    490a        .I      LDR      r1,[pc,#40] ; [0x8001734] = 0x40010814
        0x0800170a:    6008        .`      STR      r0,[r1,#0]
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
        0x0800170c:    480a        .H      LDR      r0,[pc,#40] ; [0x8001738] = 0x200000bc
        0x0800170e:    7801        .x      LDRB     r1,[r0,#0]
        0x08001710:    f0810101    ....    EOR      r1,r1,#1
        0x08001714:    7001        .p      STRB     r1,[r0,#0]
;;;372    	menu_changed = 1; 													//update menu
        0x08001716:    4909        .I      LDR      r1,[pc,#36] ; [0x800173c] = 0x2000003c
        0x08001718:    2001        .       MOVS     r0,#1
        0x0800171a:    6008        .`      STR      r0,[r1,#0]
;;;373    	s->function = do_fsm_wait_sclick;
        0x0800171c:    4808        .H      LDR      r0,[pc,#32] ; [0x8001740] = 0x80018c9
        0x0800171e:    6020         `      STR      r0,[r4,#0]
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
        0x08001720:    bd10        ..      POP      {r4,pc}
    $d
        0x08001722:    0000        ..      DCW    0
        0x08001724:    40000400    ...@    DCD    1073742848
        0x08001728:    42010180    ...B    DCD    1107362176
        0x0800172c:    40000800    ...@    DCD    1073743872
        0x08001730:    40010c14    ...@    DCD    1073810452
        0x08001734:    40010814    ...@    DCD    1073809428
        0x08001738:    200000bc    ...     DCD    536871100
        0x0800173c:    2000003c    <..     DCD    536870972
        0x08001740:    080018c9    ....    DCD    134224073
    $t
    i.do_fsm_move_start
    do_fsm_move_start
;;; .\..\Src\fsm.c (231)
        0x08001744:    b530        0.      PUSH     {r4,r5,lr}
;;;232    	if(s->sync && !s->f_tacho){
        0x08001746:    7c02        .|      LDRB     r2,[r0,#0x10]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1493     SET_BIT(TIMx->CCER, Channels);
        0x08001748:    4b1e        .K      LDR      r3,[pc,#120] ; [0x80017c4] = 0x40000800
        0x0800174a:    7b81        .{      LDRB     r1,[r0,#0xe]
        0x0800174c:    2a00        .*      CMP      r2,#0
        0x0800174e:    d000        ..      BEQ      0x8001752 ; do_fsm_move_start + 14
        0x08001750:    b109        ..      CBZ      r1,0x8001756 ; do_fsm_move_start + 18
        0x08001752:    b951        Q.      CBNZ     r1,0x800176a ; do_fsm_move_start + 38
        0x08001754:    e007        ..      B        0x8001766 ; do_fsm_move_start + 34
;;; .\..\Src\fsm.c
;;;233    		s->function = do_fsm_move_start;// return here from interrupt when TACHO event
        0x08001756:    f2af0113    ....    ADR      r1,{pc}-0x11 ; 0x8001745
        0x0800175a:    6001        .`      STR      r1,[r0,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1493     SET_BIT(TIMx->CCER, Channels);
        0x0800175c:    6a18        .j      LDR      r0,[r3,#0x20]
        0x0800175e:    f4407080    @..p    ORR      r0,r0,#0x100
        0x08001762:    6218        .b      STR      r0,[r3,#0x20]
        0x08001764:    bd30        0.      POP      {r4,r5,pc}
;;; .\..\Src\fsm.c
;;;239    	if(s->f_tacho || !s->sync) { // if tacho event or we going to start back feed to initial position with async clock
        0x08001766:    2a00        .*      CMP      r2,#0
        0x08001768:    d1fc        ..      BNE      0x8001764 ; do_fsm_move_start + 32
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x0800176a:    4c17        .L      LDR      r4,[pc,#92] ; [0x80017c8] = 0x40000400
        0x0800176c:    2501        .%      MOVS     r5,#1
;;; .\..\Src\fsm.c
;;;241    		if(s->sync && s->f_tacho) {
        0x0800176e:    b192        ..      CBZ      r2,0x8001796 ; do_fsm_move_start + 82
        0x08001770:    b189        ..      CBZ      r1,0x8001796 ; do_fsm_move_start + 82
;;;242    			s->function = do_fsm_ramp_up;
        0x08001772:    4916        .I      LDR      r1,[pc,#88] ; [0x80017cc] = 0x8001849
        0x08001774:    6001        .`      STR      r1,[r0,#0]
;;;243    			s->async_z = 0;
        0x08001776:    2100        .!      MOVS     r1,#0
        0x08001778:    6041        A`      STR      r1,[r0,#4]
;;;244    			s->syncbase = TIM4; 									// sync with spindle
        0x0800177a:    6143        Ca      STR      r3,[r0,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
        0x0800177c:    68a0        .h      LDR      r0,[r4,#8]
        0x0800177e:    f0200070     .p.    BIC      r0,r0,#0x70
        0x08001782:    f0400030    @.0.    ORR      r0,r0,#0x30
        0x08001786:    60a0        .`      STR      r0,[r4,#8]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1518)
        0x08001788:    6a18        .j      LDR      r0,[r3,#0x20]
        0x0800178a:    f4207080     ..p    BIC      r0,r0,#0x100
        0x0800178e:    6218        .b      STR      r0,[r3,#0x20]
;;; .\..\Src\fsm.c
;;;250    			enable_encoder_ticks(); 									// enable thread specific interrupt controlled by Q824set
        0x08001790:    480f        .H      LDR      r0,[pc,#60] ; [0x80017d0] = 0x42010180
        0x08001792:    6005        .`      STR      r5,[r0,#0]
        0x08001794:    bd30        0.      POP      {r4,r5,pc}
;;;251    		} else {
;;;252    			s->function = do_fsm_ramp_up_async;
        0x08001796:    490f        .I      LDR      r1,[pc,#60] ; [0x80017d4] = 0x800186d
        0x08001798:    6001        .`      STR      r1,[r0,#0]
;;;253    //			s->async_z = 1;
;;;254    			s->syncbase = TIM2; 									// sync with internal clock source(virtual spindle, "async" to main spindle)
        0x0800179a:    f04f4180    O..A    MOV      r1,#0x40000000
        0x0800179e:    6141        Aa      STR      r1,[r0,#0x14]
;;;255    
;;;256    //			s->set_pulse_function(s);
;;;257    //			dxdz_callback(s);
;;;258    //			LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;259    			TIM3->ARR = min_pulse*5;
        0x080017a0:    4b09        .K      LDR      r3,[pc,#36] ; [0x80017c8] = 0x40000400
        0x080017a2:    f6406229    @.)b    MOV      r2,#0xe29
        0x080017a6:    332c        ,3      ADDS     r3,r3,#0x2c
        0x080017a8:    601a        .`      STR      r2,[r3,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x080017aa:    6962        bi      LDR      r2,[r4,#0x14]
        0x080017ac:    f0420201    B...    ORR      r2,r2,#1
        0x080017b0:    6162        ba      STR      r2,[r4,#0x14]
;;; .\..\Src\fsm.c
;;;277    			TIM2->ARR = 10;
        0x080017b2:    220a        ."      MOVS     r2,#0xa
        0x080017b4:    62ca        .b      STR      r2,[r1,#0x2c]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1027     SET_BIT(TIMx->CR1, TIM_CR1_CEN);
        0x080017b6:    680a        .h      LDR      r2,[r1,#0]
        0x080017b8:    f0420201    B...    ORR      r2,r2,#1
        0x080017bc:    600a        .`      STR      r2,[r1,#0]
;;; .\..\Src\fsm.c
;;;291    			s->async_z = 1;
        0x080017be:    6045        E`      STR      r5,[r0,#4]
;;;292    //			TIM2->CNT = 0;
;;;293    //			LL_TIM_GenerateEvent_UPDATE(TIM2); /* Force update generation */
;;;294    
;;;295    		}
;;;296    
;;;297    //		LL_mDelay(20);
;;;298    	}	
;;;299    }
        0x080017c0:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x080017c2:    0000        ..      DCW    0
        0x080017c4:    40000800    ...@    DCD    1073743872
        0x080017c8:    40000400    ...@    DCD    1073742848
        0x080017cc:    08001849    I...    DCD    134223945
        0x080017d0:    42010180    ...B    DCD    1107362176
        0x080017d4:    0800186d    m...    DCD    134223981
    $t
    i.do_fsm_ramp_down
    do_fsm_ramp_down
;;;300    
;;;301    void do_fsm_ramp_up(state_t* s)
;;;302    {
;;;303    	z_axis.current_pos++;
;;;304    	if(z_axis_ramp_up2(s)) {
;;;305    		s->function = do_fsm_move;
;;;306    	}
;;;307    }
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
        0x080017d8:    b570        p.      PUSH     {r4-r6,lr}
        0x080017da:    4605        .F      MOV      r5,r0
;;;340    //	if(s->spindle_dir)	
;;;341    	z_axis.current_pos++;
        0x080017dc:    4c08        .L      LDR      r4,[pc,#32] ; [0x8001800] = 0x20000508
        0x080017de:    6820         h      LDR      r0,[r4,#0]
        0x080017e0:    1c40        @.      ADDS     r0,r0,#1
        0x080017e2:    6020         `      STR      r0,[r4,#0]
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
        0x080017e4:    4628        (F      MOV      r0,r5
        0x080017e6:    f000fb19    ....    BL       z_axis_ramp_down2 ; 0x8001e1c
        0x080017ea:    2800        .(      CMP      r0,#0
        0x080017ec:    d006        ..      BEQ      0x80017fc ; do_fsm_ramp_down + 36
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
        0x080017ee:    e9d40100    ....    LDRD     r0,r1,[r4,#0]
        0x080017f2:    4281        .B      CMP      r1,r0
        0x080017f4:    d000        ..      BEQ      0x80017f8 ; do_fsm_ramp_down + 32
;;;346    			z_axis.end_pos = z_axis.current_pos;
        0x080017f6:    6060        ``      STR      r0,[r4,#4]
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
        0x080017f8:    4802        .H      LDR      r0,[pc,#8] ; [0x8001804] = 0x80016c5
        0x080017fa:    6028        (`      STR      r0,[r5,#0]
;;;349    	}
;;;350    }
        0x080017fc:    bd70        p.      POP      {r4-r6,pc}
    $d
        0x080017fe:    0000        ..      DCW    0
        0x08001800:    20000508    ...     DCD    536872200
        0x08001804:    080016c5    ....    DCD    134223557
    $t
    i.do_fsm_ramp_down_async
    do_fsm_ramp_down_async
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    static inline _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
;;;436    		if( rs2 < z_axis.end_pos) {
;;;437    			s->z_period = slew_speed_period;
;;;438    			s->function = do_fsm_move_async;
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
;;;442    			s->function = do_fsm_ramp_down_async;
;;;443    			z_axis.ramp_step--;
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
;;;448    	}
;;;449    }
;;;450    
;;;451    void do_fsm_move_async(state_t* s)
;;;452    {
;;;453    	
;;;454    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;455    	// todo precalculate delta: z_axis.end_pos - z_axis.ramp_step
;;;456    //	uint32_t a = z_axis.end_pos;
;;;457    //	uint32_t b = z_axis.ramp_step;
;;;458    //	uint32_t cp = ++z_axis.current_pos;
;;;459    //	uint32_t pre = a - b - 1;
;;;460    	uint32_t pre = z_axis.end_pos - z_axis.ramp_step - 1;
;;;461    	if( ++z_axis.current_pos < pre ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;462    		s->z_period = slew_speed_period;
;;;463    	} else {
;;;464    		s->function = do_fsm_ramp_down_async;
;;;465    	}
;;;466    }
;;;467    
;;;468    void do_fsm_ramp_down_async(state_t* s)
;;;469    {
;;;470    	z_axis.current_pos++;
        0x08001808:    490c        .I      LDR      r1,[pc,#48] ; [0x800183c] = 0x20000508
        0x0800180a:    680a        .h      LDR      r2,[r1,#0]
        0x0800180c:    1c52        R.      ADDS     r2,r2,#1
        0x0800180e:    600a        .`      STR      r2,[r1,#0]
        0x08001810:    f8912028    ..(     LDRB     r2,[r1,#0x28]
        0x08001814:    4b0a        .K      LDR      r3,[pc,#40] ; [0x8001840] = 0x2000000c
        0x08001816:    1e52        R.      SUBS     r2,r2,#1
        0x08001818:    b2d2        ..      UXTB     r2,r2
        0x0800181a:    f8812028    ..(     STRB     r2,[r1,#0x28]
        0x0800181e:    5c9a        .\      LDRB     r2,[r3,r2]
        0x08001820:    7302        .s      STRB     r2,[r0,#0xc]
        0x08001822:    f8912028    ..(     LDRB     r2,[r1,#0x28]
        0x08001826:    2a00        .*      CMP      r2,#0
;;; .\..\Src\fsm.c (469)
        0x08001828:    d106        ..      BNE      0x8001838 ; do_fsm_ramp_down_async + 48
;;;470    	z_axis.current_pos++;
;;;471    
;;;472    	s->z_period = async_ramp_profile[--z_axis.ramp_step];
;;;473    	if (z_axis.ramp_step == 0) {
;;;474    //	} else {
;;;475    // for last step there is no need to wail long, motor can be start to disabled after 145 processor ticks, so with prescaler =145 and more ARR = 1 is enought
;;;476    //		s->z_period = 2; 
;;;477    //		LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED); // stop pulse generation on timer
;;;478    		if(z_axis.end_pos != z_axis.current_pos) {
        0x0800182a:    e9d12300    ...#    LDRD     r2,r3,[r1,#0]
        0x0800182e:    4293        .B      CMP      r3,r2
        0x08001830:    d000        ..      BEQ      0x8001834 ; do_fsm_ramp_down_async + 44
;;;479    			z_axis.end_pos = z_axis.current_pos;
        0x08001832:    604a        J`      STR      r2,[r1,#4]
;;;480    		}
;;;481    		s->function = do_fsm_move_end;
        0x08001834:    4903        .I      LDR      r1,[pc,#12] ; [0x8001844] = 0x80016c5
        0x08001836:    6001        .`      STR      r1,[r0,#0]
;;;482    //		do_fsm_move_end(s);
;;;483    	}
;;;484    }
        0x08001838:    4770        pG      BX       lr
    $d
        0x0800183a:    0000        ..      DCW    0
        0x0800183c:    20000508    ...     DCD    536872200
        0x08001840:    2000000c    ...     DCD    536870924
        0x08001844:    080016c5    ....    DCD    134223557
    $t
    i.do_fsm_ramp_up
    do_fsm_ramp_up
;;; .\..\Src\fsm.c (302)
        0x08001848:    b510        ..      PUSH     {r4,lr}
        0x0800184a:    4604        .F      MOV      r4,r0
;;;303    	z_axis.current_pos++;
        0x0800184c:    4805        .H      LDR      r0,[pc,#20] ; [0x8001864] = 0x20000508
        0x0800184e:    6801        .h      LDR      r1,[r0,#0]
        0x08001850:    1c49        I.      ADDS     r1,r1,#1
        0x08001852:    6001        .`      STR      r1,[r0,#0]
;;;304    	if(z_axis_ramp_up2(s)) {
        0x08001854:    4620         F      MOV      r0,r4
        0x08001856:    f000fafb    ....    BL       z_axis_ramp_up2 ; 0x8001e50
        0x0800185a:    2800        .(      CMP      r0,#0
        0x0800185c:    d001        ..      BEQ      0x8001862 ; do_fsm_ramp_up + 26
;;;305    		s->function = do_fsm_move;
        0x0800185e:    4802        .H      LDR      r0,[pc,#8] ; [0x8001868] = 0x800164d
        0x08001860:    6020         `      STR      r0,[r4,#0]
;;;306    	}
;;;307    }
        0x08001862:    bd10        ..      POP      {r4,pc}
    $d
        0x08001864:    20000508    ...     DCD    536872200
        0x08001868:    0800164d    M...    DCD    134223437
    $t
    i.do_fsm_ramp_up_async
    do_fsm_ramp_up_async
;;;308    
;;;309    void do_fsm_move(state_t* s)
;;;310    {
;;;311    //	if(s->spindle_dir)	z_axis.current_pos++;
;;;312    //	else z_axis.current_pos--;
;;;313    	if( ++z_axis.current_pos <= ( z_axis.end_pos - z_axis.ramp_step ) ) { // when end_pos is zero, end_pos-ramp_step= 4294967296 - ramp_step, so it will be much more lager then current_pos
;;;314    		z_axis_move2(s);
;;;315    	} else {
;;;316    		if(z_axis_ramp_down2(s)) {
;;;317    			if(z_axis.end_pos != z_axis.current_pos) {
;;;318    				z_axis.end_pos = z_axis.current_pos;
;;;319    			}
;;;320    			s->function = do_fsm_move_end;
;;;321    		}
;;;322    		s->function = do_fsm_ramp_down;
;;;323    	}
;;;324    }
;;;325    
;;;326    void do_long_press_end_callback(state_t* s)          // direct movement: first pass, thread recording: long press release callback
;;;327    {
;;;328    	//  1/2             2,( 1/4  4  ).
;;;329    	//                 ,
;;;330    	//        .
;;;331    	if(z_axis.end_pos == 0) //s->sync?
;;;332    		z_axis.end_pos = ( z_axis.ramp_step + z_axis.current_pos ) | (step_divider - 1);
;;;333    	s->function = do_fsm_move;
;;;334    	do_fsm_move(s);
;;;335    }
;;;336    
;;;337    
;;;338    void do_fsm_ramp_down(state_t* s)
;;;339    {
;;;340    //	if(s->spindle_dir)	
;;;341    	z_axis.current_pos++;
;;;342    //	else 
;;;343    //		z_axis.current_pos--;
;;;344    	if(z_axis_ramp_down2(s)) {
;;;345    		if(z_axis.end_pos != z_axis.current_pos) {
;;;346    			z_axis.end_pos = z_axis.current_pos;
;;;347    		}
;;;348    		s->function = do_fsm_move_end;
;;;349    	}
;;;350    }
;;;351    
;;;352    void do_fsm_move_end(state_t* s){
;;;353    	s->async_z = 0;
;;;354      LL_TIM_SetSlaveMode(TIM3, LL_TIM_SLAVEMODE_DISABLED);
;;;355    
;;;356    	//	MOTOR_Z_BlockPulse();
;;;357    	if (s->sync) {
;;;358    		disable_encoder_ticks(); 										//reset interrupt for encoder ticks, only tacho todo async mode not compatible now
;;;359    		LL_TIM_CC_DisableChannel(TIM4, LL_TIM_CHANNEL_CH3);	// configure TACHO events on channel 3
;;;360    	} else {
;;;361    		LL_TIM_DisableCounter(TIM2); // pause async timer
;;;362    //		LL_TIM_DisableIT_UPDATE(TIM2);
;;;363    	}
;;;364    	s->syncbase = 0; // reset syncbase to stop calling it from timer interrupt
;;;365    
;;;366    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;367    	LL_mDelay(2);
;;;368      MOTOR_Z_Disable();
;;;369      MOTOR_X_Disable();
;;;370    //	feed_direction = feed_direction == feed_direction_left ? feed_direction_right : feed_direction_left;
;;;371    	feed_direction = !feed_direction; 					//autochange feed direction
;;;372    	menu_changed = 1; 													//update menu
;;;373    	s->function = do_fsm_wait_sclick;
;;;374    
;;;375    //	z_axis.current_pos = 0;
;;;376    }
;;;377    
;;;378    
;;;379    _Bool z_axis_ramp_up2(state_t* s)
;;;380    {
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
;;;396    
;;;397    static inline _Bool z_axis_ramp_down2(state_t* s)
;;;398    {
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
;;;408    		return true;
;;;409    	return false;
;;;410    }
;;;411    
;;;412    void z_axis_move2(state_t* s)
;;;413    {
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;416    	s->syncbase->CNT = 0;
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;419    }
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    
;;;425    //------------------------------------ ASYNC block -----------------------------------
;;;426    //------------------------------------ ASYNC block -----------------------------------
;;;427    //------------------------------------ ASYNC block -----------------------------------
;;;428    void do_fsm_ramp_up_async(state_t* s)
;;;429    {
        0x0800186c:    b510        ..      PUSH     {r4,lr}
;;;430    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin); //debug
;;;431    //	MOTOR_Z_SetPulse();
;;;432    	z_axis.current_pos++;
        0x0800186e:    4c12        .L      LDR      r4,[pc,#72] ; [0x80018b8] = 0x20000508
        0x08001870:    6821        !h      LDR      r1,[r4,#0]
        0x08001872:    1c49        I.      ADDS     r1,r1,#1
        0x08001874:    6021        !`      STR      r1,[r4,#0]
        0x08001876:    f8941028    ..(.    LDRB     r1,[r4,#0x28]
        0x0800187a:    4b10        .K      LDR      r3,[pc,#64] ; [0x80018bc] = 0x2000000c
        0x0800187c:    1c4a        J.      ADDS     r2,r1,#1
        0x0800187e:    b2d2        ..      UXTB     r2,r2
        0x08001880:    f8842028    ..(     STRB     r2,[r4,#0x28]
        0x08001884:    5c59        Y\      LDRB     r1,[r3,r1]
        0x08001886:    0052        R.      LSLS     r2,r2,#1
        0x08001888:    4623        #F      MOV      r3,r4
;;;433    	const uint8_t z_arr = async_ramp_profile[z_axis.ramp_step++];
;;;434    	const uint16_t rs2 = z_axis.ramp_step << 1;
;;;435    	if(z_arr < slew_speed_period || rs2 >= z_axis.end_pos  ) { 	// reach desired speed
        0x0800188a:    2932        2)      CMP      r1,#0x32
        0x0800188c:    685b        [h      LDR      r3,[r3,#4]
        0x0800188e:    d301        ..      BCC      0x8001894 ; do_fsm_ramp_up_async + 40
        0x08001890:    4293        .B      CMP      r3,r2
        0x08001892:    d80e        ..      BHI      0x80018b2 ; do_fsm_ramp_up_async + 70
;;;436    		if( rs2 < z_axis.end_pos) {
        0x08001894:    4293        .B      CMP      r3,r2
        0x08001896:    d904        ..      BLS      0x80018a2 ; do_fsm_ramp_up_async + 54
;;;437    			s->z_period = slew_speed_period;
        0x08001898:    2132        2!      MOVS     r1,#0x32
        0x0800189a:    7301        .s      STRB     r1,[r0,#0xc]
;;;438    			s->function = do_fsm_move_async;
        0x0800189c:    4908        .I      LDR      r1,[pc,#32] ; [0x80018c0] = 0x8001699
        0x0800189e:    6001        .`      STR      r1,[r0,#0]
        0x080018a0:    bd10        ..      POP      {r4,pc}
;;;439    		}
;;;440    		else {
;;;441    			s->z_period = z_arr;
        0x080018a2:    7301        .s      STRB     r1,[r0,#0xc]
;;;442    			s->function = do_fsm_ramp_down_async;
        0x080018a4:    4907        .I      LDR      r1,[pc,#28] ; [0x80018c4] = 0x8001809
        0x080018a6:    6001        .`      STR      r1,[r0,#0]
;;;443    			z_axis.ramp_step--;
        0x080018a8:    f8140f28    ..(.    LDRB     r0,[r4,#0x28]!
        0x080018ac:    1e40        @.      SUBS     r0,r0,#1
        0x080018ae:    7020         p      STRB     r0,[r4,#0]
        0x080018b0:    bd10        ..      POP      {r4,pc}
;;;444    		}
;;;445    	} else {
;;;446    //		z_axis.ramp_step++;
;;;447    		s->z_period = z_arr;
        0x080018b2:    7301        .s      STRB     r1,[r0,#0xc]
;;;448    	}
;;;449    }
        0x080018b4:    bd10        ..      POP      {r4,pc}
    $d
        0x080018b6:    0000        ..      DCW    0
        0x080018b8:    20000508    ...     DCD    536872200
        0x080018bc:    2000000c    ...     DCD    536870924
        0x080018c0:    08001699    ....    DCD    134223513
        0x080018c4:    08001809    ....    DCD    134223881
    $t
    i.do_fsm_wait_sclick
    do_fsm_wait_sclick
;;; .\..\Src\fsm.c (195)
        0x080018c8:    4770        pG      BX       lr
        0x080018ca:    0000        ..      MOVS     r0,r0
    i.dxdz_callback
    dxdz_callback
;;; ../Inc/fsm.h
;;;97     	TIM3->CCER = 0;	//	LL_TIM_CC_DisableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x080018cc:    4a0d        .J      LDR      r2,[pc,#52] ; [0x8001904] = 0x40000420
        0x080018ce:    2100        .!      MOVS     r1,#0
        0x080018d0:    6011        .`      STR      r1,[r2,#0]
;;;98     	s->e2 = s->err;
        0x080018d2:    6c41        Al      LDR      r1,[r0,#0x44]
        0x080018d4:    6481        .d      STR      r1,[r0,#0x48]
;;;99     	if (s->e2 > -s->dx)	{ 
        0x080018d6:    6a82        .j      LDR      r2,[r0,#0x28]
        0x080018d8:    4253        SB      RSBS     r3,r2,#0
        0x080018da:    2201        ."      MOVS     r2,#1
        0x080018dc:    4299        .B      CMP      r1,r3
        0x080018de:    dd04        ..      BLE      0x80018ea ; dxdz_callback + 30
;;;100    		s->err -= s->dz; 
        0x080018e0:    6ac3        .j      LDR      r3,[r0,#0x2c]
        0x080018e2:    1ac9        ..      SUBS     r1,r1,r3
        0x080018e4:    6441        Ad      STR      r1,[r0,#0x44]
;;;101    		t3ccer[TIM_CCER_CC1E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1); 
        0x080018e6:    4908        .I      LDR      r1,[pc,#32] ; [0x8001908] = 0x42008400
        0x080018e8:    600a        .`      STR      r2,[r1,#0]
;;;102    	}
;;;103    	if (s->e2 < s->dz)	{ 
        0x080018ea:    6ac3        .j      LDR      r3,[r0,#0x2c]
        0x080018ec:    6c81        .l      LDR      r1,[r0,#0x48]
        0x080018ee:    4299        .B      CMP      r1,r3
        0x080018f0:    da06        ..      BGE      0x8001900 ; dxdz_callback + 52
;;;104    		s->err += s->dx;
        0x080018f2:    6a83        .j      LDR      r3,[r0,#0x28]
        0x080018f4:    6c41        Al      LDR      r1,[r0,#0x44]
        0x080018f6:    4419        .D      ADD      r1,r1,r3
        0x080018f8:    6441        Ad      STR      r1,[r0,#0x44]
;;;105    		t3ccer[TIM_CCER_CC3E_Pos] = 1; //		LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH3); 
        0x080018fa:    4803        .H      LDR      r0,[pc,#12] ; [0x8001908] = 0x42008400
        0x080018fc:    3020         0      ADDS     r0,r0,#0x20
        0x080018fe:    6002        .`      STR      r2,[r0,#0]
;;;106    	}
;;;107    }
        0x08001900:    4770        pG      BX       lr
    $d
        0x08001902:    0000        ..      DCW    0
        0x08001904:    40000420     ..@    DCD    1073742880
        0x08001908:    42008400    ...B    DCD    1107330048
    $t
    i.dzdx_init
    dzdx_init
;;; .\..\Src\fsm.c
;;;486    void dzdx_init(int dx, int dz, state_t* s) {
        0x0800190c:    b510        ..      PUSH     {r4,lr}
        0x0800190e:    f04f33ff    O..3    MOV      r3,#0xffffffff
;;;487    	s->dx = abs(dx); 
        0x08001912:    2800        .(      CMP      r0,#0
        0x08001914:    da01        ..      BGE      0x800191a ; dzdx_init + 14
        0x08001916:    f1c00000    ....    RSB      r0,r0,#0
        0x0800191a:    6290        .b      STR      r0,[r2,#0x28]
;;;488    	s->sx = dx > 0 ? 1 : -1;
        0x0800191c:    dd02        ..      BLE      0x8001924 ; dzdx_init + 24
        0x0800191e:    f04f0401    O...    MOV      r4,#1
        0x08001922:    e000        ..      B        0x8001926 ; dzdx_init + 26
        0x08001924:    461c        .F      MOV      r4,r3
        0x08001926:    6314        .c      STR      r4,[r2,#0x30]
;;;489      s->dz = abs(dz);
        0x08001928:    2900        .)      CMP      r1,#0
        0x0800192a:    da01        ..      BGE      0x8001930 ; dzdx_init + 36
        0x0800192c:    f1c10100    ....    RSB      r1,r1,#0
        0x08001930:    62d1        .b      STR      r1,[r2,#0x2c]
;;;490    	s->sz = dz > 0 ? 1 : -1; 
        0x08001932:    dd01        ..      BLE      0x8001938 ; dzdx_init + 44
        0x08001934:    f04f0301    O...    MOV      r3,#1
        0x08001938:    6353        Sc      STR      r3,[r2,#0x34]
;;;491      s->e2 = s->err = (s->dx > s->dz ? s->dx : -s->dz) >> 1;
        0x0800193a:    4288        .B      CMP      r0,r1
        0x0800193c:    dc00        ..      BGT      0x8001940 ; dzdx_init + 52
        0x0800193e:    4248        HB      RSBS     r0,r1,#0
        0x08001940:    1040        @.      ASRS     r0,r0,#1
        0x08001942:    6450        Pd      STR      r0,[r2,#0x44]
        0x08001944:    6490        .d      STR      r0,[r2,#0x48]
;;;492    	s->set_pulse_function = dxdz_callback;
        0x08001946:    4801        .H      LDR      r0,[pc,#4] ; [0x800194c] = 0x80018cd
        0x08001948:    6590        .e      STR      r0,[r2,#0x58]
;;;493    }
        0x0800194a:    bd10        ..      POP      {r4,pc}
    $d
        0x0800194c:    080018cd    ....    DCD    134224077
    $t
    i.init_buttons
    init_buttons
;;; .\..\Src\buttons.c
;;;11     void init_buttons(void){
        0x08001950:    b510        ..      PUSH     {r4,lr}
;;;12     
;;;13     	bt[0].clk_mode = 10;
        0x08001952:    4c06        .L      LDR      r4,[pc,#24] ; [0x800196c] = 0x200004e4
        0x08001954:    200a        .       MOVS     r0,#0xa
        0x08001956:    61e0        .a      STR      r0,[r4,#0x1c]
;;;14     	bt[0].GPIOx = BUTTON_1_GPIO_Port;
        0x08001958:    4805        .H      LDR      r0,[pc,#20] ; [0x8001970] = 0x40010800
        0x0800195a:    6020         `      STR      r0,[r4,#0]
;;;15     	bt[0].button_pin = BUTTON_1_Pin;
        0x0800195c:    4905        .I      LDR      r1,[pc,#20] ; [0x8001974] = 0x4010001
        0x0800195e:    6061        a`      STR      r1,[r4,#4]
;;;16     	bt[0].buttons = bt[0].buttons_mask = LL_GPIO_IsInputPinSet(bt[0].GPIOx,BUTTON_1_Pin); //bt[0].GPIOx->IDR & bt[0].button_pin;
        0x08001960:    f7fefdde    ....    BL       LL_GPIO_IsInputPinSet ; 0x8000520
        0x08001964:    61a0        .a      STR      r0,[r4,#0x18]
        0x08001966:    60e0        .`      STR      r0,[r4,#0xc]
;;;17     	return;
;;;18     	bt[1] = bt[0];
;;;19     	bt[1].clk_mode = 10;
;;;20     	bt[1].GPIOx = BUTTON_2_GPIO_Port;
;;;21     	bt[1].button_pin = BUTTON_2_Pin;
;;;22     	bt[1].buttons = bt[1].buttons_mask = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;23     
;;;24     	if(device_ready == 1){
;;;25     //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);		
;;;26     		reqest_sample_i2c_dma();
;;;27     //		while(ubTransferComplete == 0){
;;;28     //		}
;;;29     	}
;;;30     	bt[2].clk_mode = 10;
;;;31     	bt[2].button_pin = 0x02; // button_c code
;;;32     	bt[2].buttons = bt[2].buttons_mask = dma_data[5]&bt[2].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;33     	
;;;34     	bt[3].clk_mode = 10;
;;;35     	bt[3].button_pin = 0x01; // button_c code
;;;36     	bt[3].buttons = bt[3].buttons_mask = dma_data[5]&bt[3].button_pin; // = bt[1].GPIOx->IDR & bt[1].button_pin;
;;;37     
;;;38     }
        0x08001968:    bd10        ..      POP      {r4,pc}
    $d
        0x0800196a:    0000        ..      DCW    0
        0x0800196c:    200004e4    ...     DCD    536872164
        0x08001970:    40010800    ...@    DCD    1073809408
        0x08001974:    04010001    ....    DCD    67174401
    $t
    i.main
    main
;;; .\../Src/main.c
;;;540    {
        0x08001978:    b086        ..      SUB      sp,sp,#0x18
;;;541      /* USER CODE BEGIN 1 */
;;;542    //	z_axis.mode = fsm_menu_lps;
;;;543    
;;;544    	tst = tst * 1024 / 1000;
        0x0800197a:    4c69        iL      LDR      r4,[pc,#420] ; [0x8001b20] = 0x20000038
        0x0800197c:    f44f727a    O.zr    MOV      r2,#0x3e8
        0x08001980:    2300        .#      MOVS     r3,#0
        0x08001982:    e9d40108    ....    LDRD     r0,r1,[r4,#0x20]
        0x08001986:    0289        ..      LSLS     r1,r1,#10
        0x08001988:    ea415190    A..Q    ORR      r1,r1,r0,LSR #22
        0x0800198c:    0280        ..      LSLS     r0,r0,#10
        0x0800198e:    f7fefbc9    ....    BL       __aeabi_uldivmod ; 0x8000124
        0x08001992:    e9c40108    ....    STRD     r0,r1,[r4,#0x20]
;;;545    //	char code[] = "G01X.2Z100F10";
;;;546    	rs = 11;
        0x08001996:    200b        .       MOVS     r0,#0xb
        0x08001998:    60a0        .`      STR      r0,[r4,#8]
;;;547    //	f1 = fixedpt_fromint2210(400);
;;;548    	char codea[] = "2000.999";
        0x0800199a:    a062        b.      ADR      r0,{pc}+0x18a ; 0x8001b24
        0x0800199c:    e9d02100    ...!    LDRD     r2,r1,[r0,#0]
        0x080019a0:    6880        .h      LDR      r0,[r0,#8]
        0x080019a2:    e9cd2103    ...!    STRD     r2,r1,[sp,#0xc]
        0x080019a6:    9005        ..      STR      r0,[sp,#0x14]
;;;549    	char *end;
;;;550    
;;;551    	f1 = str_f_to_steps2210(codea, &end);
        0x080019a8:    a902        ..      ADD      r1,sp,#8
        0x080019aa:    a803        ..      ADD      r0,sp,#0xc
        0x080019ac:    f000f9d3    ....    BL       str_f_to_steps2210 ; 0x8001d56
        0x080019b0:    61a0        .a      STR      r0,[r4,#0x18]
;;;552    
;;;553    	char codei[] = "1.9999";
        0x080019b2:    a05f        _.      ADR      r0,{pc}+0x17e ; 0x8001b30
        0x080019b4:    c803        ..      LDM      r0,{r0,r1}
        0x080019b6:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
;;;554    	f1 = str_f_inch_to_steps2210(codei, &end);
        0x080019ba:    a902        ..      ADD      r1,sp,#8
        0x080019bc:    4668        hF      MOV      r0,sp
        0x080019be:    f000f97f    ....    BL       str_f_inch_to_steps2210 ; 0x8001cc0
        0x080019c2:    61a0        .a      STR      r0,[r4,#0x18]
;;;555    
;;;556    
;;;557    	/*	
;;;558    	circular_buffer cb;
;;;559    	cb_init(&cb, 10, sizeof(cb));
;;;560    	cb_push_back(&cb, &cb);
;;;561    
;;;562    
;;;563    	circular_buffer cb2;
;;;564    	cb_pop_front(&cb, &cb2);
;;;565    */	
;;;566    /*
;;;567    	float af = -5.5;
;;;568    	fixedpt af1 = af * (1 << FIXEDPT_FBITS);
;;;569    	float af2 = fixedpt_tofloat(af1);
;;;570    
;;;571    	char codea[] = "-1.223";
;;;572    	
;;;573    	char *end;
;;;574    	af = -1.223;
;;;575    	af1 = af * (1 << FIXEDPT_FBITS);
;;;576    	fixedpt a = strto824(codea, &end);
;;;577    	int rst = str_f_to_steps(codea, 400, &end);	
;;;578    
;;;579    	af2 = fixedpt_tofloat(a);
;;;580    
;;;581    	a = fixedpt_fromint(-1);
;;;582    	char codeb[] = "-5.5";
;;;583    	fixedpt b = strto824(codeb, &end);
;;;584    	af2 = fixedpt_tofloat(b);
;;;585    	b = fixedpt_fromint(-5);
;;;586    	fixedpt c = fixedpt_add(a,b);
;;;587    	int d = fixedpt_toint(c);
;;;588    //	return 0;
;;;589    */
;;;590    	
;;;591    	
;;;592    	
;;;593    	
;;;594    	
;;;595    	
;;;596    //	gc_execute_line(code);
;;;597    
;;;598    //	z_axis.end_pos = 50;
;;;599    //	z_axis.Q824set = Thread_Info[Menu_Step].Q824;
;;;600    
;;;601    //	state.main_feed_direction = 1;
;;;602    
;;;603    	//	do_fsm_move_start(&state);
;;;604    	//	do_fsm_wait_tacho(&state);
;;;605    	
;;;606    //	TIM4_IRQHandler();
;;;607      /* USER CODE END 1 */
;;;608    
;;;609      /* MCU Configuration--------------------------------------------------------*/
;;;610    
;;;611      /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
;;;612      
;;;613    
;;;614      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_AFIO);
        0x080019c4:    2001        .       MOVS     r0,#1
        0x080019c6:    f7fefccd    ....    BL       LL_APB2_GRP1_EnableClock ; 0x8000364
;;;615      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
        0x080019ca:    f04f5080    O..P    MOV      r0,#0x10000000
        0x080019ce:    f7fefcbd    ....    BL       LL_APB1_GRP1_EnableClock ; 0x800034c
;;; ../Drivers/CMSIS/Include/core_cm3.h
;;;1427     reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
        0x080019d2:    4959        YI      LDR      r1,[pc,#356] ; [0x8001b38] = 0xe000ed0c
        0x080019d4:    6808        .h      LDR      r0,[r1,#0]
;;;1428     reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
        0x080019d6:    f64f02ff    O...    MOV      r2,#0xf8ff
        0x080019da:    4010        .@      ANDS     r0,r0,r2
;;;1429     reg_value  =  (reg_value                                   |
        0x080019dc:    4a57        WJ      LDR      r2,[pc,#348] ; [0x8001b3c] = 0x5fa0000
        0x080019de:    f4407040    @.@p    ORR      r0,r0,#0x300
        0x080019e2:    4310        .C      ORRS     r0,r0,r2
;;;1430                   ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
;;;1431                   (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
;;;1432     SCB->AIRCR =  reg_value;
        0x080019e4:    6008        .`      STR      r0,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;1597     CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
        0x080019e6:    4856        VH      LDR      r0,[pc,#344] ; [0x8001b40] = 0x40010000
        0x080019e8:    6841        Ah      LDR      r1,[r0,#4]
        0x080019ea:    f02161e0    !..a    BIC      r1,r1,#0x7000000
        0x080019ee:    6041        A`      STR      r1,[r0,#4]
;;;1598     SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);
        0x080019f0:    6841        Ah      LDR      r1,[r0,#4]
        0x080019f2:    f0417100    A..q    ORR      r1,r1,#0x2000000
        0x080019f6:    6041        A`      STR      r1,[r0,#4]
;;; .\../Src/main.c
;;;629      SystemClock_Config();
        0x080019f8:    f7fffc7a    ..z.    BL       SystemClock_Config ; 0x80012f0
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_cortex.h
;;;291      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
        0x080019fc:    f04f20e0    O..     MOV      r0,#0xe000e000
        0x08001a00:    6901        .i      LDR      r1,[r0,#0x10]
        0x08001a02:    f0410102    A...    ORR      r1,r1,#2
        0x08001a06:    6101        .a      STR      r1,[r0,#0x10]
;;; .\../Src/main.c
;;;636      MX_GPIO_Init();
        0x08001a08:    f7feffda    ....    BL       MX_GPIO_Init ; 0x80009c0
;;;637      MX_DMA_Init();
        0x08001a0c:    f7feffb0    ....    BL       MX_DMA_Init ; 0x8000970
;;;638      MX_I2C2_Init();
        0x08001a10:    f7fff84a    ..J.    BL       MX_I2C2_Init ; 0x8000aa8
;;;639      MX_TIM1_Init();
        0x08001a14:    f7fff84a    ..J.    BL       MX_TIM1_Init ; 0x8000aac
;;;640      MX_TIM2_Init();
        0x08001a18:    f7fff8b0    ....    BL       MX_TIM2_Init ; 0x8000b7c
;;;641      MX_TIM3_Init();
        0x08001a1c:    f7fff900    ....    BL       MX_TIM3_Init ; 0x8000c20
;;;642      MX_TIM4_Init();
        0x08001a20:    f7fff9a8    ....    BL       MX_TIM4_Init ; 0x8000d74
;;;643      MX_USART2_UART_Init();
        0x08001a24:    f7fffa34    ..4.    BL       MX_USART2_UART_Init ; 0x8000e90
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2416     SET_BIT(USARTx->CR3, USART_CR3_DMAT);
        0x08001a28:    4846        FH      LDR      r0,[pc,#280] ; [0x8001b44] = 0x40004400
        0x08001a2a:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08001a2c:    f0410180    A...    ORR      r1,r1,#0x80
        0x08001a30:    6141        Aa      STR      r1,[r0,#0x14]
;;; .\../Src/main.c
;;;649      LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_7);
        0x08001a32:    4b45        EK      LDR      r3,[pc,#276] ; [0x8001b48] = 0x40020000
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h
;;;472      SET_BIT(((DMA_Channel_TypeDef *)((uint32_t)((uint32_t)DMAx + CHANNEL_OFFSET_TAB[Channel - 1U])))->CCR, DMA_CCR_EN);
        0x08001a34:    4945        EI      LDR      r1,[pc,#276] ; [0x8001b4c] = 0x8001f47
        0x08001a36:    1dca        ..      ADDS     r2,r1,#7
        0x08001a38:    7989        .y      LDRB     r1,[r1,#6]
        0x08001a3a:    5859        YX      LDR      r1,[r3,r1]
        0x08001a3c:    f8122c01    ...,    LDRB     r2,[r2,#-1]
        0x08001a40:    f0410101    A...    ORR      r1,r1,#1
        0x08001a44:    5099        .P      STR      r1,[r3,r2]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_usart.h
;;;2102     SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
        0x08001a46:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08001a48:    f0410120    A. .    ORR      r1,r1,#0x20
        0x08001a4c:    60c1        .`      STR      r1,[r0,#0xc]
;;;2103   }
;;;2104   
;;;2105   /**
;;;2106     * @brief  Enable Transmission Complete Interrupt
;;;2107     * @rmtoll CR1          TCIE          LL_USART_EnableIT_TC
;;;2108     * @param  USARTx USART Instance
;;;2109     * @retval None
;;;2110     */
;;;2111   __STATIC_INLINE void LL_USART_EnableIT_TC(USART_TypeDef *USARTx)
;;;2112   {
;;;2113     SET_BIT(USARTx->CR1, USART_CR1_TCIE);
;;;2114   }
;;;2115   
;;;2116   /**
;;;2117     * @brief  Enable TX Empty Interrupt
;;;2118     * @rmtoll CR1          TXEIE         LL_USART_EnableIT_TXE
;;;2119     * @param  USARTx USART Instance
;;;2120     * @retval None
;;;2121     */
;;;2122   __STATIC_INLINE void LL_USART_EnableIT_TXE(USART_TypeDef *USARTx)
;;;2123   {
;;;2124     SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
;;;2125   }
;;;2126   
;;;2127   /**
;;;2128     * @brief  Enable Parity Error Interrupt
;;;2129     * @rmtoll CR1          PEIE          LL_USART_EnableIT_PE
;;;2130     * @param  USARTx USART Instance
;;;2131     * @retval None
;;;2132     */
;;;2133   __STATIC_INLINE void LL_USART_EnableIT_PE(USART_TypeDef *USARTx)
;;;2134   {
;;;2135     SET_BIT(USARTx->CR1, USART_CR1_PEIE);
;;;2136   }
;;;2137   
;;;2138   /**
;;;2139     * @brief  Enable LIN Break Detection Interrupt
;;;2140     * @note   Macro @ref IS_UART_LIN_INSTANCE(USARTx) can be used to check whether or not
;;;2141     *         LIN feature is supported by the USARTx instance.
;;;2142     * @rmtoll CR2          LBDIE         LL_USART_EnableIT_LBD
;;;2143     * @param  USARTx USART Instance
;;;2144     * @retval None
;;;2145     */
;;;2146   __STATIC_INLINE void LL_USART_EnableIT_LBD(USART_TypeDef *USARTx)
;;;2147   {
;;;2148     SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
;;;2149   }
;;;2150   
;;;2151   /**
;;;2152     * @brief  Enable Error Interrupt
;;;2153     * @note   When set, Error Interrupt Enable Bit is enabling interrupt generation in case of a framing
;;;2154     *         error, overrun error or noise flag (FE=1 or ORE=1 or NF=1 in the USARTx_SR register).
;;;2155     *           0: Interrupt is inhibited
;;;2156     *           1: An interrupt is generated when FE=1 or ORE=1 or NF=1 in the USARTx_SR register.
;;;2157     * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
;;;2158     * @param  USARTx USART Instance
;;;2159     * @retval None
;;;2160     */
;;;2161   __STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
;;;2162   {
;;;2163     SET_BIT(USARTx->CR3, USART_CR3_EIE);
        0x08001a4e:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08001a50:    f0410101    A...    ORR      r1,r1,#1
        0x08001a54:    6141        Aa      STR      r1,[r0,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08001a56:    0500        ..      LSLS     r0,r0,#20
        0x08001a58:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08001a5a:    f0410101    A...    ORR      r1,r1,#1
        0x08001a5e:    6141        Aa      STR      r1,[r0,#0x14]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (2932)
        0x08001a60:    f06f0101    o...    MVN      r1,#1
        0x08001a64:    6101        .a      STR      r1,[r0,#0x10]
;;;2933   }
;;;2934   
;;;2935   /**
;;;2936     * @brief  Indicate whether update interrupt flag (UIF) is set (update interrupt is pending).
;;;2937     * @rmtoll SR           UIF           LL_TIM_IsActiveFlag_UPDATE
;;;2938     * @param  TIMx Timer instance
;;;2939     * @retval State of bit (1 or 0).
;;;2940     */
;;;2941   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *TIMx)
;;;2942   {
;;;2943     return (READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF));
;;;2944   }
;;;2945   
;;;2946   /**
;;;2947     * @brief  Clear the Capture/Compare 1 interrupt flag (CC1F).
;;;2948     * @rmtoll SR           CC1IF         LL_TIM_ClearFlag_CC1
;;;2949     * @param  TIMx Timer instance
;;;2950     * @retval None
;;;2951     */
;;;2952   __STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
;;;2953   {
;;;2954     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
;;;2955   }
;;;2956   
;;;2957   /**
;;;2958     * @brief  Indicate whether Capture/Compare 1 interrupt flag (CC1F) is set (Capture/Compare 1 interrupt is pending).
;;;2959     * @rmtoll SR           CC1IF         LL_TIM_IsActiveFlag_CC1
;;;2960     * @param  TIMx Timer instance
;;;2961     * @retval State of bit (1 or 0).
;;;2962     */
;;;2963   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1(TIM_TypeDef *TIMx)
;;;2964   {
;;;2965     return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
;;;2966   }
;;;2967   
;;;2968   /**
;;;2969     * @brief  Clear the Capture/Compare 2 interrupt flag (CC2F).
;;;2970     * @rmtoll SR           CC2IF         LL_TIM_ClearFlag_CC2
;;;2971     * @param  TIMx Timer instance
;;;2972     * @retval None
;;;2973     */
;;;2974   __STATIC_INLINE void LL_TIM_ClearFlag_CC2(TIM_TypeDef *TIMx)
;;;2975   {
;;;2976     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
;;;2977   }
;;;2978   
;;;2979   /**
;;;2980     * @brief  Indicate whether Capture/Compare 2 interrupt flag (CC2F) is set (Capture/Compare 2 interrupt is pending).
;;;2981     * @rmtoll SR           CC2IF         LL_TIM_IsActiveFlag_CC2
;;;2982     * @param  TIMx Timer instance
;;;2983     * @retval State of bit (1 or 0).
;;;2984     */
;;;2985   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2(TIM_TypeDef *TIMx)
;;;2986   {
;;;2987     return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
;;;2988   }
;;;2989   
;;;2990   /**
;;;2991     * @brief  Clear the Capture/Compare 3 interrupt flag (CC3F).
;;;2992     * @rmtoll SR           CC3IF         LL_TIM_ClearFlag_CC3
;;;2993     * @param  TIMx Timer instance
;;;2994     * @retval None
;;;2995     */
;;;2996   __STATIC_INLINE void LL_TIM_ClearFlag_CC3(TIM_TypeDef *TIMx)
;;;2997   {
;;;2998     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
;;;2999   }
;;;3000   
;;;3001   /**
;;;3002     * @brief  Indicate whether Capture/Compare 3 interrupt flag (CC3F) is set (Capture/Compare 3 interrupt is pending).
;;;3003     * @rmtoll SR           CC3IF         LL_TIM_IsActiveFlag_CC3
;;;3004     * @param  TIMx Timer instance
;;;3005     * @retval State of bit (1 or 0).
;;;3006     */
;;;3007   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3(TIM_TypeDef *TIMx)
;;;3008   {
;;;3009     return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
;;;3010   }
;;;3011   
;;;3012   /**
;;;3013     * @brief  Clear the Capture/Compare 4 interrupt flag (CC4F).
;;;3014     * @rmtoll SR           CC4IF         LL_TIM_ClearFlag_CC4
;;;3015     * @param  TIMx Timer instance
;;;3016     * @retval None
;;;3017     */
;;;3018   __STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
;;;3019   {
;;;3020     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
;;;3021   }
;;;3022   
;;;3023   /**
;;;3024     * @brief  Indicate whether Capture/Compare 4 interrupt flag (CC4F) is set (Capture/Compare 4 interrupt is pending).
;;;3025     * @rmtoll SR           CC4IF         LL_TIM_IsActiveFlag_CC4
;;;3026     * @param  TIMx Timer instance
;;;3027     * @retval State of bit (1 or 0).
;;;3028     */
;;;3029   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
;;;3030   {
;;;3031     return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
;;;3032   }
;;;3033   
;;;3034   /**
;;;3035     * @brief  Clear the commutation interrupt flag (COMIF).
;;;3036     * @rmtoll SR           COMIF         LL_TIM_ClearFlag_COM
;;;3037     * @param  TIMx Timer instance
;;;3038     * @retval None
;;;3039     */
;;;3040   __STATIC_INLINE void LL_TIM_ClearFlag_COM(TIM_TypeDef *TIMx)
;;;3041   {
;;;3042     WRITE_REG(TIMx->SR, ~(TIM_SR_COMIF));
;;;3043   }
;;;3044   
;;;3045   /**
;;;3046     * @brief  Indicate whether commutation interrupt flag (COMIF) is set (commutation interrupt is pending).
;;;3047     * @rmtoll SR           COMIF         LL_TIM_IsActiveFlag_COM
;;;3048     * @param  TIMx Timer instance
;;;3049     * @retval State of bit (1 or 0).
;;;3050     */
;;;3051   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_COM(TIM_TypeDef *TIMx)
;;;3052   {
;;;3053     return (READ_BIT(TIMx->SR, TIM_SR_COMIF) == (TIM_SR_COMIF));
;;;3054   }
;;;3055   
;;;3056   /**
;;;3057     * @brief  Clear the trigger interrupt flag (TIF).
;;;3058     * @rmtoll SR           TIF           LL_TIM_ClearFlag_TRIG
;;;3059     * @param  TIMx Timer instance
;;;3060     * @retval None
;;;3061     */
;;;3062   __STATIC_INLINE void LL_TIM_ClearFlag_TRIG(TIM_TypeDef *TIMx)
;;;3063   {
;;;3064     WRITE_REG(TIMx->SR, ~(TIM_SR_TIF));
;;;3065   }
;;;3066   
;;;3067   /**
;;;3068     * @brief  Indicate whether trigger interrupt flag (TIF) is set (trigger interrupt is pending).
;;;3069     * @rmtoll SR           TIF           LL_TIM_IsActiveFlag_TRIG
;;;3070     * @param  TIMx Timer instance
;;;3071     * @retval State of bit (1 or 0).
;;;3072     */
;;;3073   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_TRIG(TIM_TypeDef *TIMx)
;;;3074   {
;;;3075     return (READ_BIT(TIMx->SR, TIM_SR_TIF) == (TIM_SR_TIF));
;;;3076   }
;;;3077   
;;;3078   /**
;;;3079     * @brief  Clear the break interrupt flag (BIF).
;;;3080     * @rmtoll SR           BIF           LL_TIM_ClearFlag_BRK
;;;3081     * @param  TIMx Timer instance
;;;3082     * @retval None
;;;3083     */
;;;3084   __STATIC_INLINE void LL_TIM_ClearFlag_BRK(TIM_TypeDef *TIMx)
;;;3085   {
;;;3086     WRITE_REG(TIMx->SR, ~(TIM_SR_BIF));
;;;3087   }
;;;3088   
;;;3089   /**
;;;3090     * @brief  Indicate whether break interrupt flag (BIF) is set (break interrupt is pending).
;;;3091     * @rmtoll SR           BIF           LL_TIM_IsActiveFlag_BRK
;;;3092     * @param  TIMx Timer instance
;;;3093     * @retval State of bit (1 or 0).
;;;3094     */
;;;3095   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_BRK(TIM_TypeDef *TIMx)
;;;3096   {
;;;3097     return (READ_BIT(TIMx->SR, TIM_SR_BIF) == (TIM_SR_BIF));
;;;3098   }
;;;3099   
;;;3100   /**
;;;3101     * @brief  Clear the Capture/Compare 1 over-capture interrupt flag (CC1OF).
;;;3102     * @rmtoll SR           CC1OF         LL_TIM_ClearFlag_CC1OVR
;;;3103     * @param  TIMx Timer instance
;;;3104     * @retval None
;;;3105     */
;;;3106   __STATIC_INLINE void LL_TIM_ClearFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3107   {
;;;3108     WRITE_REG(TIMx->SR, ~(TIM_SR_CC1OF));
;;;3109   }
;;;3110   
;;;3111   /**
;;;3112     * @brief  Indicate whether Capture/Compare 1 over-capture interrupt flag (CC1OF) is set (Capture/Compare 1 interrupt is pending).
;;;3113     * @rmtoll SR           CC1OF         LL_TIM_IsActiveFlag_CC1OVR
;;;3114     * @param  TIMx Timer instance
;;;3115     * @retval State of bit (1 or 0).
;;;3116     */
;;;3117   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC1OVR(TIM_TypeDef *TIMx)
;;;3118   {
;;;3119     return (READ_BIT(TIMx->SR, TIM_SR_CC1OF) == (TIM_SR_CC1OF));
;;;3120   }
;;;3121   
;;;3122   /**
;;;3123     * @brief  Clear the Capture/Compare 2 over-capture interrupt flag (CC2OF).
;;;3124     * @rmtoll SR           CC2OF         LL_TIM_ClearFlag_CC2OVR
;;;3125     * @param  TIMx Timer instance
;;;3126     * @retval None
;;;3127     */
;;;3128   __STATIC_INLINE void LL_TIM_ClearFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3129   {
;;;3130     WRITE_REG(TIMx->SR, ~(TIM_SR_CC2OF));
;;;3131   }
;;;3132   
;;;3133   /**
;;;3134     * @brief  Indicate whether Capture/Compare 2 over-capture interrupt flag (CC2OF) is set (Capture/Compare 2 over-capture interrupt is pending).
;;;3135     * @rmtoll SR           CC2OF         LL_TIM_IsActiveFlag_CC2OVR
;;;3136     * @param  TIMx Timer instance
;;;3137     * @retval State of bit (1 or 0).
;;;3138     */
;;;3139   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC2OVR(TIM_TypeDef *TIMx)
;;;3140   {
;;;3141     return (READ_BIT(TIMx->SR, TIM_SR_CC2OF) == (TIM_SR_CC2OF));
;;;3142   }
;;;3143   
;;;3144   /**
;;;3145     * @brief  Clear the Capture/Compare 3 over-capture interrupt flag (CC3OF).
;;;3146     * @rmtoll SR           CC3OF         LL_TIM_ClearFlag_CC3OVR
;;;3147     * @param  TIMx Timer instance
;;;3148     * @retval None
;;;3149     */
;;;3150   __STATIC_INLINE void LL_TIM_ClearFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3151   {
;;;3152     WRITE_REG(TIMx->SR, ~(TIM_SR_CC3OF));
;;;3153   }
;;;3154   
;;;3155   /**
;;;3156     * @brief  Indicate whether Capture/Compare 3 over-capture interrupt flag (CC3OF) is set (Capture/Compare 3 over-capture interrupt is pending).
;;;3157     * @rmtoll SR           CC3OF         LL_TIM_IsActiveFlag_CC3OVR
;;;3158     * @param  TIMx Timer instance
;;;3159     * @retval State of bit (1 or 0).
;;;3160     */
;;;3161   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC3OVR(TIM_TypeDef *TIMx)
;;;3162   {
;;;3163     return (READ_BIT(TIMx->SR, TIM_SR_CC3OF) == (TIM_SR_CC3OF));
;;;3164   }
;;;3165   
;;;3166   /**
;;;3167     * @brief  Clear the Capture/Compare 4 over-capture interrupt flag (CC4OF).
;;;3168     * @rmtoll SR           CC4OF         LL_TIM_ClearFlag_CC4OVR
;;;3169     * @param  TIMx Timer instance
;;;3170     * @retval None
;;;3171     */
;;;3172   __STATIC_INLINE void LL_TIM_ClearFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3173   {
;;;3174     WRITE_REG(TIMx->SR, ~(TIM_SR_CC4OF));
;;;3175   }
;;;3176   
;;;3177   /**
;;;3178     * @brief  Indicate whether Capture/Compare 4 over-capture interrupt flag (CC4OF) is set (Capture/Compare 4 over-capture interrupt is pending).
;;;3179     * @rmtoll SR           CC4OF         LL_TIM_IsActiveFlag_CC4OVR
;;;3180     * @param  TIMx Timer instance
;;;3181     * @retval State of bit (1 or 0).
;;;3182     */
;;;3183   __STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4OVR(TIM_TypeDef *TIMx)
;;;3184   {
;;;3185     return (READ_BIT(TIMx->SR, TIM_SR_CC4OF) == (TIM_SR_CC4OF));
;;;3186   }
;;;3187   
;;;3188   /**
;;;3189     * @}
;;;3190     */
;;;3191   
;;;3192   /** @defgroup TIM_LL_EF_IT_Management IT-Management
;;;3193     * @{
;;;3194     */
;;;3195   /**
;;;3196     * @brief  Enable update interrupt (UIE).
;;;3197     * @rmtoll DIER         UIE           LL_TIM_EnableIT_UPDATE
;;;3198     * @param  TIMx Timer instance
;;;3199     * @retval None
;;;3200     */
;;;3201   __STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
;;;3202   {
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
        0x08001a66:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08001a68:    f0410101    A...    ORR      r1,r1,#1
        0x08001a6c:    60c1        .`      STR      r1,[r0,#0xc]
;;; .\../Src/main.c
;;;670    	TIM3->ARR = 0;
        0x08001a6e:    4838        8H      LDR      r0,[pc,#224] ; [0x8001b50] = 0x4000042c
        0x08001a70:    2500        .%      MOVS     r5,#0
        0x08001a72:    6005        .`      STR      r5,[r0,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3712     SET_BIT(TIMx->EGR, TIM_EGR_UG);
        0x08001a74:    4836        6H      LDR      r0,[pc,#216] ; [0x8001b50] = 0x4000042c
        0x08001a76:    382c        ,8      SUBS     r0,r0,#0x2c
        0x08001a78:    6941        Ai      LDR      r1,[r0,#0x14]
        0x08001a7a:    f0410101    A...    ORR      r1,r1,#1
        0x08001a7e:    6141        Aa      STR      r1,[r0,#0x14]
;;; .\../Src/main.c
;;;672    	LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1 | LL_TIM_CHANNEL_CH3);
        0x08001a80:    f2401201    @...    MOV      r2,#0x101
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;1493     SET_BIT(TIMx->CCER, Channels);
        0x08001a84:    6a01        .j      LDR      r1,[r0,#0x20]
        0x08001a86:    4311        .C      ORRS     r1,r1,r2
        0x08001a88:    6201        .b      STR      r1,[r0,#0x20]
;;; .\../Src/main.c
;;;673    	TIM3->SR = 0;
        0x08001a8a:    4931        1I      LDR      r1,[pc,#196] ; [0x8001b50] = 0x4000042c
        0x08001a8c:    391c        .9      SUBS     r1,r1,#0x1c
        0x08001a8e:    600d        .`      STR      r5,[r1,#0]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3203     SET_BIT(TIMx->DIER, TIM_DIER_UIE);
        0x08001a90:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08001a92:    f0410101    A...    ORR      r1,r1,#1
        0x08001a96:    60c1        .`      STR      r1,[r0,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08001a98:    492e        .I      LDR      r1,[pc,#184] ; [0x8001b54] = 0x40010800
        0x08001a9a:    1580        ..      ASRS     r0,r0,#22
        0x08001a9c:    6889        .h      LDR      r1,[r1,#8]
        0x08001a9e:    4388        .C      BICS     r0,r0,r1
        0x08001aa0:    0400        ..      LSLS     r0,r0,#16
        0x08001aa2:    0c00        ..      LSRS     r0,r0,#16
        0x08001aa4:    d03a        :.      BEQ      0x8001b1c ; main + 420
        0x08001aa6:    2000        .       MOVS     r0,#0
        0x08001aa8:    f04f0801    O...    MOV      r8,#1
;;; .\../Src/main.c
;;;680    	if(LL_GPIO_IsInputPinSet(BUTTON_1_GPIO_Port, BUTTON_1_Pin)){
        0x08001aac:    b110        ..      CBZ      r0,0x8001ab4 ; main + 316
;;;681    		demo = true;
        0x08001aae:    482a        *H      LDR      r0,[pc,#168] ; [0x8001b58] = 0x2000000b
        0x08001ab0:    f8808000    ....    STRB     r8,[r0,#0]
;;;682    	}
;;;683    //	MOTOR_Z_Disable();
;;;684    //	MOTOR_X_Disable();
;;;685    //  
;;;686    #ifndef _SIMU
;;;687    	Activate_I2C_Master();
;;;688    	init_screen(I2C2);
;;;689    //	update_screen();
;;;690    //	i2c_device_init(I2C2);
;;;691    	LL_mDelay(250);
;;;692    #endif
;;;693    	init_buttons();
        0x08001ab4:    f7ffff4c    ..L.    BL       init_buttons ; 0x8001950
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h
;;;3302     SET_BIT(TIMx->DIER, TIM_DIER_CC3IE);
        0x08001ab8:    4828        (H      LDR      r0,[pc,#160] ; [0x8001b5c] = 0x40000800
        0x08001aba:    68c1        .h      LDR      r1,[r0,#0xc]
        0x08001abc:    f0410108    A...    ORR      r1,r1,#8
        0x08001ac0:    60c1        .`      STR      r1,[r0,#0xc]
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h (1027)
        0x08001ac2:    6801        .h      LDR      r1,[r0,#0]
        0x08001ac4:    f0410101    A...    ORR      r1,r1,#1
        0x08001ac8:    6001        .`      STR      r1,[r0,#0]
;;; .\../Src/main.c
;;;756    	TIM4->SR = 0; 																			// reset interrup flags
        0x08001aca:    4824        $H      LDR      r0,[pc,#144] ; [0x8001b5c] = 0x40000800
        0x08001acc:    3010        .0      ADDS     r0,r0,#0x10
        0x08001ace:    6005        .`      STR      r5,[r0,#0]
;;;757    
;;;758    //	LL_TIM_EnableIT_UPDATE(TIM1);
;;;759    //	LL_TIM_EnableIT_UPDATE(TIM2);
;;;760    //	LL_TIM_EnableCounter(TIM2);
;;;761    	
;;;762    //	do_fsm_move_start(&state);
;;;763    
;;;764    	
;;;765      /* Enable counter */
;;;766    //  LL_TIM_EnableCounter(TIM2);
;;;767      /* Force update generation */
;;;768    //  LL_TIM_GenerateEvent_UPDATE(TIM2);
;;;769    
;;;770    // init buttons
;;;771    //	LL_mDelay(5);
;;;772    	do_fsm_menu(&state);
        0x08001ad0:    4813        .H      LDR      r0,[pc,#76] ; [0x8001b20] = 0x20000038
        0x08001ad2:    3028        (0      ADDS     r0,r0,#0x28
        0x08001ad4:    f7fffd5a    ..Z.    BL       do_fsm_menu ; 0x800158c
;;;773    //	LL_mDelay(5);
;;;774    //	LL_GPIO_TogglePin(MOTOR_Z_ENABLE_GPIO_Port, MOTOR_Z_ENABLE_Pin);
;;;775    	LED_GPIO_Port->BSRR = LED_Pin; // led off
        0x08001ad8:    4922        "I      LDR      r1,[pc,#136] ; [0x8001b64] = 0x40011000
        0x08001ada:    4821        !H      LDR      r0,[pc,#132] ; [0x8001b60] = 0x4200020
        0x08001adc:    6108        .a      STR      r0,[r1,#0x10]
        0x08001ade:    4f22        "O      LDR      r7,[pc,#136] ; [0x8001b68] = 0x200005dc
        0x08001ae0:    4e22        "N      LDR      r6,[pc,#136] ; [0x8001b6c] = 0x20000508
;;;776    	while (1) {
;;;777        /* USER CODE END WHILE */
;;;778    
;;;779        /* USER CODE BEGIN 3 */
;;;780    #ifndef _SIMU		
;;;781    //		reqest_sample_i2c_dma(); // init reqest to joystick by DMA, when process_button complete i2c done its job
;;;782    #endif		
;;;783    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;784    		process_button();
        0x08001ae2:    f000f845    ..E.    BL       process_button ; 0x8001b70
;;;785    //		process_joystick();
;;;786    //		read_sample_i2c(&i2c_device_logging.sample[i2c_device_logging.index]);
;;;787    
;;;788    
;;;789    //		uint8_t level = Thread_Info[Menu_Step].level;
;;;790    
;;;791    //		if(auto_mode == true) {
;;;792    //			if ( auto_mode_delay == 0 ) {
;;;793    //				buttons_flag_set = single_click_Msk; //
;;;794    //			}
;;;795    //		}
;;;796    
;;;797    		if(buttons_flag_set) {
        0x08001ae6:    6838        8h      LDR      r0,[r7,#0]
        0x08001ae8:    b120         .      CBZ      r0,0x8001af4 ; main + 380
;;;798    			do_fsm_menu(&state);
        0x08001aea:    480d        .H      LDR      r0,[pc,#52] ; [0x8001b20] = 0x20000038
        0x08001aec:    3028        (0      ADDS     r0,r0,#0x28
        0x08001aee:    f7fffd4d    ..M.    BL       do_fsm_menu ; 0x800158c
;;;799    			buttons_flag_set = 0; // reset button flags
        0x08001af2:    603d        =`      STR      r5,[r7,#0]
;;;800    		}
;;;801    
;;;802    		if(z_axis.ramp_step != rs) {
        0x08001af4:    f8960028    ..(.    LDRB     r0,[r6,#0x28]
        0x08001af8:    68a1        .h      LDR      r1,[r4,#8]
        0x08001afa:    4288        .B      CMP      r0,r1
        0x08001afc:    d002        ..      BEQ      0x8001b04 ; main + 396
;;;803    			rs = z_axis.ramp_step;
        0x08001afe:    60a0        .`      STR      r0,[r4,#8]
;;;804    			menu_changed = 1;
        0x08001b00:    f8c48004    ....    STR      r8,[r4,#4]
;;;805    		}
;;;806    
;;;807    		if(z_axis.current_pos != rs) {
        0x08001b04:    6830        0h      LDR      r0,[r6,#0]
        0x08001b06:    68a1        .h      LDR      r1,[r4,#8]
        0x08001b08:    4288        .B      CMP      r0,r1
        0x08001b0a:    d000        ..      BEQ      0x8001b0e ; main + 406
;;;808    			rs = z_axis.current_pos;
        0x08001b0c:    60a0        .`      STR      r0,[r4,#8]
;;;809    //			menu_changed = 1;
;;;810    		}
;;;811    
;;;812    // update display info
;;;813    		if(menu_changed == 1){ // haltodo && hi2c2.hdmatx->State == HAL_DMA_STATE_READY) {
        0x08001b0e:    6860        `h      LDR      r0,[r4,#4]
        0x08001b10:    2801        .(      CMP      r0,#1
        0x08001b12:    d1e6        ..      BNE      0x8001ae2 ; main + 362
;;;814    			menu_changed = update_screen();
        0x08001b14:    f000f966    ..f.    BL       update_screen ; 0x8001de4
        0x08001b18:    6060        ``      STR      r0,[r4,#4]
        0x08001b1a:    e7e2        ..      B        0x8001ae2 ; main + 362
;;; ../Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_gpio.h
;;;741      return (READ_BIT(GPIOx->IDR, (PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU) == ((PinMask >> GPIO_PIN_MASK_POS) & 0x0000FFFFU));
        0x08001b1c:    2001        .       MOVS     r0,#1
        0x08001b1e:    e7c3        ..      B        0x8001aa8 ; main + 304
    $d
        0x08001b20:    20000038    8..     DCD    536870968
        0x08001b24:    30303032    2000    DCD    808464434
        0x08001b28:    3939392e    .999    DCD    960051502
        0x08001b2c:    00000000    ....    DCD    0
        0x08001b30:    39392e31    1.99    DCD    960048689
        0x08001b34:    00003939    99..    DCD    14649
        0x08001b38:    e000ed0c    ....    DCD    3758157068
        0x08001b3c:    05fa0000    ....    DCD    100270080
        0x08001b40:    40010000    ...@    DCD    1073807360
        0x08001b44:    40004400    .D.@    DCD    1073759232
        0x08001b48:    40020000    ...@    DCD    1073872896
        0x08001b4c:    08001f47    G...    DCD    134225735
        0x08001b50:    4000042c    ,..@    DCD    1073742892
        0x08001b54:    40010800    ...@    DCD    1073809408
        0x08001b58:    2000000b    ...     DCD    536870923
        0x08001b5c:    40000800    ...@    DCD    1073743872
        0x08001b60:    04200020     . .    DCD    69206048
        0x08001b64:    40011000    ...@    DCD    1073811456
        0x08001b68:    200005dc    ...     DCD    536872412
        0x08001b6c:    20000508    ...     DCD    536872200
    $t
    i.process_button
    process_button
;;; .\..\Src\buttons.c
;;;57     {
        0x08001b70:    e92d5ff0    -.._    PUSH     {r4-r12,lr}
;;;58     	for(int a =0; a<BT_TOTAL;a++){
        0x08001b74:    2500        .%      MOVS     r5,#0
        0x08001b76:    4f4f        OO      LDR      r7,[pc,#316] ; [0x8001cb4] = 0x2200b000
        0x08001b78:    f04f0832    O.2.    MOV      r8,#0x32
        0x08001b7c:    f44f7bfa    O..{    MOV      r11,#0x1f4
        0x08001b80:    46a9        .F      MOV      r9,r5
        0x08001b82:    2601        .&      MOVS     r6,#1
        0x08001b84:    f04f0a0a    O...    MOV      r10,#0xa
;;;59     	/*
;;;60     	click Nondeterministic finite automaton(NFA):
;;;61     	10.    
;;;62     	20.  ,  .   > 1000   ,   30
;;;63     	30.  long_press_start,   40
;;;64     	40.   ,   50
;;;65     	50.  ,    200   70,   60
;;;66     	60.   < 1000   CLICK,      long_press_end,   10
;;;67     	70.   200,    -,   100,     60,     80
;;;68     	80.   ,   90
;;;69     	90.  ,  DOUBLE_CLICK,   10
;;;70     	*/
;;;71      
;;;72     //	#if defined ( _SIMU )
;;;73     //		uint32_t tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin;
;;;74     //	#else
;;;75     		uint32_t tmp_buttons;
;;;76     		if(bt[a].GPIOx != 0)
        0x08001b88:    484b        KH      LDR      r0,[pc,#300] ; [0x8001cb8] = 0x200004e4
        0x08001b8a:    eb001445    ..E.    ADD      r4,r0,r5,LSL #5
        0x08001b8e:    6820         h      LDR      r0,[r4,#0]
        0x08001b90:    b118        ..      CBZ      r0,0x8001b9a ; process_button + 42
;;;77     			tmp_buttons = LL_GPIO_IsInputPinSet(bt[a].GPIOx,bt[a].button_pin);
        0x08001b92:    6861        ah      LDR      r1,[r4,#4]
        0x08001b94:    f7fefcc4    ....    BL       LL_GPIO_IsInputPinSet ; 0x8000520
        0x08001b98:    e003        ..      B        0x8001ba2 ; process_button + 50
;;;78     //			tmp_buttons = bt[a].GPIOx->IDR & bt[a].button_pin; //BUTTON_1_GPIO_Port->IDR & bt[a].button_pin;
;;;79     		else{
;;;80     			
;;;81     //			if(ubTransferComplete == 0)
;;;82     //				continue;
;;;83     			//	dma_delay = 0;
;;;84     //	while(hi2c2->hdmarx->State != HAL_DMA_STATE_READY){
;;;85     //		dma_delay++;
;;;86     //		HAL_Delay(1);
;;;87     //	}
;;;88     //	dma_delay2 = dma_delay;
;;;89     
;;;90     			tmp_buttons = dma_data[5] & bt[a].button_pin;
        0x08001b9a:    4848        HH      LDR      r0,[pc,#288] ; [0x8001cbc] = 0x20000005
        0x08001b9c:    6861        ah      LDR      r1,[r4,#4]
        0x08001b9e:    7940        @y      LDRB     r0,[r0,#5]
        0x08001ba0:    4008        .@      ANDS     r0,r0,r1
;;;91     		}
;;;92     //	#endif
;;;93     
;;;94     //		if(z_axis.current_pos < 20)
;;;95     //			tmp_buttons = 0;
;;;96     		
;;;97     		if( tmp_buttons != bt[a].buttons ) { // start debounce
        0x08001ba2:    68e1        .h      LDR      r1,[r4,#0xc]
        0x08001ba4:    4281        .B      CMP      r1,r0
        0x08001ba6:    d006        ..      BEQ      0x8001bb6 ; process_button + 70
;;;98     			bt[a].buttons = tmp_buttons;
        0x08001ba8:    4943        CI      LDR      r1,[pc,#268] ; [0x8001cb8] = 0x200004e4
        0x08001baa:    eb011145    ..E.    ADD      r1,r1,r5,LSL #5
        0x08001bae:    60c8        .`      STR      r0,[r1,#0xc]
;;;99     			// reset debounce counter and start count every one ms
;;;100    			bt[a].buttons_mstick = 1;
        0x08001bb0:    6126        &a      STR      r6,[r4,#0x10]
        0x08001bb2:    e8bd9ff0    ....    POP      {r4-r12,pc}
;;;101    			return;
;;;102    		}
;;;103    
;;;104    		if( bt[a].buttons_mstick > DEBOUNCE_MS ) {
        0x08001bb6:    6922        "i      LDR      r2,[r4,#0x10]
        0x08001bb8:    2a14        .*      CMP      r2,#0x14
        0x08001bba:    d976        v.      BLS      0x8001caa ; process_button + 314
;;;105    			switch(bt[a].clk_mode) {
        0x08001bbc:    69e1        .i      LDR      r1,[r4,#0x1c]
        0x08001bbe:    2932        2)      CMP      r1,#0x32
        0x08001bc0:    d034        4.      BEQ      0x8001c2c ; process_button + 188
        0x08001bc2:    dc08        ..      BGT      0x8001bd6 ; process_button + 102
        0x08001bc4:    290a        .)      CMP      r1,#0xa
        0x08001bc6:    d00f        ..      BEQ      0x8001be8 ; process_button + 120
        0x08001bc8:    2914        .)      CMP      r1,#0x14
        0x08001bca:    d013        ..      BEQ      0x8001bf4 ; process_button + 132
        0x08001bcc:    291e        .)      CMP      r1,#0x1e
        0x08001bce:    d01e        ..      BEQ      0x8001c0e ; process_button + 158
        0x08001bd0:    2928        ()      CMP      r1,#0x28
        0x08001bd2:    d16a        j.      BNE      0x8001caa ; process_button + 314
        0x08001bd4:    e022        ".      B        0x8001c1c ; process_button + 172
        0x08001bd6:    293c        <)      CMP      r1,#0x3c
        0x08001bd8:    d030        0.      BEQ      0x8001c3c ; process_button + 204
        0x08001bda:    2946        F)      CMP      r1,#0x46
        0x08001bdc:    d046        F.      BEQ      0x8001c6c ; process_button + 252
        0x08001bde:    2950        P)      CMP      r1,#0x50
        0x08001be0:    d050        P.      BEQ      0x8001c84 ; process_button + 276
        0x08001be2:    295a        Z)      CMP      r1,#0x5a
        0x08001be4:    d161        a.      BNE      0x8001caa ; process_button + 314
        0x08001be6:    e055        U.      B        0x8001c94 ; process_button + 292
;;;106    			case 10: {
;;;107    				if ( tmp_buttons & bt[a].button_pin ) {   // released
        0x08001be8:    6861        ah      LDR      r1,[r4,#4]
        0x08001bea:    4201        .B      TST      r1,r0
        0x08001bec:    d15d        ].      BNE      0x8001caa ; process_button + 314
;;;108    				} else { // pressed
;;;109    //					buttons_mstick = 1;
;;;110    					bt[a].clk_mode = 20;
        0x08001bee:    2014        .       MOVS     r0,#0x14
        0x08001bf0:    61e0        .a      STR      r0,[r4,#0x1c]
        0x08001bf2:    e05a        Z.      B        0x8001caa ; process_button + 314
;;;111    				}
;;;112    				break;
;;;113    			}
;;;114    			case 20: {
;;;115    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x08001bf4:    6861        ah      LDR      r1,[r4,#4]
        0x08001bf6:    4201        .B      TST      r1,r0
        0x08001bf8:    d002        ..      BEQ      0x8001c00 ; process_button + 144
;;;116    					bt[a].clk_mode = 50;
        0x08001bfa:    f8c4801c    ....    STR      r8,[r4,#0x1c]
        0x08001bfe:    e000        ..      B        0x8001c02 ; process_button + 146
;;;117    				} else {
;;;118    					bt[a].downTime = bt[a].buttons_mstick;
        0x08001c00:    60a2        .`      STR      r2,[r4,#8]
;;;119    				}
;;;120    				if (bt[a].downTime > HOLDTIME_MS ) { // long press detected
        0x08001c02:    68a0        .h      LDR      r0,[r4,#8]
        0x08001c04:    4558        XE      CMP      r0,r11
        0x08001c06:    d950        P.      BLS      0x8001caa ; process_button + 314
;;;121    					bt[a].clk_mode = 30;
        0x08001c08:    201e        .       MOVS     r0,#0x1e
        0x08001c0a:    61e0        .a      STR      r0,[r4,#0x1c]
        0x08001c0c:    e04d        M.      B        0x8001caa ; process_button + 314
;;;122    				}
;;;123    				break;
;;;124    			}
;;;125    			case 30: { // long_press_start event
;;;126    				buttons_flag_setbb[(a<<2)+long_press_start_Pos]  = 1; //long_press_start = 1;
        0x08001c0e:    eb071005    ....    ADD      r0,r7,r5,LSL #4
        0x08001c12:    f8c06b80    ...k    STR      r6,[r0,#0xb80]
;;;127    				bt[a].clk_mode = 40;
        0x08001c16:    2028        (       MOVS     r0,#0x28
        0x08001c18:    61e0        .a      STR      r0,[r4,#0x1c]
;;;128    				break;
        0x08001c1a:    e046        F.      B        0x8001caa ; process_button + 314
;;;129    			}
;;;130    			case 40: {
;;;131    				if ( tmp_buttons & bt[a].button_pin ) { //released
        0x08001c1c:    6861        ah      LDR      r1,[r4,#4]
        0x08001c1e:    4201        .B      TST      r1,r0
        0x08001c20:    d002        ..      BEQ      0x8001c28 ; process_button + 184
;;;132    					bt[a].clk_mode = 50;
        0x08001c22:    f8c4801c    ....    STR      r8,[r4,#0x1c]
        0x08001c26:    e040        @.      B        0x8001caa ; process_button + 314
;;;133    				} else {
;;;134    					bt[a].downTime = bt[a].buttons_mstick;
        0x08001c28:    60a2        .`      STR      r2,[r4,#8]
        0x08001c2a:    e03e        >.      B        0x8001caa ; process_button + 314
;;;135    				}
;;;136    				break;
;;;137    			}
;;;138    			case 50: {
;;;139    				bt[a].clk_mode = bt[a].downTime < CLICKTIME_MS ? 70 : 60;
        0x08001c2c:    68a0        .h      LDR      r0,[r4,#8]
        0x08001c2e:    28fa        .(      CMP      r0,#0xfa
        0x08001c30:    d201        ..      BCS      0x8001c36 ; process_button + 198
        0x08001c32:    2046        F       MOVS     r0,#0x46
        0x08001c34:    e000        ..      B        0x8001c38 ; process_button + 200
        0x08001c36:    203c        <       MOVS     r0,#0x3c
        0x08001c38:    61e0        .a      STR      r0,[r4,#0x1c]
;;;140    				break;
        0x08001c3a:    e036        6.      B        0x8001caa ; process_button + 314
;;;141    			}
;;;142    			case 60: {//60 if tick count < 1000 generate CLICK event, else generate long_press_end event, go to 10 state
;;;143    				if(bt[a].downTime < HOLDTIME_MS) { //single CLICK event
        0x08001c3c:    68a0        .h      LDR      r0,[r4,#8]
        0x08001c3e:    4558        XE      CMP      r0,r11
        0x08001c40:    d207        ..      BCS      0x8001c52 ; process_button + 226
;;;144    					buttons_flag_setbb[(a<<2)+single_click_Pos]  = 1; //single_click = 1;
        0x08001c42:    2002        .       MOVS     r0,#2
        0x08001c44:    eb000085    ....    ADD      r0,r0,r5,LSL #2
        0x08001c48:    eb070080    ....    ADD      r0,r7,r0,LSL #2
        0x08001c4c:    f8c06b80    ...k    STR      r6,[r0,#0xb80]
        0x08001c50:    e005        ..      B        0x8001c5e ; process_button + 238
;;;145    				} else { //  long_press_end event
;;;146    					buttons_flag_setbb[(a<<2)+long_press_end_Pos]  = 1; //long_press_end = 1;
        0x08001c52:    eb060085    ....    ADD      r0,r6,r5,LSL #2
        0x08001c56:    eb070080    ....    ADD      r0,r7,r0,LSL #2
        0x08001c5a:    f8c06b80    ...k    STR      r6,[r0,#0xb80]
;;;147    				}
;;;148    				bt[a].downTime = bt[a].buttons_mstick = 0;
        0x08001c5e:    f8c49010    ....    STR      r9,[r4,#0x10]
        0x08001c62:    f8c49008    ....    STR      r9,[r4,#8]
;;;149    				bt[a].clk_mode = 10;
        0x08001c66:    f8c4a01c    ....    STR      r10,[r4,#0x1c]
;;;150    				break;
        0x08001c6a:    e01e        ..      B        0x8001caa ; process_button + 314
;;;151    			}
;;;152    			case 70: { //70.   200,    -,    100,     60,     80
;;;153    				if ( tmp_buttons & bt[a].button_pin ) {
        0x08001c6c:    6861        ah      LDR      r1,[r4,#4]
        0x08001c6e:    4201        .B      TST      r1,r0
        0x08001c70:    d005        ..      BEQ      0x8001c7e ; process_button + 270
;;;154    					bt[a].downTime = bt[a].buttons_mstick;
        0x08001c72:    60a2        .`      STR      r2,[r4,#8]
;;;155    					if( bt[a].downTime > DOUBLECLICK_GAP_MS ) {
        0x08001c74:    2a96        .*      CMP      r2,#0x96
        0x08001c76:    d918        ..      BLS      0x8001caa ; process_button + 314
;;;156    						bt[a].clk_mode = 60;
        0x08001c78:    203c        <       MOVS     r0,#0x3c
        0x08001c7a:    61e0        .a      STR      r0,[r4,#0x1c]
        0x08001c7c:    e015        ..      B        0x8001caa ; process_button + 314
;;;157    					}
;;;158    				} else {
;;;159    					bt[a].clk_mode = 80;
        0x08001c7e:    2050        P       MOVS     r0,#0x50
        0x08001c80:    61e0        .a      STR      r0,[r4,#0x1c]
        0x08001c82:    e012        ..      B        0x8001caa ; process_button + 314
;;;160    				}
;;;161    				break;
;;;162    			}
;;;163    			case 80: {
;;;164    				if ( tmp_buttons & bt[a].button_pin ) { // released
        0x08001c84:    6861        ah      LDR      r1,[r4,#4]
        0x08001c86:    4201        .B      TST      r1,r0
        0x08001c88:    d002        ..      BEQ      0x8001c90 ; process_button + 288
;;;165    					bt[a].clk_mode = 90;
        0x08001c8a:    205a        Z       MOVS     r0,#0x5a
        0x08001c8c:    61e0        .a      STR      r0,[r4,#0x1c]
        0x08001c8e:    e00c        ..      B        0x8001caa ; process_button + 314
;;;166    				} else {
;;;167    					bt[a].downTime = bt[a].buttons_mstick;
        0x08001c90:    60a2        .`      STR      r2,[r4,#8]
        0x08001c92:    e00a        ..      B        0x8001caa ; process_button + 314
;;;168    				}
;;;169    				break;
;;;170    			}
;;;171    			case 90: { //  DOUBLE_CLICK
;;;172    				buttons_flag_setbb[(a<<2)+double_click_Pos]  = 1; //double_click = 1;
        0x08001c94:    2003        .       MOVS     r0,#3
        0x08001c96:    eb000085    ....    ADD      r0,r0,r5,LSL #2
        0x08001c9a:    eb070080    ....    ADD      r0,r7,r0,LSL #2
        0x08001c9e:    f8c06b80    ...k    STR      r6,[r0,#0xb80]
;;;173    				bt[a].clk_mode = 10;
        0x08001ca2:    f8c4a01c    ....    STR      r10,[r4,#0x1c]
;;;174    				bt[a].buttons_mstick = 0;
        0x08001ca6:    f8c49010    ....    STR      r9,[r4,#0x10]
        0x08001caa:    1c6d        m.      ADDS     r5,r5,#1
        0x08001cac:    2d01        .-      CMP      r5,#1
        0x08001cae:    f6ffaf6b    ..k.    BLT      0x8001b88 ; process_button + 24
;;;175    				break;
;;;176    			}
;;;177    			}
;;;178    		}
;;;179    	}
;;;180    //	ubTransferComplete = 0;
;;;181    }
        0x08001cb2:    e77e        ~.      B        0x8001bb2 ; process_button + 66
    $d
        0x08001cb4:    2200b000    ..."    DCD    570470400
        0x08001cb8:    200004e4    ...     DCD    536872164
        0x08001cbc:    20000005    ...     DCD    536870917
    $t
    i.str_f_inch_to_steps2210
    str_f_inch_to_steps2210
;;; .\../Src/main.c
;;;408    int str_f_inch_to_steps2210(const char *str, char **endptr){
        0x08001cc0:    b5f0        ..      PUSH     {r4-r7,lr}
;;;409    // minimum processed value is 0.0001inch
;;;410    	#define steps_per_inch_Z_2210	254*40*1024 //
;;;411    
;;;412    	uint8_t ten = 0;
        0x08001cc2:    2400        .$      MOVS     r4,#0
;;;413    	fixedpt t2210 = 0;
        0x08001cc4:    2700        .'      MOVS     r7,#0
;;;414    	uint32_t number = 0;
        0x08001cc6:    2200        ."      MOVS     r2,#0
;;;415    	bool negative = false;
        0x08001cc8:    2600        .&      MOVS     r6,#0
;;;416    	bool fract = false;
        0x08001cca:    2500        .%      MOVS     r5,#0
        0x08001ccc:    e024        $.      B        0x8001d18 ; str_f_inch_to_steps2210 + 88
;;;417    	char c;
;;;418    	while ((c = *str) != 0) {
;;;419    		if (c >= '0' && c <= '9')	{
        0x08001cce:    f1a30c30    ..0.    SUB      r12,r3,#0x30
        0x08001cd2:    f1bc0f09    ....    CMP      r12,#9
        0x08001cd6:    d810        ..      BHI      0x8001cfa ; str_f_inch_to_steps2210 + 58
;;;420    			if(fract==false){
        0x08001cd8:    b14d        M.      CBZ      r5,0x8001cee ; str_f_inch_to_steps2210 + 46
;;;421    				number = number * 10 + (c - '0');
;;;422    			} else{
;;;423    				if(ten<4){
        0x08001cda:    2c04        .,      CMP      r4,#4
        0x08001cdc:    d204        ..      BCS      0x8001ce8 ; str_f_inch_to_steps2210 + 40
;;;424    					number = number * 10 + (c - '0');
        0x08001cde:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x08001ce2:    eb030242    ..B.    ADD      r2,r3,r2,LSL #1
        0x08001ce6:    3a30        0:      SUBS     r2,r2,#0x30
;;;425    				}
;;;426    				ten++;
        0x08001ce8:    1c64        d.      ADDS     r4,r4,#1
        0x08001cea:    b2e4        ..      UXTB     r4,r4
        0x08001cec:    e013        ..      B        0x8001d16 ; str_f_inch_to_steps2210 + 86
        0x08001cee:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x08001cf2:    eb030242    ..B.    ADD      r2,r3,r2,LSL #1
        0x08001cf6:    3a30        0:      SUBS     r2,r2,#0x30
        0x08001cf8:    e00d        ..      B        0x8001d16 ; str_f_inch_to_steps2210 + 86
;;;427    			}
;;;428    		} 
;;;429    		else if (c == '-')	{
        0x08001cfa:    2b2d        -+      CMP      r3,#0x2d
        0x08001cfc:    d002        ..      BEQ      0x8001d04 ; str_f_inch_to_steps2210 + 68
        0x08001cfe:    2b2e        .+      CMP      r3,#0x2e
        0x08001d00:    d002        ..      BEQ      0x8001d08 ; str_f_inch_to_steps2210 + 72
        0x08001d02:    e008        ..      B        0x8001d16 ; str_f_inch_to_steps2210 + 86
;;;430    			negative = true;
        0x08001d04:    2601        .&      MOVS     r6,#1
        0x08001d06:    e006        ..      B        0x8001d16 ; str_f_inch_to_steps2210 + 86
;;;431    		}
;;;432    		else if (c == '.') {
;;;433    			t2210 = number * steps_per_inch_Z_2210; //steps_per_unit_Z_2210 already in 2210 format
        0x08001d08:    ebc212c2    ....    RSB      r2,r2,r2,LSL #7
        0x08001d0c:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x08001d10:    0397        ..      LSLS     r7,r2,#14
;;;434    			number = 0;
        0x08001d12:    2200        ."      MOVS     r2,#0
;;;435    			fract = true;
        0x08001d14:    2501        .%      MOVS     r5,#1
;;;436    		}	
;;;437    		str++;
        0x08001d16:    1c40        @.      ADDS     r0,r0,#1
        0x08001d18:    7803        .x      LDRB     r3,[r0,#0]
        0x08001d1a:    2b00        .+      CMP      r3,#0
        0x08001d1c:    d1d7        ..      BNE      0x8001cce ; str_f_inch_to_steps2210 + 14
;;;438    	}
;;;439    	if (endptr != 0) *endptr = (char *)str;
        0x08001d1e:    b101        ..      CBZ      r1,0x8001d22 ; str_f_inch_to_steps2210 + 98
        0x08001d20:    6008        .`      STR      r0,[r1,#0]
;;;440    
;;;441    	switch(ten){
        0x08001d22:    2c01        .,      CMP      r4,#1
        0x08001d24:    d004        ..      BEQ      0x8001d30 ; str_f_inch_to_steps2210 + 112
        0x08001d26:    2c02        .,      CMP      r4,#2
        0x08001d28:    d006        ..      BEQ      0x8001d38 ; str_f_inch_to_steps2210 + 120
        0x08001d2a:    2c03        .,      CMP      r4,#3
        0x08001d2c:    d10a        ..      BNE      0x8001d44 ; str_f_inch_to_steps2210 + 132
        0x08001d2e:    e006        ..      B        0x8001d3e ; str_f_inch_to_steps2210 + 126
;;;442    		case 1:{ // if only one fract didgit in g-code
;;;443    			number *= 1000;
        0x08001d30:    f44f707a    O.zp    MOV      r0,#0x3e8
        0x08001d34:    4342        BC      MULS     r2,r0,r2
;;;444    			break;
        0x08001d36:    e005        ..      B        0x8001d44 ; str_f_inch_to_steps2210 + 132
;;;445    		}
;;;446    		case 2:{// if only two fract didgits in g-code
;;;447    			number *= 100;
        0x08001d38:    2064        d       MOVS     r0,#0x64
        0x08001d3a:    4342        BC      MULS     r2,r0,r2
;;;448    			break;
        0x08001d3c:    e002        ..      B        0x8001d44 ; str_f_inch_to_steps2210 + 132
;;;449    		}
;;;450    		case 3:{// if only three fract didgits in g-code
;;;451    			number *= 10;
        0x08001d3e:    eb020082    ....    ADD      r0,r2,r2,LSL #2
        0x08001d42:    0042        B.      LSLS     r2,r0,#1
;;;452    			break;
;;;453    		}
;;;454    	}
;;;455    
;;;456    	/* some explanations:
;;;457    	number contains fract part*10000, ie when 0.9999inch = 9999.
;;;458    	translate in to 25.4*10, = 9999*254
;;;459    	next mul to steps per mm(400) and pack it into 2210 by multiplying to 1024.
;;;460    	and divide to 100000 to get aling fract and fixed parts
;;;461    	so we have 9999*254*400*1024/100000
;;;462    	we cannot just calculate this because of long (9999*254*400*1024 = 10402799616 is greater then 2^32= 4294967296)
;;;463    	but 254*400*1024/100000 equal 127*400*1024/50000 and equal 127*4*512/250 and equal 127*1024/125
;;;464    	in this case 9999*127*1024 = 1300349952, this value is fitted to uint32 without loosing speed 
;;;465    	
;;;466    	For other cases(steps per mm) it should be done the same way.
;;;467    	Also its possible to find some fraction with smaller numerator to get result with little more error
;;;468    	in my case 1024*127/125=1040,384
;;;469    	8323/8=1040,375. That's add acceptable 0.0002mm error and its possible to avoid devision at all
;;;470    	*/
;;;471    //	t2210 += ((number<<10)*127/125);
;;;472    	t2210 += ((number*8323)>>3);
        0x08001d44:    f2420083    B...    MOV      r0,#0x2083
        0x08001d48:    4342        BC      MULS     r2,r0,r2
        0x08001d4a:    eb0700d2    ....    ADD      r0,r7,r2,LSR #3
        0x08001d4e:    2e00        ..      CMP      r6,#0
        0x08001d50:    d000        ..      BEQ      0x8001d54 ; str_f_inch_to_steps2210 + 148
;;;473    	if (negative) return -t2210;
        0x08001d52:    4240        @B      RSBS     r0,r0,#0
;;;474    	else return t2210;
;;;475    }
        0x08001d54:    bdf0        ..      POP      {r4-r7,pc}
    i.str_f_to_steps2210
    str_f_to_steps2210
;;;476    
;;;477    
;;;478    
;;;479    int str_f_to_steps2210(const char *str, char **endptr){
        0x08001d56:    b5f0        ..      PUSH     {r4-r7,lr}
;;;480    // minimum processed value is 0.001mm
;;;481    	#define steps_per_unit_Z_2210	400<<10
;;;482    
;;;483    	uint8_t ten = 0;
        0x08001d58:    2400        .$      MOVS     r4,#0
;;;484    	fixedpt t2210 = 0;
        0x08001d5a:    2600        .&      MOVS     r6,#0
;;;485    	uint32_t number = 0;
        0x08001d5c:    2200        ."      MOVS     r2,#0
;;;486    	bool negative = false;
        0x08001d5e:    2700        .'      MOVS     r7,#0
;;;487    	bool fract = false;
        0x08001d60:    2500        .%      MOVS     r5,#0
        0x08001d62:    e023        #.      B        0x8001dac ; str_f_to_steps2210 + 86
;;;488    	char c;
;;;489    	while ((c = *str) != 0) {
;;;490    		if (c >= '0' && c <= '9')	{
        0x08001d64:    f1a30c30    ..0.    SUB      r12,r3,#0x30
        0x08001d68:    f1bc0f09    ....    CMP      r12,#9
        0x08001d6c:    d810        ..      BHI      0x8001d90 ; str_f_to_steps2210 + 58
;;;491    			if(fract==false){
        0x08001d6e:    b14d        M.      CBZ      r5,0x8001d84 ; str_f_to_steps2210 + 46
;;;492    				number = number * 10 + (c - '0');
;;;493    			} else{
;;;494    				if(ten<3){
        0x08001d70:    2c03        .,      CMP      r4,#3
        0x08001d72:    d204        ..      BCS      0x8001d7e ; str_f_to_steps2210 + 40
;;;495    					number = number * 10 + (c - '0');
        0x08001d74:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x08001d78:    eb030242    ..B.    ADD      r2,r3,r2,LSL #1
        0x08001d7c:    3a30        0:      SUBS     r2,r2,#0x30
;;;496    				}
;;;497    				ten++;
        0x08001d7e:    1c64        d.      ADDS     r4,r4,#1
        0x08001d80:    b2e4        ..      UXTB     r4,r4
        0x08001d82:    e012        ..      B        0x8001daa ; str_f_to_steps2210 + 84
        0x08001d84:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x08001d88:    eb030242    ..B.    ADD      r2,r3,r2,LSL #1
        0x08001d8c:    3a30        0:      SUBS     r2,r2,#0x30
        0x08001d8e:    e00c        ..      B        0x8001daa ; str_f_to_steps2210 + 84
;;;498    			}
;;;499    		} 
;;;500    		else if (c == '-')	{
        0x08001d90:    2b2d        -+      CMP      r3,#0x2d
        0x08001d92:    d002        ..      BEQ      0x8001d9a ; str_f_to_steps2210 + 68
        0x08001d94:    2b2e        .+      CMP      r3,#0x2e
        0x08001d96:    d002        ..      BEQ      0x8001d9e ; str_f_to_steps2210 + 72
        0x08001d98:    e007        ..      B        0x8001daa ; str_f_to_steps2210 + 84
;;;501    			negative = true;
        0x08001d9a:    2701        .'      MOVS     r7,#1
        0x08001d9c:    e005        ..      B        0x8001daa ; str_f_to_steps2210 + 84
;;;502    		}
;;;503    		else if (c == '.') {
;;;504    			t2210 = number * steps_per_unit_Z_2210; //steps_per_unit_Z_2210 already in 2210 format
        0x08001d9e:    f44f23c8    O..#    MOV      r3,#0x64000
        0x08001da2:    fb02f603    ....    MUL      r6,r2,r3
;;;505    			number = 0;
        0x08001da6:    2200        ."      MOVS     r2,#0
;;;506    			fract = true;
        0x08001da8:    2501        .%      MOVS     r5,#1
;;;507    		}	
;;;508    		str++;
        0x08001daa:    1c40        @.      ADDS     r0,r0,#1
        0x08001dac:    7803        .x      LDRB     r3,[r0,#0]
        0x08001dae:    2b00        .+      CMP      r3,#0
        0x08001db0:    d1d8        ..      BNE      0x8001d64 ; str_f_to_steps2210 + 14
;;;509    	}
;;;510    	if (endptr != 0) *endptr = (char *)str;
        0x08001db2:    b101        ..      CBZ      r1,0x8001db6 ; str_f_to_steps2210 + 96
        0x08001db4:    6008        .`      STR      r0,[r1,#0]
;;;511    
;;;512    	switch(ten){
        0x08001db6:    2c01        .,      CMP      r4,#1
        0x08001db8:    d002        ..      BEQ      0x8001dc0 ; str_f_to_steps2210 + 106
        0x08001dba:    2c02        .,      CMP      r4,#2
        0x08001dbc:    d106        ..      BNE      0x8001dcc ; str_f_to_steps2210 + 118
        0x08001dbe:    e002        ..      B        0x8001dc6 ; str_f_to_steps2210 + 112
;;;513    		case 1:{ // if only one fract didgit in g-code
;;;514    			number *= 100;
        0x08001dc0:    2064        d       MOVS     r0,#0x64
        0x08001dc2:    4342        BC      MULS     r2,r0,r2
;;;515    			break;
        0x08001dc4:    e002        ..      B        0x8001dcc ; str_f_to_steps2210 + 118
        0x08001dc6:    eb020082    ....    ADD      r0,r2,r2,LSL #2
        0x08001dca:    0042        B.      LSLS     r2,r0,#1
        0x08001dcc:    f44f20c8    O..     MOV      r0,#0x64000
        0x08001dd0:    4342        BC      MULS     r2,r0,r2
        0x08001dd2:    f44f707a    O.zp    MOV      r0,#0x3e8
        0x08001dd6:    fbb2f0f0    ....    UDIV     r0,r2,r0
        0x08001dda:    4430        0D      ADD      r0,r0,r6
        0x08001ddc:    2f00        ./      CMP      r7,#0
        0x08001dde:    d000        ..      BEQ      0x8001de2 ; str_f_to_steps2210 + 140
;;;516    		}
;;;517    		case 2:{// if only two fract didgits in g-code
;;;518    			number *= 10;
;;;519    			break;
;;;520    		}
;;;521    	}
;;;522    
;;;523    //	t2210 += ((number * 419430) >> 10); // quick divide for 400 steps/mm, 400/1000 = 4/10, number<<10*4/10 = number<<12/10. 
;;;524    	t2210 += ((number << 10) * 400 / 1000);
;;;525    	
;;;526    //	t2210 += (( number * steps_per_unit_Z_fract_2210 ) / 10 );
;;;527    	if (negative) return -t2210;
        0x08001de0:    4240        @B      RSBS     r0,r0,#0
;;;528    	else return t2210;
;;;529    }
        0x08001de2:    bdf0        ..      POP      {r4-r7,pc}
    i.update_screen
    update_screen
;;; .\..\Src\screen.c
;;;86     	return 0;
        0x08001de4:    2000        .       MOVS     r0,#0
;;;87     }
        0x08001de6:    4770        pG      BX       lr
    i.z_axis_move2
    z_axis_move2
;;; .\..\Src\fsm.c
;;;413    {
        0x08001de8:    b510        ..      PUSH     {r4,lr}
;;;414    	const fixedptu set_with_fract = fixedpt_add(z_axis.Q824set, z_axis.fract_part); // calculate new step delay with fract from previous step
        0x08001dea:    4a0b        .J      LDR      r2,[pc,#44] ; [0x8001e18] = 0x20000508
        0x08001dec:    e9d21303    ....    LDRD     r1,r3,[r2,#0xc]
        0x08001df0:    4419        .D      ADD      r1,r1,r3
;;;415    	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
        0x08001df2:    6944        Di      LDR      r4,[r0,#0x14]
        0x08001df4:    f04f33ff    O..3    MOV      r3,#0xffffffff
        0x08001df8:    eb036311    ...c    ADD      r3,r3,r1,LSR #24
        0x08001dfc:    62e3        .b      STR      r3,[r4,#0x2c]
;;;416    	s->syncbase->CNT = 0;
        0x08001dfe:    6944        Di      LDR      r4,[r0,#0x14]
        0x08001e00:    2300        .#      MOVS     r3,#0
        0x08001e02:    6263        cb      STR      r3,[r4,#0x24]
;;;417    	s->syncbase->EGR |= TIM_EGR_UG;
        0x08001e04:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001e06:    6943        Ci      LDR      r3,[r0,#0x14]
        0x08001e08:    f0430301    C...    ORR      r3,r3,#1
        0x08001e0c:    6143        Ca      STR      r3,[r0,#0x14]
;;;418    	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
        0x08001e0e:    f021407f    !..@    BIC      r0,r1,#0xff000000
        0x08001e12:    6110        .a      STR      r0,[r2,#0x10]
;;;419    }
        0x08001e14:    bd10        ..      POP      {r4,pc}
    $d
        0x08001e16:    0000        ..      DCW    0
        0x08001e18:    20000508    ...     DCD    536872200
    $t
    i.z_axis_ramp_down2
    z_axis_ramp_down2
;;; .\..\Src\fsm.c (399)
        0x08001e1c:    4a0a        .J      LDR      r2,[pc,#40] ; [0x8001e48] = 0x20000508
        0x08001e1e:    f8921028    ..(.    LDRB     r1,[r2,#0x28]
        0x08001e22:    2900        .)      CMP      r1,#0
;;; .\..\Src\fsm.c (398)
        0x08001e24:    d00b        ..      BEQ      0x8001e3e ; z_axis_ramp_down2 + 34
;;;399    	if (z_axis.ramp_step == 0)
;;;400    		return true;
;;;401    //	const fixedptu set_with_fract = ramp2[--z_axis.ramp_step] << 24;
;;;402    //	s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; // update register ARR
;;;403    
;;;404    	s->syncbase->ARR = sync_ramp_profile[--z_axis.ramp_step];
        0x08001e26:    1e49        I.      SUBS     r1,r1,#1
        0x08001e28:    b2c9        ..      UXTB     r1,r1
        0x08001e2a:    f8021f28    ..(.    STRB     r1,[r2,#0x28]!
        0x08001e2e:    4b07        .K      LDR      r3,[pc,#28] ; [0x8001e4c] = 0x2000002c
        0x08001e30:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001e32:    5c59        Y\      LDRB     r1,[r3,r1]
        0x08001e34:    62c1        .b      STR      r1,[r0,#0x2c]
;;;405    	//	s->syncbase->EGR |= TIM_EGR_UG;
;;;406    //	z_axis.fract_part = fixedpt_fracpart( set_with_fract ); // save fract part for future use on next step
;;;407    	if(z_axis.ramp_step == 0)
        0x08001e36:    7810        .x      LDRB     r0,[r2,#0]
        0x08001e38:    b118        ..      CBZ      r0,0x8001e42 ; z_axis_ramp_down2 + 38
;;;408    		return true;
;;;409    	return false;
        0x08001e3a:    2000        .       MOVS     r0,#0
;;;410    }
        0x08001e3c:    4770        pG      BX       lr
        0x08001e3e:    2001        .       MOVS     r0,#1
        0x08001e40:    4770        pG      BX       lr
        0x08001e42:    2001        .       MOVS     r0,#1
        0x08001e44:    4770        pG      BX       lr
    $d
        0x08001e46:    0000        ..      DCW    0
        0x08001e48:    20000508    ...     DCD    536872200
        0x08001e4c:    2000002c    ,..     DCD    536870956
    $t
    i.z_axis_ramp_up2
    z_axis_ramp_up2
;;; .\..\Src\fsm.c (380)
        0x08001e50:    b530        0.      PUSH     {r4,r5,lr}
;;;381    	const fixedptu  set_with_fract = sync_ramp_profile[z_axis.ramp_step] << 24;
        0x08001e52:    4c10        .L      LDR      r4,[pc,#64] ; [0x8001e94] = 0x20000508
        0x08001e54:    4a10        .J      LDR      r2,[pc,#64] ; [0x8001e98] = 0x2000002c
        0x08001e56:    f8941028    ..(.    LDRB     r1,[r4,#0x28]
        0x08001e5a:    5c52        R\      LDRB     r2,[r2,r1]
        0x08001e5c:    0612        ..      LSLS     r2,r2,#24
;;;382    	if(z_axis.Q824set > set_with_fract || z_axis.ramp_step == sync_ramp_profile_len) { 	// reach desired speed or end of ramp map
        0x08001e5e:    68e3        .h      LDR      r3,[r4,#0xc]
        0x08001e60:    f04f35ff    O..5    MOV      r5,#0xffffffff
        0x08001e64:    4293        .B      CMP      r3,r2
        0x08001e66:    d80a        ..      BHI      0x8001e7e ; z_axis_ramp_up2 + 46
        0x08001e68:    2905        .)      CMP      r1,#5
        0x08001e6a:    d008        ..      BEQ      0x8001e7e ; z_axis_ramp_up2 + 46
        0x08001e6c:    1c49        I.      ADDS     r1,r1,#1
        0x08001e6e:    f8841028    ..(.    STRB     r1,[r4,#0x28]
        0x08001e72:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001e74:    eb056112    ...a    ADD      r1,r5,r2,LSR #24
        0x08001e78:    62c1        .b      STR      r1,[r0,#0x2c]
        0x08001e7a:    2000        .       MOVS     r0,#0
        0x08001e7c:    bd30        0.      POP      {r4,r5,pc}
;;;383    		s->syncbase->ARR = fixedpt_toint(z_axis.Q824set) - 1; 			// update register ARR
        0x08001e7e:    6940        @i      LDR      r0,[r0,#0x14]
        0x08001e80:    eb056113    ...a    ADD      r1,r5,r3,LSR #24
        0x08001e84:    62c1        .b      STR      r1,[r0,#0x2c]
;;;384    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;385    		z_axis.fract_part = fixedpt_fracpart(z_axis.Q824set); 								// save fract part for future use on next step
        0x08001e86:    68e0        .h      LDR      r0,[r4,#0xc]
        0x08001e88:    f020407f     ..@    BIC      r0,r0,#0xff000000
        0x08001e8c:    6120         a      STR      r0,[r4,#0x10]
;;;386    //		z_axis.end_minus_ramp_delta =
;;;387    		return true;
        0x08001e8e:    2001        .       MOVS     r0,#1
;;;388    	} else {
;;;389    		z_axis.ramp_step++;
;;;390    		s->syncbase->ARR = fixedpt_toint(set_with_fract) - 1; 			// update register ARR
;;;391    //		s->syncbase->EGR |= TIM_EGR_UG;
;;;392    //		z_axis.fract_part = fixedpt_fracpart( set_with_fract ); 						// save fract part for future use on next step
;;;393    	}
;;;394    	return false;
;;;395    }
        0x08001e90:    bd30        0.      POP      {r4,r5,pc}
    $d
        0x08001e92:    0000        ..      DCW    0
        0x08001e94:    20000508    ...     DCD    536872200
        0x08001e98:    2000002c    ,..     DCD    536870956
    $t
    i.z_move
    z_move
;;; .\..\Src\fsm.c (197)
        0x08001e9c:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x08001ea0:    460c        .F      MOV      r4,r1
        0x08001ea2:    4616        .F      MOV      r6,r2
;;;198    	MOTOR_X_Enable();
        0x08001ea4:    4b19        .K      LDR      r3,[pc,#100] ; [0x8001f0c] = 0x40010810
        0x08001ea6:    f2402102    @..!    MOV      r1,#0x202
        0x08001eaa:    6019        .`      STR      r1,[r3,#0]
;;;199    	MOTOR_Z_Enable(); // time to wakeup motor from sleep is quite high(1.7ms), so enable it as soon as possible
        0x08001eac:    4a18        .J      LDR      r2,[pc,#96] ; [0x8001f10] = 0x40010c10
        0x08001eae:    6011        .`      STR      r1,[r2,#0]
        0x08001eb0:    018a        ..      LSLS     r2,r1,#6
        0x08001eb2:    4918        .I      LDR      r1,[pc,#96] ; [0x8001f14] = 0x4800080
        0x08001eb4:    f8dfc060    ..`.    LDR      r12,[pc,#96] ; [0x8001f18] = 0x40011000
        0x08001eb8:    4d18        .M      LDR      r5,[pc,#96] ; [0x8001f1c] = 0x200000bc
        0x08001eba:    2701        .'      MOVS     r7,#1
        0x08001ebc:    f04f0800    O...    MOV      r8,#0
;;;200    
;;;201    	if(direction == feed_direction_left) {
        0x08001ec0:    2800        .(      CMP      r0,#0
        0x08001ec2:    d014        ..      BEQ      0x8001eee ; z_move + 82
;;;202    		feed_direction = feed_direction_left;
;;;203    		MOTOR_Z_Reverse();
;;;204    		MOTOR_X_Reverse();
;;;205    	} else {
;;;206    		feed_direction = feed_direction_right;
        0x08001ec4:    702f        /p      STRB     r7,[r5,#0]
;;;207    		MOTOR_Z_Forward();
        0x08001ec6:    601a        .`      STR      r2,[r3,#0]
;;;208    		MOTOR_X_Forward();
        0x08001ec8:    f8cc1010    ....    STR      r1,[r12,#0x10]
;;;209    	}
;;;210    	LL_mDelay(2);
        0x08001ecc:    2002        .       MOVS     r0,#2
        0x08001ece:    f7fefd3f    ..?.    BL       LL_mDelay ; 0x8000950
;;;211    
;;;212    	state.sync = sync;
        0x08001ed2:    4813        .H      LDR      r0,[pc,#76] ; [0x8001f20] = 0x20000060
        0x08001ed4:    7406        .t      STRB     r6,[r0,#0x10]
;;;213    	if(sync){
        0x08001ed6:    b10e        ..      CBZ      r6,0x8001edc ; z_move + 64
;;;214    		state.main_feed_direction = feed_direction;
        0x08001ed8:    7829        )x      LDRB     r1,[r5,#0]
        0x08001eda:    7441        At      STRB     r1,[r0,#0x11]
;;;215    	}
;;;216    
;;;217    	z_axis.current_pos = 0;
        0x08001edc:    4a11        .J      LDR      r2,[pc,#68] ; [0x8001f24] = 0x20000508
        0x08001ede:    f8c28000    ....    STR      r8,[r2,#0]
;;;218    	z_axis.end_pos = length;
        0x08001ee2:    6054        T`      STR      r4,[r2,#4]
;;;219    	if(z_axis.end_pos > 0){
        0x08001ee4:    b15c        \.      CBZ      r4,0x8001efe ; z_move + 98
;;;220    		z_axis.end_pos &= 0xFFFFFFFF - step_divider + 1;
        0x08001ee6:    f0240001    $...    BIC      r0,r4,#1
        0x08001eea:    6050        P`      STR      r0,[r2,#4]
        0x08001eec:    e008        ..      B        0x8001f00 ; z_move + 100
        0x08001eee:    f8858000    ....    STRB     r8,[r5,#0]
        0x08001ef2:    4806        .H      LDR      r0,[pc,#24] ; [0x8001f0c] = 0x40010810
        0x08001ef4:    1d00        ..      ADDS     r0,r0,#4
        0x08001ef6:    6002        .`      STR      r2,[r0,#0]
        0x08001ef8:    f8cc1014    ....    STR      r1,[r12,#0x14]
        0x08001efc:    e7e6        ..      B        0x8001ecc ; z_move + 48
;;;221    //		z_axis.end_pos |= step_divider; // to make sure that we'll not stop between full steps
;;;222    
;;;223    	} else {
;;;224    		state.sync = true;
        0x08001efe:    7407        .t      STRB     r7,[r0,#0x10]
;;;225    	}
;;;226    
;;;227    	do_fsm_move_start(&state);
        0x08001f00:    e8bd41f0    ...A    POP      {r4-r8,lr}
        0x08001f04:    4806        .H      LDR      r0,[pc,#24] ; [0x8001f20] = 0x20000060
        0x08001f06:    f7ffbc1d    ....    B.W      do_fsm_move_start ; 0x8001744
    $d
        0x08001f0a:    0000        ..      DCW    0
        0x08001f0c:    40010810    ...@    DCD    1073809424
        0x08001f10:    40010c10    ...@    DCD    1073810448
        0x08001f14:    04800080    ....    DCD    75497600
        0x08001f18:    40011000    ...@    DCD    1073811456
        0x08001f1c:    200000bc    ...     DCD    536871100
        0x08001f20:    20000060    `..     DCD    536871008
        0x08001f24:    20000508    ...     DCD    536872200
    $d.realdata
    .constdata
    AHBPrescTable
        0x08001f28:    00000000    ....    DCD    0
        0x08001f2c:    00000000    ....    DCD    0
        0x08001f30:    04030201    ....    DCD    67305985
        0x08001f34:    09080706    ....    DCD    151521030
    .constdata
    APBPrescTable
        0x08001f38:    00000000    ....    DCD    0
        0x08001f3c:    04030201    ....    DCD    67305985
    .constdata
    CHANNEL_OFFSET_TAB
        0x08001f40:    44301c08    ..0D    DCD    1144003592
        0x08001f44:    6c58        Xl      DCW    27736
        0x08001f46:    80          .       DCB    128
    .constdata
    CHANNEL_OFFSET_TAB
        0x08001f47:    08          .       DCB    8
        0x08001f48:    5844301c    .0DX    DCD    1480863772
        0x08001f4c:    806c        l.      DCW    32876
    OFFSET_TAB_CCMRx
        0x08001f4e:    0000        ..      DCW    0
        0x08001f50:    04040000    ....    DCD    67371008
        0x08001f54:    04          .       DCB    4
    SHIFT_TAB_OCxx
        0x08001f55:    000008      ...     DCB    0,0,8
        0x08001f58:    08000000    ....    DCD    134217728
    SHIFT_TAB_ICxx
        0x08001f5c:    00080000    ....    DCD    524288
        0x08001f60:    0000        ..      DCW    0
        0x08001f62:    08          .       DCB    8
    SHIFT_TAB_CCxP
        0x08001f63:    00          .       DCB    0
        0x08001f64:    08060402    ....    DCD    134611970
        0x08001f68:    0c0a        ..      DCW    3082
    aTxBuffer
        0x08001f6a:    5453        ST      DCW    21587
        0x08001f6c:    4632334d    M32F    DCD    1177695053
        0x08001f70:    20787831    1xx     DCD    544766001
        0x08001f74:    52415355    USAR    DCD    1380012885
        0x08001f78:    4c4c2054    T LL    DCD    1280057428
        0x08001f7c:    49504120     API    DCD    1229996320
        0x08001f80:    61784520     Exa    DCD    1635271968
        0x08001f84:    656c706d    mple    DCD    1701605485
        0x08001f88:    54203a20     : T    DCD    1411398176
        0x08001f8c:    58522f58    X/RX    DCD    1481781080
        0x08001f90:    206e6920     in     DCD    544106784
        0x08001f94:    20414d44    DMA     DCD    541150532
        0x08001f98:    65646f6d    mode    DCD    1701080941
        0x08001f9c:    6f430a0d    ..Co    DCD    1866664461
        0x08001fa0:    6769666e    nfig    DCD    1734960750
        0x08001fa4:    74617275    urat    DCD    1952543349
        0x08001fa8:    206e6f69    ion     DCD    544108393
        0x08001fac:    54524155    UART    DCD    1414676821
        0x08001fb0:    35313120     115    DCD    892416288
        0x08001fb4:    20303032    200     DCD    540028978
        0x08001fb8:    2c737062    bps,    DCD    745762914
        0x08001fbc:    64203820     8 d    DCD    1679833120
        0x08001fc0:    20617461    ata     DCD    543257697
        0x08001fc4:    2f746962    bit/    DCD    796158306
        0x08001fc8:    74732031    1 st    DCD    1953701937
        0x08001fcc:    6220706f    op b    DCD    1646293103
        0x08001fd0:    4e2f7469    it/N    DCD    1311732841
        0x08001fd4:    6170206f    o pa    DCD    1634738287
        0x08001fd8:    79746972    rity    DCD    2037672306
        0x08001fdc:    206f4e2f    /No     DCD    544165423
        0x08001fe0:    66205748    HW f    DCD    1713395528
        0x08001fe4:    20776f6c    low     DCD    544698220
        0x08001fe8:    746e6f63    cont    DCD    1953394531
        0x08001fec:    0d6c6f72    rol.    DCD    225210226
        0x08001ff0:    656c500a    .Ple    DCD    1701597194
        0x08001ff4:    20657361    ase     DCD    543519585
        0x08001ff8:    65746e65    ente    DCD    1702129253
        0x08001ffc:    45272072    r 'E    DCD    1160192114
        0x08002000:    2027444e    ND'     DCD    539444302
        0x08002004:    69727473    stri    DCD    1769108595
        0x08002008:    2e20676e    ng .    DCD    773875566
        0x0800200c:    0a0d2e2e    ....    DCD    168635950
        0x08002010:    00          .       DCB    0
    .constdata
    Menu_size
        0x08002011:    210000      !..     DCB    33,0,0
    Region$$Table$$Base
        0x08002014:    08002034    4 ..    DCD    134225972
        0x08002018:    20000000    ...     DCD    536870912
        0x0800201c:    000004e4    ....    DCD    1252
        0x08002020:    0800020c    ....    DCD    134218252
        0x08002024:    080021d0    .!..    DCD    134226384
        0x08002028:    200004e4    ...     DCD    536872164
        0x0800202c:    000004fc    ....    DCD    1276
        0x08002030:    0800157c    |...    DCD    134223228
    Region$$Table$$Limit

** Section #2 'RW_IRAM1' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 412 bytes (alignment 8)
    Address: 0x20000000


** Section #3 'RW_IRAM1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 1276 bytes (alignment 8)
    Address: 0x200004e4


** Section #4 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #5 '.debug_frame' (SHT_PROGBITS)
    Size   : 3068 bytes


** Section #6 '.debug_info' (SHT_PROGBITS)
    Size   : 180236 bytes


** Section #7 '.debug_line' (SHT_PROGBITS)
    Size   : 22368 bytes


** Section #8 '.debug_loc' (SHT_PROGBITS)
    Size   : 7024 bytes


** Section #9 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 509512 bytes


** Section #10 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 3290 bytes


** Section #11 '.symtab' (SHT_SYMTAB)
    Size   : 8528 bytes (alignment 4)
    String table #12 '.strtab'
    Last local symbol no. 373


** Section #12 '.strtab' (SHT_STRTAB)
    Size   : 7260 bytes


** Section #13 '.note' (SHT_NOTE)
    Size   : 28 bytes (alignment 4)


** Section #14 '.comment' (SHT_PROGBITS)
    Size   : 25176 bytes


** Section #15 '.shstrtab' (SHT_STRTAB)
    Size   : 156 bytes


